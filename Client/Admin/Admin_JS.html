<script>
  // Namespace for the admin application
  window.adminApp = {};

  // --- Application State ---
  adminApp.state = {
    isLoading: false,
    currentProjectId: null,
    currentView: 'list',
    projectData: null, 
    currentSlideIndex: -1, 
    fabricCanvasInstance: null,
    defaultCanvasWidth: 960, 
    defaultCanvasHeight: 540,
    projectListCache: [] // Added to cache project list for status updates/reverts
  };

  // --- DOM Element References ---
  let projectTitleInputEl, createProjectButtonEl, messageAreaEl, loadingSpinnerEl;
  let listViewContainerEl, adminProjectListContainerEl;
  let editViewContainerEl, editingProjectTitleEl, backToProjectsListButtonEl, fabricCanvasEl;
  let imageUploaderEl;
  let addSlideButtonEl, slideThumbnailsContainerEl, saveProjectButtonEl; 
  let addRectangleButtonEl, addCircleButtonEl; 
  let addTextboxButtonEl; 

  let overlayPropertiesToolbarEl, objXEl, objYEl, objWidthEl, objHeightEl, objAngleEl,
      objInteractionTriggerEl, objInteractionActionEl, 
      modalContentConfigEl, objModalContentEl,
      navigateToConfigEl, objNavigateToEl,
      objFillEl, objStrokeColorEl, objStrokeWidthEl, objOpacityEl,
      textSpecificControlsEl, objTextContentEl,
      objShadowColorEl, objShadowBlurEl, objShadowOffsetXEl, objShadowOffsetYEl;

  // --- Initialization ---
  document.addEventListener('DOMContentLoaded', function() {
    console.log("Admin_JS: DOMContentLoaded event fired!");
    adminApp.setupDOMReferences();
    adminApp.attachEventListeners();
    switchToListView();
    loadAdminProjectsList(); 
    console.log("Admin_JS: Initialization complete.");
  });

  // --- Setup and Listeners ---
  adminApp.setupDOMReferences = function() {
    messageAreaEl = document.getElementById('messageArea');
    loadingSpinnerEl = document.getElementById('loadingSpinner');
    listViewContainerEl = document.getElementById('listViewContainer');
    projectTitleInputEl = document.getElementById('projectTitleInput');
    createProjectButtonEl = document.getElementById('createProjectButton');
    adminProjectListContainerEl = document.getElementById('adminProjectListContainer');
    editViewContainerEl = document.getElementById('editViewContainer');
    editingProjectTitleEl = document.getElementById('editingProjectTitle');
    backToProjectsListButtonEl = document.getElementById('backToProjectsListButton');
    fabricCanvasEl = document.getElementById('fabricCanvasElement');
    imageUploaderEl = document.getElementById('imageUploader');
    addSlideButtonEl = document.getElementById('addSlideButton');
    slideThumbnailsContainerEl = document.getElementById('slideThumbnailsContainer');
    saveProjectButtonEl = document.getElementById('saveProjectButton');
    
    addRectangleButtonEl = document.getElementById('addRectangleButton');
    addCircleButtonEl = document.getElementById('addCircleButton');
    addTextboxButtonEl = document.getElementById('addTextboxButton');

    overlayPropertiesToolbarEl  = document.getElementById('overlayPropertiesToolbar'); 
    objXEl = document.getElementById('objX');
    objYEl = document.getElementById('objY');
    objWidthEl = document.getElementById('objWidth');
    objHeightEl = document.getElementById('objHeight');
    objAngleEl = document.getElementById('objAngle');
    objFillEl = document.getElementById('objFill');
    objStrokeColorEl = document.getElementById('objStrokeColor');
    objStrokeWidthEl = document.getElementById('objStrokeWidth');
    objOpacityEl = document.getElementById('objOpacity');
    textSpecificControlsEl = document.getElementById('textSpecificControls');
    objTextContentEl = document.getElementById('objTextContent');
    objShadowColorEl = document.getElementById('objShadowColor');
    objShadowBlurEl = document.getElementById('objShadowBlur');
    objShadowOffsetXEl = document.getElementById('objShadowOffsetX');
    objShadowOffsetYEl = document.getElementById('objShadowOffsetY');

    objInteractionTriggerEl = document.getElementById('objInteractionTrigger');
    objInteractionActionEl = document.getElementById('objInteractionAction');
    modalContentConfigEl = document.getElementById('modalContentConfig');
    objModalContentEl = document.getElementById('objModalContent');
    navigateToConfigEl = document.getElementById('navigateToConfig');
    objNavigateToEl = document.getElementById('objNavigateTo');

    if (!addSlideButtonEl) console.warn("addSlideButtonEl not found during initial setup.");
    if (!slideThumbnailsContainerEl) console.warn("slideThumbnailsContainerEl not found during initial setup.");
    if (!saveProjectButtonEl) console.warn("saveProjectButtonEl not found during initial setup.");
    if (!imageUploaderEl) console.warn("imageUploaderEl not found during initial setup.");
    if (!fabricCanvasEl) console.warn("fabricCanvasEl not found during initial setup.");
    console.log("Admin_JS: DOM references set up.");
  };

  adminApp.attachEventListeners = function() {
    const safelyAddListener = (element, eventType, handler, elementName) => {
        if (element) {
            element.addEventListener(eventType, handler);
        } else {
            if (elementName === 'createProjectButtonEl') console.warn(`Could not attach listener - ${elementName} not found initially.`);
        }
    };
    safelyAddListener(createProjectButtonEl, 'click', handleCreateProject, 'createProjectButtonEl');
    console.log("Admin_JS: Initial event listeners attached.");
  };

  // --- UI View Management ---
  function switchToListView() {
    console.log("Switching to List View");
    adminApp.state.currentView = 'list';
    adminApp.state.currentProjectId = null;
    adminApp.state.projectData = null; 
    adminApp.state.currentSlideIndex = -1;
    if (adminApp.state.fabricCanvasInstance) {
        adminApp.state.fabricCanvasInstance.dispose();
        adminApp.state.fabricCanvasInstance = null;
        console.log("Admin_JS: Disposed fabric canvas instance.");
    }
    if(listViewContainerEl) listViewContainerEl.style.display = 'block';
    if(editViewContainerEl) editViewContainerEl.style.display = 'none';
    if (messageAreaEl) messageAreaEl.innerHTML = '';
    loadAdminProjectsList();
  }

  function switchToEditView(projectIdToEdit) {
      console.log("Switching to Edit View for project ID:", projectIdToEdit);
      adminApp.state.currentView = 'edit';
      adminApp.state.currentProjectId = projectIdToEdit;
      adminApp.state.projectData = null;
      adminApp.state.currentSlideIndex = -1;

      if(listViewContainerEl) listViewContainerEl.style.display = 'none';
      if(editViewContainerEl) editViewContainerEl.style.display = 'block';

      if(editingProjectTitleEl) { 
          editingProjectTitleEl.textContent = `Loading Project (ID: ${projectIdToEdit})...`;
      }

      if (adminApp.state.fabricCanvasInstance) {
          adminApp.state.fabricCanvasInstance.dispose();
          adminApp.state.fabricCanvasInstance = null;
      }
      if (messageAreaEl) messageAreaEl.innerHTML = '';
      if (slideThumbnailsContainerEl) slideThumbnailsContainerEl.innerHTML = ''; 

      const ensureEditViewListener = (elementVar, id, eventType, handler) => {
          if (!window[elementVar]) { 
              window[elementVar] = document.getElementById(id);
          }
          const element = window[elementVar];
          if (element && !element.hasAttribute('listener-attached')) {
              element.addEventListener(eventType, handler);
              element.setAttribute('listener-attached', 'true'); 
              console.log(`Listener attached for ${eventType} on #${id} in switchToEditView.`);
          } else if (!element) {
              console.error(`CRITICAL: Element #${id} not found in switchToEditView!`);
          }
      };

      fabricCanvasEl = document.getElementById('fabricCanvasElement'); 
      slideThumbnailsContainerEl = document.getElementById('slideThumbnailsContainer'); 

      ensureEditViewListener('backToProjectsListButtonEl', 'backToProjectsListButton', 'click', switchToListView);
      ensureEditViewListener('imageUploaderEl', 'imageUploader', 'change', handleImageUpload);
      ensureEditViewListener('addSlideButtonEl', 'addSlideButton', 'click', handleAddSlide);
      ensureEditViewListener('saveProjectButtonEl', 'saveProjectButton', 'click', handleSaveProject);
      ensureEditViewListener('addRectangleButtonEl', 'addRectangleButton', 'click', addRectangle);
      ensureEditViewListener('addCircleButtonEl', 'addCircleButton', 'click', addCircle);
      ensureEditViewListener('addTextboxButtonEl', 'addTextboxButton', 'click', addTextbox);

      if (typeof fabric !== 'undefined' && fabricCanvasEl) {
          adminApp.state.fabricCanvasInstance = new fabric.Canvas('fabricCanvasElement', {
              width: adminApp.state.defaultCanvasWidth,
              height: adminApp.state.defaultCanvasHeight,
              backgroundColor: '#e9e9e9'
          });
          fabricCanvasEl.width = adminApp.state.defaultCanvasWidth;
          fabricCanvasEl.height = adminApp.state.defaultCanvasHeight;
          console.log("Admin_JS: Fabric.js canvas initialized with default dimensions.");

          initToolbar(); 
          
          adminApp.state.fabricCanvasInstance.on('object:modified', (e) => {
            if (e.target) populateToolbar(e.target);
          });
          adminApp.state.fabricCanvasInstance.on('selection:created', (e) => { 
            if (e.selected && e.selected.length > 0) populateToolbar(e.selected[0]); 
          });
          adminApp.state.fabricCanvasInstance.on('selection:updated', (e) => { 
             if (e.selected && e.selected.length > 0) populateToolbar(e.selected[0]);
          });
          adminApp.state.fabricCanvasInstance.on('selection:cleared', () => {
            populateToolbar(null);
          });
          if(overlayPropertiesToolbarEl) overlayPropertiesToolbarEl.style.display = 'none'; 

          loadProjectForEditing(projectIdToEdit); 

      } else { 
          console.error("Fabric.js or canvas element not ready in switchToEditView.");
          displayMessage("Critical error: Editor components not ready.", false);
          showLoading(false);
      }
  }

  function loadProjectForEditing(projectId) {
    console.log(`loadProjectForEditing: Called for projectId: ${projectId}`);
    if (!projectId) { console.error("loadProjectForEditing: No projectId."); displayMessage("Error: Cannot load project.", false); return; }
    showLoading(true);
    displayMessage("Loading project data...", true);
    google.script.run
        .withSuccessHandler(onProjectDataLoaded)
        .withFailureHandler(onServerError) 
        .getProjectDataForEditing(projectId);
  }

  function onProjectDataLoaded(jsonString) {
    console.log("onProjectDataLoaded: Received data string length:", jsonString ? jsonString.length : 'null');

    if (jsonString === null || jsonString === undefined) { 
        showLoading(false);
        console.error("onProjectDataLoaded: Received null data string from server (Project or data file likely not found).");
        displayMessage("Error: Could not load project data. Project or its data file may not exist.", false);
        adminApp.state.projectData = { projectId: adminApp.state.currentProjectId, title: "Error Loading", slides: [] };
        adminApp.state.currentSlideIndex = -1;
        if (editingProjectTitleEl) editingProjectTitleEl.textContent = `Error Loading Project (ID: ${adminApp.state.currentProjectId})`;
        updateSlideThumbnailsUI(); 
        return;
    }

    try {
        const loadedData = JSON.parse(jsonString);
        console.log("Parsed project data:", loadedData);

        if (!loadedData || typeof loadedData !== 'object') throw new Error("Parsed data is not a valid object.");
        if (!loadedData.projectId) throw new Error("Loaded project data is missing 'projectId'.");
        
        if (!Array.isArray(loadedData.slides)) {
             console.warn("Loaded data missing 'slides' array or it's invalid, defaulting to empty.");
             loadedData.slides = [];
        }

        adminApp.state.projectData = loadedData; 

        if (editingProjectTitleEl) {
            editingProjectTitleEl.textContent = `Editing Project: ${adminApp.state.projectData.title || '(Untitled)'}`;
        }

        updateSlideThumbnailsUI(); 

        if (adminApp.state.projectData.slides.length > 0) {
            selectSlide(0); 
            displayMessage("Project loaded successfully.", true);
        } else {
            displayMessage("Project loaded, but it has no slides. Adding one.", true);
            handleAddSlide(); 
        }
        showLoading(false); 

    } catch (e) {
        showLoading(false);
        console.error("onProjectDataLoaded: Error parsing JSON data or invalid structure:", e);
        console.error("Received JSON string that failed parsing:", jsonString); 
        displayMessage(`Error: Failed to parse loaded project data. ${e.message}`, false);
        adminApp.state.projectData = { projectId: adminApp.state.currentProjectId, title: "Invalid Data", slides: [] };
        adminApp.state.currentSlideIndex = -1;
        if (editingProjectTitleEl) editingProjectTitleEl.textContent = `Invalid Project Data (ID: ${adminApp.state.currentProjectId})`;
        updateSlideThumbnailsUI(); 
    }
  }

  function handleAddSlide() {
      console.log("handleAddSlide called");
      if (!adminApp.state.projectData) { console.error("handleAddSlide: projectData not initialized."); return; }
      saveCurrentSlideState();
      const newSlideId = 'slide_' + Utilities.getUuid();
      const newSlide = { slideId: newSlideId, canvasWidth: adminApp.state.defaultCanvasWidth, canvasHeight: adminApp.state.defaultCanvasHeight, fabricCanvasJSON: null, slideMedia: { type: null, url: null, driveFileId: null, mimeType: null } };
      if (!adminApp.state.projectData.slides) adminApp.state.projectData.slides = []; 
      adminApp.state.projectData.slides.push(newSlide);
      const newSlideIndex = adminApp.state.projectData.slides.length - 1;
      selectSlide(newSlideIndex);
      console.log("Added new slide. Total slides:", adminApp.state.projectData.slides.length);
  }

  function selectSlide(slideIndex) {
      if (!adminApp.state.projectData || !adminApp.state.projectData.slides || slideIndex < 0 || slideIndex >= adminApp.state.projectData.slides.length) { console.error("selectSlide: Invalid index or slides array missing.", slideIndex); return; }
      console.log(`Selecting slide ${slideIndex + 1}`);
      saveCurrentSlideState();

      adminApp.state.currentSlideIndex = slideIndex;
      const selectedSlideData = adminApp.state.projectData.slides[slideIndex];
      const canvas = adminApp.state.fabricCanvasInstance;
      if (!canvas) { console.error("selectSlide: Canvas not ready!"); return; }

      const slideWidth = selectedSlideData.canvasWidth || adminApp.state.defaultCanvasWidth;
      const slideHeight = selectedSlideData.canvasHeight || adminApp.state.defaultCanvasHeight;
      canvas.setWidth(slideWidth);
      canvas.setHeight(slideHeight);
      if (fabricCanvasEl) { fabricCanvasEl.width = slideWidth; fabricCanvasEl.height = slideHeight; }
      console.log(`Canvas set to dimensions for slide ${slideIndex + 1}: ${slideWidth}x${slideHeight}`);

      canvas.clear();
      canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas)); 
      canvas.backgroundColor = '#e9e9e9';

      const media = selectedSlideData.slideMedia;
      if (media && media.type === 'image' && media.url) {
          if (media.url.startsWith('data:image')) { 
              console.log("Loading background from base64 data URI.");
              fabric.Image.fromURL(media.url, function(img) {
                  if (!adminApp.state.fabricCanvasInstance) return;
                  if (adminApp.state.currentSlideIndex !== slideIndex) {
                      console.log("Slide changed before background loaded for index", slideIndex);
                      return;
                  }
                  adminApp.state.fabricCanvasInstance.setBackgroundImage(img, canvas.renderAll.bind(canvas), { scaleX: canvas.width / img.width, scaleY: canvas.height / img.height });
                  console.log("Background loaded for slide", slideIndex);
              }, { crossOrigin: 'anonymous' }); 
          } else if (media.driveFileId) { 
               console.log(`Background needs fetch from Drive ID for slide ${slideIndex + 1}:`, media.driveFileId);
               showLoading(true); displayMessage("Loading slide background...", true);
               google.script.run
                   .withSuccessHandler(function(response) { 
                        showLoading(false);
                        if (adminApp.state.currentSlideIndex !== slideIndex) {
                            console.log("Slide changed before background could be fetched for index", slideIndex);
                            return;
                        }
                        if (response && response.success && response.base64Data) {
                            fabric.Image.fromURL(response.base64Data, function(img) { 
                                if (!adminApp.state.fabricCanvasInstance) return;
                                adminApp.state.fabricCanvasInstance.setBackgroundImage(img, canvas.renderAll.bind(canvas), { scaleX: canvas.width / img.width, scaleY: canvas.height / img.height });
                                console.log("Background fetched and loaded for slide", slideIndex);
                            });
                        } else { 
                            console.error("Failed to re-fetch background", response);
                            displayMessage("Error loading slide background image.", false); 
                            canvas.renderAll(); 
                        }
                   })
                   .withFailureHandler(onServerError) 
                   .getImageAsBase64(media.driveFileId);
           } else {
              console.warn("Slide media URL/ID not suitable for loading:", media);
              canvas.renderAll();
          }
      } else {
          console.log("No background media found for slide", slideIndex);
          canvas.renderAll();
      }

      if (selectedSlideData.fabricCanvasJSON) {
        console.log("Loading fabricCanvasJSON for slide", slideIndex);
        canvas.loadFromJSON(selectedSlideData.fabricCanvasJSON, function() {
            if (!adminApp.state.fabricCanvasInstance) return; 
            if (adminApp.state.currentSlideIndex !== slideIndex) {
                console.log("Slide changed before overlays loaded for index", slideIndex);
                return;
            }
            adminApp.state.fabricCanvasInstance.renderAll(); 
            console.log("Finished loading canvas JSON for slide", slideIndex);
            const activeObj = adminApp.state.fabricCanvasInstance.getActiveObject();
            populateToolbar(activeObj); 
          }, function(o, object) { 
          });
          } else { 
          console.log("No fabricCanvasJSON to load for slide", slideIndex);
          canvas.renderAll(); 
          populateToolbar(null); 
      }
      updateSlideThumbnailsUI(); 
      if (imageUploaderEl) imageUploaderEl.value = null; 
  }

  function updateSlideThumbnailsUI() {
      if (!slideThumbnailsContainerEl || !adminApp.state.projectData) { console.warn("updateSlideThumbnailsUI: Container or project data missing."); return; }
      slideThumbnailsContainerEl.innerHTML = '';
      if (!adminApp.state.projectData.slides) adminApp.state.projectData.slides = []; 
      adminApp.state.projectData.slides.forEach((slide, index) => {
          const thumb = document.createElement('div'); thumb.className = 'slide-thumbnail';
          thumb.textContent = `Slide ${index + 1}`; thumb.title = `Select Slide ${index + 1}`;
          if (index === adminApp.state.currentSlideIndex) thumb.classList.add('active-slide');
          thumb.onclick = function() { selectSlide(index); };
          const deleteBtn = document.createElement('button'); deleteBtn.className = 'delete-slide-btn'; deleteBtn.innerHTML = 'Ã—'; deleteBtn.title = "Delete slide";
          deleteBtn.onclick = function(event) { event.stopPropagation(); handleDeleteSlide(index); };
          thumb.appendChild(deleteBtn); slideThumbnailsContainerEl.appendChild(thumb);
      });
  }

  function handleDeleteSlide(slideIndex) {
      if (!adminApp.state.projectData || !adminApp.state.projectData.slides || slideIndex < 0 || slideIndex >= adminApp.state.projectData.slides.length) { console.error("handleDeleteSlide: Invalid index."); return; }
      if (adminApp.state.projectData.slides.length <= 1) { displayMessage("Cannot delete the last slide.", false); return; }
      if (!confirm(`Are you sure you want to delete Slide ${slideIndex + 1}?`)) return;
      adminApp.state.projectData.slides.splice(slideIndex, 1);
      console.log("Deleted slide at index:", slideIndex);
      const indexToSelect = (slideIndex === 0 && adminApp.state.projectData.slides.length > 0) ? 0 : Math.max(0, slideIndex - 1);

      if (adminApp.state.currentSlideIndex === slideIndex) {
          adminApp.state.currentSlideIndex = -1; 
          selectSlide(indexToSelect);
      } else if (adminApp.state.currentSlideIndex > slideIndex) {
          adminApp.state.currentSlideIndex--; 
          updateSlideThumbnailsUI(); 
      } else {
           updateSlideThumbnailsUI(); 
      }
  }

  function saveCurrentSlideState() {
      if (adminApp.state.currentSlideIndex === -1 || !adminApp.state.fabricCanvasInstance || !adminApp.state.projectData || !adminApp.state.projectData.slides[adminApp.state.currentSlideIndex]) { return; }
      try {
        const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
        const canvas = adminApp.state.fabricCanvasInstance;
        const propsToInclude = ['slideId', 'canvasWidth', 'canvasHeight', 'customInteraction', 'customAnimation', 'sequenceOrder']; 
        currentSlide.fabricCanvasJSON = canvas.toJSON(propsToInclude);
        currentSlide.canvasWidth = canvas.getWidth();
        currentSlide.canvasHeight = canvas.getHeight();
        if (!currentSlide.slideMedia) {
             currentSlide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null };
        }
        console.log(`Slide ${adminApp.state.currentSlideIndex + 1} state saved.`);
      } catch(e) {
          console.error("Error saving slide state:", e);
      }
  }

  function handleSaveProject() {
      if (!adminApp.state.projectData || !adminApp.state.currentProjectId) { displayMessage("No project data to save.", false); return; }
      if (adminApp.state.isLoading) return;
      saveCurrentSlideState();
      showLoading(true); displayMessage("Saving project...", true);
      try {
          const jsonDataString = JSON.stringify(adminApp.state.projectData);
          console.log("Saving projectData string length:", jsonDataString.length); 
          google.script.run
              .withSuccessHandler(onProjectSaved)
              .withFailureHandler(onServerError)
              .saveProjectData(adminApp.state.currentProjectId, jsonDataString);
      } catch (e) {
           showLoading(false);
           console.error("Error stringifying project data:", e);
           displayMessage("Error preparing data for saving.", false);
      }
  }

  function onProjectSaved(response) {
      showLoading(false);
      if (response && response.success) { displayMessage(response.message || "Project saved!", true); }
      else { onServerError((response && response.error) ? response.error : "Failed to save."); }
  }

  function showLoading(show) {
    adminApp.state.isLoading = show;
    if (loadingSpinnerEl) loadingSpinnerEl.style.display = show ? 'flex' : 'none';
    else if (show) console.warn("showLoading(true) loadingSpinnerEl not found.");
  }
  function displayMessage(message, isSuccess) {
      if (messageAreaEl) { messageAreaEl.innerHTML = ''; const p = document.createElement('p'); p.textContent = message; messageAreaEl.appendChild(p); messageAreaEl.className = isSuccess ? 'success' : 'error'; setTimeout(() => { if (messageAreaEl) { messageAreaEl.innerHTML = ''; messageAreaEl.className = ''; } }, 7000); } else { console.warn("displayMessage messageAreaEl not found. Message:", message); }
  }
  
  function handleProjectStatusChange(projectId, newStatus, selectElement) {
      console.log(`Attempting to update status for project ${projectId} to ${newStatus}`);
      showLoading(true);
      // Store original value in case of failure
      const originalStatus = selectElement.getAttribute('data-original-status') || 
                             (adminApp.state.projectListCache.find(p => p.projectId === projectId) || {}).status;
      selectElement.setAttribute('data-original-status', originalStatus);


      google.script.run
          .withSuccessHandler(function(response) { onProjectStatusUpdated(response, projectId, newStatus, selectElement); })
          .withFailureHandler(function(error) { 
              onServerError(error);
              if (selectElement) { // Revert dropdown on actual network/script errors
                  console.log("Reverting status dropdown due to server error for project:", projectId);
                  selectElement.value = originalStatus; 
              }
          })
          .updateProjectStatus(projectId, newStatus);
  }

  function onProjectStatusUpdated(response, projectId, newStatus, selectElement) {
      showLoading(false);
      if (response && response.success) {
          displayMessage(response.message || "Project status updated successfully!", true);
          
          // Update cache
          const projectInCache = adminApp.state.projectListCache.find(p => p.projectId === projectId);
          if (projectInCache) projectInCache.status = newStatus;
          selectElement.removeAttribute('data-original-status'); // Clear original status on success

          // Update visual status text in the list
          const statusSpan = selectElement.closest('.project-item').querySelector('.status-text');
          if(statusSpan) statusSpan.textContent = `(${newStatus})`;
          
          // If this project is currently being edited, update its status in projectData
          if (adminApp.state.currentView === 'edit' && adminApp.state.currentProjectId === projectId && adminApp.state.projectData) {
              adminApp.state.projectData.status = newStatus;
              // If there's a status selector on the edit page, update it too (future enhancement)
              // const editPageStatusSelector = document.getElementById('projectStatusSelectorOnEditPage');
              // if (editPageStatusSelector) editPageStatusSelector.value = newStatus;
          }
      } else {
          onServerError((response && response.error) ? response.error : "Failed to update status.");
          if (selectElement) { // Revert dropdown on server-side failure reported as success:false
               console.log("Reverting status dropdown due to server failure for project:", projectId);
               selectElement.value = selectElement.getAttribute('data-original-status') || projectInCache.status; // Fallback to cache if attr cleared
          }
      }
  }

  function handleDeleteProject(projectId, projectTitle) {
      if (!confirm(`Are you sure you want to delete the project "${projectTitle}" (ID: ${projectId})? This action cannot be undone.`)) {
          return;
      }
      console.log(`Attempting to delete project ${projectId}`);
      showLoading(true);
      google.script.run
          .withSuccessHandler(onProjectDeleted)
          .withFailureHandler(onServerError)
          .deleteProject(projectId);
  }

  function onProjectDeleted(response) {
      showLoading(false);
      if (response && response.success) {
          displayMessage(response.message || "Project deleted successfully!", true);
          // If the deleted project was being edited, switch to list view
          if (adminApp.state.currentView === 'edit' && adminApp.state.currentProjectId === response.deletedProjectId) {
              switchToListView(); // This will also call loadAdminProjectsList
          } else {
              loadAdminProjectsList(); // Refresh the list
          }
      } else {
          onServerError((response && response.error) ? response.error : "Failed to delete project.");
      }
  }

  function onServerError(errorObject) {
    console.error("onServerError triggered:", errorObject);
    showLoading(false);
    let errorMessage = "An unknown server error occurred.";
     if (typeof errorObject === 'string') { errorMessage = errorObject; }
     else if (errorObject && errorObject.message) { errorMessage = errorObject.message; }
     else if (errorObject && errorObject.error && typeof errorObject.error === 'string') { errorMessage = errorObject.error; }
    console.error('Formatted Server Error Message:', errorMessage);
    displayMessage('Server Error: ' + errorMessage, false);
  }

  function handleCreateProject() {
      if (adminApp.state.isLoading) return;
      const currentProjectTitle = projectTitleInputEl.value.trim();
      if (!currentProjectTitle) { displayMessage('Project title cannot be empty.', false); projectTitleInputEl.focus(); return; }
      showLoading(true);
      google.script.run.withSuccessHandler(onProjectCreated).withFailureHandler(onServerError).createProject(currentProjectTitle);
  }
  function onProjectCreated(response) {
      showLoading(false);
      if (response && response.success) { displayMessage(response.message || 'Project created!', true); if(projectTitleInputEl) projectTitleInputEl.value = ''; loadAdminProjectsList(); }
      else { onServerError((response && response.error) ? response.error : 'Failed to create project.'); }
  }

  function loadAdminProjectsList() {
    console.log("loadAdminProjectsList: Function called.");
    if (!adminProjectListContainerEl) { console.error("loadAdminProjectsList: adminProjectListContainerEl not found."); showLoading(false); return; }
    if (!google || !google.script || !google.script.run) { console.error("loadAdminProjectsList: google.script.run unavailable."); displayMessage("Error: Client-server bridge unavailable.", false); return; }
    showLoading(true);
    console.log("loadAdminProjectsList: Calling google.script.run.getAllProjectsForAdmin...");
    google.script.run
      .withSuccessHandler(displayAdminProjects)
      .withFailureHandler(onServerError)
      .getAllProjectsForAdmin();
     console.log("loadAdminProjectsList: google.script.run.getAllProjectsForAdmin call initiated.");
  }
  function displayAdminProjects(projectsArray) {
    console.log("displayAdminProjects (Success Handler) received data:", projectsArray);
    showLoading(false);
    if (!adminProjectListContainerEl) { console.error("displayAdminProjects: adminProjectListContainerEl not found."); return; }
    adminProjectListContainerEl.innerHTML = '';
    if (!projectsArray || projectsArray.length === 0) { adminProjectListContainerEl.innerHTML = '<p>No projects found.</p>'; return; }
    
    adminApp.state.projectListCache = projectsArray; 

    projectsArray.forEach(project => { 
        if (!project || !project.projectId) return; 
        const projectItem = document.createElement('div'); 
        projectItem.className = 'project-item'; 
        
        const titleAndStatusDiv = document.createElement('div');
        titleAndStatusDiv.style.display = 'flex';
        titleAndStatusDiv.style.flexDirection = 'column'; 

        const titleSpan = document.createElement('span'); 
        titleSpan.textContent = project.projectTitle || 'Untitled Project'; 
        titleSpan.style.fontWeight = 'bold';
        
        const statusTextSpan = document.createElement('span'); 
        statusTextSpan.className = 'status-text'; 
        statusTextSpan.textContent = `(${project.status || 'N/A'})`; 
        statusTextSpan.style.fontSize = '0.9em';
        statusTextSpan.style.fontStyle = 'italic';
        statusTextSpan.style.color = '#555';
        
        titleAndStatusDiv.appendChild(titleSpan);
        titleAndStatusDiv.appendChild(statusTextSpan);

        const controlsDiv = document.createElement('div'); 
        controlsDiv.style.display = 'flex';
        controlsDiv.style.alignItems = 'center';

        const statusSelect = document.createElement('select');
        statusSelect.className = 'project-status-select';
        statusSelect.setAttribute('data-project-id', project.projectId);
        // Store original status for potential revert
        statusSelect.setAttribute('data-original-status', project.status || "Draft"); 
        ['Draft', 'Active', 'Inactive'].forEach(statusValue => {
            const option = document.createElement('option');
            option.value = statusValue;
            option.textContent = statusValue;
            if (project.status === statusValue) {
                option.selected = true;
            }
            statusSelect.appendChild(option);
        });
        statusSelect.onchange = function() {
            handleProjectStatusChange(project.projectId, this.value, this);
        };
        statusSelect.style.padding = '5px';
        statusSelect.style.marginRight = '10px';
        statusSelect.style.fontSize = '0.9em';
        statusSelect.style.border = '1px solid #ccc';
        statusSelect.style.borderRadius = '3px';

        const editButton = document.createElement('button'); 
        editButton.textContent = 'Edit'; 
        editButton.className = 'edit-button'; 
        editButton.setAttribute('data-project-id', project.projectId); 
        editButton.onclick = function() { console.log("Edit button clicked:", project.projectId); switchToEditView(project.projectId); }; 
        
        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.className = 'danger-button'; // Use existing style for danger buttons
        deleteButton.setAttribute('data-project-id', project.projectId);
        deleteButton.setAttribute('data-project-title', project.projectTitle || 'Untitled Project');
        deleteButton.style.marginLeft = '5px';
        deleteButton.onclick = function() {
            handleDeleteProject(project.projectId, project.projectTitle || 'Untitled Project');
        };

        controlsDiv.appendChild(statusSelect);
        controlsDiv.appendChild(editButton);
        controlsDiv.appendChild(deleteButton); // Add delete button
        
        projectItem.appendChild(titleAndStatusDiv); 
        projectItem.appendChild(controlsDiv); 
        adminProjectListContainerEl.appendChild(projectItem);
     });
    console.log("displayAdminProjects: Finished rendering project list.");
  }

  function handleImageUpload(event) {
      if (adminApp.state.isLoading) { if(event.target) event.target.value = null; return; }
      const file = event.target.files[0];
      if (!file || !file.type.startsWith('image/')) { if(event.target) event.target.value = null; return; }
      showLoading(true); displayMessage("Uploading image...", true);
      const reader = new FileReader();
      reader.onload = function(e) {
          const fileData = { fileName: file.name, mimeType: file.type, data: e.target.result.split(',')[1] };
          if (!adminApp.state.currentProjectId) { showLoading(false); displayMessage("Error: No project.", false); if(event.target) event.target.value = null; return; }
          google.script.run.withSuccessHandler(onImageUploaded).withFailureHandler(onServerError).uploadFileToDrive(fileData, adminApp.state.currentProjectId, 'image');
      };
      reader.onerror = function(error) { showLoading(false); displayMessage("Error reading file.", false); console.error(error); if(event.target) event.target.value = null; };
      reader.readAsDataURL(file);
  }
  function onImageUploaded(response) { 
      showLoading(false); if (imageUploaderEl) imageUploaderEl.value = null;
      if (response && response.success && response.driveFileId) {
          displayMessage("Image uploaded. Fetching...", true); showLoading(true);
          adminApp.state.lastUploadedDriveId = response.driveFileId; 
          google.script.run.withSuccessHandler(onBase64ImageReceived).withFailureHandler(onServerError).getImageAsBase64(response.driveFileId);
      } else { onServerError({ message: (response && response.error) ? response.error : "Upload failed." }); }
  }
  function onBase64ImageReceived(response) { 
      showLoading(false);
      if (response && response.success && response.base64Data) {
          if (!adminApp.state.fabricCanvasInstance || adminApp.state.currentSlideIndex === -1) { displayMessage("Error: Canvas/Slide not ready.", false); return; }
          const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
          if (!currentSlide) { displayMessage("Error: Slide data missing.", false); return; }
          fabric.Image.fromURL(response.base64Data, function(img) {
              if (!adminApp.state.fabricCanvasInstance) return;
              if (adminApp.state.currentSlideIndex === -1) return; 
              const canvas = adminApp.state.fabricCanvasInstance; const imgWidth = img.width; const imgHeight = img.height; const maxWidth = 960;
              let cvWidth = imgWidth; let cvHeight = imgHeight; const ratio = imgWidth / imgHeight;
              if (cvWidth > maxWidth) { cvWidth = maxWidth; cvHeight = Math.round(cvWidth / ratio); }
              canvas.setWidth(cvWidth); canvas.setHeight(cvHeight);
              if (fabricCanvasEl) { fabricCanvasEl.width = cvWidth; fabricCanvasEl.height = cvHeight; }
              canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), { scaleX: cvWidth / imgWidth, scaleY: cvHeight / imgHeight });
              canvas.renderAll(); displayMessage("Background set.", true);
              if (!currentSlide.slideMedia) currentSlide.slideMedia = {}; 
              currentSlide.slideMedia.type = 'image';
              currentSlide.slideMedia.url = response.base64Data; 
              currentSlide.slideMedia.driveFileId = adminApp.state.lastUploadedDriveId || null; 
              currentSlide.slideMedia.mimeType = response.mimeType;
              currentSlide.canvasWidth = cvWidth; currentSlide.canvasHeight = cvHeight;
              console.log(`Slide ${adminApp.state.currentSlideIndex + 1} media/dims updated.`);
              updateSlideThumbnailsUI();
              delete adminApp.state.lastUploadedDriveId; 
          });
      } else { onServerError({ message: (response && response.error) ? response.error : "Failed to fetch image." }); }
  }

  function addRectangle() {
    if (!adminApp.state.fabricCanvasInstance) { console.error("addRectangle: Fabric canvas not initialized."); displayMessage("Error: Canvas not ready to add shapes.", false); return; }
    const canvas = adminApp.state.fabricCanvasInstance;
    const rect = new fabric.Rect({ left: 50, top: 50, fill: 'rgba(255,0,0,0.7)', width: 150, height: 100, stroke: 'black', strokeWidth: 1, customInteraction: { trigger: "", action: "", modalContent: "", navigateTo: "" }, customAnimation: { type: null, duration: 500, strength: 5, trigger: null }, sequenceOrder: null });
    canvas.add(rect); canvas.setActiveObject(rect); canvas.renderAll(); console.log("Rectangle added to canvas:", rect);
  }

  function addCircle() {
    if (!adminApp.state.fabricCanvasInstance) { console.error("addCircle: Fabric canvas not initialized."); displayMessage("Error: Canvas not ready to add shapes.", false); return; }
    const canvas = adminApp.state.fabricCanvasInstance;
    const circle = new fabric.Circle({ left: 150, top: 150, radius: 50, fill: 'rgba(0,0,255,0.7)', stroke: 'black', strokeWidth: 1, customInteraction: { trigger: "", action: "", modalContent: "", navigateTo: "" }, customAnimation: { type: null, duration: 500, strength: 5, trigger: null }, sequenceOrder: null });
    canvas.add(circle); canvas.setActiveObject(circle); canvas.renderAll(); console.log("Circle added to canvas:", circle);
  }

  function addTextbox() {
    if (!adminApp.state.fabricCanvasInstance) { console.error("addTextbox: Fabric canvas not initialized."); displayMessage("Error: Canvas not ready to add text.", false); return; }
    const canvas = adminApp.state.fabricCanvasInstance;
    const textbox = new fabric.Textbox('Editable Text', { left: 100, top: 100, width: 200, fontSize: 24, fill: '#000000', customInteraction: { trigger: "", action: "", modalContent: "", navigateTo: "" }, customAnimation: { type: null, duration: 500, strength: 5, trigger: null }, sequenceOrder: null });
    canvas.add(textbox); canvas.setActiveObject(textbox); canvas.renderAll(); canvas.bringToFront(textbox); console.log("Textbox added to canvas:", textbox);
  }
  
  function toHexColor(fabricColor) {
    if (!fabricColor) return '#000000'; 
    try {
      const colorInstance = new fabric.Color(fabricColor);
      const hex = colorInstance.toHex();
      return '#' + hex;
    } catch (e) {
      console.warn("Could not convert color to HEX:", fabricColor, e);
      return '#000000'; 
    }
  }

  function initToolbar() { 
    console.log("initToolbar: Attaching listeners to toolbar inputs."); 
    const inputs = [
      {el: objXEl, prop: 'left', type: 'number'}, {el: objYEl, prop: 'top', type: 'number'},
      {el: objWidthEl, prop: 'width', type: 'number', targetProp: 'scaleX'}, 
      {el: objHeightEl, prop: 'height', type: 'number', targetProp: 'scaleY'},
      {el: objAngleEl, prop: 'angle', type: 'number'},
      {el: objFillEl, prop: 'fill', type: 'color'},
      {el: objStrokeColorEl, prop: 'stroke', type: 'color'},
      {el: objStrokeWidthEl, prop: 'strokeWidth', type: 'number'},
      {el: objOpacityEl, prop: 'opacity', type: 'range'},
      {el: objTextContentEl, prop: 'text', type: 'textarea'},
      {el: objShadowColorEl, prop: 'shadow.color', type: 'color'},
      {el: objShadowBlurEl, prop: 'shadow.blur', type: 'range'},
      {el: objShadowOffsetXEl, prop: 'shadow.offsetX', type: 'number'},
      {el: objShadowOffsetYEl, prop: 'shadow.offsetY', type: 'number'}
    ];

    inputs.forEach(inputConfig => {
      if (inputConfig.el) {
        inputConfig.el.addEventListener('input', (e) => { 
          updateFabricObjectFromToolbar(inputConfig.prop, e.target.value, inputConfig.type); 
        });
        if (inputConfig.el.type === 'color' || inputConfig.el.tagName === 'SELECT') { 
             inputConfig.el.addEventListener('change', (e) => {
                updateFabricObjectFromToolbar(inputConfig.prop, e.target.value, inputConfig.type); 
            });
        }
      } else {
        console.warn(`initToolbar: Element for property "${inputConfig.prop}" not found.`); 
      }
    });

    if (objInteractionTriggerEl) objInteractionTriggerEl.addEventListener('change', handleInteractionChange);
    if (objInteractionActionEl) objInteractionActionEl.addEventListener('change', handleInteractionChange);
    if (objModalContentEl) objModalContentEl.addEventListener('input', handleInteractionChange);
    if (objNavigateToEl) objNavigateToEl.addEventListener('input', handleInteractionChange);
  }

  function populateToolbar(activeObject) { 
    if (!overlayPropertiesToolbarEl) { console.error("populateToolbar: overlayPropertiesToolbarEl not found."); return; } 
    if (!activeObject) {
      overlayPropertiesToolbarEl.style.display = 'none'; 
      return;
    }
    overlayPropertiesToolbarEl.style.display = 'block'; 

    if (objXEl) objXEl.value = activeObject.left ? activeObject.left.toFixed(0) : 0;
    if (objYEl) objYEl.value = activeObject.top ? activeObject.top.toFixed(0) : 0;
    if (objWidthEl) objWidthEl.value = activeObject.getScaledWidth ? activeObject.getScaledWidth().toFixed(0) : (activeObject.width || 0);
    if (objHeightEl) objHeightEl.value = activeObject.getScaledHeight ? activeObject.getScaledHeight().toFixed(0) : (activeObject.height || 0);
    if (objAngleEl) objAngleEl.value = activeObject.angle ? activeObject.angle.toFixed(0) : 0;

    if (objFillEl) objFillEl.value = toHexColor(activeObject.fill); 
    if (objStrokeColorEl) objStrokeColorEl.value = toHexColor(activeObject.stroke); 
    if (objStrokeWidthEl) objStrokeWidthEl.value = activeObject.strokeWidth === undefined ? 0 : activeObject.strokeWidth; 
    if (objOpacityEl) objOpacityEl.value = activeObject.opacity === undefined ? 1 : activeObject.opacity; 

    if (textSpecificControlsEl) {
      if (activeObject.type === 'textbox' || activeObject.type === 'i-text') { 
        textSpecificControlsEl.style.display = 'block'; 
        if (objTextContentEl) objTextContentEl.value = activeObject.text || '';
      } else {
        textSpecificControlsEl.style.display = 'none';
      }
    }
    
    const shadow = activeObject.shadow;
    if (objShadowColorEl) objShadowColorEl.value = shadow ? toHexColor(shadow.color) : '#000000'; 
    if (objShadowBlurEl) objShadowBlurEl.value = shadow ? shadow.blur : 0;
    if (objShadowOffsetXEl) objShadowOffsetXEl.value = shadow ? shadow.offsetX : 0;
    if (objShadowOffsetYEl) objShadowOffsetYEl.value = shadow ? shadow.offsetY : 0;

    const interaction = activeObject.customInteraction || { trigger: "", action: "", modalContent: "", navigateTo: "" };
    if (objInteractionTriggerEl) objInteractionTriggerEl.value = interaction.trigger || "";
    if (objInteractionActionEl) objInteractionActionEl.value = interaction.action || "";
    if (objModalContentEl) objModalContentEl.value = interaction.modalContent || "";
    if (objNavigateToEl) objNavigateToEl.value = interaction.navigateTo || "";
    
    updateInteractionConfigVisibility(interaction.action);
  }

  function handleInteractionChange() {
      const canvas = adminApp.state.fabricCanvasInstance;
      if (!canvas) return;
      const activeObject = canvas.getActiveObject();
      if (!activeObject) return;

      if (!activeObject.customInteraction) {
          activeObject.customInteraction = { trigger: "", action: "", modalContent: "", navigateTo: "" };
      }

      if (objInteractionTriggerEl) activeObject.customInteraction.trigger = objInteractionTriggerEl.value;
      if (objInteractionActionEl) activeObject.customInteraction.action = objInteractionActionEl.value;
      if (objModalContentEl) activeObject.customInteraction.modalContent = objModalContentEl.value;
      if (objNavigateToEl) activeObject.customInteraction.navigateTo = objNavigateToEl.value;

      updateInteractionConfigVisibility(activeObject.customInteraction.action);
      console.log("Interaction data updated for object:", activeObject.customInteraction);
  }

  function updateInteractionConfigVisibility(action) {
      if (modalContentConfigEl) modalContentConfigEl.style.display = (action === 'showModal') ? 'block' : 'none';
      if (navigateToConfigEl) navigateToConfigEl.style.display = (action === 'navigateToSlide' || action === 'navigateToURL') ? 'block' : 'none';
  }


  function updateFabricObjectFromToolbar(propertyName, value, inputType) { 
    const canvas = adminApp.state.fabricCanvasInstance;
    if (!canvas) return;
    const activeObject = canvas.getActiveObject();
    if (!activeObject) return;

    let parsedValue = value;
    if (inputType === 'number' || inputType === 'range') {
      parsedValue = inputType === 'range' ? parseFloat(value) : parseInt(value, 10);
      if (isNaN(parsedValue)) {
          if (propertyName === 'strokeWidth' && value === '') parsedValue = 0;
          else if (value === '') return; 
          else return; 
      }
    }
    
    if (propertyName === 'width') {
      activeObject.scaleX = parsedValue > 0 ? (parsedValue / activeObject.width) : (activeObject.width > 0 ? 0.0001 / activeObject.width : 0.0001);
    } else if (propertyName === 'height') {
      activeObject.scaleY = parsedValue > 0 ? (parsedValue / activeObject.height) : (activeObject.height > 0 ? 0.0001 / activeObject.height : 0.0001);
    } else if (propertyName.startsWith('shadow.')) {
      const shadowProp = propertyName.split('.')[1];
      let shadowOptions = activeObject.shadow instanceof fabric.Shadow ? activeObject.shadow.toObject() : {};
      shadowOptions[shadowProp] = parsedValue;
      shadowOptions.blur = parseInt(objShadowBlurEl.value, 10) || 0;
      shadowOptions.offsetX = parseInt(objShadowOffsetXEl.value, 10) || 0;
      shadowOptions.offsetY = parseInt(objShadowOffsetYEl.value, 10) || 0;
      shadowOptions.color = objShadowColorEl.value || '#000000';
      activeObject.set('shadow', new fabric.Shadow(shadowOptions));
    } else {
      if (!propertyName.startsWith('interaction.')) { 
          activeObject.set(propertyName, parsedValue);
      }
    }

    if ((activeObject.type === 'textbox' || activeObject.type === 'i-text') && propertyName === 'text') {
        activeObject.initDimensions(); 
    }

    activeObject.setCoords(); 
    canvas.renderAll();
  }

  Utilities = { getUuid: function() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); } };

</script>