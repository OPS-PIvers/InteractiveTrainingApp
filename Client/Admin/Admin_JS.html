<script>
    // Namespace for the admin application
    window.adminApp = {};

    // --- Constants ---
    const ADMIN_DEFAULT_CANVAS_WIDTH = 960;
    const ADMIN_DEFAULT_CANVAS_HEIGHT = 540;
    const ADMIN_MAX_HISTORY_SIZE = 20;
    const ADMIN_SHORT_DELAY = 100; 
    const ADMIN_RECT_DEFAULT_FILL = 'rgba(255,0,0,0.7)';
    const ADMIN_RECT_DEFAULT_WIDTH = 150;
    const ADMIN_RECT_DEFAULT_HEIGHT = 100;
    const ADMIN_CIRCLE_DEFAULT_FILL = 'rgba(0,0,255,0.7)';
    const ADMIN_CIRCLE_DEFAULT_RADIUS = 50;
    const ADMIN_TEXTBOX_DEFAULT_FONT_SIZE = 24;
    const ADMIN_TEXTBOX_DEFAULT_FILL = '#000000';
    const ADMIN_TEXTBOX_DEFAULT_WIDTH = 200;
    const ADMIN_CANVAS_BACKGROUND_COLOR = '#e9e9e9';
    const ADMIN_MAX_IMAGE_WIDTH_ON_UPLOAD = 960;
    const ADMIN_PREVIEW_OVERLAY_Z_INDEX = 1050;
    // Note: Other Z-indexes (like for modals, popovers) are primarily CSS-controlled.

    // --- Application State ---
    adminApp.state = {
      isLoading: false,
      currentProjectId: null,
      currentView: 'list',
      projectData: null,
      currentSlideIndex: -1,
      fabricCanvasInstance: null,
      defaultCanvasWidth: ADMIN_DEFAULT_CANVAS_WIDTH,
      defaultCanvasHeight: ADMIN_DEFAULT_CANVAS_HEIGHT,
      projectListCache: [], // Added to cache project list for status updates/reverts
      lastUploadedDriveId: null, // Temp store for image uploads before base64 fetch
      lastUploadedMimeType: null,
      lastUploadedFileName: null,
      isPasteListenerActive: false, // To manage listener attachment for pasting images
      activePopoverId: null, // To track the currently open popover
      history: [],
      historyIndex: -1,
      isApplyingHistory: false, // Flag to prevent re-saving state during undo and redo
      // adminYouTubePlayer: null, // Will use mediaManager.state.ytPlayer
      // isYouTubeApiReady: false, // Will use mediaManager.state.isYouTubeApiReady
      // deferredYouTubeSetup: null, // Will use mediaManager.state.deferredMediaSetup
      placingOverlay: null,
      editingOverlayId: null,
      previewingOverlays: false,
      overlayPreviewInterval: null // This specific interval for admin preview might remain or be adapted
    };

// ADD interval tracking:
adminApp.intervals = {
  // playerUpdate: null, // To be managed by MediaManager
  overlayPreview: null, // This specific interval for admin preview might remain or be adapted
  autoSave: null, // If you add autosave later
  // playerQuestionCheckInterval: null // To be managed by MediaManager
};

// Helper to safely clear interval
adminApp.clearInterval = function(intervalName) {
  const timerId = adminApp.intervals[intervalName];
  if (timerId) {
    baseApp.timerManager.clearTimer(timerId); // Use timerManager to clear
    adminApp.intervals[intervalName] = null; // Nullify in our tracking object
    console.log(`Cleared interval via timerManager: ${intervalName} (ID: ${timerId})`);
    // Also remove from resourceManager tracking if it was individually cleared
    baseApp.resourceManager.disposeByName('interval-' + intervalName);
  } else {
    // console.log(`Interval ${intervalName} already clear or not found in adminApp.intervals.`);
  }
};

// ADD after adminApp.state definition:
// adminApp.eventListeners = new WeakMap(); // No longer needed, replaced by resourceManager
// adminApp.activeListeners = []; // No longer needed, replaced by resourceManager

// --- Global function for YouTube API is now handled by MediaManager.html ---
// function onYouTubeIframeAPIReady() { ... } // Removed

// function isYouTubePlayerAvailable() { ... } // Removed, use mediaManager.isYouTubePlayerAvailable()

// function validateYouTubeEnvironment() { ... } // Removed, or logic incorporated into MediaManager or app callbacks

// function safeGetCurrentTime(player) { ... } // Removed, use mediaManager.safeGetCurrentTime()

    // --- DOM Element References ---
    let projectTitleInputEl, createProjectButtonEl, messageAreaEl, loadingSpinnerEl;
    let listViewContainerEl, adminProjectListContainerEl;
    let editViewContainerEl, editingProjectTitleEl, backToProjectsListButtonEl, fabricCanvasEl;
    let imageUploaderEl;
    let addSlideButtonEl, slideThumbnailsContainerEl, saveProjectButtonEl;
    let addRectangleButtonEl, addCircleButtonEl;
    let addTextboxButtonEl;

    // Toolbar Elements (existing and new)
    let overlayPropertiesToolbarEl, objXEl, objYEl, objWidthEl, objHeightEl, objAngleEl,
        objFillEl, objStrokeColorEl, objStrokeWidthEl, objOpacityEl,
        textSpecificControlsEl, objTextContentEl, // Text specific row
        objFontFamilyEl, objFontSizeEl, objFontWeightEl, objFontStyleEl, objTextAlignEl, objLineHeightEl, objCharSpacingEl, // Core text inputs (some hidden, some direct)
        objShadowColorEl, objShadowBlurEl, objShadowOffsetXEl, objShadowOffsetYEl, objShadowAffectStrokeEl, objShadowNonScalingEl, // Shadow inputs
        objInteractionTriggerEl, objInteractionActionEl, modalContentConfigEl, objModalContentEl, navigateToConfigEl, objNavigateToEl, panZoomConfigEl, objPanZoomLevelEl, // Interaction inputs
        objAnimationTriggerEl, objAnimationTypeEl, animationParamsConfigEl, objAnimationDurationEl, objAnimationStrengthEl, objAnimationStrengthUnitEl, // Animation inputs
        objAnimationLoopEl, animationLoopCountConfigEl, objAnimationLoopCountEl, objAnimationLoopDelayEl;

    // New Popover and Toolbar Button DOM elements
    let fillColorButtonEl, strokeColorButtonEl, opacityButtonEl, // Direct action buttons for color/opacity that might reveal inputs
        shadowSettingsButtonEl, interactionSettingsButtonEl, animationSettingsButtonEl, fontFamilyButtonEl, // Popover triggers
        shadowPopoverEl, interactionPopoverEl, animationPopoverEl, fontFamilyPopoverEl, // Popover containers
        fillColorPopoverEl, strokeColorPopoverEl, opacityPopoverEl, // NEW POPOVERS for color/opacity
        objOpacityValueDisplayEl, // Span to show opacity percentage
        fontWeightButtonEl, fontStyleButtonEl, textAlignGroupEl; // Text style toggle buttons

    // Step 20 Media Elements
    let youtubeUrlInputEl, setYoutubeBackgroundButtonEl,
        audioUploaderEl, attachedAudioNameEl, removeAudioButtonEl,
        adminMediaPlaceholderEl, adminYouTubePlayerContainerEl; // Added adminYouTubePlayerContainerEl
    
    // New toolbar buttons
    let mediaToolsButtonEl, addShapeButtonEl, positionToolsButtonEl;
    // New popovers
    let mediaToolsPopoverEl, shapesPopoverEl, positionToolsPopoverEl;
    // Media tab elements
    let mediaTabButtonsEl, mediaTabPanesEl;
    // Drag and drop zones
    let imageDropZoneEl, audioDropZoneEl;

    // Video Question/Timeline Elements
    let mediaTimelineControlsEl, videoTimelineSliderEl, videoCurrentTimeDisplayEl, videoTotalDurationDisplayEl,
        addQuestionBtnEl, questionModalEl, questionTimestampDisplayEl, questionTextEl,
        saveQuestionBtnEl, cancelQuestionBtnEl, editingQuestionIndexEl,
        videoQuestionsListContainerEl, videoQuestionsListEl; // Added question list elements
    let optionInputsEl = [], correctAnswerRadiosEl = [];

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function() {
      console.log("Admin_JS: DOMContentLoaded event fired!");
      adminApp.setupDOMReferences();
      adminApp.attachEventListeners();
      adminApp.attachVideoQuestionEventListeners(); // This now also includes overlay management button listeners
      switchToListView();
      loadAdminProjectsList();
      console.log("Admin_JS: Initialization complete.");
    });

    // --- Setup and Listeners ---
    adminApp.resizeCanvasToFit = function(slideData) {
    const canvas = adminApp.state.fabricCanvasInstance;
    if (!canvas || !fabricCanvasEl) {
        console.warn("resizeCanvasToFit: Canvas or fabricCanvasEl not ready.");
        return;
    }

    const fabricCanvasContainer = document.getElementById('fabricCanvasContainer');
    if (!fabricCanvasContainer) {
        console.warn("resizeCanvasToFit: fabricCanvasContainer not found.");
        return;
    }

    const containerWidth = fabricCanvasContainer.clientWidth;
    const containerHeight = fabricCanvasContainer.clientHeight;

    if (containerWidth === 0 || containerHeight === 0) {
        console.log("resizeCanvasToFit: Container has no dimensions, skipping resize.");
        return;
    }
    
    // Get content dimensions
    let contentWidth = (slideData && slideData.canvasWidth) ? slideData.canvasWidth : adminApp.state.defaultCanvasWidth;
    let contentHeight = (slideData && slideData.canvasHeight) ? slideData.canvasHeight : adminApp.state.defaultCanvasHeight;

    if (!contentWidth || contentWidth <= 0) contentWidth = adminApp.state.defaultCanvasWidth;
    if (!contentHeight || contentHeight <= 0) contentHeight = adminApp.state.defaultCanvasHeight;

    // Set canvas dimensions
    canvas.setDimensions({
        width: contentWidth,
        height: contentHeight
    });

    // Calculate zoom to fit container
    const zoomX = containerWidth / contentWidth;
    const zoomY = containerHeight / contentHeight;
    const zoom = Math.min(zoomX, zoomY) * 0.9; // 0.9 gives a little padding

    // Apply zoom using Fabric's built-in method
    canvas.setZoom(zoom);
    
    // Center the canvas
    const scaledWidth = contentWidth * zoom;
    const scaledHeight = contentHeight * zoom;
    const left = (containerWidth - scaledWidth) / 2;
    const top = (containerHeight - scaledHeight) / 2;
    
    // Apply positioning
    canvas.viewportTransform[4] = left;
    canvas.viewportTransform[5] = top;
    
    // Update canvas
    canvas.calcOffset();
    canvas.renderAll();
            
    console.log(`Canvas resized: ${contentWidth}x${contentHeight}, Zoom: ${zoom.toFixed(2)}`);
};

    adminApp.setupDOMReferences = function() {
      messageAreaEl = document.getElementById('messageArea');
      loadingSpinnerEl = document.getElementById('loadingSpinner');
      listViewContainerEl = document.getElementById('listViewContainer');
      projectTitleInputEl = document.getElementById('projectTitleInput');
      createProjectButtonEl = document.getElementById('createProjectButton');
      adminProjectListContainerEl = document.getElementById('adminProjectListContainer');
      editViewContainerEl = document.getElementById('editViewContainer');
      editingProjectTitleEl = document.getElementById('editingProjectTitle');
      backToProjectsListButtonEl = document.getElementById('backToProjectsListButton');
      fabricCanvasEl = document.getElementById('fabricCanvasElement');
      imageUploaderEl = document.getElementById('imageUploader');
      addSlideButtonEl = document.getElementById('addSlideButton');
      slideThumbnailsContainerEl = document.getElementById('slideThumbnailsContainer');
      saveProjectButtonEl = document.getElementById('saveProjectButton');

      addRectangleButtonEl = document.getElementById('addRectangleButton');
      addCircleButtonEl = document.getElementById('addCircleButton');
      addTextboxButtonEl = document.getElementById('addTextboxButton');

      overlayPropertiesToolbarEl  = document.getElementById('overlayPropertiesToolbar');

      objXEl = document.getElementById('objX');
      objYEl = document.getElementById('objY');
      objWidthEl = document.getElementById('objWidth');
      objHeightEl = document.getElementById('objHeight');
      objAngleEl = document.getElementById('objAngle');
      objFillEl = document.getElementById('objFill'); 
      objStrokeColorEl = document.getElementById('objStrokeColor'); 
      objStrokeWidthEl = document.getElementById('objStrokeWidth');
      objOpacityEl = document.getElementById('objOpacity'); 

      textSpecificControlsEl = document.getElementById('textSpecificControls');
      objTextContentEl = document.getElementById('objTextContent');
      objFontFamilyEl = document.getElementById('objFontFamily'); 
      objFontSizeEl = document.getElementById('objFontSize');
      objFontWeightEl = document.getElementById('objFontWeight'); 
      objFontStyleEl = document.getElementById('objFontStyle');   
      objTextAlignEl = document.getElementById('objTextAlign');   
      objLineHeightEl = document.getElementById('objLineHeight');
      objCharSpacingEl = document.getElementById('objCharSpacing');

      objShadowColorEl = document.getElementById('objShadowColor');
      objShadowBlurEl = document.getElementById('objShadowBlur');
      objShadowOffsetXEl = document.getElementById('objShadowOffsetX');
      objShadowOffsetYEl = document.getElementById('objShadowOffsetY');
      objShadowAffectStrokeEl = document.getElementById('objShadowAffectStroke');
      objShadowNonScalingEl = document.getElementById('objShadowNonScaling');

      objInteractionTriggerEl = document.getElementById('objInteractionTrigger');
      objInteractionActionEl = document.getElementById('objInteractionAction');
      modalContentConfigEl = document.getElementById('modalContentConfig');
      objModalContentEl = document.getElementById('objModalContent');
      navigateToConfigEl = document.getElementById('navigateToConfig');
      objNavigateToEl = document.getElementById('objNavigateTo');
      panZoomConfigEl = document.getElementById('panZoomConfigEl'); 
      objPanZoomLevelEl = document.getElementById('objPanZoomLevel');

      objAnimationTriggerEl = document.getElementById('objAnimationTrigger');
      objAnimationTypeEl = document.getElementById('objAnimationType');
      animationParamsConfigEl = document.getElementById('animationParamsConfig');
      objAnimationSpeedEl = document.getElementById('objAnimationSpeed'); 
      objAnimationStrengthEl = document.getElementById('objAnimationStrength');
      objAnimationStrengthUnitEl = document.getElementById('objAnimationStrengthUnit');
      objAnimationLoopEl = document.getElementById('objAnimationLoop');
      animationLoopCountConfigEl = document.getElementById('animationLoopCountConfig'); 
      objAnimationLoopCountEl = document.getElementById('objAnimationLoopCount'); 
      objAnimationLoopDelayEl = document.getElementById('objAnimationLoopDelay'); 

      fillColorButtonEl = document.getElementById('fillColorButton');
      strokeColorButtonEl = document.getElementById('strokeColorButton');
      opacityButtonEl = document.getElementById('opacityButton');
      shadowSettingsButtonEl = document.getElementById('shadowSettingsButton');
      interactionSettingsButtonEl = document.getElementById('interactionSettingsButton');
      animationSettingsButtonEl = document.getElementById('animationSettingsButton');
      fontFamilyButtonEl = document.getElementById('fontFamilyButton');

      shadowPopoverEl = document.getElementById('shadowPopover');
      interactionPopoverEl = document.getElementById('interactionPopover');
      animationPopoverEl = document.getElementById('animationPopover');
      fontFamilyPopoverEl = document.getElementById('fontFamilyPopover');
      
      fillColorPopoverEl = document.getElementById('fillColorPopover');
      strokeColorPopoverEl = document.getElementById('strokeColorPopover');
      opacityPopoverEl = document.getElementById('opacityPopover');
      objOpacityValueDisplayEl = document.getElementById('objOpacityValueDisplay');

      fontWeightButtonEl = document.getElementById('fontWeightButton'); 
      fontStyleButtonEl = document.getElementById('fontStyleButton');   
      textAlignGroupEl = document.getElementById('textAlignGroup');     

      undoButtonEl = document.getElementById('undoButton');
      redoButtonEl = document.getElementById('redoButton');
      deleteObjectButtonEl = document.getElementById('deleteObjectButton');

      youtubeUrlInputEl = document.getElementById('youtubeUrlInput');
      setYoutubeBackgroundButtonEl = document.getElementById('setYoutubeBackgroundButton');
      audioUploaderEl = document.getElementById('audioUploader');
      attachedAudioNameEl = document.getElementById('attachedAudioName');
      removeAudioButtonEl = document.getElementById('removeAudioButton');
      adminMediaPlaceholderEl = document.getElementById('adminMediaPlaceholder');
      adminYouTubePlayerContainerEl = document.getElementById('adminYouTubePlayerContainer'); 

      mediaToolsButtonEl = document.getElementById('mediaToolsButton');
      addShapeButtonEl = document.getElementById('addShapeButton'); 
      positionToolsButtonEl = document.getElementById('positionToolsButton');

      mediaToolsPopoverEl = document.getElementById('mediaToolsPopover');
      shapesPopoverEl = document.getElementById('shapesPopover');
      positionToolsPopoverEl = document.getElementById('positionToolsPopover');

      mediaTabButtonsEl = document.querySelectorAll('.media-tab-btn');
      mediaTabPanesEl = document.querySelectorAll('.media-tab-pane');

      imageDropZoneEl = document.getElementById('imageDropZone');
      audioDropZoneEl = document.getElementById('audioDropZone');

      mediaTimelineControlsEl = document.getElementById('mediaTimelineControls');
      videoTimelineSliderEl = document.getElementById('videoTimelineSlider');
      videoCurrentTimeDisplayEl = document.getElementById('videoCurrentTimeDisplay');
      videoTotalDurationDisplayEl = document.getElementById('videoTotalDurationDisplay');
      addQuestionBtnEl = document.getElementById('addQuestionBtn');
      questionModalEl = document.getElementById('questionModal');
      questionTimestampDisplayEl = document.getElementById('questionTimestampDisplay');
      questionTextEl = document.getElementById('questionText');
      saveQuestionBtnEl = document.getElementById('saveQuestionBtn');
      cancelQuestionBtnEl = document.getElementById('cancelQuestionBtn');
      editingQuestionIndexEl = document.getElementById('editingQuestionIndex');
      videoQuestionsListContainerEl = document.getElementById('videoQuestionsListContainer'); 
      videoQuestionsListEl = document.getElementById('videoQuestionsList'); 
      for (let i = 0; i < 4; i++) {
          optionInputsEl.push(document.getElementById(`option${i+1}`));
          correctAnswerRadiosEl.push(document.getElementById(`correctAnswer${i}`));
      }

      // Timestamp Overlay Elements
      // manageTimestampOverlaysButtonEl = document.getElementById('manageTimestampOverlaysButton'); // Removed
      // timestampOverlayModalEl = document.getElementById('timestampOverlayModal'); // Removed
      // makeOverlayInteractiveCheckboxEl = document.getElementById('makeOverlayInteractiveCheckbox'); // Removed
      // addTimestampOverlayButtonEl = document.getElementById('addTimestampOverlayButton'); // Removed
      // timestampOverlayListEl = document.getElementById('timestampOverlayList'); // Removed
      // closeTimestampOverlayModalBtnEl = document.getElementById('closeTimestampOverlayModalBtn'); // Removed
      // currentOverlayTimestampInputEl = document.getElementById('currentOverlayTimestampInput'); // This is commented out in HTML

      if (!messageAreaEl) console.warn("setupDOMReferences: messageAreaEl not found.");
      if (!loadingSpinnerEl) console.warn("setupDOMReferences: loadingSpinnerEl not found.");
      if (!listViewContainerEl) console.warn("setupDOMReferences: listViewContainerEl not found.");
      if (!editViewContainerEl) console.warn("setupDOMReferences: editViewContainerEl not found.");
      if (!createProjectButtonEl) console.warn("setupDOMReferences: createProjectButtonEl not found.");
      if (!overlayPropertiesToolbarEl) console.warn("setupDOMReferences: overlayPropertiesToolbarEl (new toolbar) not found.");
      if (!shadowPopoverEl || !interactionPopoverEl || !animationPopoverEl || !fontFamilyPopoverEl) {
          console.warn("setupDOMReferences: One or more popover elements not found.");
      }
      // if (!manageTimestampOverlaysButtonEl) console.warn("setupDOMReferences: manageTimestampOverlaysButtonEl not found."); // Removed
      // if (!timestampOverlayModalEl) console.warn("setupDOMReferences: timestampOverlayModalEl not found."); // Removed


      console.log("Admin_JS: DOM references set up.");
    };

    adminApp.attachEventListeners = function() {
      const safelyAddListener = (element, eventType, handler, resourceName) => {
          if (element) {
              element.addEventListener(eventType, handler);
              baseApp.resourceManager.trackDisposable(resourceName, () => {
                  // console.log('Removing listener:', resourceName);
                  element.removeEventListener(eventType, handler);
              });
          } else {
              if (resourceName === 'adminView-createProjectButton-click') console.warn(`Could not attach listener - Element for resource ${resourceName} not found initially.`);
          }
      };
      safelyAddListener(createProjectButtonEl, 'click', handleCreateProject, 'adminView-createProjectButton-click');
      
      const debouncedResizeHandler = sharedUtils.debounce(handleWindowResize, 250);
      window.addEventListener('resize', debouncedResizeHandler);
      baseApp.resourceManager.trackDisposable('adminView-window-resize', () => {
          // console.log('Removing listener: adminView-window-resize');
          window.removeEventListener('resize', debouncedResizeHandler);
      });

      console.log("Admin_JS: Initial event listeners attached.");

      const popoverGlobalClickHandler = function(event) {
        if (adminApp.state.activePopoverId && adminApp.state.currentView === 'edit') {
            const popover = document.getElementById(adminApp.state.activePopoverId);
            let triggerButton = null;
            const baseId = adminApp.state.activePopoverId.replace('Popover', ''); 
            const possibleTriggerIds = [
                baseId + 'SettingsButton', 
                baseId + 'Button',         
                baseId + 'ToolsButton'     
            ];

            for (const id of possibleTriggerIds) {
                const btn = document.getElementById(id);
                if (id === 'addShapeButton' && adminApp.state.activePopoverId === 'shapesPopover') {
                    triggerButton = document.getElementById('addShapeButton');
                    if (triggerButton) break;
                }
                if (btn) {
                    triggerButton = btn;
                    break;
                }
            }

            if (popover && !popover.contains(event.target) && (!triggerButton || !triggerButton.contains(event.target))) {
                // Check if the click is inside the timestampOverlayModal, if it's the active "popover" (though it's a modal)
                if (adminApp.state.activePopoverId === 'timestampOverlayModal' && timestampOverlayModalEl && timestampOverlayModalEl.contains(event.target)) {
                    return; // Don't close timestamp overlay modal if click is inside it
                }
                hideActivePopover();
            }
        }
      };
      document.addEventListener('click', popoverGlobalClickHandler, true);
      baseApp.resourceManager.trackDisposable('adminView-document-click-popoverManagement', () => {
          // console.log('Removing listener: adminView-document-click-popoverManagement');
          document.removeEventListener('click', popoverGlobalClickHandler, true);
      });
    };

// ADD new comprehensive cleanup function:
function cleanupAllEventListeners() {
  console.log("Starting comprehensive event listener cleanup using resourceManager.");
  baseApp.resourceManager.disposeAll();
  // Clear named intervals separately if they are not fully managed by resourceManager yet,
  // or if their disposal logic in resourceManager doesn't nullify them in adminApp.intervals
  // For now, assuming disposeAll() handles their registered dispose functions which should include clearInterval.
  // If adminApp.clearInterval itself was tracked, then disposeAll is enough.
  // If setInterval was directly tracked with a disposeFn of () => clearInterval(id), it's also fine.

  // The old logic for removing paste listener, window resize, etc., is now handled by their tracked disposers.
  // Fabric canvas listeners are handled by canvas.dispose() or canvas.off() in safeDisposeCanvas.
  console.log("Comprehensive event listener cleanup via resourceManager completed.");
}

// --- Canvas Disposal ---
function safeDisposeCanvas() {
    console.log("safeDisposeCanvas: Attempting to dispose Fabric canvas.");
    const canvas = adminApp.state.fabricCanvasInstance;

    if (canvas) {
        try {
            console.log("safeDisposeCanvas: Canvas instance found. Proceeding with disposal.");

            // 1. Clear all event listeners first
            canvas.off();
            
            // 2. Stop all animations
            canvas.forEachObject(obj => {
                if (obj && obj._animateHandler) {
                    fabric.util.cancelAnimFrame(obj._animateHandler);
                    obj._animateHandler = null;
                }
            });
            
            // 3. Clear all objects
            canvas.clear();
            
            // 4. Reset zoom and viewport
            canvas.setZoom(1);
            canvas.viewportTransform = [1, 0, 0, 1, 0, 0];
            
            // 5. Dispose canvas
            canvas.dispose();
            
            console.log("safeDisposeCanvas: Fabric canvas disposed successfully.");

        } catch (e) {
            console.error("safeDisposeCanvas: Error during canvas disposal:", e);
        } finally {
            // 6. Always nullify reference
            adminApp.state.fabricCanvasInstance = null;
        }
    } else {
        console.log("safeDisposeCanvas: No active Fabric canvas instance to dispose.");
    }
}

    // --- UI View Management ---
    function switchToListView() {
      console.log("Switching to List View");
      
      // Critical: Clean up all event listeners first
      cleanupAllEventListeners();
      
      // Hide any active popovers
      hideActivePopover();
      
      // Stop any playing media
      stopAndDestroyAdminYouTubePlayer();
      
      // Clear modal states
      adminApp.state.editingOverlayId = null;
      adminApp.state.placingOverlay = null;
      
      adminApp.state.currentView = 'list';
      adminApp.state.currentProjectId = null;
      adminApp.state.projectData = null;
      adminApp.state.currentSlideIndex = -1;

      safeDisposeCanvas(); // Use the new safe disposal function

      sharedUtils.safeDOMUpdate(listViewContainerEl, el => el.style.display = 'block', "Failed to show list view container");
      sharedUtils.safeDOMUpdate(editViewContainerEl, el => el.style.display = 'none', "Failed to hide edit view container");
      // messageAreaEl will be managed by baseApp.displayMessage or baseApp.onServerError
      
      loadAdminProjectsList(); 
    }

    function switchToEditView(projectIdToEdit) {
        console.log("Switching to Edit View for project ID:", projectIdToEdit);
        adminApp.state.currentView = 'edit';
        adminApp.state.currentProjectId = projectIdToEdit;
        adminApp.state.projectData = null; 
        adminApp.state.currentSlideIndex = -1; 
        hideActivePopover(); 

        sharedUtils.safeDOMUpdate(listViewContainerEl, el => el.style.display = 'none', "Failed to hide list view container for edit view");
        sharedUtils.safeDOMUpdate(editViewContainerEl, el => el.style.display = 'block', "Failed to show edit view container");

        sharedUtils.safeDOMUpdate(editingProjectTitleEl,
          el => el.textContent = `Loading Project (ID: ${projectIdToEdit})...`,
          "Failed to update editing project title on view switch"
        );

        safeDisposeCanvas(); // Use the new safe disposal function before initializing a new one

        // messageAreaEl will be managed by baseApp.displayMessage or baseApp.onServerError
        sharedUtils.safeDOMUpdate(slideThumbnailsContainerEl, el => el.innerHTML = '', "Failed to clear slide thumbnails for edit view");

        const ensureEditViewListener = (element, eventType, handler, resourceName, critical = false) => {
            if (element) {
                // Check if already tracked to avoid duplicates if this function is called multiple times for same element/event
                // This simple check might not be foolproof if resource names are not perfectly unique across calls.
                // However, disposeAll() should handle cleanup regardless.
                // For robust duplicate prevention, a more complex tracking in ensureEditViewListener itself would be needed.
                element.addEventListener(eventType, handler);
                baseApp.resourceManager.trackDisposable(resourceName, () => {
                    // console.log('Removing listener:', resourceName);
                    element.removeEventListener(eventType, handler);
                });
                console.log(`Listener attached for ${resourceName} in switchToEditView.`);
            } else if (critical) {
                 console.warn(`CRITICAL WARN: Element for resource ${resourceName} not found in switchToEditView! Cannot attach listener.`);
            }
        };

        fabricCanvasEl = document.getElementById('fabricCanvasElement');
        slideThumbnailsContainerEl = document.getElementById('slideThumbnailsContainer');
        adminMediaPlaceholderEl = document.getElementById('adminMediaPlaceholder');
        overlayPropertiesToolbarEl = document.getElementById('overlayPropertiesToolbar');

        // Re-fetch elements before attaching listeners
        backToProjectsListButtonEl = document.getElementById('backToProjectsListButton');
        imageUploaderEl = document.getElementById('imageUploader');
        addSlideButtonEl = document.getElementById('addSlideButton');
        saveProjectButtonEl = document.getElementById('saveProjectButton');
        addRectangleButtonEl = document.getElementById('addRectangleButton');
        addCircleButtonEl = document.getElementById('addCircleButton');
        addTextboxButtonEl = document.getElementById('addTextboxButton');
        setYoutubeBackgroundButtonEl = document.getElementById('setYoutubeBackgroundButton');
        audioUploaderEl = document.getElementById('audioUploader');
        removeAudioButtonEl = document.getElementById('removeAudioButton');

        ensureEditViewListener(backToProjectsListButtonEl, 'click', switchToListView, 'editView-backToProjectsListButton-click', true);
        ensureEditViewListener(imageUploaderEl, 'change', handleImageUpload, 'editView-imageUploader-change', true);
        ensureEditViewListener(addSlideButtonEl, 'click', handleAddSlide, 'editView-addSlideButton-click', true);
        ensureEditViewListener(saveProjectButtonEl, 'click', handleSaveProject, 'editView-saveProjectButton-click', true);
        
        ensureEditViewListener(addRectangleButtonEl, 'click', addRectangle, 'editView-addRectangleButton-click', true);
        ensureEditViewListener(addCircleButtonEl, 'click', addCircle, 'editView-addCircleButton-click', true);
        ensureEditViewListener(addTextboxButtonEl, 'click', addTextbox, 'editView-addTextboxButton-click', true);

        ensureEditViewListener(setYoutubeBackgroundButtonEl, 'click', handleSetYoutubeBackground, 'editView-setYoutubeBackgroundButton-click', true);
        ensureEditViewListener(audioUploaderEl, 'change', handleAudioUpload, 'editView-audioUploader-change', true);
        ensureEditViewListener(removeAudioButtonEl, 'click', handleRemoveAudio, 'editView-removeAudioButton-click', true);

        if (typeof fabric !== 'undefined' && fabricCanvasEl) {
            adminApp.state.fabricCanvasInstance = new fabric.Canvas('fabricCanvasElement', {
                width: adminApp.state.defaultCanvasWidth,
                height: adminApp.state.defaultCanvasHeight,
                backgroundColor: '#e9e9e9' 
            });
            fabricCanvasEl.width = adminApp.state.defaultCanvasWidth;
            fabricCanvasEl.height = adminApp.state.defaultCanvasHeight;
            console.log("Admin_JS: Fabric.js canvas initialized with default dimensions.");

            initToolbar(); 
            adminApp.resizeCanvasToFit(null); 
            
            adminApp.state.fabricCanvasInstance.off(); 
            adminApp.state.fabricCanvasInstance.on('object:modified', (e) => {
            if (e.target) {
                populateToolbar(e.target);
                saveCanvasStateForHistory(); // Save state on modification
            }
            });
            adminApp.state.fabricCanvasInstance.on('selection:created', (e) => {
                const activeObject = e.selected && e.selected.length === 1 ? e.selected[0] : null;
                populateToolbar(activeObject);
            });
            adminApp.state.fabricCanvasInstance.on('selection:updated', (e) => {
                const activeObject = e.selected && e.selected.length === 1 ? e.selected[0] : null;
                populateToolbar(activeObject);
            });
            adminApp.state.fabricCanvasInstance.on('selection:cleared', () => {
               populateToolbar(null);
            });
             adminApp.state.fabricCanvasInstance.on('object:added', () => saveCanvasStateForHistory()); // Save on add
             adminApp.state.fabricCanvasInstance.on('object:removed', () => saveCanvasStateForHistory()); // Save on remove


            sharedUtils.safeDOMUpdate(overlayPropertiesToolbarEl, el => el.style.display = 'block', "Failed to show overlay properties toolbar in switchToEditView");
            populateToolbar(null); 
            hideActivePopover();

            // Check if paste listener needs to be (re-)added and tracked for the edit view
            // Note: If this listener should be truly global and active even outside edit view, its management might differ.
            // For now, assuming it's primarily for the edit view context.
            // If cleanupAllEventListeners (via disposeAll) correctly removes it, it can be re-added here.
            if (!adminApp.state.isPasteListenerActive) { // This flag might need re-evaluation with resourceManager
                document.addEventListener('paste', handlePasteImage);
                baseApp.resourceManager.trackDisposable('editView-document-paste-image', () => {
                    // console.log('Removing listener: editView-document-paste-image');
                    document.removeEventListener('paste', handlePasteImage);
                    adminApp.state.isPasteListenerActive = false; // Reset flag if it's still used
                });
                adminApp.state.isPasteListenerActive = true;
                console.log("Admin_JS: Paste event listener for images attached and tracked for edit view.");
            }

            loadProjectForEditing(projectIdToEdit);

        } else {
            console.error("Fabric.js library or canvas element #fabricCanvasElement not found in switchToEditView.");
            baseApp.displayMessage("Critical error: Editor canvas could not be initialized.", false, 'messageArea');
            baseApp.showLoading(false, 'loadingSpinner');
            adminApp.state.isLoading = false;
        }
    }

    // --- Popover Management ---
    function togglePopover(popoverId, triggerButtonEl) {
        if (adminApp.state.activePopoverId === popoverId) {
            hideActivePopover();
        } else {
            hideActivePopover(); 
            
            const popover = document.getElementById(popoverId);
            if (popover && triggerButtonEl) {
                sharedUtils.safeDOMUpdate(popover, el => {
                    el.style.display = 'block';
                    el.style.position = 'absolute';
                    el.style.top = 'auto';
                    el.style.left = 'auto';

                    const btnRect = triggerButtonEl.getBoundingClientRect();
                    const popoverRect = el.getBoundingClientRect(); // Use el here
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    
                    let posTop = btnRect.bottom + 5;
                    let posLeft = btnRect.left;
                    
                    if (posLeft + popoverRect.width > viewportWidth) {
                        posLeft = Math.max(5, viewportWidth - popoverRect.width - 5); 
                    }
                    if (posLeft < 0) posLeft = 5; 

                    if (posTop + popoverRect.height > viewportHeight && btnRect.top - popoverRect.height - 5 > 0) { 
                        posTop = btnRect.top - popoverRect.height - 5;
                    } else if (posTop + popoverRect.height > viewportHeight) { 
                         posTop = Math.max(5, viewportHeight - popoverRect.height - 5);
                    }
                    if (posTop < 0) posTop = 5; 
                    
                    el.style.top = posTop + 'px';
                    el.style.left = posLeft + 'px';
                }, `Failed to display or position popover ${popoverId}`);
                
                adminApp.state.activePopoverId = popoverId;
                
                document.querySelectorAll('.toolbar-button').forEach(btn => {
                    btn.classList.remove('popover-active');
                });
                triggerButtonEl.classList.add('popover-active');

                if (popoverId === 'mediaToolsPopover') {
                   const activeTab = popover.querySelector('.media-tab-btn.active');
                   if (!activeTab) {
                       switchMediaTab('image-tab'); 
                   }
                   if (popover.querySelector('.media-tab-btn[data-tab="audio-tab"].active')) {
                       const currentSlide = getCurrentSlide();
                       const hasAudio = currentSlide && currentSlide.slideMedia && 
                                       currentSlide.slideMedia.type === 'audio' && 
                                       currentSlide.slideMedia.driveFileId;
                       const audioControlsEl = document.getElementById('audioControls');
                       sharedUtils.safeDOMUpdate(audioControlsEl, audioEl => { // Changed el to audioEl for clarity
                           audioEl.style.display = hasAudio ? 'block' : 'none';
                           if (hasAudio) {
                               sharedUtils.safeDOMUpdate(attachedAudioNameEl,
                                 nameEl => nameEl.textContent = `Attached: ${currentSlide.slideMedia.originalName || 'Audio File'}`, // Changed el to nameEl
                                 "Failed to update attached audio name in popover");
                           }
                       }, "Failed to update audio controls display in popover");
                   }
                }
            } else {
                console.warn("togglePopover: Popover or trigger button not found for ID:", popoverId);
            }
        }
    }

    function hideActivePopover() {
        if (adminApp.state.activePopoverId) {
            const popover = document.getElementById(adminApp.state.activePopoverId);
            sharedUtils.safeDOMUpdate(popover, el => el.style.display = 'none', "Failed to hide active popover in hideActivePopover");
            
            document.querySelectorAll('.toolbar-button.popover-active').forEach(btn => {
                btn.classList.remove('popover-active');
            });
            adminApp.state.activePopoverId = null;
        }
    }


    function switchMediaTab(tabId) {
        document.querySelectorAll('.media-tab-pane').forEach(pane => {
            pane.classList.remove('active');
        });
        document.querySelectorAll('.media-tab-btn').forEach(tab => {
            tab.classList.remove('active');
        });
        const tabPane = document.getElementById(tabId);
        if (tabPane) tabPane.classList.add('active');
        const activeTabBtn = document.querySelector(`.media-tab-btn[data-tab="${tabId}"]`);
        if (activeTabBtn) activeTabBtn.classList.add('active');
        
        if (tabId === 'audio-tab') {
            const currentSlide = getCurrentSlide();
            const hasAudio = currentSlide && currentSlide.slideMedia && 
                            currentSlide.slideMedia.type === 'audio' && 
                            currentSlide.slideMedia.driveFileId;
            const audioControlsEl = document.getElementById('audioControls');
            sharedUtils.safeDOMUpdate(audioControlsEl, el => {
                el.style.display = hasAudio ? 'block' : 'none';
                if (hasAudio) {
                    sharedUtils.safeDOMUpdate(attachedAudioNameEl,
                      nameEl => nameEl.textContent = `Attached: ${currentSlide.slideMedia.originalName || 'Audio File'}`,
                      "Failed to update attached audio name in media tab (switchMediaTab)");
                }
            }, "Failed to update audio controls display in media tab (switchMediaTab)");
        }
    }

    function getCurrentSlide() {
        if (adminApp.state.currentSlideIndex === -1 || !adminApp.state.projectData || 
            !adminApp.state.projectData.slides || 
            !adminApp.state.projectData.slides[adminApp.state.currentSlideIndex]) {
            return null;
        }
        return adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
    }

    // --- Project Loading/Saving ---
    function loadProjectForEditing(projectId) {
      console.log(`loadProjectForEditing: Called for projectId: ${projectId}`);
      if (!projectId) { console.error("loadProjectForEditing: No projectId."); baseApp.displayMessage("Error: Cannot load project.", false, 'messageArea'); return; }
      baseApp.showLoading(true, 'loadingSpinner');
      adminApp.state.isLoading = true;
      baseApp.displayMessage("Loading project data...", true, 'messageArea');
      google.script.run
          .withSuccessHandler(onProjectDataLoaded)
          .withFailureHandler(error => baseApp.onServerError(error, 'messageArea'))
          .getProjectDataForEditing(projectId);
    }

    function onProjectDataLoaded(response) { // Argument changed
    // Note: baseApp.showLoading(false, 'loadingSpinner') is handled within specific paths below as per original logic,
    // or in the new error block.

    if (!response || !response.success) {
        baseApp.showLoading(false, 'loadingSpinner');
        adminApp.state.isLoading = false;
        baseApp.onServerError(response || { error: "Failed to load project data" }, 'messageArea');
        // Attempt to set a generic error title if project ID is known
        if (adminApp.state.currentProjectId) {
             adminApp.state.projectData = { projectId: adminApp.state.currentProjectId, title: "Error Loading Project", slides: [] };
             adminApp.state.currentSlideIndex = -1;
             sharedUtils.safeDOMUpdate(editingProjectTitleEl,
                el => el.textContent = `Error Loading Project (ID: ${adminApp.state.currentProjectId})`,
                "Failed to update editing project title on server error in onProjectDataLoaded (new handler)");
             updateSlideThumbnailsUI(); // Update UI to reflect error state
        }
        return;
    }

    const jsonString = response.data && response.data.projectDataJSON ? response.data.projectDataJSON : null;
    console.log("onProjectDataLoaded: Received response. Processing projectDataJSON:", jsonString); // Updated console log

    // The old 'if (jsonString && typeof jsonString === 'object' && jsonString.error)' check is removed
    // as it's now covered by the '!response.success' check above.

    // Existing null/undefined check for the extracted jsonString
    if (jsonString === null || jsonString === undefined) {
        baseApp.showLoading(false, 'loadingSpinner');
        adminApp.state.isLoading = false;
        console.error("onProjectDataLoaded: Extracted null or undefined projectDataJSON from server response.");
        baseApp.displayMessage("Error: Could not load project data. Project or its data file may not exist or the data is empty.", false, 'messageArea');
        adminApp.state.projectData = { projectId: adminApp.state.currentProjectId, title: "Error Loading", slides: [] };
        adminApp.state.currentSlideIndex = -1;
        sharedUtils.safeDOMUpdate(editingProjectTitleEl,
            el => el.textContent = `Error Loading Project (ID: ${adminApp.state.currentProjectId})`, // Message consistent with other errors
            "Failed to update editing project title on null data in onProjectDataLoaded");
        updateSlideThumbnailsUI();
        return;
    }
    
    try {
        if (typeof jsonString !== 'string') {
            // This specific error implies the data format is incorrect even if response.success was true.
            // Call baseApp.showLoading(false, 'loadingSpinner') here before throwing, as the catch block will also call it.
            baseApp.showLoading(false, 'loadingSpinner');
            adminApp.state.isLoading = false;
            throw new Error("Received project data is not a JSON string.");
        }
        const loadedData = JSON.parse(jsonString);
          console.log("Parsed project data:", loadedData);

          if (!loadedData || typeof loadedData !== 'object') throw new Error("Parsed data is not a valid object.");
          if (!loadedData.projectId) throw new Error("Loaded project data is missing 'projectId'.");

          if (!Array.isArray(loadedData.slides)) {
               console.warn("Loaded data missing 'slides' array or it's invalid, defaulting to empty.");
               loadedData.slides = [];
          }

          loadedData.slides.forEach(slide => {
              if (!slide.slideMedia) {
                  slide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
              }
              // Ensure videoOverlays array exists for slideMedia
              if (slide.slideMedia && !Array.isArray(slide.slideMedia.videoOverlays)) {
                  slide.slideMedia.videoOverlays = [];
              }
              // Ensure old video-specific arrays exist for backward compatibility or if still used
              if (slide.slideMedia && !Array.isArray(slide.slideMedia.videoQuestions)) {
                  slide.slideMedia.videoQuestions = [];
              }
              // Initialize timelineEvents if missing
              if (!Array.isArray(slide.timelineEvents)) {
                  slide.timelineEvents = [];
              }
        // Ensure youtubeOptions exists for YouTube slides
        if (slide.slideMedia && slide.slideMedia.type === 'youtube' && typeof slide.slideMedia.youtubeOptions === 'undefined') { // CORRECTED
            slide.slideMedia.youtubeOptions = { showClickToBeginButton: false }; // CORRECTED
        }
              if (!slide.fabricCanvasJSON || !slide.fabricCanvasJSON.objects) {
              } else {
                slide.fabricCanvasJSON.objects.forEach(obj => {
                    if (!obj.customInteraction) {
                        obj.customInteraction = { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
                    }
                    if (!obj.customAnimation) {
                        obj.customAnimation = { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
                    }
                });
              }
          });

          adminApp.state.projectData = loadedData;

          sharedUtils.safeDOMUpdate(editingProjectTitleEl,
            el => el.textContent = `Editing Project: ${adminApp.state.projectData.title || '(Untitled)'}`,
            "Failed to update editing project title after data load in onProjectDataLoaded");

          updateSlideThumbnailsUI();

          if (adminApp.state.projectData.slides.length > 0) {
              selectSlide(0); 
              baseApp.displayMessage("Project loaded successfully.", true, 'messageArea');
          } else {
              baseApp.displayMessage("Project loaded, but it has no slides. Adding one.", true, 'messageArea');
              handleAddSlide(); 
          }
          baseApp.showLoading(false, 'loadingSpinner');
          adminApp.state.isLoading = false;

      } catch (e) {
          baseApp.showLoading(false, 'loadingSpinner');
          adminApp.state.isLoading = false;
          console.error("onProjectDataLoaded: Error parsing JSON data or invalid structure:", e);
          console.error("Received JSON string that failed parsing:", jsonString);
          baseApp.displayMessage(`Error: Failed to parse loaded project data. ${e.message}`, false, 'messageArea');
          adminApp.state.projectData = { projectId: adminApp.state.currentProjectId, title: "Invalid Data", slides: [] };
          adminApp.state.currentSlideIndex = -1;
          sharedUtils.safeDOMUpdate(editingProjectTitleEl,
            el => el.textContent = `Invalid Project Data (ID: ${adminApp.state.currentProjectId})`,
            "Failed to update editing project title on parse error in onProjectDataLoaded");
          updateSlideThumbnailsUI(); 
      }
    }

    function saveCurrentSlideState() {
        if (adminApp.state.currentSlideIndex === -1 || !adminApp.state.fabricCanvasInstance || !adminApp.state.projectData || !adminApp.state.projectData.slides[adminApp.state.currentSlideIndex]) {
            console.log("saveCurrentSlideState: Skipping, no active slide/canvas/data.");
            return;
        }
        try {
          const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
          const canvas = adminApp.state.fabricCanvasInstance;
          canvas.getObjects().forEach(obj => {
              if (!obj.customInteraction) {
                  obj.customInteraction = { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
              }
              if (!obj.customAnimation) {
                  obj.customAnimation = { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
              }
          });

          const propsToInclude = ['slideId', 'canvasWidth', 'canvasHeight', 'customInteraction', 'customAnimation', 'sequenceOrder'];
          currentSlide.fabricCanvasJSON = canvas.toJSON(propsToInclude);
          currentSlide.canvasWidth = canvas.getWidth();
          currentSlide.canvasHeight = canvas.getHeight();
          if (!currentSlide.slideMedia) {
               currentSlide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
          }
          if(currentSlide.slideMedia.type !== 'image' && currentSlide.slideMedia.url && currentSlide.slideMedia.url.startsWith('data:image')) {
              currentSlide.slideMedia.url = null;
          }


          console.log(`Slide ${adminApp.state.currentSlideIndex + 1} state saved. Media:`, JSON.stringify(currentSlide.slideMedia));
        } catch(e) {
            console.error(`Error saving slide state for index ${adminApp.state.currentSlideIndex}:`, e);
            baseApp.displayMessage(`Error saving current slide state: ${e.message}`, false, 'messageArea');
        }
    }

    function handleSaveProject() {
        if (!adminApp.state.projectData || !adminApp.state.currentProjectId) { baseApp.displayMessage("No project data to save.", false, 'messageArea'); return; }
        if (adminApp.state.isLoading) { console.log("handleSaveProject: Already saving."); return; }

        saveCurrentSlideState(); 

        baseApp.showLoading(true, 'loadingSpinner');
        adminApp.state.isLoading = true;
        baseApp.displayMessage("Saving project...", true, 'messageArea');
        try {
            const projectDataToSave = JSON.parse(JSON.stringify(adminApp.state.projectData));

             projectDataToSave.slides.forEach(slide => {
                 if (slide.slideMedia && slide.slideMedia.type !== 'image' && 
                     slide.slideMedia.url && slide.slideMedia.url.startsWith('data:image')) {
                     slide.slideMedia.url = null; 
                 }
             });

            const jsonDataString = JSON.stringify(projectDataToSave);
            console.log("Saving projectData string length:", jsonDataString.length);

            google.script.run
                .withSuccessHandler(onProjectSaved)
                .withFailureHandler(onServerError)
                .saveProjectData(adminApp.state.currentProjectId, jsonDataString);
        } catch (e) {
             baseApp.showLoading(false, 'loadingSpinner');
             adminApp.state.isLoading = false;
             console.error("Error stringifying project data for saving:", e);
             baseApp.displayMessage("Error preparing data for saving.", false, 'messageArea');
        }
    }

    function saveCanvasStateForHistory() {
        if (!adminApp.state.fabricCanvasInstance || adminApp.state.isApplyingHistory) {
            return;
        }
        const canvas = adminApp.state.fabricCanvasInstance;

        const propsToInclude = ['slideId', 'canvasWidth', 'canvasHeight', 'customInteraction', 'customAnimation', 'sequenceOrder']; 
        const currentState = canvas.toJSON(propsToInclude);

        if (adminApp.state.historyIndex < adminApp.state.history.length - 1) {
            adminApp.state.history = adminApp.state.history.slice(0, adminApp.state.historyIndex + 1);
        }

        adminApp.state.history.push(currentState);
        adminApp.state.historyIndex = adminApp.state.history.length - 1;

        const maxHistorySize = 20;
        if (adminApp.state.history.length > maxHistorySize) {
            adminApp.state.history.shift(); 
            adminApp.state.historyIndex--;
        }
        console.log("Canvas state saved to history. Index:", adminApp.state.historyIndex, "Total states:", adminApp.state.history.length);
        updateUndoRedoButtonStates();
    }

    function updateUndoRedoButtonStates() {
        if (undoButtonEl) undoButtonEl.disabled = adminApp.state.historyIndex <= 0;
        if (redoButtonEl) redoButtonEl.disabled = adminApp.state.historyIndex >= adminApp.state.history.length - 1;
    }

    function onProjectSaved(response) {
        baseApp.showLoading(false, 'loadingSpinner');
        adminApp.state.isLoading = false;
        if (response && response.success) {
            sharedUtils.showNotification(response.message || "Project saved successfully!", "success");
        } else {
            onServerError((response && response.error) ? response.error : "Failed to save.");
        }
    }

    // --- Slide Management ---
    function handleAddSlide() {
        console.log("handleAddSlide called");
        if (!adminApp.state.projectData) { console.error("handleAddSlide: projectData not initialized."); return; }
        saveCurrentSlideState(); 
        const newSlideId = 'slide_' + sharedUtils.generateClientUuid();
        const newSlide = {
            slideId: newSlideId,
            canvasWidth: adminApp.state.defaultCanvasWidth,
            canvasHeight: adminApp.state.defaultCanvasHeight,
            fabricCanvasJSON: null, 
            slideMedia: { type: null, url: null, driveFileId: null, mimeType: null, originalName: null, videoQuestions: [], videoOverlays: [] },
            timelineEvents: [] // Ensure this line is added
        };
        if (!adminApp.state.projectData.slides) adminApp.state.projectData.slides = [];
        adminApp.state.projectData.slides.push(newSlide);
        const newSlideIndex = adminApp.state.projectData.slides.length - 1;
        selectSlide(newSlideIndex); 
        console.log("Added new slide. Total slides:", adminApp.state.projectData.slides.length);
        sharedUtils.showNotification("New slide added.", "success");
        saveCanvasStateForHistory(); // Save initial state of new slide
    }

    function selectSlide(slideIndex) {
        if (!adminApp.state.projectData || !adminApp.state.projectData.slides || slideIndex < 0 || slideIndex >= adminApp.state.projectData.slides.length) { 
            console.error("selectSlide: Invalid index or slides array missing.", slideIndex); 
            return; 
        }
        console.log(`Selecting slide ${slideIndex + 1}`);

        if (adminApp.state.currentSlideIndex !== -1 && adminApp.state.currentSlideIndex < adminApp.state.projectData.slides.length) {
            saveCurrentSlideState();
        }

        adminApp.state.currentSlideIndex = slideIndex;
        const selectedSlideData = adminApp.state.projectData.slides[slideIndex];
        
        // Store current slide type
        adminApp.state.currentSlideType = (selectedSlideData.slideMedia && selectedSlideData.slideMedia.type) ? selectedSlideData.slideMedia.type : 'none';
        console.log("Current slide type set to:", adminApp.state.currentSlideType);

        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas) { 
            console.error("selectSlide: Canvas not ready!"); 
            return; 
        }

        if (!selectedSlideData.slideMedia) {
            selectedSlideData.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null, videoQuestions: [], videoOverlays: [] }; // Ensure videoOverlays is also here
        } else { // Ensure these arrays exist even if media is present
            if (!Array.isArray(selectedSlideData.slideMedia.videoQuestions)) {
                selectedSlideData.slideMedia.videoQuestions = [];
            }
            if (!Array.isArray(selectedSlideData.slideMedia.videoOverlays)) { // Ensure this check is also here
                selectedSlideData.slideMedia.videoOverlays = [];
            }
        }
        // Ensure timelineEvents exists
        if (!Array.isArray(selectedSlideData.timelineEvents)) {
            selectedSlideData.timelineEvents = [];
        }
        // Ensure youtubeOptions exists for YouTube slides (this part might already be there from issue snippet)
        if (selectedSlideData.slideMedia && selectedSlideData.slideMedia.type === 'youtube' && typeof selectedSlideData.slideMedia.youtubeOptions === 'undefined') {
            selectedSlideData.slideMedia.youtubeOptions = { showClickToBeginButton: false };
        }

        // In selectSlide() function
        if (typeof mediaManager !== 'undefined') {
            if (mediaManager.stopAndDestroyPlayer) mediaManager.stopAndDestroyPlayer();
            if (mediaManager.stopAndClearAudioPlayer) mediaManager.stopAndClearAudioPlayer();
        }

        sharedUtils.safeDOMUpdate(adminYouTubePlayerContainerEl, el => {
            el.style.display = 'none';
            el.innerHTML = ''; 
        }, "Failed to reset YouTube player container in selectSlide");
        // TODO: Add similar for an admin audio player container if one is introduced
        
        sharedUtils.safeDOMUpdate(fabricCanvasEl, el => el.style.opacity = '1', "Failed to set canvas opacity in selectSlide");

        canvas.clear(); 
        canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas)); 
        canvas.backgroundColor = '#e9e9e9'; 

        adminApp.resizeCanvasToFit(selectedSlideData);

        if (imageUploaderEl) imageUploaderEl.value = null;
        if (youtubeUrlInputEl) youtubeUrlInputEl.value = '';
        if (audioUploaderEl) audioUploaderEl.value = null;
        
        sharedUtils.safeDOMUpdate(attachedAudioNameEl, el => el.textContent = '', "Failed to clear attached audio name in selectSlide");
        const audioControls = document.getElementById('audioControls');
        sharedUtils.safeDOMUpdate(audioControls, el => el.style.display = 'none', "Failed to hide audio controls in selectSlide");
        sharedUtils.safeDOMUpdate(removeAudioButtonEl, el => el.style.display = 'none', "Failed to hide remove audio button in selectSlide");
        sharedUtils.safeDOMUpdate(adminMediaPlaceholderEl, el => el.style.display = 'none', "Failed to hide admin media placeholder in selectSlide");

        const media = selectedSlideData.slideMedia;
        updateVideoToolsVisibility(false); // Default to false, MediaManager callbacks will enable if YT

        if (media && media.type === 'image' && media.driveFileId) {
            sharedUtils.safeDOMUpdate(adminMediaPlaceholderEl, el => el.style.display = 'none', "Failed to hide admin media placeholder for image bg in selectSlide");
            console.log(`Background needs fetch from Drive ID for slide ${slideIndex + 1}:`, media.driveFileId);
            baseApp.showLoading(true, 'loadingSpinner');
            adminApp.state.isLoading = true;
            baseApp.displayMessage("Loading slide background...", true, 'messageArea');
            
            google.script.run.withSuccessHandler(function(response) {
                baseApp.showLoading(false, 'loadingSpinner');
                adminApp.state.isLoading = false;
                if (adminApp.state.currentSlideIndex !== slideIndex) { 
                    console.log("Slide changed before background could be fetched for index", slideIndex); 
                    return; 
                }
                if (response && response.success && response.base64Data) {
                    fabric.Image.fromURL(response.base64Data, function(img) {
                        if (!adminApp.state.fabricCanvasInstance) return;
                        adminApp.state.fabricCanvasInstance.setBackgroundImage(img, canvas.renderAll.bind(canvas), { 
                            scaleX: canvas.width / img.width, 
                            scaleY: canvas.height / img.height 
                        });
                        console.log("Background fetched and loaded for slide", slideIndex);
                    }, { crossOrigin: 'anonymous' });
                } else { 
                    console.error("Failed to fetch background", response); 
                    baseApp.displayMessage("Error loading slide background image.", false, 'messageArea');
                    canvas.backgroundColor = '#e9e9e9'; 
                    canvas.renderAll(); 
                }
            }).withFailureHandler(onServerError).getImageAsBase64(media.driveFileId);
            
        } else if (media && media.type === 'image' && !media.driveFileId) {
            console.warn("Image media type set but no driveFileId:", media); 
            canvas.backgroundColor = '#e9e9e9';
            canvas.renderAll(); 
            
        } else if (media && media.type === 'youtube' && media.url) {
            console.log("AdminApp: Preparing YouTube player via MediaManager for URL:", media.url);
            sharedUtils.safeDOMUpdate(adminMediaPlaceholderEl, el => el.style.display = 'none');
            if (youtubeUrlInputEl) youtubeUrlInputEl.value = media.url;
            
            // Opacity and background color are more complex with MediaManager, as it controls the player visibility.
            // The canvas itself might remain transparent or be styled via CSS.
            // sharedUtils.safeDOMUpdate(fabricCanvasEl, el => el.style.opacity = '1');
            canvas.backgroundColor = 'rgba(0,0,0,0)'; // Keep canvas transparent for YT

            const videoId = sharedUtils.extractYouTubeVideoId(media.url);
            if (videoId && adminYouTubePlayerContainerEl) {
                sharedUtils.safeDOMUpdate(adminYouTubePlayerContainerEl, el => {
                    el.style.display = 'block'; // Ensure container is visible for MediaManager
                    // MediaManager will handle player's internal styling (position, size)
                });

                const playerVars = {
                    'playsinline': 1,
                    'controls': 1, // Admin might want controls
                    'showinfo': 0,
                    'rel': 0,
                    // No 'disablekb': 1 for admin, as admin might use keyboard for testing.
                    // width/height will be set by MediaManager based on container.
                };

                // These are the handlers MediaManager will call internally
                const eventHandlersForMediaManager = {
                    'onReady': mediaManager.onPlayerReady,
                    'onStateChange': mediaManager.onPlayerStateChange,
                    'onError': mediaManager.onPlayerError
                };

                // Configure admin-specific callbacks for MediaManager to use
                mediaManager.state.callbacks.onReady = adminApp.handleMediaPlayerReady;
                mediaManager.state.callbacks.onStateChange = adminApp.handleMediaPlayerStateChange;
                mediaManager.state.callbacks.onError = adminApp.handleMediaPlayerError;
                mediaManager.state.callbacks.onTimeUpdate = adminApp.handleMediaTimeUpdate;
                mediaManager.state.callbacks.onQuestionTrigger = adminApp.handleMediaQuestionTrigger;
                mediaManager.state.callbacks.onOverlayUpdateNeeded = adminApp.handleMediaOverlayUpdate;
                mediaManager.state.callbacks.onEnded = adminApp.handleMediaEnded;

                mediaManager.setupPlayer(videoId, 'adminYouTubePlayerContainer', playerVars, eventHandlersForMediaManager);

            } else {
                console.error("AdminApp: Invalid YouTube setup. Video ID or container missing.", { videoId, container: !!adminYouTubePlayerContainerEl, url: media.url });
                updateVideoToolsVisibility(false); // Hide YT specific tools
                sharedUtils.safeDOMUpdate(adminMediaPlaceholderEl, el => {
                    el.textContent = `Error: Could not load YouTube video. Check URL. URL: ${media.url}`;
                    el.style.display = 'block';
                });
                canvas.backgroundColor = '#444'; // Show a dark background if player fails
            }
            canvas.renderAll();
            
        } else if (media && media.type === 'audio' && (media.driveFileId)) {
             // TODO: Integrate with MediaManager for audio if admin needs audio editing features like questions/overlays for audio.
             // For now, keeping it simple or assuming admin doesn't edit audio timeline events.
            sharedUtils.safeDOMUpdate(adminMediaPlaceholderEl, el => el.style.display = 'block');
            console.log("Indicating attached audio:", media.originalName || media.driveFileId);
            sharedUtils.safeDOMUpdate(attachedAudioNameEl, el => {
                el.textContent = `Attached: ${media.originalName || 'Audio File'}`;
                const currentAudioControls = document.getElementById('audioControls'); // Re-fetch or ensure it's in scope
                sharedUtils.safeDOMUpdate(currentAudioControls, audioEl => audioEl.style.display = 'block', "Failed to show audio controls for audio in selectSlide");
            }, "Failed to update attached audio name for audio in selectSlide");
            sharedUtils.safeDOMUpdate(removeAudioButtonEl, el => el.style.display = 'inline-block', "Failed to show remove audio button for audio in selectSlide");
            
            sharedUtils.safeDOMUpdate(adminMediaPlaceholderEl, el => {
                el.textContent = `Audio Attached: ${media.originalName || 'Audio File'}`;
                el.style.display = 'block';
            }, "Failed to update admin media placeholder for audio in selectSlide");
            canvas.backgroundColor = '#e9e9e9'; 
            canvas.renderAll();
            
        } else {
            console.log("No background media found or configured for slide", slideIndex);
            sharedUtils.safeDOMUpdate(adminMediaPlaceholderEl, el => el.style.display = 'none', "Failed to hide admin media placeholder for no media in selectSlide");
            canvas.backgroundColor = '#e9e9e9'; 
            canvas.renderAll();
        }

        if (selectedSlideData.fabricCanvasJSON) {
        console.log("Loading fabricCanvasJSON for slide", slideIndex);
        canvas.loadFromJSON(selectedSlideData.fabricCanvasJSON, function() {
            if (!adminApp.state.fabricCanvasInstance || adminApp.state.currentSlideIndex !== slideIndex) return;
            
            adminApp.state.fabricCanvasInstance.getObjects().forEach(obj => {
                if (!obj.customInteraction) {
                    obj.customInteraction = { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
                }
                if (!obj.customAnimation) {
                    obj.customAnimation = { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
                }
            });

            adminApp.state.fabricCanvasInstance.renderAll();
            console.log("Finished loading canvas JSON for slide", slideIndex);
            const activeObj = adminApp.state.fabricCanvasInstance.getActiveObject();
            populateToolbar(activeObj); 
            }, function(o, object) { 
            });
        } else {
            console.log("No fabricCanvasJSON to load for slide", slideIndex);
            canvas.renderAll(); 
            populateToolbar(null); 
        }
        updateSlideThumbnailsUI();
        adminApp.state.history = [];
        adminApp.state.historyIndex = -1;
        setTimeout(() => {
            saveCanvasStateForHistory();
            updateUndoRedoButtonStates();
        }, 100); 
    }

    function updateSlideThumbnailsUI() {
        if (!adminApp.state.projectData) { 
            console.warn("updateSlideThumbnailsUI: Project data missing."); 
            // Ensure the container is cleared if there's no project data or no slides.
            sharedUtils.safeDOMUpdate(slideThumbnailsContainerEl, el => el.innerHTML = '<p>No slides available.</p>', "Failed to clear slide thumbnails container on no project data");
            return; 
        }
        
        sharedUtils.safeDOMUpdate(slideThumbnailsContainerEl, el => {
            el.innerHTML = ''; // Clear existing thumbnails
            if (!adminApp.state.projectData.slides || adminApp.state.projectData.slides.length === 0) {
                el.innerHTML = '<p>No slides. Click "Add Slide" to begin.</p>'; // Message when no slides exist
                return;
            }
            adminApp.state.projectData.slides.forEach((slide, index) => {
                const thumb = document.createElement('div'); thumb.className = 'slide-thumbnail';
                thumb.textContent = `Slide ${index + 1}`; thumb.title = `Select Slide ${index + 1}`;
                if (index === adminApp.state.currentSlideIndex) thumb.classList.add('active-slide');
                thumb.onclick = function() { selectSlide(index); };
                const deleteBtn = document.createElement('button'); deleteBtn.className = 'delete-slide-btn'; deleteBtn.innerHTML = ''; deleteBtn.title = "Delete slide";
                deleteBtn.onclick = function(event) { event.stopPropagation(); handleDeleteSlide(index); };
                thumb.appendChild(deleteBtn); 
                el.appendChild(thumb);
            });
        }, "Failed to update slide thumbnails UI");
    }

    function handleDeleteSlide(slideIndex) {
        if (!adminApp.state.projectData || !adminApp.state.projectData.slides || slideIndex < 0 || slideIndex >= adminApp.state.projectData.slides.length) { console.error("handleDeleteSlide: Invalid index."); return; }
        if (adminApp.state.projectData.slides.length <= 1) { baseApp.displayMessage("Cannot delete the last slide.", false, 'messageArea'); return; }
        if (!confirm(`Are you sure you want to delete Slide ${slideIndex + 1}?`)) return;
        
        const wasCurrentSlide = adminApp.state.currentSlideIndex === slideIndex;
        adminApp.state.projectData.slides.splice(slideIndex, 1);
        console.log("Deleted slide at index:", slideIndex);

        if (wasCurrentSlide) {
            adminApp.state.currentSlideIndex = -1; 
            const newIndexToSelect = Math.max(0, Math.min(slideIndex, adminApp.state.projectData.slides.length - 1));
             if (adminApp.state.projectData.slides.length > 0) {
                selectSlide(newIndexToSelect);
            } else {
                if(adminApp.state.fabricCanvasInstance) adminApp.state.fabricCanvasInstance.clear();
                updateSlideThumbnailsUI();
                populateToolbar(null);
            }
        } else if (adminApp.state.currentSlideIndex > slideIndex) {
            adminApp.state.currentSlideIndex--; 
            updateSlideThumbnailsUI(); 
        } else {
             updateSlideThumbnailsUI(); 
        }
    }

    // --- Project Management (Status/Delete) ---
    function handleProjectStatusChange(projectId, newStatus, selectElement) {
        console.log(`Attempting to update status for project ${projectId} to ${newStatus}`);
        baseApp.showLoading(true, 'loadingSpinner');
        adminApp.state.isLoading = true;
        const originalStatus = selectElement.getAttribute('data-original-status') ||
                               (adminApp.state.projectListCache.find(p => p.projectId === projectId) || {}).status;
        selectElement.setAttribute('data-original-status', originalStatus);

        google.script.run
            .withSuccessHandler(function(response) { onProjectStatusUpdated(response, projectId, newStatus, selectElement); })
            .withFailureHandler(function(error) {
                baseApp.onServerError(error, 'messageArea');
                if (selectElement) {
                    console.log("Reverting status dropdown due to server error for project:", projectId);
                    selectElement.value = originalStatus;
                }
            })
            .updateProjectStatus(projectId, newStatus);
    }

    function onProjectStatusUpdated(response, projectId, newStatus, selectElement) {
        baseApp.showLoading(false, 'loadingSpinner');
        adminApp.state.isLoading = false;
        if (response && response.success) {
            baseApp.displayMessage(response.message || "Project status updated successfully!", true, 'messageArea');

            const projectInCache = adminApp.state.projectListCache.find(p => p.projectId === projectId);
            if (projectInCache) projectInCache.status = newStatus;
            selectElement.removeAttribute('data-original-status');

            const statusSpan = selectElement.closest('.project-item').querySelector('.status-text');
            if(statusSpan) statusSpan.textContent = `(${newStatus})`;

            if (adminApp.state.currentView === 'edit' && adminApp.state.currentProjectId === projectId && adminApp.state.projectData) {
                adminApp.state.projectData.status = newStatus;
            }
        } else {
            baseApp.onServerError((response && response.error) ? response.error : "Failed to update status.", 'messageArea');
            if (selectElement) {
                 console.log("Reverting status dropdown due to server failure for project:", projectId);
                 const originalStatus = selectElement.getAttribute('data-original-status');
                 if(originalStatus) selectElement.value = originalStatus;
            }
        }
    }

    function handleDeleteProject(projectId, projectTitle) {
        if (!confirm(`Are you sure you want to delete the project "${projectTitle}" (ID: ${projectId})? This action cannot be undone.`)) {
            return;
        }
        console.log(`Attempting to delete project ${projectId}`);
        baseApp.showLoading(true, 'loadingSpinner');
        adminApp.state.isLoading = true;
        google.script.run
            .withSuccessHandler(onProjectDeleted)
            .withFailureHandler(error => baseApp.onServerError(error, 'messageArea'))
            .deleteProject(projectId);
    }

    function onProjectDeleted(response) {
        baseApp.showLoading(false, 'loadingSpinner');
        adminApp.state.isLoading = false;
        if (response && response.success) {
            baseApp.displayMessage(response.message || "Project deleted successfully!", true, 'messageArea');
            if (adminApp.state.currentView === 'edit' && adminApp.state.currentProjectId === response.deletedProjectId) {
                switchToListView();
            } else {
                loadAdminProjectsList();
            }
        } else {
            baseApp.onServerError((response && response.error) ? response.error : "Failed to delete project.", 'messageArea');
        }
    }

    // --- Error Handling & UI Utils ---
// MODIFY onServerError function to check for session errors:
    // function onServerError(errorObject) { // This function is being removed
    //   console.error("onServerError triggered:", errorObject);
    //   baseApp.showLoading(false, 'loadingSpinner');
    //   adminApp.state.isLoading = false;
      
    //   // Check if it's a session error first
    //   if (handleDriveSessionError(errorObject)) {
    //     return; // Session error handled
    //   }
      
    //   let errorMessage = "An unknown server error occurred.";
    //    if (typeof errorObject === 'string') { errorMessage = errorObject; }
    //    else if (errorObject && errorObject.message) { errorMessage = errorObject.message; }
    //    else if (errorObject && errorObject.error && typeof errorObject.error === 'string') { errorMessage = errorObject.error; }
    //   console.error('Formatted Server Error Message:', errorMessage);
    //   baseApp.displayMessage('Server Error: ' + errorMessage, false, 'messageArea');
    // }

    function handleCreateProject() {
        if (adminApp.state.isLoading) return;
        const currentProjectTitle = projectTitleInputEl.value.trim();
        if (!currentProjectTitle) { baseApp.displayMessage('Project title cannot be empty.', false, 'messageArea'); projectTitleInputEl.focus(); return; }
        baseApp.showLoading(true, 'loadingSpinner');
        adminApp.state.isLoading = true;
        google.script.run.withSuccessHandler(onProjectCreated).withFailureHandler(error => baseApp.onServerError(error, 'messageArea')).createProject(currentProjectTitle);
    }
    function onProjectCreated(response) {
        baseApp.showLoading(false, 'loadingSpinner');
        adminApp.state.isLoading = false;
        if (response && response.success) { baseApp.displayMessage(response.message || 'Project created!', true, 'messageArea'); if(projectTitleInputEl) projectTitleInputEl.value = ''; loadAdminProjectsList(); }
        else { baseApp.onServerError((response && response.error) ? response.error : 'Failed to create project.', 'messageArea'); }
    }

    function loadAdminProjectsList() {
      console.log("loadAdminProjectsList: Function called.");
      if (!adminProjectListContainerEl) { console.error("loadAdminProjectsList: adminProjectListContainerEl not found."); baseApp.showLoading(false, 'loadingSpinner'); adminApp.state.isLoading = false; return; }
      if (!google || !google.script || !google.script.run) { console.error("loadAdminProjectsList: google.script.run unavailable."); baseApp.displayMessage("Error: Client-server bridge unavailable.", false, 'messageArea'); return; }
      baseApp.showLoading(true, 'loadingSpinner');
      adminApp.state.isLoading = true;
      console.log("loadAdminProjectsList: Calling google.script.run.getAllProjectsForAdmin...");
      google.script.run
        .withSuccessHandler(displayAdminProjects)
        .withFailureHandler(error => baseApp.onServerError(error, 'messageArea'))
        .getAllProjectsForAdmin();
       console.log("loadAdminProjectsList: google.script.run.getAllProjectsForAdmin call initiated.");
    }
    function displayAdminProjects(response) { // Argument changed from projectsArray to response
    baseApp.showLoading(false, 'loadingSpinner');
    adminApp.state.isLoading = false;

    if (!response || !response.success) {
        baseApp.onServerError(response || { error: "Failed to load projects" }, 'messageArea'); // Will now use centralized session error check
        return;
    }
    
    const projectsArray = response.data && response.data.projects ? response.data.projects : [];
    console.log("displayAdminProjects (Success Handler) received response. Processing projects:", projectsArray); // Keep or adapt console log

      sharedUtils.safeDOMUpdate(adminProjectListContainerEl, el => {
          el.innerHTML = ''; // Clear previous projects
          if (!projectsArray || projectsArray.length === 0) { 
              el.innerHTML = '<p>No projects found. Create one above!</p>';
              return; 
          }

          adminApp.state.projectListCache = projectsArray;

          projectsArray.forEach(project => {
              if (!project || !project.projectId) return;
              const projectItem = document.createElement('div');
              projectItem.className = 'project-item';

              const titleAndStatusDiv = document.createElement('div');
              const titleSpan = document.createElement('span');
              titleSpan.textContent = project.projectTitle || 'Untitled Project';
              titleSpan.style.fontWeight = 'bold';
              const statusTextSpan = document.createElement('span');
              statusTextSpan.className = 'status-text';
              statusTextSpan.textContent = `(${project.status || 'N/A'})`;
              titleAndStatusDiv.appendChild(titleSpan);
              titleAndStatusDiv.appendChild(statusTextSpan);

              const controlsDiv = document.createElement('div');
              const statusSelect = document.createElement('select');
              statusSelect.className = 'project-status-select';
              statusSelect.setAttribute('data-project-id', project.projectId);
              statusSelect.setAttribute('data-original-status', project.status || "Draft");
              ['Draft', 'Active', 'Inactive'].forEach(statusValue => {
                  const option = document.createElement('option');
                  option.value = statusValue;
                  option.textContent = statusValue;
                  if (project.status === statusValue) { option.selected = true; }
                  statusSelect.appendChild(option);
              });
              statusSelect.onchange = function() { handleProjectStatusChange(project.projectId, this.value, this); };

              const editButton = document.createElement('button');
              editButton.textContent = 'Edit';
              editButton.className = 'edit-button';
              editButton.setAttribute('data-project-id', project.projectId);
              editButton.onclick = function() { console.log("Edit button clicked:", project.projectId); switchToEditView(project.projectId); };

              const deleteButton = document.createElement('button');
              deleteButton.textContent = 'Delete';
              deleteButton.className = 'danger-button';
              deleteButton.setAttribute('data-project-id', project.projectId);
              deleteButton.setAttribute('data-project-title', project.projectTitle || 'Untitled Project');
              deleteButton.style.marginLeft = '5px';
              deleteButton.onclick = function() { handleDeleteProject(project.projectId, project.projectTitle || 'Untitled Project'); };

              controlsDiv.appendChild(statusSelect);
              controlsDiv.appendChild(editButton);
              controlsDiv.appendChild(deleteButton);

              projectItem.appendChild(titleAndStatusDiv);
              projectItem.appendChild(controlsDiv);
              el.appendChild(projectItem);
           });
      }, "Failed to display admin projects in list container");
      console.log("displayAdminProjects: Finished rendering project list.");
    }

// REMOVE function handleDriveSessionError(error) as it's now in BaseApp.html
/*
function handleDriveSessionError(error) {
  console.error("Drive session error:", error);
  
  if (error && error.message && 
      (error.message.includes("authorization") || 
       error.message.includes("401") || 
       error.message.includes("403"))) {
    
    // Session expired
    baseApp.displayMessage("Your session has expired. The page will reload to re-authenticate.", false, 'messageArea');
    
    // Save current state if possible
    if (adminApp.state.projectData) {
      try {
        localStorage.setItem('adminTempProjectData', JSON.stringify({
          projectId: adminApp.state.currentProjectId,
          projectData: adminApp.state.projectData,
          slideIndex: adminApp.state.currentSlideIndex
        }));
      } catch (e) {
        console.error("Could not save temporary state:", e);
      }
    }
    
    // Reload after brief delay
    setTimeout(() => {
      window.location.reload();
    }, 2000);
    
    return true; // Handled
  }
  
  return false; // Not a session error
}
*/

    // --- Media Handling ---
    function handleImageUpload(event) {
        if (adminApp.state.isLoading) { if (event.target) event.target.value = null; return; }
        const file = event.target.files[0];
        if (!file || !file.type.startsWith('image/')) { if(event.target) event.target.value = null; return; }

        saveCurrentSlideState(); 

        baseApp.showLoading(true, 'loadingSpinner');
        adminApp.state.isLoading = true;
        baseApp.displayMessage("Uploading image...", true, 'messageArea');
        const reader = new FileReader();
        reader.onload = function(e) {
            const fileData = { fileName: file.name, mimeType: file.type, data: e.target.result.split(',')[1] };
            if (!adminApp.state.currentProjectId) { baseApp.showLoading(false, 'loadingSpinner'); adminApp.state.isLoading = false; baseApp.displayMessage("Error: No project selected.", false, 'messageArea'); if(event.target) event.target.value = null; return; }
            google.script.run.withSuccessHandler(onImageUploaded).withFailureHandler(error => baseApp.onServerError(error, 'messageArea')).uploadFileToDrive(fileData, adminApp.state.currentProjectId, 'image');
        };
        reader.onerror = function(error) { baseApp.showLoading(false, 'loadingSpinner'); adminApp.state.isLoading = false; baseApp.displayMessage("Error reading file.", false, 'messageArea'); console.error(error); if(event.target) event.target.value = null; };
        reader.readAsDataURL(file);
    }

    function onImageUploaded(response) {
        baseApp.showLoading(false, 'loadingSpinner');
        adminApp.state.isLoading = false;
        if (imageUploaderEl) imageUploaderEl.value = null;
        if (response && response.success && response.driveFileId) {
            baseApp.displayMessage("Image processed. Fetching for preview...", true, 'messageArea');
            baseApp.showLoading(true, 'loadingSpinner');
            adminApp.state.isLoading = true;
            adminApp.state.lastUploadedDriveId = response.driveFileId;
            adminApp.state.lastUploadedMimeType = response.mimeType;
            adminApp.state.lastUploadedFileName = response.fileName;
            google.script.run
                .withSuccessHandler(onBase64ImageReceived)
                .withFailureHandler(error => baseApp.onServerError(error, 'messageArea'))
                .getImageAsBase64(response.driveFileId);
        } else {
            baseApp.onServerError({ message: (response && response.error) ? response.error : "Image processing failed." }, 'messageArea');
        }
    }

    function onBase64ImageReceived(response) {
        baseApp.showLoading(false, 'loadingSpinner');
        adminApp.state.isLoading = false;
        if (response && response.success && response.base64Data) {
            if (!adminApp.state.fabricCanvasInstance || adminApp.state.currentSlideIndex === -1) { 
                baseApp.displayMessage("Error: Canvas/Slide not ready.", false, 'messageArea');
                return; 
            }
            const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
            if (!currentSlide) { 
                baseApp.displayMessage("Error: Slide data missing.", false, 'messageArea');
                return; 
            }

            fabric.Image.fromURL(response.base64Data, function(img) {
                if (!adminApp.state.fabricCanvasInstance || adminApp.state.currentSlideIndex === -1) return;
                const canvas = adminApp.state.fabricCanvasInstance;
                const imgWidth = img.width; 
                const imgHeight = img.height;
                const maxWidth = 960;
                let cvWidth = imgWidth; 
                let cvHeight = imgHeight; 
                const ratio = imgWidth / imgHeight;

                if (cvWidth > maxWidth) { 
                    cvWidth = maxWidth; 
                    cvHeight = Math.round(cvWidth / ratio); 
                }

                canvas.setWidth(cvWidth); 
                canvas.setHeight(cvHeight);
                if (fabricCanvasEl) { 
                    fabricCanvasEl.width = cvWidth; 
                    fabricCanvasEl.height = cvHeight; 
                }
                canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), { 
                    scaleX: cvWidth / imgWidth, 
                    scaleY: cvHeight / imgHeight 
                });
                baseApp.displayMessage("Background image set.", true, 'messageArea');

                if (!currentSlide.slideMedia) currentSlide.slideMedia = {};
                currentSlide.slideMedia.type = 'image';
                currentSlide.slideMedia.url = null; 
                currentSlide.slideMedia.driveFileId = adminApp.state.lastUploadedDriveId || null;
                currentSlide.slideMedia.mimeType = adminApp.state.lastUploadedMimeType || response.mimeType;
                currentSlide.slideMedia.originalName = adminApp.state.lastUploadedFileName || null;
                currentSlide.canvasWidth = cvWidth;
                currentSlide.canvasHeight = cvHeight;

                console.log(`Slide ${adminApp.state.currentSlideIndex + 1} media/dims updated for image.`);
                updateSlideThumbnailsUI();

                delete adminApp.state.lastUploadedDriveId;
                delete adminApp.state.lastUploadedMimeType;
                delete adminApp.state.lastUploadedFileName;

            }, { crossOrigin: 'anonymous' });
        } else {
            baseApp.onServerError({ message: (response && response.error) ? response.error : "Failed to fetch image data." }, 'messageArea');
        }
    }

    function handleSetYoutubeBackground() {
        if (!adminApp.state.projectData || adminApp.state.currentSlideIndex < 0) {
            baseApp.displayMessage("Please select a slide first.", false, 'messageArea'); return;
        }
        if (!youtubeUrlInputEl || !youtubeUrlInputEl.value) {
            baseApp.displayMessage("Please enter a YouTube URL.", false, 'messageArea'); return;
        }
        const url = youtubeUrlInputEl.value.trim();
        if (!url.includes("youtube.com/") && !url.includes("youtu.be/")) { // Simplified check
            baseApp.displayMessage("Please enter a valid YouTube URL.", false, 'messageArea');
            return;
        }

        saveCurrentSlideState(); 

        const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
        if (!currentSlide.slideMedia) {
            currentSlide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
        }
        currentSlide.slideMedia.type = 'youtube';
        currentSlide.slideMedia.url = url;
        currentSlide.slideMedia.driveFileId = null; 
        currentSlide.slideMedia.mimeType = 'video/youtube';
        currentSlide.slideMedia.originalName = null;
        currentSlide.slideMedia.videoQuestions = currentSlide.slideMedia.videoQuestions || []; // Ensure array exists
        currentSlide.slideMedia.videoOverlays = currentSlide.slideMedia.videoOverlays || [];


        console.log(`Set YouTube background for slide ${adminApp.state.currentSlideIndex + 1} to: ${url}`);
        selectSlide(adminApp.state.currentSlideIndex); // Reload slide to show YouTube player
        baseApp.displayMessage("YouTube background set for this slide.", true, 'messageArea');
    }

    function handleAudioUpload(event) {
        if (adminApp.state.isLoading) { if (event.target) event.target.value = null; return; }
        const file = event.target.files[0];
        if (!file || !file.type.startsWith('audio/')) {
            if (event.target) event.target.value = null;
            return;
        }
        if (!adminApp.state.projectData || adminApp.state.currentSlideIndex < 0) {
             baseApp.displayMessage("Please select a slide first before uploading audio.", false, 'messageArea');
             if (event.target) event.target.value = null;
             return;
        }

        saveCurrentSlideState(); 

        baseApp.showLoading(true, 'loadingSpinner');
        adminApp.state.isLoading = true;
        baseApp.displayMessage("Uploading audio...", true, 'messageArea');
        const reader = new FileReader();
        reader.onload = function(e) {
            const fileData = {
                fileName: file.name,
                mimeType: file.type,
                data: e.target.result.split(',')[1]
            };
            google.script.run
                .withSuccessHandler(onAudioUploaded)
                .withFailureHandler(error => baseApp.onServerError(error, 'messageArea'))
                .uploadFileToDrive(fileData, adminApp.state.currentProjectId, 'audio');
        };
        reader.onerror = function(error) {
            baseApp.showLoading(false, 'loadingSpinner');
            adminApp.state.isLoading = false;
            baseApp.displayMessage("Error reading audio file.", false, 'messageArea');
            console.error(error);
            if (event.target) event.target.value = null;
        };
        reader.readAsDataURL(file);
    }

     function onAudioUploaded(response) {
        baseApp.showLoading(false, 'loadingSpinner');
        adminApp.state.isLoading = false;
        if (audioUploaderEl) audioUploaderEl.value = null;

        if (response && response.success && response.driveFileId) {
            baseApp.displayMessage("Audio processed successfully.", true, 'messageArea');

            const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
             if (!currentSlide.slideMedia) {
                currentSlide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
             }
            currentSlide.slideMedia.type = 'audio';
            currentSlide.slideMedia.url = null; 
            currentSlide.slideMedia.driveFileId = response.driveFileId;
            currentSlide.slideMedia.mimeType = response.mimeType;
            currentSlide.slideMedia.originalName = response.fileName;

            console.log(`Audio attached for slide ${adminApp.state.currentSlideIndex + 1}:`, currentSlide.slideMedia);
            
            sharedUtils.safeDOMUpdate(attachedAudioNameEl, el => {
                el.textContent = `Attached: ${response.fileName}`;
                const currentAudioControls = document.getElementById('audioControls');
                sharedUtils.safeDOMUpdate(currentAudioControls, audioEl => audioEl.style.display = 'block', "Failed to show audio controls on audio upload");
            }, "Failed to update attached audio name on upload");
            sharedUtils.safeDOMUpdate(removeAudioButtonEl, el => el.style.display = 'inline-block', "Failed to show remove audio button on upload");

            if (youtubeUrlInputEl) youtubeUrlInputEl.value = '';
            if (imageUploaderEl) imageUploaderEl.value = null;
            if(adminApp.state.fabricCanvasInstance) {
                adminApp.state.fabricCanvasInstance.setBackgroundImage(null, adminApp.state.fabricCanvasInstance.renderAll.bind(adminApp.state.fabricCanvasInstance));
                adminApp.state.fabricCanvasInstance.backgroundColor = '#e9e9e9'; 
                adminApp.state.fabricCanvasInstance.renderAll();
            }
            sharedUtils.safeDOMUpdate(adminMediaPlaceholderEl, el => {
                 el.textContent = `Audio Attached: ${response.fileName}`;
                 el.style.display = 'block';
            }, "Failed to update admin media placeholder on audio upload");

        } else {
            onServerError((response && response.error) ? response.error : "Failed to process audio.");
        }
    }

    function handleRemoveAudio() {
        if (!adminApp.state.projectData || adminApp.state.currentSlideIndex < 0) return;

        const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
        if (currentSlide.slideMedia && currentSlide.slideMedia.type === 'audio') {
            console.log(`Removing audio from slide ${adminApp.state.currentSlideIndex + 1}`);

            currentSlide.slideMedia.type = null;
            currentSlide.slideMedia.url = null;
            currentSlide.slideMedia.driveFileId = null;
            currentSlide.slideMedia.mimeType = null;
            currentSlide.slideMedia.originalName = null;

            sharedUtils.safeDOMUpdate(attachedAudioNameEl, el => {
                el.textContent = '';
                const currentAudioControls = document.getElementById('audioControls');
                sharedUtils.safeDOMUpdate(currentAudioControls, audioEl => audioEl.style.display = 'none', "Failed to hide audio controls on audio removal");
            }, "Failed to clear attached audio name on removal");
            sharedUtils.safeDOMUpdate(removeAudioButtonEl, el => el.style.display = 'none', "Failed to hide remove audio button on removal");
            if (audioUploaderEl) audioUploaderEl.value = null; 
            sharedUtils.safeDOMUpdate(adminMediaPlaceholderEl, el => el.style.display = 'none', "Failed to hide admin media placeholder on audio removal");
            
            if(adminApp.state.fabricCanvasInstance) {
                adminApp.state.fabricCanvasInstance.backgroundColor = '#e9e9e9';
                adminApp.state.fabricCanvasInstance.renderAll();
             }
            baseApp.displayMessage("Audio removed from this slide.", true, 'messageArea');
        }
    }

    function handlePasteImage(event) {
        if (adminApp.state.currentView !== 'edit' || !adminApp.state.currentProjectId || adminApp.state.isLoading) {
            return;
        }
        const items = (event.clipboardData || event.originalEvent.clipboardData).items;
        let imageFound = false;
        for (let i = 0; i < items.length; i++) {
            if (items[i].kind === 'file' && items[i].type.startsWith('image/')) {
                imageFound = true;
                const blob = items[i].getAsFile();
                if (!blob) continue;
                event.preventDefault();
                console.log("Image pasted from clipboard:", blob.name || 'pasted_image', blob.type);
                saveCurrentSlideState(); 
                baseApp.showLoading(true, 'loadingSpinner');
                adminApp.state.isLoading = true;
                baseApp.displayMessage("Processing pasted image...", true, 'messageArea');
                const reader = new FileReader();
                reader.onload = function(e_reader) {
                    const fileData = {
                        fileName: blob.name || `pasted_image_${Date.now()}.${blob.type.split('/')[1] || 'png'}`, 
                        mimeType: blob.type,
                        data: e_reader.target.result.split(',')[1]
                    };
                    if (!adminApp.state.currentProjectId) {
                        baseApp.showLoading(false, 'loadingSpinner');
                        adminApp.state.isLoading = false;
                        baseApp.displayMessage("Error: No project selected for pasted image.", false, 'messageArea');
                        return;
                    }
                    google.script.run
                        .withSuccessHandler(onImageUploaded) 
                        .withFailureHandler(error => baseApp.onServerError(error, 'messageArea'))
                        .uploadFileToDrive(fileData, adminApp.state.currentProjectId, 'image');
                };
                reader.onerror = function(error) {
                    baseApp.showLoading(false, 'loadingSpinner');
                    adminApp.state.isLoading = false;
                    baseApp.displayMessage("Error reading pasted image data.", false, 'messageArea');
                    console.error("FileReader error:", error);
                };
                reader.readAsDataURL(blob);
                break; 
            }
        }
        if (imageFound) {
            console.log("Handled pasted image.");
        } else {
            console.log("Paste event did not contain a direct image file.");
        }
    }

    function handleMediaSelection(mediaType) {
        if (adminApp.state.currentView !== 'edit' || !adminApp.state.currentProjectId || adminApp.state.isLoading) {
            sharedUtils.showNotification("Cannot add media now. Please wait...", "error");
            return;
        }
        
        switch(mediaType) {
            case 'image':
                if (imageUploaderEl) {
                    imageUploaderEl.click();
                } else {
                    sharedUtils.showNotification("Image upload not available", "error");
                }
                break;
            case 'audio':
                if (audioUploaderEl) {
                    audioUploaderEl.click();
                } else {
                    sharedUtils.showNotification("Audio upload not available", "error");
                }
                break;
            case 'youtube':
                const youtubeUrl = prompt("Enter YouTube URL:");
                if (youtubeUrl) {
                    if (youtubeUrlInputEl) {
                        youtubeUrlInputEl.value = youtubeUrl;
                        handleSetYoutubeBackground();
                    } else {
                        sharedUtils.showNotification("YouTube background functionality not available", "error");
                    }
                }
                break;
            default:
                sharedUtils.showNotification("Unknown media type: " + mediaType, "error");
        }
    }

    function handleUndo() {
        if (adminApp.state.historyIndex <= 0) return; 

        adminApp.state.isApplyingHistory = true;
        adminApp.state.historyIndex--;
        const canvas = adminApp.state.fabricCanvasInstance;
        const stateToLoad = adminApp.state.history[adminApp.state.historyIndex];

        canvas.loadFromJSON(stateToLoad, () => {
            canvas.renderAll();
            canvas.getObjects().forEach(obj => {
                const originalObjState = stateToLoad.objects.find(sObj => sObj.slideId === obj.slideId );
                if (originalObjState) { 
                    obj.customInteraction = originalObjState.customInteraction || { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
                    obj.customAnimation = originalObjState.customAnimation || { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
                }
            });
            populateToolbar(canvas.getActiveObject()); 
            adminApp.state.isApplyingHistory = false;
            updateUndoRedoButtonStates();
            console.log("Undo applied. History index:", adminApp.state.historyIndex);
        });
    }

    function handleRedo() {
        if (adminApp.state.historyIndex >= adminApp.state.history.length - 1) return;

        adminApp.state.isApplyingHistory = true;
        adminApp.state.historyIndex++;
        const canvas = adminApp.state.fabricCanvasInstance;
        const stateToLoad = adminApp.state.history[adminApp.state.historyIndex];

        canvas.loadFromJSON(stateToLoad, () => {
            canvas.renderAll();
            canvas.getObjects().forEach(obj => {
                const originalObjState = stateToLoad.objects.find(sObj => sObj.slideId === obj.slideId);
                if (originalObjState) {
                    obj.customInteraction = originalObjState.customInteraction || { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
                    obj.customAnimation = originalObjState.customAnimation || { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
                }
            });
            populateToolbar(canvas.getActiveObject());
            adminApp.state.isApplyingHistory = false;
            updateUndoRedoButtonStates();
            console.log("Redo applied. History index:", adminApp.state.historyIndex);
        });
    }

    function handleDeleteObject() {
        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas) return;
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
            canvas.remove(activeObject);
            if (activeObject.type === 'activeSelection') { 
                activeObject.forEachObject(obj => canvas.remove(obj));
                canvas.discardActiveObject(); 
            }
            canvas.renderAll();
            saveCanvasStateForHistory(); 
            populateToolbar(null); 
            sharedUtils.showNotification("Object deleted", "info");
        } else {
            sharedUtils.showNotification("No object selected to delete.", "info");
        }
    }

// Overlay creation workflow
function initiateOverlayPlacement() {
    // Use MediaManager's player and availability check
    if (!mediaManager.isYouTubePlayerAvailable() || !mediaManager.state.ytPlayer) {
        baseApp.displayMessage("YouTube player is not available or ready.", false, "messageArea");
        return;
    }
    
    // Pause video at current time
    mediaManager.state.ytPlayer.pauseVideo();
    const currentTime = mediaManager.safeGetCurrentTime(); // Uses MediaManager's player
    
    // Show placement overlay
    const placementMode = document.getElementById('overlayPlacementMode');
    sharedUtils.safeDOMUpdate(placementMode, el => el.style.display = 'block', "Failed to show overlay placement mode in initiateOverlayPlacement");
    
    // Store placement state
    adminApp.state.placingOverlay = {
        startTime: currentTime,
        position: null
    };
}

// Handle click on video to place overlay
function handleOverlayPlacement(event) {
    const container = document.getElementById('adminYouTubePlayerContainer');
    if (!container) { // Added null check
        console.warn('handleOverlayPlacement: adminYouTubePlayerContainer element not found.');
        return;
    }
    const rect = container.getBoundingClientRect();
    
    // Calculate percentage position
    const x = ((event.clientX - rect.left) / rect.width) * 100;
    const y = ((event.clientY - rect.top) / rect.height) * 100;
    
    adminApp.state.placingOverlay.position = { x, y };
    
    // Hide placement mode
    const placementMode = document.getElementById('overlayPlacementMode');
    sharedUtils.safeDOMUpdate(placementMode, el => el.style.display = 'none', "Failed to hide overlay placement mode in handleOverlayPlacement");
    
    // Show editor modal
    showOverlayEditor();
}

// Show overlay editor modal
function showOverlayEditor(overlayId = null) {
    const modal = document.getElementById('overlayEditorModal');
    if (!modal) { // Added null check
        console.warn('showOverlayEditor: overlayEditorModal element not found.');
        return;
    }
    const overlay = overlayId ? findOverlayById(overlayId) : createNewOverlay();
    
    if (!overlay) { // Added null check for overlay object
        console.warn('showOverlayEditor: Overlay object could not be found or created.');
        return;
    }

    // Populate form fields
    const overlayTemplateEl = document.getElementById('overlayTemplate');
    if (overlayTemplateEl) overlayTemplateEl.value = overlay.template; // Input value
    
    const overlayStartTimeDisplayEl = document.getElementById('overlayStartTimeDisplay');
    sharedUtils.safeDOMUpdate(overlayStartTimeDisplayEl, el => el.textContent = sharedUtils.formatTime(overlay.startTime), "Failed to set overlay start time display in showOverlayEditor");
    
    const overlayDurationEl = document.getElementById('overlayDuration');
    if (overlayDurationEl) overlayDurationEl.value = overlay.duration; // Input value
    
    const overlayTextContentEl = document.getElementById('overlayTextContent'); // This is the one in the modal
    if (overlayTextContentEl) overlayTextContentEl.value = overlay.content.text || ''; // Input value
    
    const overlayPauseVideoEl = document.getElementById('overlayPauseVideo');
    if (overlayPauseVideoEl) overlayPauseVideoEl.checked = overlay.interaction.pauseVideo; // Input checked
    
    const overlayDismissibleEl = document.getElementById('overlayDismissible');
    if (overlayDismissibleEl) overlayDismissibleEl.checked = overlay.interaction.dismissible; // Input checked
    
    const overlayActionEl = document.getElementById('overlayAction');
    if (overlayActionEl) overlayActionEl.value = overlay.interaction.action; // Input value
    
    // Show position
    const overlayPositionDisplayEl = document.getElementById('overlayPositionDisplay');
    sharedUtils.safeDOMUpdate(overlayPositionDisplayEl, el => {
        if (overlay.position) {
            el.textContent = `X: ${overlay.position.x.toFixed(0)}%, Y: ${overlay.position.y.toFixed(0)}%`;
        } else {
            el.textContent = 'Position not set';
        }
    }, "Failed to set overlay position display in showOverlayEditor");
    
    // Show/hide delete button
    const deleteOverlayBtnEl = document.getElementById('deleteOverlayBtn');
    sharedUtils.safeDOMUpdate(deleteOverlayBtnEl, el => el.style.display = overlayId ? 'inline-block' : 'none', "Failed to update delete overlay button display in showOverlayEditor");
    
    sharedUtils.safeDOMUpdate(modal, el => el.style.display = 'block', "Failed to show overlay editor modal in showOverlayEditor");
    adminApp.state.editingOverlayId = overlayId;
}

// Create new overlay object
function createNewOverlay() {
    // Ensure placingOverlay state is valid or provide defaults
    let startTime = 0;
    let position = { x: 50, y: 50 }; // Default position

    if (adminApp.state.placingOverlay) {
        startTime = adminApp.state.placingOverlay.startTime;
        // Use position from placingOverlay if it exists, otherwise keep default
        if (adminApp.state.placingOverlay.position) {
            position = adminApp.state.placingOverlay.position;
        }
    } else if (mediaManager.isYouTubePlayerAvailable() && mediaManager.state.ytPlayer) { // Use MediaManager
        // Fallback if placingOverlay is not set, use current video time
        startTime = mediaManager.safeGetCurrentTime(); // Uses MediaManager's player
    }


    return {
        id: 'overlay_' + sharedUtils.generateClientUuid(),
        template: 'lowerThird',
        startTime: startTime,
        duration: 5,
        position: position,
        content: {
            text: '',
            backgroundColor: '#000000',
            textColor: '#FFFFFF'
        },
        interaction: {
            pauseVideo: false,
            dismissible: true,
            action: 'none',
            actionTarget: ''
        }
    };
}

// Save overlay
function saveOverlay() {
    const currentSlide = getCurrentSlide();
    if (!currentSlide || !currentSlide.slideMedia) { // Added null check for currentSlide and slideMedia
        console.warn("saveOverlay: Current slide or slide media not found.");
        return;
    }
    if (!currentSlide.slideMedia.videoOverlays) {
        currentSlide.slideMedia.videoOverlays = [];
    }
    
    const overlay = gatherOverlayFromForm();
    if (!overlay) { // Added null check for overlay data
        console.warn("saveOverlay: Could not gather overlay data from form.");
        return;
    }
    
    if (adminApp.state.editingOverlayId) {
        // Update existing
        const index = currentSlide.slideMedia.videoOverlays.findIndex(
            o => o.id === adminApp.state.editingOverlayId
        );
        if (index !== -1) {
            currentSlide.slideMedia.videoOverlays[index] = overlay;
        } else {
            // If for some reason the ID is not found, add as new to prevent data loss
            currentSlide.slideMedia.videoOverlays.push(overlay);
            console.warn("saveOverlay: Editing overlay ID not found, added as new.");
        }
    } else {
        // Add new
        currentSlide.slideMedia.videoOverlays.push(overlay);
    }
    
    // Sort by start time
    currentSlide.slideMedia.videoOverlays.sort((a, b) => a.startTime - b.startTime);
    
    hideOverlayEditor();
    renderOverlayTimeline();
    renderOverlayList();
    sharedUtils.showNotification('Overlay saved.', 'success'); // Added user feedback
}

// Render overlay bars on timeline
function renderOverlayTimeline() {
    const track = document.getElementById('overlayTimelineTrack');
    if (!track) { // Added null check
        console.warn("renderOverlayTimeline: overlayTimelineTrack element not found.");
        return;
    }
    if (!isYouTubePlayerAvailable() || !adminApp.state.adminYouTubePlayer) {
        console.warn("renderOverlayTimeline: adminYouTubePlayer not available.");
        track.innerHTML = '<p>Video player not ready.</p>'; // User feedback
        return;
    }
    sharedUtils.safeDOMUpdate(track, el => {
        el.innerHTML = ''; // Clear previous timeline
        const duration = adminApp.state.adminYouTubePlayer.getDuration(); // getDuration() is generally safe
        if (duration === 0) { // Handle case where duration might not be available yet
            el.innerHTML = '<p>Video duration not available.</p>'; // User feedback
            return;
        }

        const currentSlide = getCurrentSlide();
        // Ensure videoOverlays exists and is an array
        const overlays = (currentSlide && currentSlide.slideMedia && Array.isArray(currentSlide.slideMedia.videoOverlays)) 
                         ? currentSlide.slideMedia.videoOverlays 
                         : [];
        
        if (overlays.length === 0) {
            el.innerHTML = '<p style="text-align: center; margin-top: 10px;">No overlays on this slide.</p>'; // User feedback
            return;
        }

        overlays.forEach(overlay => {
        const bar = document.createElement('div');
        bar.className = 'overlay-timeline-bar';
        bar.dataset.overlayId = overlay.id;
        
        const startPercent = (overlay.startTime / duration) * 100;
        const widthPercent = (overlay.duration / duration) * 100;
        
        bar.style.cssText = `
            position: absolute;
            left: ${startPercent}%;
            width: ${widthPercent}%;
            height: 100%;
            background-color: ${getTemplateColor(overlay.template)};
            opacity: 0.8;
            cursor: pointer;
            border: 1px solid rgba(0,0,0,0.3);
            box-sizing: border-box; /* Added for better layout */
        `;
        
        bar.title = `${overlay.content.text || overlay.template} (${sharedUtils.formatTime(overlay.startTime)})`;
        bar.onclick = () => showOverlayEditor(overlay.id);
        
        el.appendChild(bar); // Appending to el (the track)
        });
    }, "Failed to render overlay timeline");
}

// Helper to get color for template type
function getTemplateColor(template) {
    const colors = {
        lowerThird: '#2196F3',
        cornerCallout: '#4CAF50',
        centerCard: '#FF9800',
        hotspot: '#E91E63',
        quizBubble: '#9C27B0'
    };
    return colors[template] || '#607D8B'; // Default color
}

// Preview overlays (toggle preview mode)
function toggleOverlayPreview() {
    adminApp.state.previewingOverlays = !adminApp.state.previewingOverlays;
    const previewButton = document.getElementById('previewOverlaysBtn');
    const intervalName = 'overlayPreview';
    const resourceName = 'interval-' + intervalName; // For resourceManager

    if (adminApp.state.previewingOverlays) {
        renderVideoOverlaysAdmin();
        // Clear any existing interval for 'overlayPreview' using the updated clearInterval
        // This ensures its associated resourceManager entry is also cleaned up if it exists.
        adminApp.clearInterval(intervalName);

        const timerId = baseApp.timerManager.setInterval(updateOverlayPreview, 100);
        if (timerId) {
            adminApp.intervals[intervalName] = timerId; // Store timerManager's ID
            // Track with resourceManager to clear this specific timer if disposeAll is called
            baseApp.resourceManager.trackDisposable(resourceName, () => {
                // This function is called by resourceManager.disposeAll() or disposeByName(resourceName)
                // It should directly clear the timer using timerManager.
                // No need to call adminApp.clearInterval here as that would cause a loop with disposeByName.
                baseApp.timerManager.clearTimer(adminApp.intervals[intervalName]);
                adminApp.intervals[intervalName] = null; // Ensure it's marked as cleared in local tracking too
                // console.log(`Cleared interval ${intervalName} (ID: ${timerId}) via resourceManager dispose`);
            });
            console.log(`Set and tracked interval ${intervalName} with timerManager ID: ${timerId} and resourceName: ${resourceName}`);
            sharedUtils.safeDOMUpdate(previewButton, el => el.textContent = 'Stop Preview', "Failed to update preview button text to Stop in toggleOverlayPreview");
        } else {
            console.error("Failed to set interval using timerManager for overlayPreview.");
            adminApp.state.previewingOverlays = false; // Revert state
        }
    } else {
        // This calls the updated adminApp.clearInterval, which handles both timerManager.clearTimer
        // and resourceManager.disposeByName for this specific interval.
        adminApp.clearInterval(intervalName);
        clearVideoOverlaysAdmin();
        sharedUtils.safeDOMUpdate(previewButton, el => el.textContent = 'Preview Overlays', "Failed to update preview button text to Preview in toggleOverlayPreview");
    }
}

// --- Helper Functions for Overlay Management ---
function findOverlayById(overlayId) {
    const currentSlide = getCurrentSlide();
    if (!currentSlide || !currentSlide.slideMedia || !Array.isArray(currentSlide.slideMedia.videoOverlays)) { // Check if array
        return null;
    }
    return currentSlide.slideMedia.videoOverlays.find(o => o.id === overlayId);
}

function hideOverlayEditor() {
    const modal = document.getElementById('overlayEditorModal');
    sharedUtils.safeDOMUpdate(modal, el => el.style.display = 'none', "Failed to hide overlay editor modal in hideOverlayEditor");
    adminApp.state.editingOverlayId = null;
}

function deleteCurrentOverlay() {
    if (!adminApp.state.editingOverlayId) {
        sharedUtils.showNotification('No overlay selected to delete.', 'error');
        return;
    }

    const currentSlide = getCurrentSlide();
    if (!currentSlide || !currentSlide.slideMedia || !Array.isArray(currentSlide.slideMedia.videoOverlays)) { // Check if array
        sharedUtils.showNotification('Cannot find overlay data for this slide.', 'error');
        return;
    }

    const overlayIdToDelete = adminApp.state.editingOverlayId;
    const initialLength = currentSlide.slideMedia.videoOverlays.length;
    currentSlide.slideMedia.videoOverlays = currentSlide.slideMedia.videoOverlays.filter(
        o => o.id !== overlayIdToDelete
    );

    if (currentSlide.slideMedia.videoOverlays.length < initialLength) {
        sharedUtils.showNotification('Overlay deleted.', 'success');
    } else {
        sharedUtils.showNotification('Could not delete overlay. Not found.', 'error');
    }

    hideOverlayEditor();
    renderOverlayTimeline();
    renderOverlayList();
}

function gatherOverlayFromForm() {
    const editingId = adminApp.state.editingOverlayId;
    const isNew = !editingId;
    const existingOverlay = editingId ? findOverlayById(editingId) : null;
    
    let startTime, position;

    if (isNew && adminApp.state.placingOverlay) {
        startTime = adminApp.state.placingOverlay.startTime;
        position = adminApp.state.placingOverlay.position;
    } else if (existingOverlay) {
        startTime = existingOverlay.startTime;
        position = existingOverlay.position;
    } else { 
        startTime = (adminApp.state.adminYouTubePlayer && typeof adminApp.state.adminYouTubePlayer.getCurrentTime === 'function') 
                      ? adminApp.state.adminYouTubePlayer.getCurrentTime() 
                      : 0;
        position = { x: 50, y: 50 }; // Default
        console.warn("gatherOverlayFromForm: Could not determine start time or position reliably, using defaults.");
    }
    
    if (!position) { // Ensure position is an object
        position = { x: 50, y: 50 };
    }
    
    // Get values from form elements, with null checks for each element
    const overlayTemplateEl = document.getElementById('overlayTemplate');
    const templateValue = overlayTemplateEl ? overlayTemplateEl.value : 'lowerThird';

    const overlayDurationEl = document.getElementById('overlayDuration');
    const durationValue = overlayDurationEl ? (parseInt(overlayDurationEl.value, 10) || 5) : 5;

    const overlayTextContentEl = document.getElementById('overlayTextContent');
    const textContentValue = overlayTextContentEl ? overlayTextContentEl.value : '';

    const overlayPauseVideoEl = document.getElementById('overlayPauseVideo');
    const pauseVideoValue = overlayPauseVideoEl ? overlayPauseVideoEl.checked : false;

    const overlayDismissibleEl = document.getElementById('overlayDismissible');
    const dismissibleValue = overlayDismissibleEl ? overlayDismissibleEl.checked : true;

    const overlayActionEl = document.getElementById('overlayAction');
    const actionValue = overlayActionEl ? overlayActionEl.value : 'none';

    return {
        id: editingId || ('overlay_' + sharedUtils.generateClientUuid()),
        template: templateValue,
        startTime: startTime,
        duration: durationValue,
        position: position, // Already ensured it's an object
        content: {
            text: textContentValue,
            backgroundColor: (existingOverlay && existingOverlay.content) ? existingOverlay.content.backgroundColor : '#000000',
            textColor: (existingOverlay && existingOverlay.content) ? existingOverlay.content.textColor : '#FFFFFF'
        },
        interaction: {
            pauseVideo: pauseVideoValue,
            dismissible: dismissibleValue,
            action: actionValue,
            actionTarget: (existingOverlay && existingOverlay.interaction) ? existingOverlay.interaction.actionTarget : ''
        }
    };
}

function renderOverlayList() {
    const listEl = document.getElementById('adminOverlayList'); 
    if (!listEl) {
        console.warn("renderOverlayList: adminOverlayList element not found.");
        return;
    }
    sharedUtils.safeDOMUpdate(listEl, el => {
        el.innerHTML = ''; // Clear previous list
        const currentSlide = getCurrentSlide();
        const overlays = (currentSlide && currentSlide.slideMedia && Array.isArray(currentSlide.slideMedia.videoOverlays)) 
                         ? currentSlide.slideMedia.videoOverlays 
                         : [];

        if (overlays.length === 0) {
            el.innerHTML = '<li>No overlays added for this video.</li>';
            return;
        }

        overlays.forEach(overlay => {
            const item = document.createElement('li');
            item.className = 'overlay-list-item'; 
            item.setAttribute('data-overlay-id', overlay.id); 

            const textSpan = document.createElement('span');
            textSpan.textContent = `[${sharedUtils.formatTime(overlay.startTime)}] ${overlay.content.text || overlay.template} (Duration: ${overlay.duration}s)`;
            
            const editButton = document.createElement('button');
            editButton.textContent = 'Edit';
            editButton.className = 'edit-overlay-list-btn'; 
            editButton.style.marginLeft = '10px';
            editButton.onclick = (e) => {
                e.stopPropagation(); 
                showOverlayEditor(overlay.id);
            };

            item.appendChild(textSpan);
            item.appendChild(editButton);
            el.appendChild(item);
        });
    }, "Failed to render overlay list in renderOverlayList");
}

function renderVideoOverlaysAdmin() {
    const playerContainer = document.getElementById('adminYouTubePlayerContainer');
    if (!playerContainer) {
        console.warn("renderVideoOverlaysAdmin: adminYouTubePlayerContainer not found.");
        return;
    }

    clearVideoOverlaysAdmin(false); 

    const currentSlide = getCurrentSlide();
    if (!currentSlide || !currentSlide.slideMedia || !Array.isArray(currentSlide.slideMedia.videoOverlays)) return;

    const overlaysToDisplay = currentSlide.slideMedia.videoOverlays; 

    overlaysToDisplay.forEach(overlay => {
        if (!overlay.position) { // Skip if position is somehow missing
            console.warn("renderVideoOverlaysAdmin: Overlay missing position data", overlay.id);
            return;
        }
        const overlayDiv = document.createElement('div');
        overlayDiv.className = `video-overlay-preview admin-preview-${overlay.template}`; 
        overlayDiv.setAttribute('data-preview-overlay-id', overlay.id);
        overlayDiv.style.position = 'absolute';
        overlayDiv.style.left = `${overlay.position.x}%`;
        overlayDiv.style.top = `${overlay.position.y}%`;
        overlayDiv.style.padding = '5px 10px';
        overlayDiv.style.backgroundColor = overlay.content.backgroundColor || 'rgba(0,0,0,0.7)';
        overlayDiv.style.color = overlay.content.textColor || 'white';
        overlayDiv.style.border = '1px dashed #ccc'; // Dashed to distinguish from real ones
        overlayDiv.style.zIndex = '1050'; // High z-index for admin preview
        overlayDiv.style.pointerEvents = 'none'; // Make them non-interactive for admin preview
        overlayDiv.textContent = overlay.content.text || `[${overlay.template}]`;
        
        playerContainer.appendChild(overlayDiv);
    });
    // After rendering all, explicitly call updateOverlayPreview to set initial visibility
    updateOverlayPreview(); 
}

function updateOverlayPreview() {
    // This function's core logic is now part of adminApp.handleMediaOverlayUpdate,
    // which is called by MediaManager's checkMediaTime interval.
    // This direct function `updateOverlayPreview` might be removable if `toggleOverlayPreview`
    // correctly triggers the display via `handleMediaOverlayUpdate`.
    // For now, let's update it to use MediaManager if it were to be called directly.
    if (!mediaManager.isYouTubePlayerAvailable() || !mediaManager.state.ytPlayer || typeof mediaManager.state.ytPlayer.getCurrentTime !== 'function') {
        return;
    }
    if (!adminApp.state.previewingOverlays) return;

    const currentTime = mediaManager.safeGetCurrentTime();
    const currentSlide = getCurrentSlide();
    if (!currentSlide || !currentSlide.slideMedia || !Array.isArray(currentSlide.slideMedia.videoOverlays)) return;

    const overlays = currentSlide.slideMedia.videoOverlays;
    const activeOverlaysContainer = document.getElementById('adminYouTubePlayerContainer'); 
    if (!activeOverlaysContainer) return;

    overlays.forEach(overlay => {
        const overlayEl = activeOverlaysContainer.querySelector(`.video-overlay-preview[data-preview-overlay-id="${overlay.id}"]`);
        if (!overlayEl) return; 

        const isVisible = currentTime >= overlay.startTime && currentTime < (overlay.startTime + overlay.duration);
        overlayEl.style.display = isVisible ? 'block' : 'none';
    });
}

function clearVideoOverlaysAdmin(stopPreviewLogicAndButtonUpdate = true) {
    const playerContainer = document.getElementById('adminYouTubePlayerContainer');
    sharedUtils.safeDOMUpdate(playerContainer, el => {
        const previewOverlays = el.querySelectorAll('.video-overlay-preview');
        previewOverlays.forEach(previewEl => previewEl.remove());
    }, "Failed to clear video overlays from admin player container in clearVideoOverlaysAdmin");
    
    if (stopPreviewLogicAndButtonUpdate) {
        adminApp.clearInterval('overlayPreview');
        adminApp.state.previewingOverlays = false; 
        const previewButton = document.getElementById('previewOverlaysBtn');
        sharedUtils.safeDOMUpdate(previewButton, btnEl => btnEl.textContent = 'Preview Overlays', "Failed to reset preview button text in clearVideoOverlaysAdmin");
    }
}

    // --- Overlay Creation ---
    function addRectangle() {
      if (!adminApp.state.fabricCanvasInstance) { console.error("addRectangle: Fabric canvas not initialized."); baseApp.displayMessage("Error: Canvas not ready to add shapes.", false, 'messageArea'); return; }
      const canvas = adminApp.state.fabricCanvasInstance;
      const rect = new fabric.Rect({ 
          left: 50, top: 50, fill: 'rgba(255,0,0,0.7)', width: 150, height: 100, 
          stroke: 'black', strokeWidth: 1,
          customInteraction: { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 }, 
          customAnimation: { trigger: "", type: "", speed: "normal", strength: 5, loop: false }, 
          sequenceOrder: null 
      });
    canvas.add(rect); canvas.setActiveObject(rect); canvas.renderAll();
    saveCanvasStateForHistory(); 
    console.log("Rectangle added to canvas:", rect);
    hideActivePopover();
    }

    function addCircle() {
      if (!adminApp.state.fabricCanvasInstance) { console.error("addCircle: Fabric canvas not initialized."); baseApp.displayMessage("Error: Canvas not ready to add shapes.", false, 'messageArea'); return; }
      const canvas = adminApp.state.fabricCanvasInstance;
      const circle = new fabric.Circle({ 
          left: 150, top: 150, radius: 50, fill: 'rgba(0,0,255,0.7)', 
          stroke: 'black', strokeWidth: 1, 
          customInteraction: { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 }, 
          customAnimation: { trigger: "", type: "", speed: "normal", strength: 5, loop: false }, 
          sequenceOrder: null 
      });
    canvas.add(circle); canvas.setActiveObject(circle); canvas.renderAll();
    saveCanvasStateForHistory(); 
    console.log("Circle added to canvas:", circle);
    hideActivePopover();
    }

    function addTextbox() {
      if (!adminApp.state.fabricCanvasInstance) { console.error("addTextbox: Fabric canvas not initialized."); baseApp.displayMessage("Error: Canvas not ready to add text.", false, 'messageArea'); return; }
      const canvas = adminApp.state.fabricCanvasInstance;
      const textbox = new fabric.Textbox('Editable Text', {
          left: 100, top: 100, width: 200, fontSize: 24, fill: '#000000',
          fontFamily: 'Arial', fontWeight: 'normal', fontStyle: 'normal',
          textAlign: 'left', lineHeight: 1.16, charSpacing: 0,
          customInteraction: { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 },
          customAnimation: { trigger: "", type: "", speed: "normal", strength: 5, loop: false },
          sequenceOrder: null
      });
        canvas.add(textbox); canvas.setActiveObject(textbox); canvas.renderAll();
        saveCanvasStateForHistory(); 
        console.log("Textbox added to canvas:", textbox);
        hideActivePopover();
        }

    // --- Toolbar Logic (Significantly Reworked) ---
    function toHexColor(fabricColor) {
      if (!fabricColor) return '#000000'; 
      try {
        if (typeof fabricColor === 'string') {
            const colorInstance = new fabric.Color(fabricColor);
            const hex = colorInstance.toHex(); 
            return '#' + hex;
        }
        return '#000000'; 
      } catch (e) {
        console.warn("Could not convert color to HEX:", fabricColor, e);
        return '#000000'; 
      }
    }

    function initToolbar() {
        console.log("initToolbar: Attaching listeners to NEW toolbar inputs and popovers.");
        hideActivePopover(); 

        if(objFontFamilyEl) {
            objFontFamilyEl.innerHTML = ''; 
            sharedUtils.FONT_FAMILIES.forEach(font => {
                const option = document.createElement('option'); option.value = font; option.textContent = font; objFontFamilyEl.appendChild(option);
            });
            if (!objFontFamilyEl.hasAttribute('listener-attached')) {
                objFontFamilyEl.addEventListener('change', (e) => updateFabricObjectFromToolbar('fontFamily', e.target.value));
                objFontFamilyEl.setAttribute('listener-attached', 'true');
            }
        } else { console.warn("initToolbar: objFontFamilyEl not found for populating fonts."); }

        const popoverTriggers = [
            { buttonEl: shadowSettingsButtonEl, popoverId: 'shadowPopover' },
            { buttonEl: interactionSettingsButtonEl, popoverId: 'interactionPopover' },
            { buttonEl: animationSettingsButtonEl, popoverId: 'animationPopover' },
            { buttonEl: fontFamilyButtonEl, popoverId: 'fontFamilyPopover' },
            { buttonEl: mediaToolsButtonEl, popoverId: 'mediaToolsPopover' },
            { buttonEl: addShapeButtonEl, popoverId: 'shapesPopover' }, 
            { buttonEl: positionToolsButtonEl, popoverId: 'positionToolsPopover' },
            { buttonEl: fillColorButtonEl, popoverId: 'fillColorPopover' },
            { buttonEl: strokeColorButtonEl, popoverId: 'strokeColorPopover' },
            { buttonEl: opacityButtonEl, popoverId: 'opacityPopover' }
        ];

        popoverTriggers.forEach(item => {
            if (item.buttonEl && !item.buttonEl.hasAttribute('listener-attached')) {
                item.buttonEl.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    togglePopover(item.popoverId, item.buttonEl);
                });
                item.buttonEl.setAttribute('listener-attached', 'true');
            } else if (!item.buttonEl) {
                console.warn(`initToolbar: Popover trigger button for ${item.popoverId} not found.`);
            }
        });

        if (mediaTabButtonsEl && mediaTabButtonsEl.length > 0) {
            mediaTabButtonsEl.forEach(tab => {
                if (!tab.hasAttribute('listener-attached')) {
                    tab.addEventListener('click', () => {
                        const tabId = tab.dataset.tab;
                        switchMediaTab(tabId);
                    });
                    tab.setAttribute('listener-attached', 'true');
                }
            });
        }

        const setupDropZone = (dropZoneEl, uploaderEl, fileTypePrefix, uploadHandler) => {
            if (dropZoneEl && !dropZoneEl.hasAttribute('listener-attached')) {
                dropZoneEl.addEventListener('click', () => {
                    if (uploaderEl) uploaderEl.click();
                });
                dropZoneEl.addEventListener('dragover', (e) => { e.preventDefault(); dropZoneEl.classList.add('drag-over'); });
                dropZoneEl.addEventListener('dragleave', () => { dropZoneEl.classList.remove('drag-over'); });
                dropZoneEl.addEventListener('drop', (e) => {
                    e.preventDefault(); dropZoneEl.classList.remove('drag-over');
                    if (e.dataTransfer.files.length > 0) {
                        const file = e.dataTransfer.files[0];
                        if (file.type.startsWith(fileTypePrefix)) {
                            const mockEvent = { target: { files: [file] } };
                            uploadHandler(mockEvent);
                        } else {
                            baseApp.displayMessage(`Please drop a ${fileTypePrefix.split('/')[0]} file.`, false, 'messageArea');
                        }
                    }
                });
                dropZoneEl.setAttribute('listener-attached', 'true');
            }
        };
        setupDropZone(imageDropZoneEl, imageUploaderEl, 'image/', handleImageUpload);
        setupDropZone(audioDropZoneEl, audioUploaderEl, 'audio/', handleAudioUpload);

        const directInputs = [
            {el: objStrokeWidthEl, prop: 'strokeWidth', type: 'number'}, 
            {el: objOpacityEl, prop: 'opacity', type: 'range'}, 
            {el: objFontSizeEl, prop: 'fontSize', type: 'number'},
            {el: objLineHeightEl, prop: 'lineHeight', type: 'number', isFloat: true},
            {el: objCharSpacingEl, prop: 'charSpacing', type: 'number'},
            {el: objTextContentEl, prop: 'text', type: 'textarea'}
        ];
        directInputs.forEach(inputConfig => {
            if (inputConfig.el && !inputConfig.el.hasAttribute('listener-attached')) {
                const eventType = (inputConfig.el.type === 'range' || inputConfig.el.type === 'textarea') ? 'input' : 'change';
                inputConfig.el.addEventListener(eventType, (e) => {
                    updateFabricObjectFromToolbar(inputConfig.prop, e.target.value, inputConfig.type, inputConfig.isFloat);
                });
                inputConfig.el.setAttribute('listener-attached', 'true');
            } else if (!inputConfig.el) {
                 console.warn(`initToolbar: Direct input element for prop "${inputConfig.prop}" not found (this may be ok if it's in a popover, e.g. opacityEl).`);
            }
        });

        if (objOpacityEl && objOpacityValueDisplayEl && !objOpacityEl.hasAttribute('listener-opacity-display')) {
            objOpacityEl.addEventListener('input', function(e) {
                objOpacityValueDisplayEl.textContent = Math.round(parseFloat(e.target.value) * 100) + '%';
            });
            objOpacityEl.setAttribute('listener-opacity-display', 'true');
        }
        
        const positionInputs = [
            {el: objXEl, prop: 'left', type: 'number'}, {el: objYEl, prop: 'top', type: 'number'},
            {el: objWidthEl, prop: 'width', type: 'number', targetProp: 'scaleX'}, 
            {el: objHeightEl, prop: 'height', type: 'number', targetProp: 'scaleY'},
            {el: objAngleEl, prop: 'angle', type: 'number'}
        ];
        positionInputs.forEach(inputConfig => {
            if (inputConfig.el && !inputConfig.el.hasAttribute('listener-attached')) {
                 inputConfig.el.addEventListener('change', (e) => { 
                    updateFabricObjectFromToolbar(inputConfig.prop, e.target.value, inputConfig.type);
                });
                inputConfig.el.setAttribute('listener-attached', 'true');
            } else if (!inputConfig.el) {
                console.warn(`initToolbar: Position input element for prop "${inputConfig.prop}" not found.`);
            }
        });

        const colorInputs = [
            {el: objFillEl, prop: 'fill'},
            {el: objStrokeColorEl, prop: 'stroke'}
        ];
        colorInputs.forEach(inputConfig => {
            if (inputConfig.el && !inputConfig.el.hasAttribute('listener-attached')) {
                inputConfig.el.addEventListener('input', (e) => updateFabricObjectFromToolbar(inputConfig.prop, e.target.value));
                inputConfig.el.setAttribute('listener-attached', 'true');
            } else if (!inputConfig.el) {
                console.warn(`initToolbar: Color input element for prop "${inputConfig.prop}" not found.`);
            }
        });

        if (fontWeightButtonEl && !fontWeightButtonEl.hasAttribute('listener-attached')) {
            fontWeightButtonEl.addEventListener('click', () => {
                const activeObject = adminApp.state.fabricCanvasInstance.getActiveObject();
                if (!activeObject || !(activeObject.type === 'textbox' || activeObject.type === 'i-text')) return;
                const newValue = activeObject.fontWeight === 'bold' ? 'normal' : 'bold';
                updateFabricObjectFromToolbar('fontWeight', newValue);
                populateToolbar(activeObject); 
            });
            fontWeightButtonEl.setAttribute('listener-attached', 'true');
        } else if(!fontWeightButtonEl) { console.warn("initToolbar: fontWeightButtonEl not found."); }

        if (fontStyleButtonEl && !fontStyleButtonEl.hasAttribute('listener-attached')) {
            fontStyleButtonEl.addEventListener('click', () => {
                const activeObject = adminApp.state.fabricCanvasInstance.getActiveObject();
                if (!activeObject || !(activeObject.type === 'textbox' || activeObject.type === 'i-text')) return;
                const newValue = activeObject.fontStyle === 'italic' ? 'normal' : 'italic';
                updateFabricObjectFromToolbar('fontStyle', newValue);
                populateToolbar(activeObject); 
            });
            fontStyleButtonEl.setAttribute('listener-attached', 'true');
        } else if(!fontStyleButtonEl) { console.warn("initToolbar: fontStyleButtonEl not found."); }

        if (textAlignGroupEl && !textAlignGroupEl.hasAttribute('listener-attached')) {
            const alignButtons = textAlignGroupEl.querySelectorAll('.toolbar-button[data-align]');
            alignButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const activeObject = adminApp.state.fabricCanvasInstance.getActiveObject();
                    if (!activeObject || !(activeObject.type === 'textbox' || activeObject.type === 'i-text')) return;
                    const alignValue = button.dataset.align;
                    updateFabricObjectFromToolbar('textAlign', alignValue);
                    populateToolbar(activeObject); 
                });
            });
            textAlignGroupEl.setAttribute('listener-attached', 'true');
        } else if(!textAlignGroupEl) { console.warn("initToolbar: textAlignGroupEl not found."); }

        const shadowInputs = [ 
            {el: objShadowColorEl, prop: 'shadow.color', type: 'color'},
            {el: objShadowBlurEl, prop: 'shadow.blur', type: 'range'},
            {el: objShadowOffsetXEl, prop: 'shadow.offsetX', type: 'number'},
            {el: objShadowOffsetYEl, prop: 'shadow.offsetY', type: 'number'},
            {el: objShadowAffectStrokeEl, prop: 'shadow.affectStroke', type: 'checkbox'},
            {el: objShadowNonScalingEl, prop: 'shadow.nonScaling', type: 'checkbox'}
        ];
        shadowInputs.forEach(inputConfig => {
            if (inputConfig.el && !inputConfig.el.hasAttribute('listener-attached')) {
                const eventType = (inputConfig.el.type === 'color' || inputConfig.el.type === 'range') ? 'input' : 'change';
                inputConfig.el.addEventListener(eventType, (e) => {
                    const value = inputConfig.el.type === 'checkbox' ? e.target.checked : e.target.value;
                    updateFabricObjectFromToolbar(inputConfig.prop, value, inputConfig.type);
                });
                inputConfig.el.setAttribute('listener-attached', 'true');
            } else if(!inputConfig.el) { console.warn(`initToolbar: Shadow input element for prop "${inputConfig.prop}" not found.`);}
        });

        const editActionButtons = [
            { el: undoButtonEl, handler: handleUndo, critical: false },
            { el: redoButtonEl, handler: handleRedo, critical: false },
            { el: deleteObjectButtonEl, handler: handleDeleteObject, critical: true }
        ];

        editActionButtons.forEach(config => {
            if (config.el && !config.el.hasAttribute('listener-attached')) {
                config.el.addEventListener('click', config.handler);
                config.el.setAttribute('listener-attached', 'true');
            } else if (!config.el && config.critical) {
                console.warn(`initToolbar: Critical edit action button element not found (e.g., delete).`);
            }
        });
        updateUndoRedoButtonStates(); 

        if (objInteractionTriggerEl && !objInteractionTriggerEl.hasAttribute('listener-attached')) {
            objInteractionTriggerEl.addEventListener('change', handleInteractionChange); objInteractionTriggerEl.setAttribute('listener-attached', 'true');
        } else if(!objInteractionTriggerEl) { console.warn("initToolbar: objInteractionTriggerEl not found.");}
        if (objInteractionActionEl && !objInteractionActionEl.hasAttribute('listener-attached')) {
            objInteractionActionEl.addEventListener('change', handleInteractionChange); objInteractionActionEl.setAttribute('listener-attached', 'true');
        } else if(!objInteractionActionEl) { console.warn("initToolbar: objInteractionActionEl not found.");}
        if (objModalContentEl && !objModalContentEl.hasAttribute('listener-attached')) { 
            objModalContentEl.addEventListener('input', handleInteractionChange); objModalContentEl.setAttribute('listener-attached', 'true');
        } else if(!objModalContentEl) { console.warn("initToolbar: objModalContentEl (popover) not found.");}
        if (objNavigateToEl && !objNavigateToEl.hasAttribute('listener-attached')) { 
            objNavigateToEl.addEventListener('input', handleInteractionChange); objNavigateToEl.setAttribute('listener-attached', 'true');
        } else if(!objNavigateToEl) { console.warn("initToolbar: objNavigateToEl (popover) not found.");}
         if (objPanZoomLevelEl && !objPanZoomLevelEl.hasAttribute('listener-attached')) { 
             objPanZoomLevelEl.addEventListener('input', handleInteractionChange); objPanZoomLevelEl.setAttribute('listener-attached', 'true');
        } else if(!objPanZoomLevelEl) { console.warn("initToolbar: objPanZoomLevelEl (popover) not found.");}

        if (objAnimationTriggerEl && !objAnimationTriggerEl.hasAttribute('listener-attached')) {
            objAnimationTriggerEl.addEventListener('change', handleAnimationChange); objAnimationTriggerEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationTriggerEl) { console.warn("initToolbar: objAnimationTriggerEl not found.");}
        if (objAnimationTypeEl && !objAnimationTypeEl.hasAttribute('listener-attached')) {
            objAnimationTypeEl.addEventListener('change', handleAnimationChange); objAnimationTypeEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationTypeEl) { console.warn("initToolbar: objAnimationTypeEl not found.");}
        if (objAnimationSpeedEl && !objAnimationSpeedEl.hasAttribute('listener-attached')) { 
            objAnimationSpeedEl.addEventListener('change', handleAnimationChange); objAnimationSpeedEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationSpeedEl) { console.warn("initToolbar: objAnimationSpeedEl not found.");}
        if (objAnimationStrengthEl && !objAnimationStrengthEl.hasAttribute('listener-attached')) {
             objAnimationStrengthEl.addEventListener('input', handleAnimationChange); objAnimationStrengthEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationStrengthEl) { console.warn("initToolbar: objAnimationStrengthEl not found.");}
        if (objAnimationLoopEl && !objAnimationLoopEl.hasAttribute('listener-attached')) {
            objAnimationLoopEl.addEventListener('change', handleAnimationChange);
            objAnimationLoopEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationLoopEl) { console.warn("initToolbar: objAnimationLoopEl not found.");}
        
        if (objAnimationLoopCountEl && !objAnimationLoopCountEl.hasAttribute('listener-attached')) {
            objAnimationLoopCountEl.addEventListener('input', handleAnimationChange);
            objAnimationLoopCountEl.setAttribute('listener-attached', 'true');
        }
        if (objAnimationLoopDelayEl && !objAnimationLoopDelayEl.hasAttribute('listener-attached')) {
            objAnimationLoopDelayEl.addEventListener('input', handleAnimationChange);
            objAnimationLoopDelayEl.setAttribute('listener-attached', 'true');
        }
    }
    
    function populateToolbar(activeObject) {
        safeDOMUpdate(overlayPropertiesToolbarEl, el => el.style.display = 'block', "Failed to show overlay properties toolbar in populateToolbar");
        if (!overlayPropertiesToolbarEl) { console.error("populateToolbar: overlayPropertiesToolbarEl not found."); return; }

        const isObjectSelected = !!activeObject;
        const isTextObject = isObjectSelected && (activeObject.type === 'textbox' || activeObject.type === 'i-text');

        safeDOMUpdate(deleteObjectButtonEl, el => el.disabled = !isObjectSelected, "Failed to set deleteObjectButtonEl disabled state in populateToolbar");
        
        if (mediaToolsButtonEl) mediaToolsButtonEl.disabled = false; // These are not selection dependent
        if (addShapeButtonEl) addShapeButtonEl.disabled = false;   // These are not selection dependent

        safeDOMUpdate(textSpecificControlsEl, el => el.style.display = isTextObject ? 'flex' : 'none', "Failed to set textSpecificControlsEl display in populateToolbar");

        const generalObjectControlsAndTriggers = [
            objFillEl, objStrokeColorEl, objStrokeWidthEl, objOpacityEl, 
            positionToolsButtonEl, shadowSettingsButtonEl, interactionSettingsButtonEl, animationSettingsButtonEl 
        ];
        generalObjectControlsAndTriggers.forEach(control => {
            if (control) control.disabled = !isObjectSelected;
        });

        const textPropertyControlsAndTriggers = [
            fontFamilyButtonEl, 
            objFontSizeEl, objLineHeightEl, objCharSpacingEl, objTextContentEl, 
            fontWeightButtonEl, fontStyleButtonEl 
        ];
        if (textAlignGroupEl) { 
            textAlignGroupEl.querySelectorAll('.toolbar-button[data-align]').forEach(btn => textPropertyControlsAndTriggers.push(btn));
        }
        textPropertyControlsAndTriggers.forEach(control => {
            if (control) control.disabled = !isTextObject;
        });

        if (!isObjectSelected) {
            hideActivePopover(); 

            const popoverTriggerButtons = [positionToolsButtonEl, shadowSettingsButtonEl, interactionSettingsButtonEl, animationSettingsButtonEl, fontFamilyButtonEl];
            popoverTriggerButtons.forEach(btn => {
                if (btn) btn.classList.remove('active', 'popover-active');
            });

            if (fontWeightButtonEl) fontWeightButtonEl.classList.remove('active');
            if (fontStyleButtonEl) fontStyleButtonEl.classList.remove('active');
            if (textAlignGroupEl) {
                textAlignGroupEl.querySelectorAll('.toolbar-button[data-align]').forEach(btn => btn.classList.remove('active'));
            }
            
            if (objOpacityEl) objOpacityEl.value = 1; 
            if (objOpacityValueDisplayEl) objOpacityValueDisplayEl.textContent = '100%';

            if (fillColorButtonEl) fillColorButtonEl.classList.remove('active');
            if (strokeColorButtonEl) strokeColorButtonEl.classList.remove('active');
            if (opacityButtonEl) opacityButtonEl.classList.remove('active');

            return; 
        }
        
        if (objXEl) objXEl.value = activeObject.left !== undefined ? activeObject.left.toFixed(0) : 0;
        if (objYEl) objYEl.value = activeObject.top !== undefined ? activeObject.top.toFixed(0) : 0;
        if (objWidthEl) objWidthEl.value = activeObject.getScaledWidth ? activeObject.getScaledWidth().toFixed(0) : (activeObject.width || 0);
        if (objHeightEl) objHeightEl.value = activeObject.getScaledHeight ? activeObject.getScaledHeight().toFixed(0) : (activeObject.height || 0);
        if (objAngleEl) objAngleEl.value = activeObject.angle !== undefined ? activeObject.angle.toFixed(0) : 0;
        
        if (objFillEl) objFillEl.value = toHexColor(activeObject.fill);
        if (objStrokeColorEl) objStrokeColorEl.value = toHexColor(activeObject.stroke);
        if (objStrokeWidthEl) objStrokeWidthEl.value = activeObject.strokeWidth === undefined ? 0 : activeObject.strokeWidth;
        if (objOpacityEl) { 
            objOpacityEl.value = activeObject.opacity === undefined ? 1 : activeObject.opacity; // Input value
            safeDOMUpdate(objOpacityValueDisplayEl, 
              el => el.textContent = Math.round(parseFloat(objOpacityEl.value) * 100) + '%',
              "Failed to update opacity value display in populateToolbar");
        }

        if (isTextObject) { 
            if (objTextContentEl) objTextContentEl.value = activeObject.text || ''; // Input value
            if (objFontFamilyEl) objFontFamilyEl.value = activeObject.fontFamily || 'Arial';  // Input value
            if (objFontSizeEl) objFontSizeEl.value = activeObject.fontSize || 24; // Input value
            if (objLineHeightEl) objLineHeightEl.value = activeObject.lineHeight === undefined ? 1.16 : activeObject.lineHeight; // Input value
            if (objCharSpacingEl) objCharSpacingEl.value = activeObject.charSpacing === undefined ? 0 : activeObject.charSpacing; // Input value

            if (fontWeightButtonEl) fontWeightButtonEl.classList.toggle('active', activeObject.fontWeight === 'bold');
            if (fontStyleButtonEl) fontStyleButtonEl.classList.toggle('active', activeObject.fontStyle === 'italic');
            if (textAlignGroupEl) {
                textAlignGroupEl.querySelectorAll('.toolbar-button[data-align]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.align === activeObject.textAlign);
                });
            }
            if (objFontWeightEl) objFontWeightEl.value = activeObject.fontWeight || 'normal'; // Input value
            if (objFontStyleEl) objFontStyleEl.value = activeObject.fontStyle || 'normal'; // Input value
            if (objTextAlignEl) objTextAlignEl.value = activeObject.textAlign || 'left'; // Input value
        }

        const shadow = activeObject.shadow instanceof fabric.Shadow ? activeObject.shadow : null;
        if (objShadowColorEl) objShadowColorEl.value = shadow ? toHexColor(shadow.color) : '#000000'; // Input value
        if (objShadowBlurEl) objShadowBlurEl.value = shadow ? shadow.blur : 0; // Input value
        if (objShadowOffsetXEl) objShadowOffsetXEl.value = shadow ? shadow.offsetX : 0; // Input value
        if (objShadowOffsetYEl) objShadowOffsetYEl.value = shadow ? shadow.offsetY : 0; // Input value
        if (objShadowAffectStrokeEl) objShadowAffectStrokeEl.checked = shadow ? !!shadow.affectStroke : false; // Input checked
        if (objShadowNonScalingEl) objShadowNonScalingEl.checked = shadow ? !!shadow.nonScaling : false; // Input checked
        if (shadowSettingsButtonEl) shadowSettingsButtonEl.classList.toggle('active', !!shadow);

        if (fillColorButtonEl) {
            const hasFill = activeObject.fill && activeObject.fill !== 'transparent' && 
                            (typeof activeObject.fill !== 'object' || activeObject.fill.type !== 'gradient' || activeObject.fill.colorStops.length > 0);
            fillColorButtonEl.classList.toggle('active', !!hasFill);
        }

        if (strokeColorButtonEl) {
            const hasStroke = activeObject.stroke && activeObject.strokeWidth > 0;
            strokeColorButtonEl.classList.toggle('active', hasStroke);
        }

        if (opacityButtonEl) {
            const isTranslucent = activeObject.opacity !== undefined && activeObject.opacity < 1;
            opacityButtonEl.classList.toggle('active', isTranslucent);
        }

        const interaction = activeObject.customInteraction || { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
        if (objInteractionTriggerEl) objInteractionTriggerEl.value = interaction.trigger || ""; // Input value
        if (objInteractionActionEl) objInteractionActionEl.value = interaction.action || ""; // Input value
        if (objModalContentEl) objModalContentEl.value = interaction.modalContent || ""; // Input value
        if (objNavigateToEl) objNavigateToEl.value = interaction.navigateTo || ""; // Input value
        if (objPanZoomLevelEl) objPanZoomLevelEl.value = interaction.panZoomLevel === undefined ? 1.5 : interaction.panZoomLevel; // Input value
        updateInteractionConfigVisibility(interaction.action);
        if (interactionSettingsButtonEl) interactionSettingsButtonEl.classList.toggle('active', !!(interaction.trigger && interaction.action));

        const animation = activeObject.customAnimation || { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
        if (objAnimationTriggerEl) objAnimationTriggerEl.value = animation.trigger || ""; // Input value
        if (objAnimationTypeEl) objAnimationTypeEl.value = animation.type || ""; // Input value
        const showAnimParams = !!(animation.trigger && animation.type);
        const animParamsConfig = animationPopoverEl ? animationPopoverEl.querySelector('#animationParamsConfig') : null;
        safeDOMUpdate(animParamsConfig, el => el.style.display = showAnimParams ? 'block' : 'none', "Failed to update animation params config display in populateToolbar");
        
        if (showAnimParams) {
            if (objAnimationSpeedEl) objAnimationSpeedEl.value = animation.speed || "normal"; // Input value
            if (objAnimationStrengthEl) objAnimationStrengthEl.value = animation.strength === undefined ? 5 : animation.strength; // Input value
            updateAnimationStrengthUnit(animation.type);
            if (objAnimationLoopEl) objAnimationLoopEl.value = animation.loop ? "true" : "false"; // Input value
        }
        if (animationSettingsButtonEl) animationSettingsButtonEl.classList.toggle('active', showAnimParams);
    }
    function handleInteractionChange() {
        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas) return;
        const activeObject = canvas.getActiveObject();
        if (!activeObject) return;
        if (!activeObject.customInteraction) { activeObject.customInteraction = { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 }; }

        if (objInteractionTriggerEl) activeObject.customInteraction.trigger = objInteractionTriggerEl.value;
        if (objInteractionActionEl) activeObject.customInteraction.action = objInteractionActionEl.value;
        if (objModalContentEl) activeObject.customInteraction.modalContent = objModalContentEl.value;
        if (objNavigateToEl) activeObject.customInteraction.navigateTo = objNavigateToEl.value;
        if (objPanZoomLevelEl) activeObject.customInteraction.panZoomLevel = parseFloat(objPanZoomLevelEl.value) || 1.5;

        updateInteractionConfigVisibility(activeObject.customInteraction.action);
        if (interactionSettingsButtonEl) interactionSettingsButtonEl.classList.toggle('active', !!(activeObject.customInteraction.trigger && activeObject.customInteraction.action));
        console.log("Interaction data updated for object:", activeObject.customInteraction);
        canvas.renderAll(); 
        saveCanvasStateForHistory();
    }

    function updateInteractionConfigVisibility(action) {
        const modalConfig = interactionPopoverEl ? interactionPopoverEl.querySelector('#modalContentConfig') : null;
        const navigateConfig = interactionPopoverEl ? interactionPopoverEl.querySelector('#navigateToConfig') : null;
        const panZoomConfig = interactionPopoverEl ? interactionPopoverEl.querySelector('#panZoomConfigEl') : null;

        const showModal = action === 'showModal';
        const showNavigate = action === 'navigateToSlide' || action === 'navigateToURL';
        const showPanZoomConfig = action === 'panZoomToTarget';

        sharedUtils.safeDOMUpdate(modalConfig, el => el.style.display = showModal ? 'block' : 'none', "Failed to update modal config visibility in updateInteractionConfigVisibility");
        sharedUtils.safeDOMUpdate(navigateConfig, el => el.style.display = showNavigate ? 'block' : 'none', "Failed to update navigate config visibility in updateInteractionConfigVisibility");
        sharedUtils.safeDOMUpdate(panZoomConfig, el => el.style.display = showPanZoomConfig ? 'block' : 'none', "Failed to update pan/zoom config visibility in updateInteractionConfigVisibility");
    }

    function updateAnimationStrengthUnit(animationType) {
        const strengthUnitEl = animationPopoverEl ? animationPopoverEl.querySelector('#objAnimationStrengthUnit') : null;
        if (!strengthUnitEl) return;

        let unitText = "(pixels/degrees/scale)"; 
        switch(animationType) {
            case 'wiggle': unitText = "(degrees)"; break;
            case 'float': unitText = "(pixels)"; break;
            case 'growShrink': unitText = "(scale factor e.g., 1.2)"; break;
        }
        sharedUtils.safeDOMUpdate(strengthUnitEl, el => el.textContent = unitText, "Failed to update animation strength unit text in updateAnimationStrengthUnit");
    }

    function handleAnimationChange() {
        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas) return;
        const activeObject = canvas.getActiveObject();
        if (!activeObject) return;

        if (!activeObject.customAnimation) {
            activeObject.customAnimation = { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
        }

        if (objAnimationTriggerEl) activeObject.customAnimation.trigger = objAnimationTriggerEl.value;
        if (objAnimationTypeEl) activeObject.customAnimation.type = objAnimationTypeEl.value;
        
        const showAnimParams = !!(activeObject.customAnimation.trigger && activeObject.customAnimation.type);
        const animParamsConfig = animationPopoverEl ? animationPopoverEl.querySelector('#animationParamsConfig') : null;
        sharedUtils.safeDOMUpdate(animParamsConfig, el => el.style.display = showAnimParams ? 'block' : 'none', "Failed to update animation params config display on change in handleAnimationChange");

        if (showAnimParams) {
            if (objAnimationSpeedEl) activeObject.customAnimation.speed = objAnimationSpeedEl.value;
            switch(activeObject.customAnimation.speed) {
                case 'slow': activeObject.customAnimation.duration = 1500; break;
                case 'fast': activeObject.customAnimation.duration = 500; break;
                default: activeObject.customAnimation.duration = 1000; 
            }
            
            if (objAnimationStrengthEl) activeObject.customAnimation.strength = parseFloat(objAnimationStrengthEl.value) || 5;
            updateAnimationStrengthUnit(activeObject.customAnimation.type);
            if (objAnimationLoopEl) activeObject.customAnimation.loop = objAnimationLoopEl.value === "true";
            
            delete activeObject.customAnimation.loopCount;
            delete activeObject.customAnimation.loopDelay; 

        } else { 
            activeObject.customAnimation.trigger = "";
            activeObject.customAnimation.type = "";
            activeObject.customAnimation.speed = "normal";
            activeObject.customAnimation.duration = 1000;
            activeObject.customAnimation.strength = 5;
            activeObject.customAnimation.loop = false;
            delete activeObject.customAnimation.loopCount;
            delete activeObject.customAnimation.loopDelay;
            updateAnimationStrengthUnit(""); 
        }
        if (animationSettingsButtonEl) animationSettingsButtonEl.classList.toggle('active', showAnimParams);
        console.log("Animation data updated for object:", activeObject.customAnimation);
        canvas.renderAll();
        saveCanvasStateForHistory();
    }

    function updateFabricObjectFromToolbar(propertyName, value, inputType, isFloat = false) {
      const canvas = adminApp.state.fabricCanvasInstance;
      if (!canvas) return;
      const activeObject = canvas.getActiveObject();
      if (!activeObject) return;

      let parsedValue = value;
      if (inputType === 'number') {
          parsedValue = isFloat ? parseFloat(value) : parseInt(value, 10);
          if (isNaN(parsedValue)) {
              if ((propertyName === 'strokeWidth' || propertyName === 'charSpacing') && value === '') parsedValue = 0;
              else if (value === '') return; 
              else return; 
          }
      } else if (inputType === 'range') { 
          parsedValue = parseFloat(value);
          if (isNaN(parsedValue)) return;
      } else if (inputType === 'checkbox') { 
          parsedValue = !!value; 
      }

      if (propertyName === 'width') { 
          const newWidth = parseFloat(value);
          if (!isNaN(newWidth) && newWidth >= 0) {
            activeObject.scaleX = newWidth > 0 ? (newWidth / activeObject.width) : (activeObject.width > 0 ? 0.0001 / activeObject.width : 0.0001);
          }
      } else if (propertyName === 'height') { 
          const newHeight = parseFloat(value);
           if (!isNaN(newHeight) && newHeight >= 0) {
            activeObject.scaleY = newHeight > 0 ? (newHeight / activeObject.height) : (activeObject.height > 0 ? 0.0001 / activeObject.height : 0.0001);
           }
      } else if (propertyName.startsWith('shadow.')) {
        const shadowPropKey = propertyName.split('.')[1]; 
        let shadowOptions = activeObject.shadow instanceof fabric.Shadow ? activeObject.shadow.toObject() : {};
        
        shadowOptions[shadowPropKey] = parsedValue;

        if (shadowPopoverEl) { 
            const popoverShadowColorEl = shadowPopoverEl.querySelector('#objShadowColor');
            const popoverShadowBlurEl = shadowPopoverEl.querySelector('#objShadowBlur');
            const popoverShadowOffsetXEl = shadowPopoverEl.querySelector('#objShadowOffsetX');
            const popoverShadowOffsetYEl = shadowPopoverEl.querySelector('#objShadowOffsetY');
            const popoverShadowAffectStrokeEl = shadowPopoverEl.querySelector('#objShadowAffectStroke');
            const popoverShadowNonScalingEl = shadowPopoverEl.querySelector('#objShadowNonScaling');

            if (popoverShadowColorEl) shadowOptions.color = popoverShadowColorEl.value || '#000000';
            if (popoverShadowBlurEl) shadowOptions.blur = parseFloat(popoverShadowBlurEl.value) || 0;
            if (popoverShadowOffsetXEl) shadowOptions.offsetX = parseInt(popoverShadowOffsetXEl.value, 10) || 0;
            if (popoverShadowOffsetYEl) shadowOptions.offsetY = parseInt(popoverShadowOffsetYEl.value, 10) || 0;
            if (popoverShadowAffectStrokeEl) shadowOptions.affectStroke = popoverShadowAffectStrokeEl.checked;
            if (popoverShadowNonScalingEl) shadowOptions.nonScaling = popoverShadowNonScalingEl.checked;
        }
        
        if (shadowOptions.blur > 0 || shadowOptions.offsetX !== 0 || shadowOptions.offsetY !== 0 || 
            (shadowOptions.color && shadowOptions.color !== '#000000' && shadowOptions.color.toLowerCase() !== 'rgb(0,0,0)' && shadowOptions.color.toLowerCase() !== 'rgba(0,0,0,0)')) {
            activeObject.set('shadow', new fabric.Shadow(shadowOptions));
        } else {
            activeObject.set('shadow', null); 
        }
        if (shadowSettingsButtonEl) shadowSettingsButtonEl.classList.toggle('active', !!activeObject.shadow);

      } else {
        if (!propertyName.startsWith('customInteraction.') && !propertyName.startsWith('customAnimation.')) {
             activeObject.set(propertyName, parsedValue);
             if (propertyName === 'fontWeight' && objFontWeightEl) objFontWeightEl.value = parsedValue;
             if (propertyName === 'fontStyle' && objFontStyleEl) objFontStyleEl.value = parsedValue;
             if (propertyName === 'textAlign' && objTextAlignEl) objTextAlignEl.value = parsedValue;
        }
      }

      if ((activeObject.type === 'textbox' || activeObject.type === 'i-text') &&
          ['text', 'fontSize', 'fontWeight', 'fontStyle', 'fontFamily', 'lineHeight', 'charSpacing', 'textAlign'].includes(propertyName)) {
          activeObject.initDimensions(); 
      }
      activeObject.setCoords(); 
      canvas.renderAll();
      // Do NOT call populateToolbar here.
      // Call saveCanvasStateForHistory only if it's not a shadow property being actively dragged (range/color)
      // to avoid too many history states. For discrete changes (like number input 'change'), it's fine.
      if (inputType !== 'range' && inputType !== 'color' && !propertyName.startsWith('shadow.')) {
        saveCanvasStateForHistory();
      }
    }

    // --- Utilities ---
    // var Utilities = { 
    //     getUuid: function() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }
    // };

    function handleWindowResize() {
        if (adminApp.state.currentView === 'edit' && adminApp.state.fabricCanvasInstance) {
            console.log("Window resized, attempting to refit canvas.");
            const currentSlide = (adminApp.state.currentSlideIndex !== -1 && adminApp.state.projectData && adminApp.state.projectData.slides) ? 
                                 adminApp.state.projectData.slides[adminApp.state.currentSlideIndex] : 
                                 null;
            adminApp.resizeCanvasToFit(currentSlide);
        }
    }

    // --- New AdminApp Media Handling Callbacks ---
    adminApp.handleMediaPlayerReady = function(event) {
        // event.target is the player instance (from MediaManager)
        console.log("AdminApp: Media Player Ready. Video ID:", mediaManager.state.ytPlayer.getVideoData().video_id);
        updateVideoToolsVisibility(true);
        renderVideoQuestionsList(); // Questions for the current slide
        renderOverlayTimeline();    // Overlays for the current slide
        // If admin wants to autoplay or do other things on ready, it can be done here.
        // For example: mediaManager.state.ytPlayer.playVideo();
    };

    adminApp.handleMediaPlayerStateChange = function(event) {
        console.log("AdminApp: Media Player State Change:", event.data);
        // Admin-specific logic based on player state, if any, beyond what MediaManager handles.
        // For example, if specific UI elements need to change based on PLAYING, PAUSED, ENDED.
        // The core interval for time updates and question/overlay checks is managed by MediaManager.
    };

    adminApp.handleMediaPlayerError = function(eventData) { // eventData is { type: 'youtube', errorData: event.data }
        console.error("AdminApp: Media Player Error:", eventData.errorData);
        baseApp.displayMessage(`YouTube Player Error in Admin: Code ${eventData.errorData}`, false, 'messageArea');
        updateVideoToolsVisibility(false);
    };

    adminApp.handleMediaTimeUpdate = function(currentTime, duration) {
        // Update Admin-specific timeline UI
        if (videoTimelineSliderEl) {
            videoTimelineSliderEl.max = duration;
            videoTimelineSliderEl.value = currentTime;
        }
        safeDOMUpdate(videoCurrentTimeDisplayEl, el => el.textContent = sharedUtils.formatTime(currentTime));
        safeDOMUpdate(videoTotalDurationDisplayEl, el => el.textContent = sharedUtils.formatTime(duration));
    };

    adminApp.handleMediaQuestionTrigger = function(currentTime) {
        const currentSlide = getCurrentSlide();
        if (!currentSlide || !currentSlide.slideMedia || !currentSlide.slideMedia.videoQuestions || currentSlide.slideMedia.videoQuestions.length === 0) {
            return;
        }

        currentSlide.slideMedia.videoQuestions.forEach((question, index) => {
            // Check if question should be triggered (within a small window, not already triggered)
            // The 'triggered' flag management needs to be robust, potentially reset when a video starts over.
            // For now, let's assume 'triggered' is a property on the question object in projectData.
            if (!question.triggered && currentTime >= question.timestamp && currentTime < question.timestamp + 1.5) { // 1.5s window
                console.log(`AdminApp: Triggering question ${index} at ${sharedUtils.formatTime(question.timestamp)} (current: ${sharedUtils.formatTime(currentTime)})`);
                if (mediaManager.state.ytPlayer && typeof mediaManager.state.ytPlayer.pauseVideo === 'function') {
                    mediaManager.state.ytPlayer.pauseVideo();
                }
                question.triggered = true; // Mark as triggered

                safeDOMUpdate(questionTimestampDisplayEl, el => {
                    el.textContent = sharedUtils.formatTime(question.timestamp);
                    if(questionModalEl) questionModalEl.dataset.rawTimestamp = question.timestamp;
                });
                if(questionTextEl) questionTextEl.value = question.questionText;
                optionInputsEl.forEach((input, i) => { if(input) input.value = question.options[i] || ''; });
                correctAnswerRadiosEl.forEach((radio, i) => { if(radio) radio.checked = (i === question.correctOptionIndex && i < question.options.length); });
                if(editingQuestionIndexEl) editingQuestionIndexEl.value = index;

                safeDOMUpdate(questionModalEl, el => el.style.display = 'block');
            }
        });
    };

    adminApp.handleMediaOverlayUpdate = function(currentTime) {
        // This is where Admin's specific overlay preview logic would go, if it depends on media time.
        // This replaces the core logic of the old `updateOverlayPreview`.
        if (!adminApp.state.previewingOverlays || !mediaManager.state.ytPlayer) return;

        const currentSlide = getCurrentSlide();
        if (!currentSlide || !currentSlide.slideMedia || !Array.isArray(currentSlide.slideMedia.videoOverlays)) return;

        const overlays = currentSlide.slideMedia.videoOverlays;
        const activeOverlaysContainer = document.getElementById('adminYouTubePlayerContainer');
        if (!activeOverlaysContainer) return;

        overlays.forEach(overlay => {
            const overlayEl = activeOverlaysContainer.querySelector(`.video-overlay-preview[data-preview-overlay-id="${overlay.id}"]`);
            if (!overlayEl) return;

            const isVisible = currentTime >= overlay.startTime && currentTime < (overlay.startTime + overlay.duration);
            overlayEl.style.display = isVisible ? 'block' : 'none';
        });
    };

    adminApp.handleMediaEnded = function(mediaType) { // mediaType is {type: 'youtube'} or {type: 'audio'}
        console.log(`AdminApp: ${mediaType.type} media ended.`);
        // Admin-specific logic for when media finishes, if any.
    };


    adminApp.attachVideoQuestionEventListeners = function() {
        const safelyAttachListener = (element, eventType, handler, resourceName) => {
            if (element) {
                element.addEventListener(eventType, handler);
                baseApp.resourceManager.trackDisposable(resourceName, () => {
                    element.removeEventListener(eventType, handler);
                });
            } else {
                console.warn(`Could not attach listener for video/overlay - Element for resource ${resourceName} not found.`);
            }
        };

        const handleVideoTimelineSliderInput = function() {
            if (mediaManager.state.ytPlayer && typeof mediaManager.state.ytPlayer.seekTo === 'function') {
                mediaManager.state.ytPlayer.seekTo(this.value, true);
            }
        };
        safelyAttachListener(videoTimelineSliderEl, 'input', handleVideoTimelineSliderInput, 'admin-videoTimelineSlider-input');

        const handleAddQuestionClick = function() {
            if (mediaManager.state.ytPlayer && typeof mediaManager.state.ytPlayer.pauseVideo === 'function') {
                mediaManager.state.ytPlayer.pauseVideo();
            }
            const currentTime = mediaManager.safeGetCurrentTime();
            safeDOMUpdate(questionTimestampDisplayEl, el => {
                el.textContent = sharedUtils.formatTime(currentTime);
                if(questionModalEl) questionModalEl.dataset.rawTimestamp = currentTime;
            }, "Failed to set question timestamp display in handleAddQuestionClick");
            if(questionTextEl) questionTextEl.value = '';
            optionInputsEl.forEach(input => { if(input) input.value = ''; });
            correctAnswerRadiosEl.forEach(radio => { if(radio) radio.checked = false; });
            if(editingQuestionIndexEl) editingQuestionIndexEl.value = '-1';
            safeDOMUpdate(questionModalEl, el => el.style.display = 'block', "Failed to show question modal in handleAddQuestionClick");
        };
        safelyAttachListener(addQuestionBtnEl, 'click', handleAddQuestionClick, 'admin-addQuestionBtn-click');

        const handleSaveQuestionClick = function() {
            const currentSlide = getCurrentSlide();
            if (!currentSlide || !currentSlide.slideMedia || currentSlide.slideMedia.type !== 'youtube') {
                baseApp.displayMessage("Not a YouTube slide or slide data missing.", false, 'messageArea'); return;
            }
            const questionText = questionTextEl ? questionTextEl.value.trim() : '';
            if (!questionText) {
                baseApp.displayMessage("Question text cannot be empty.", false, 'messageArea'); return;
            }
            const options = optionInputsEl.map(input => input ? input.value.trim() : '').filter(opt => opt !== '');
            if (options.length < 2) {
                baseApp.displayMessage("Please provide at least two options.", false, 'messageArea'); return;
            }
            let correctOptionIndex = -1;
            for (let i = 0; i < correctAnswerRadiosEl.length; i++) {
                if (correctAnswerRadiosEl[i] && correctAnswerRadiosEl[i].checked) { correctOptionIndex = i; break; }
            }
            if (correctOptionIndex === -1 || correctOptionIndex >= options.length) {
                baseApp.displayMessage("Please select a correct answer from the provided options.", false, 'messageArea'); return;
            }
            const timestamp = questionModalEl && questionModalEl.dataset.rawTimestamp ? parseFloat(questionModalEl.dataset.rawTimestamp) : 0;
            const questionData = { timestamp, questionText, options, correctOptionIndex };
            const editIndex = editingQuestionIndexEl ? parseInt(editingQuestionIndexEl.value, 10) : -1;
            if (!Array.isArray(currentSlide.slideMedia.videoQuestions)) {
                currentSlide.slideMedia.videoQuestions = [];
            }
            if (editIndex === -1) {
                currentSlide.slideMedia.videoQuestions.push(questionData);
            } else {
                currentSlide.slideMedia.videoQuestions[editIndex] = questionData;
            }
            currentSlide.slideMedia.videoQuestions.sort((a, b) => a.timestamp - b.timestamp);
            baseApp.displayMessage("Question saved!", true, 'messageArea');
            safeDOMUpdate(questionModalEl, el => el.style.display = 'none', "Failed to hide question modal after save in handleSaveQuestionClick");
            renderVideoQuestionsList();
        };
        safelyAttachListener(saveQuestionBtnEl, 'click', handleSaveQuestionClick, 'admin-saveQuestionBtn-click');

        const handleCancelQuestionClick = function() {
            safeDOMUpdate(questionModalEl, el => el.style.display = 'none', "Failed to hide question modal on cancel in handleCancelQuestionClick");
        };
        safelyAttachListener(cancelQuestionBtnEl, 'click', handleCancelQuestionClick, 'admin-cancelQuestionBtn-click');

        // Video Overlay Event Listeners
        const addTimelineOverlayBtn = document.getElementById('addTimelineOverlayBtn');
        safelyAttachListener(addTimelineOverlayBtn, 'click', initiateOverlayPlacement, 'admin-addTimelineOverlayBtn-click');

        const placementOverlay = document.getElementById('overlayPlacementOverlay');
        safelyAttachListener(placementOverlay, 'click', handleOverlayPlacement, 'admin-overlayPlacementOverlay-click');

        const saveOverlayBtn = document.getElementById('saveOverlayBtn');
        safelyAttachListener(saveOverlayBtn, 'click', saveOverlay, 'admin-saveOverlayBtn-click');

        const cancelOverlayBtn = document.getElementById('cancelOverlayBtn');
        safelyAttachListener(cancelOverlayBtn, 'click', hideOverlayEditor, 'admin-cancelOverlayBtn-click');

        const deleteOverlayBtn = document.getElementById('deleteOverlayBtn');
        safelyAttachListener(deleteOverlayBtn, 'click', deleteCurrentOverlay, 'admin-deleteOverlayBtn-click');

        const previewOverlaysBtn = document.getElementById('previewOverlaysBtn');
        safelyAttachListener(previewOverlaysBtn, 'click', toggleOverlayPreview, 'admin-previewOverlaysBtn-click');
    
        console.log("Video question and overlay UI event listeners attached using resourceManager.");
    };

    function updateVideoToolsVisibility(show) {
        safeDOMUpdate(mediaTimelineControlsEl, 
          el => el.style.display = show ? 'block' : 'none', 
          "Failed to update video timeline controls display in updateVideoToolsVisibility");
        if (show && !mediaTimelineControlsEl) { 
            console.warn("updateVideoToolsVisibility: mediaTimelineControlsEl not found.");
        }
        safeDOMUpdate(videoQuestionsListContainerEl, 
          el => el.style.display = show ? 'block' : 'none',
          "Failed to update video questions list container display in updateVideoToolsVisibility");
        if (show && !videoQuestionsListContainerEl) { 
            console.warn("updateVideoToolsVisibility: videoQuestionsListContainerEl not found.");
        }
    }

    function renderVideoQuestionsList() {
        if (!videoQuestionsListEl) {
            console.warn("renderVideoQuestionsList: videoQuestionsListEl not found.");
            return;
        }
        
        safeDOMUpdate(videoQuestionsListEl, el => {
            el.innerHTML = ''; // Clear existing list

            const currentSlide = getCurrentSlide();
            if (!currentSlide || !currentSlide.slideMedia || currentSlide.slideMedia.type !== 'youtube' || !currentSlide.slideMedia.videoQuestions || currentSlide.slideMedia.videoQuestions.length === 0) {
                const li = document.createElement('li');
                li.textContent = "No questions added yet.";
                li.style.fontStyle = "italic";
                el.appendChild(li);
                return;
            }

            const questions = currentSlide.slideMedia.videoQuestions;
            console.log("Rendering questions list:", questions); 

            questions.forEach((question, index) => {
                const li = document.createElement('li');
                li.style.marginBottom = "8px";
                li.style.padding = "5px";
                li.style.border = "1px solid #eee"; 
                li.style.borderRadius = "3px";
                li.style.display = "flex"; 
                li.style.justifyContent = "space-between"; 
                li.style.alignItems = "center"; 

                const questionTextSpan = document.createElement('span'); 
                questionTextSpan.textContent = `[${sharedUtils.formatTime(question.timestamp)}] ${question.questionText.substring(0, 40)}${question.questionText.length > 40 ? '...' : ''}`;
                questionTextSpan.style.flexGrow = "1"; 
                
                const actionsDiv = document.createElement('div');
                actionsDiv.style.whiteSpace = "nowrap"; 

                const editBtn = document.createElement('button');
                editBtn.textContent = 'Edit';
                editBtn.style.marginLeft = '5px'; 
                editBtn.style.padding = '3px 8px';
                editBtn.style.fontSize = '0.8em';
                editBtn.className = 'edit-button'; 
                editBtn.onclick = function() {
                    console.log("Editing question index:", index, questions[index]); 

                    // Use mediaManager.state.ytPlayer
                    if (mediaManager.state.ytPlayer && typeof mediaManager.state.ytPlayer.pauseVideo === 'function') {
                        mediaManager.state.ytPlayer.pauseVideo();
                    }
                    
                    safeDOMUpdate(questionTimestampDisplayEl, tsEl => tsEl.textContent = sharedUtils.formatTime(question.timestamp), "Failed to set question timestamp display on edit in renderVideoQuestionsList");
                    if(questionModalEl) questionModalEl.dataset.rawTimestamp = question.timestamp;
                    if(questionTextEl) questionTextEl.value = question.questionText;

                    optionInputsEl.forEach((input, i) => {
                        if(input) input.value = question.options[i] || '';
                    });
                    correctAnswerRadiosEl.forEach((radio, i) => {
                        if(radio) radio.checked = (i === question.correctOptionIndex && i < question.options.length);
                    });
                    
                    if(editingQuestionIndexEl) editingQuestionIndexEl.value = index;
                    safeDOMUpdate(questionModalEl, modalEl => modalEl.style.display = 'block', "Failed to show question modal on edit in renderVideoQuestionsList");
                };

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.className = 'danger-button'; 
                deleteBtn.style.marginLeft = '5px';
                deleteBtn.style.padding = '3px 8px'; 
                deleteBtn.style.fontSize = '0.8em';
                deleteBtn.onclick = function() {
                    if (confirm(`Are you sure you want to delete the question: "${question.questionText.substring(0,30)}..."?`)) {
                        console.log("Deleting question index:", index); 

                        currentSlide.slideMedia.videoQuestions.splice(index, 1);
                        renderVideoQuestionsList(); 
                        baseApp.displayMessage("Question deleted.", true, 'messageArea');
                    }
                };
                
                actionsDiv.appendChild(editBtn);
                actionsDiv.appendChild(deleteBtn);
                
                li.appendChild(questionTextSpan);
                li.appendChild(actionsDiv);

                el.appendChild(li);
            });
        }, "Failed to render video questions list");
    }

// function setupAdminYouTubePlayer(videoId) { ... } // Removed;
// function checkVideoQuestions() { ... } // Removed;
// function updateVideoTimeline() { ... } // Removed;
// function stopAndDestroyAdminYouTubePlayer() { ... } // Removed

// --- All old commented out YouTube functions are now fully removed ---
</script>
[end of Client/Admin/Admin_JS.html]
