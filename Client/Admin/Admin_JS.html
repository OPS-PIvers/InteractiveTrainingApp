<script>
    // Namespace for the admin application
    window.adminApp = {};

    // --- Constants ---
    const FONT_FAMILIES = ["Arial", "Verdana", "Times New Roman", "Georgia", "Courier New", "Comic Sans MS", "Impact", "Tahoma"];

    // --- Application State ---
    adminApp.state = {
      isLoading: false,
      currentProjectId: null,
      currentView: 'list',
      projectData: null,
      currentSlideIndex: -1,
      fabricCanvasInstance: null,
      defaultCanvasWidth: 960,
      defaultCanvasHeight: 540,
      projectListCache: [], // Added to cache project list for status updates/reverts
      lastUploadedDriveId: null, // Temp store for image uploads before base64 fetch
      lastUploadedMimeType: null,
      lastUploadedFileName: null,
      isPasteListenerActive: false, // To manage listener attachment for pasting images
      activePopoverId: null, // To track the currently open popover
      history: [],
      historyIndex: -1,
      isApplyingHistory: false, // Flag to prevent re-saving state during undo and redo
      adminYouTubePlayer: null, // Reference to the admin's YouTube player instance
      isYouTubeApiReady: false, // Flag for YouTube API readiness
      placingOverlay: null,
      editingOverlayId: null,
      previewingOverlays: false,
      overlayPreviewInterval: null
    };

// ADD after adminApp.state definition:
adminApp.eventListeners = new WeakMap(); // Track event listeners for cleanup
adminApp.activeListeners = []; // Array of {element, event, handler} for global listeners

// --- safeDOMUpdate Helper Function ---
function safeDOMUpdate(element, operation, errorMessage = "DOM operation failed") {
  if (!element) {
    console.warn(`${errorMessage}: Element is null/undefined`);
    return false;
  }
  
  try {
    operation(element);
    return true;
  } catch (e) {
    console.error(`${errorMessage}:`, e);
    return false;
  }
}

// --- Global function for YouTube API ---
function onYouTubeIframeAPIReady() {
  adminApp.state.isYouTubeApiReady = true;
  console.log('Admin YouTube API Ready.');
  
  // Process any deferred setup
  if (adminApp.state.deferredYouTubeSetup) {
    const { videoId, retryCount = 0 } = adminApp.state.deferredYouTubeSetup;
    setTimeout(() => {
      if (isYouTubePlayerAvailable()) {
        setupAdminYouTubePlayer(videoId);
        adminApp.state.deferredYouTubeSetup = null;
      } else if (retryCount < 3) {
        adminApp.state.deferredYouTubeSetup.retryCount = retryCount + 1;
        onYouTubeIframeAPIReady(); // Retry
      } else {
        displayMessage("YouTube player failed to initialize after retries.", false);
        adminApp.state.deferredYouTubeSetup = null;
      }
    }, 100);
  }
}

function isYouTubePlayerAvailable() {
    return adminApp.state.isYouTubeApiReady &&
           typeof YT !== 'undefined' &&
           typeof YT.Player !== 'undefined';
}

// ADD after isYouTubePlayerAvailable function:
function validateYouTubeEnvironment() {
    return adminApp.state.isYouTubeApiReady && 
           typeof YT !== 'undefined' && 
           typeof YT.Player !== 'undefined' &&
           typeof YT.PlayerState !== 'undefined' &&
           adminYouTubePlayerContainerEl && 
           adminYouTubePlayerContainerEl.parentNode;
}

function safeGetCurrentTime(player) {
    if (!player || typeof player.getCurrentTime !== 'function') {
        return 0;
    }
    try {
        return player.getCurrentTime();
    } catch (e) {
        console.warn("Could not get current time from YouTube player:", e);
        return 0;
    }
}
    // --- DOM Element References ---
    let projectTitleInputEl, createProjectButtonEl, messageAreaEl, loadingSpinnerEl;
    let listViewContainerEl, adminProjectListContainerEl;
    let editViewContainerEl, editingProjectTitleEl, backToProjectsListButtonEl, fabricCanvasEl;
    let imageUploaderEl;
    let addSlideButtonEl, slideThumbnailsContainerEl, saveProjectButtonEl;
    let addRectangleButtonEl, addCircleButtonEl;
    let addTextboxButtonEl;

    // Toolbar Elements (existing and new)
    let overlayPropertiesToolbarEl, objXEl, objYEl, objWidthEl, objHeightEl, objAngleEl,
        objFillEl, objStrokeColorEl, objStrokeWidthEl, objOpacityEl,
        textSpecificControlsEl, objTextContentEl, // Text specific row
        objFontFamilyEl, objFontSizeEl, objFontWeightEl, objFontStyleEl, objTextAlignEl, objLineHeightEl, objCharSpacingEl, // Core text inputs (some hidden, some direct)
        objShadowColorEl, objShadowBlurEl, objShadowOffsetXEl, objShadowOffsetYEl, objShadowAffectStrokeEl, objShadowNonScalingEl, // Shadow inputs
        objInteractionTriggerEl, objInteractionActionEl, modalContentConfigEl, objModalContentEl, navigateToConfigEl, objNavigateToEl, panZoomConfigEl, objPanZoomLevelEl, // Interaction inputs
        objAnimationTriggerEl, objAnimationTypeEl, animationParamsConfigEl, objAnimationDurationEl, objAnimationStrengthEl, objAnimationStrengthUnitEl, // Animation inputs
        objAnimationLoopEl, animationLoopCountConfigEl, objAnimationLoopCountEl, objAnimationLoopDelayEl;

    // New Popover and Toolbar Button DOM elements
    let fillColorButtonEl, strokeColorButtonEl, opacityButtonEl, // Direct action buttons for color/opacity that might reveal inputs
        shadowSettingsButtonEl, interactionSettingsButtonEl, animationSettingsButtonEl, fontFamilyButtonEl, // Popover triggers
        shadowPopoverEl, interactionPopoverEl, animationPopoverEl, fontFamilyPopoverEl, // Popover containers
        fillColorPopoverEl, strokeColorPopoverEl, opacityPopoverEl, // NEW POPOVERS for color/opacity
        objOpacityValueDisplayEl, // Span to show opacity percentage
        fontWeightButtonEl, fontStyleButtonEl, textAlignGroupEl; // Text style toggle buttons

    // Step 20 Media Elements
    let youtubeUrlInputEl, setYoutubeBackgroundButtonEl,
        audioUploaderEl, attachedAudioNameEl, removeAudioButtonEl,
        adminMediaPlaceholderEl, adminYouTubePlayerContainerEl; // Added adminYouTubePlayerContainerEl
    
    // New toolbar buttons
    let mediaToolsButtonEl, addShapeButtonEl, positionToolsButtonEl;
    // New popovers
    let mediaToolsPopoverEl, shapesPopoverEl, positionToolsPopoverEl;
    // Media tab elements
    let mediaTabButtonsEl, mediaTabPanesEl;
    // Drag and drop zones
    let imageDropZoneEl, audioDropZoneEl;

    // Video Question/Timeline Elements
    let videoTimelineControlsEl, videoTimelineSliderEl, videoCurrentTimeDisplayEl, videoTotalDurationDisplayEl,
        addQuestionBtnEl, questionModalEl, questionTimestampDisplayEl, questionTextEl,
        saveQuestionBtnEl, cancelQuestionBtnEl, editingQuestionIndexEl,
        videoQuestionsListContainerEl, videoQuestionsListEl; // Added question list elements
    let optionInputsEl = [], correctAnswerRadiosEl = [];

    // Timestamp Overlay Elements (from AdminView.html)
    // let manageTimestampOverlaysButtonEl, timestampOverlayModalEl, makeOverlayInteractiveCheckboxEl,
    //     addTimestampOverlayButtonEl, timestampOverlayListEl, closeTimestampOverlayModalBtnEl,
    //     currentOverlayTimestampInputEl; // These are removed as per plan


    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function() {
      console.log("Admin_JS: DOMContentLoaded event fired!");
      adminApp.setupDOMReferences();
      adminApp.attachEventListeners();
      adminApp.attachVideoQuestionEventListeners(); // This now also includes overlay management button listeners
      switchToListView();
      loadAdminProjectsList();
      console.log("Admin_JS: Initialization complete.");
    });

    // --- Setup and Listeners ---
    adminApp.resizeCanvasToFit = function(slideData) {
        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas || !fabricCanvasEl) {
            console.warn("resizeCanvasToFit: Canvas or fabricCanvasEl not ready.");
            return;
        }

        const fabricCanvasContainer = document.getElementById('fabricCanvasContainer');
        if (!fabricCanvasContainer) {
            console.warn("resizeCanvasToFit: fabricCanvasContainer not found.");
            return;
        }

        const containerWidth = fabricCanvasContainer.clientWidth;
        const containerHeight = fabricCanvasContainer.clientHeight;

        if (containerWidth === 0 || containerHeight === 0) {
            console.log("resizeCanvasToFit: Container has no dimensions, skipping resize.");
            return;
        }
        
        let contentWidth = (slideData && slideData.canvasWidth) ? slideData.canvasWidth : adminApp.state.defaultCanvasWidth;
        let contentHeight = (slideData && slideData.canvasHeight) ? slideData.canvasHeight : adminApp.state.defaultCanvasHeight;

        if (!contentWidth || contentWidth <= 0) contentWidth = adminApp.state.defaultCanvasWidth;
        if (!contentHeight || contentHeight <= 0) contentHeight = adminApp.state.defaultCanvasHeight;

        canvas.setWidth(contentWidth);
        canvas.setHeight(contentHeight);

        fabricCanvasEl.width = contentWidth;
        fabricCanvasEl.height = contentHeight;
        
        const zoomX = containerWidth / contentWidth;
        const zoomY = containerHeight / contentHeight;
        const finalZoom = Math.max(0.01, Math.min(zoomX, zoomY)); 


        canvas.zoomToPoint(new fabric.Point(contentWidth / 2, contentHeight / 2), finalZoom);
        
        console.log(`Resized canvas. Logical: ${contentWidth}x${contentHeight}. Container: ${containerWidth}x${containerHeight}. Zoom: ${finalZoom}`);
    };

    adminApp.setupDOMReferences = function() {
      messageAreaEl = document.getElementById('messageArea');
      loadingSpinnerEl = document.getElementById('loadingSpinner');
      listViewContainerEl = document.getElementById('listViewContainer');
      projectTitleInputEl = document.getElementById('projectTitleInput');
      createProjectButtonEl = document.getElementById('createProjectButton');
      adminProjectListContainerEl = document.getElementById('adminProjectListContainer');
      editViewContainerEl = document.getElementById('editViewContainer');
      editingProjectTitleEl = document.getElementById('editingProjectTitle');
      backToProjectsListButtonEl = document.getElementById('backToProjectsListButton');
      fabricCanvasEl = document.getElementById('fabricCanvasElement');
      imageUploaderEl = document.getElementById('imageUploader');
      addSlideButtonEl = document.getElementById('addSlideButton');
      slideThumbnailsContainerEl = document.getElementById('slideThumbnailsContainer');
      saveProjectButtonEl = document.getElementById('saveProjectButton');

      addRectangleButtonEl = document.getElementById('addRectangleButton');
      addCircleButtonEl = document.getElementById('addCircleButton');
      addTextboxButtonEl = document.getElementById('addTextboxButton');

      overlayPropertiesToolbarEl  = document.getElementById('overlayPropertiesToolbar');

      objXEl = document.getElementById('objX');
      objYEl = document.getElementById('objY');
      objWidthEl = document.getElementById('objWidth');
      objHeightEl = document.getElementById('objHeight');
      objAngleEl = document.getElementById('objAngle');
      objFillEl = document.getElementById('objFill'); 
      objStrokeColorEl = document.getElementById('objStrokeColor'); 
      objStrokeWidthEl = document.getElementById('objStrokeWidth');
      objOpacityEl = document.getElementById('objOpacity'); 

      textSpecificControlsEl = document.getElementById('textSpecificControls');
      objTextContentEl = document.getElementById('objTextContent');
      objFontFamilyEl = document.getElementById('objFontFamily'); 
      objFontSizeEl = document.getElementById('objFontSize');
      objFontWeightEl = document.getElementById('objFontWeight'); 
      objFontStyleEl = document.getElementById('objFontStyle');   
      objTextAlignEl = document.getElementById('objTextAlign');   
      objLineHeightEl = document.getElementById('objLineHeight');
      objCharSpacingEl = document.getElementById('objCharSpacing');

      objShadowColorEl = document.getElementById('objShadowColor');
      objShadowBlurEl = document.getElementById('objShadowBlur');
      objShadowOffsetXEl = document.getElementById('objShadowOffsetX');
      objShadowOffsetYEl = document.getElementById('objShadowOffsetY');
      objShadowAffectStrokeEl = document.getElementById('objShadowAffectStroke');
      objShadowNonScalingEl = document.getElementById('objShadowNonScaling');

      objInteractionTriggerEl = document.getElementById('objInteractionTrigger');
      objInteractionActionEl = document.getElementById('objInteractionAction');
      modalContentConfigEl = document.getElementById('modalContentConfig');
      objModalContentEl = document.getElementById('objModalContent');
      navigateToConfigEl = document.getElementById('navigateToConfig');
      objNavigateToEl = document.getElementById('objNavigateTo');
      panZoomConfigEl = document.getElementById('panZoomConfigEl'); 
      objPanZoomLevelEl = document.getElementById('objPanZoomLevel');

      objAnimationTriggerEl = document.getElementById('objAnimationTrigger');
      objAnimationTypeEl = document.getElementById('objAnimationType');
      animationParamsConfigEl = document.getElementById('animationParamsConfig');
      objAnimationSpeedEl = document.getElementById('objAnimationSpeed'); 
      objAnimationStrengthEl = document.getElementById('objAnimationStrength');
      objAnimationStrengthUnitEl = document.getElementById('objAnimationStrengthUnit');
      objAnimationLoopEl = document.getElementById('objAnimationLoop');
      animationLoopCountConfigEl = document.getElementById('animationLoopCountConfig'); 
      objAnimationLoopCountEl = document.getElementById('objAnimationLoopCount'); 
      objAnimationLoopDelayEl = document.getElementById('objAnimationLoopDelay'); 

      fillColorButtonEl = document.getElementById('fillColorButton');
      strokeColorButtonEl = document.getElementById('strokeColorButton');
      opacityButtonEl = document.getElementById('opacityButton');
      shadowSettingsButtonEl = document.getElementById('shadowSettingsButton');
      interactionSettingsButtonEl = document.getElementById('interactionSettingsButton');
      animationSettingsButtonEl = document.getElementById('animationSettingsButton');
      fontFamilyButtonEl = document.getElementById('fontFamilyButton');

      shadowPopoverEl = document.getElementById('shadowPopover');
      interactionPopoverEl = document.getElementById('interactionPopover');
      animationPopoverEl = document.getElementById('animationPopover');
      fontFamilyPopoverEl = document.getElementById('fontFamilyPopover');
      
      fillColorPopoverEl = document.getElementById('fillColorPopover');
      strokeColorPopoverEl = document.getElementById('strokeColorPopover');
      opacityPopoverEl = document.getElementById('opacityPopover');
      objOpacityValueDisplayEl = document.getElementById('objOpacityValueDisplay');

      fontWeightButtonEl = document.getElementById('fontWeightButton'); 
      fontStyleButtonEl = document.getElementById('fontStyleButton');   
      textAlignGroupEl = document.getElementById('textAlignGroup');     

      undoButtonEl = document.getElementById('undoButton');
      redoButtonEl = document.getElementById('redoButton');
      deleteObjectButtonEl = document.getElementById('deleteObjectButton');

      youtubeUrlInputEl = document.getElementById('youtubeUrlInput');
      setYoutubeBackgroundButtonEl = document.getElementById('setYoutubeBackgroundButton');
      audioUploaderEl = document.getElementById('audioUploader');
      attachedAudioNameEl = document.getElementById('attachedAudioName');
      removeAudioButtonEl = document.getElementById('removeAudioButton');
      adminMediaPlaceholderEl = document.getElementById('adminMediaPlaceholder');
      adminYouTubePlayerContainerEl = document.getElementById('adminYouTubePlayerContainer'); 

      mediaToolsButtonEl = document.getElementById('mediaToolsButton');
      addShapeButtonEl = document.getElementById('addShapeButton'); 
      positionToolsButtonEl = document.getElementById('positionToolsButton');

      mediaToolsPopoverEl = document.getElementById('mediaToolsPopover');
      shapesPopoverEl = document.getElementById('shapesPopover');
      positionToolsPopoverEl = document.getElementById('positionToolsPopover');

      mediaTabButtonsEl = document.querySelectorAll('.media-tab-btn');
      mediaTabPanesEl = document.querySelectorAll('.media-tab-pane');

      imageDropZoneEl = document.getElementById('imageDropZone');
      audioDropZoneEl = document.getElementById('audioDropZone');

      videoTimelineControlsEl = document.getElementById('videoTimelineControls');
      videoTimelineSliderEl = document.getElementById('videoTimelineSlider');
      videoCurrentTimeDisplayEl = document.getElementById('videoCurrentTimeDisplay');
      videoTotalDurationDisplayEl = document.getElementById('videoTotalDurationDisplay');
      addQuestionBtnEl = document.getElementById('addQuestionBtn');
      questionModalEl = document.getElementById('questionModal');
      questionTimestampDisplayEl = document.getElementById('questionTimestampDisplay');
      questionTextEl = document.getElementById('questionText');
      saveQuestionBtnEl = document.getElementById('saveQuestionBtn');
      cancelQuestionBtnEl = document.getElementById('cancelQuestionBtn');
      editingQuestionIndexEl = document.getElementById('editingQuestionIndex');
      videoQuestionsListContainerEl = document.getElementById('videoQuestionsListContainer'); 
      videoQuestionsListEl = document.getElementById('videoQuestionsList'); 
      for (let i = 0; i < 4; i++) {
          optionInputsEl.push(document.getElementById(`option${i+1}`));
          correctAnswerRadiosEl.push(document.getElementById(`correctAnswer${i}`));
      }

      // Timestamp Overlay Elements
      // manageTimestampOverlaysButtonEl = document.getElementById('manageTimestampOverlaysButton'); // Removed
      // timestampOverlayModalEl = document.getElementById('timestampOverlayModal'); // Removed
      // makeOverlayInteractiveCheckboxEl = document.getElementById('makeOverlayInteractiveCheckbox'); // Removed
      // addTimestampOverlayButtonEl = document.getElementById('addTimestampOverlayButton'); // Removed
      // timestampOverlayListEl = document.getElementById('timestampOverlayList'); // Removed
      // closeTimestampOverlayModalBtnEl = document.getElementById('closeTimestampOverlayModalBtn'); // Removed
      // currentOverlayTimestampInputEl = document.getElementById('currentOverlayTimestampInput'); // This is commented out in HTML

      if (!messageAreaEl) console.warn("setupDOMReferences: messageAreaEl not found.");
      if (!loadingSpinnerEl) console.warn("setupDOMReferences: loadingSpinnerEl not found.");
      if (!listViewContainerEl) console.warn("setupDOMReferences: listViewContainerEl not found.");
      if (!editViewContainerEl) console.warn("setupDOMReferences: editViewContainerEl not found.");
      if (!createProjectButtonEl) console.warn("setupDOMReferences: createProjectButtonEl not found.");
      if (!overlayPropertiesToolbarEl) console.warn("setupDOMReferences: overlayPropertiesToolbarEl (new toolbar) not found.");
      if (!shadowPopoverEl || !interactionPopoverEl || !animationPopoverEl || !fontFamilyPopoverEl) {
          console.warn("setupDOMReferences: One or more popover elements not found.");
      }
      // if (!manageTimestampOverlaysButtonEl) console.warn("setupDOMReferences: manageTimestampOverlaysButtonEl not found."); // Removed
      // if (!timestampOverlayModalEl) console.warn("setupDOMReferences: timestampOverlayModalEl not found."); // Removed


      console.log("Admin_JS: DOM references set up.");
    };

    adminApp.attachEventListeners = function() {
      const safelyAddListener = (element, eventType, handler, elementName) => {
          if (element) {
              element.addEventListener(eventType, handler);
          } else {
              if (elementName === 'createProjectButtonEl') console.warn(`Could not attach listener - ${elementName} not found initially.`);
          }
      };
      safelyAddListener(createProjectButtonEl, 'click', handleCreateProject, 'createProjectButtonEl');
      
      window.addEventListener('resize', debounce(handleWindowResize, 250));

      console.log("Admin_JS: Initial event listeners attached.");

      document.addEventListener('click', function(event) {
        if (adminApp.state.activePopoverId && adminApp.state.currentView === 'edit') {
            const popover = document.getElementById(adminApp.state.activePopoverId);
            let triggerButton = null;
            const baseId = adminApp.state.activePopoverId.replace('Popover', ''); 
            const possibleTriggerIds = [
                baseId + 'SettingsButton', 
                baseId + 'Button',         
                baseId + 'ToolsButton'     
            ];

            for (const id of possibleTriggerIds) {
                const btn = document.getElementById(id);
                if (id === 'addShapeButton' && adminApp.state.activePopoverId === 'shapesPopover') {
                    triggerButton = document.getElementById('addShapeButton');
                    if (triggerButton) break;
                }
                if (btn) {
                    triggerButton = btn;
                    break;
                }
            }

            if (popover && !popover.contains(event.target) && (!triggerButton || !triggerButton.contains(event.target))) {
                // Check if the click is inside the timestampOverlayModal, if it's the active "popover" (though it's a modal)
                if (adminApp.state.activePopoverId === 'timestampOverlayModal' && timestampOverlayModalEl && timestampOverlayModalEl.contains(event.target)) {
                    return; // Don't close timestamp overlay modal if click is inside it
                }
                hideActivePopover();
            }
        }
      }, true); 
    };

// ADD new comprehensive cleanup function:
function cleanupAllEventListeners() {
  console.log("Starting comprehensive event listener cleanup");
  
  // 1. Remove paste listener
  if (adminApp.state.isPasteListenerActive) {
    document.removeEventListener('paste', handlePasteImage);
    adminApp.state.isPasteListenerActive = false;
  }
  
  // 2. Remove window resize listener
  window.removeEventListener('resize', handleWindowResize);
  
  // 3. Clean up YouTube player listeners
  if (adminYouTubePlayerContainerEl && adminYouTubePlayerContainerEl.hasAttribute('click-listener-added')) {
    // Get the stored handler from WeakMap if available
    const handler = adminApp.eventListeners.get(adminYouTubePlayerContainerEl);
    if (handler) {
      adminYouTubePlayerContainerEl.removeEventListener('click', handler);
      adminApp.eventListeners.delete(adminYouTubePlayerContainerEl);
    }
    adminYouTubePlayerContainerEl.removeAttribute('click-listener-added');
  }
  
  // 4. Clean up all tracked listeners
  adminApp.activeListeners.forEach(({ element, event, handler }) => {
    if (element && typeof element.removeEventListener === 'function') {
      element.removeEventListener(event, handler);
    }
  });
  adminApp.activeListeners = [];
  
  // 5. Clean up Fabric canvas listeners
  if (adminApp.state.fabricCanvasInstance) {
    adminApp.state.fabricCanvasInstance.off(); // Remove all Fabric listeners
  }
  
  // 6. Clear all intervals
  if (adminApp.state.playerUpdateInterval) {
    clearInterval(adminApp.state.playerUpdateInterval);
    adminApp.state.playerUpdateInterval = null;
  }
  
  console.log("Event listener cleanup completed");
}

    // --- UI View Management ---
    function switchToListView() {
      console.log("Switching to List View");
      
      // Critical: Clean up all event listeners first
      cleanupAllEventListeners();
      
      // Hide any active popovers
      hideActivePopover();
      
      // Stop any playing media
      stopAndDestroyAdminYouTubePlayer();
      
      // Clear modal states
      adminApp.state.editingOverlayId = null;
      adminApp.state.placingOverlay = null;
      
      adminApp.state.currentView = 'list';
      adminApp.state.currentProjectId = null;
      adminApp.state.projectData = null;
      adminApp.state.currentSlideIndex = -1;

      if (adminApp.state.fabricCanvasInstance) {
          adminApp.state.fabricCanvasInstance.dispose();
          adminApp.state.fabricCanvasInstance = null;
          console.log("Admin_JS: Disposed fabric canvas instance.");
      }
      safeDOMUpdate(listViewContainerEl, el => el.style.display = 'block', "Failed to show list view container");
      safeDOMUpdate(editViewContainerEl, el => el.style.display = 'none', "Failed to hide edit view container");
      safeDOMUpdate(messageAreaEl, el => el.innerHTML = '', "Failed to clear message area in switchToListView");
      
      loadAdminProjectsList(); 
    }

    function switchToEditView(projectIdToEdit) {
        console.log("Switching to Edit View for project ID:", projectIdToEdit);
        adminApp.state.currentView = 'edit';
        adminApp.state.currentProjectId = projectIdToEdit;
        adminApp.state.projectData = null; 
        adminApp.state.currentSlideIndex = -1; 
        hideActivePopover(); 

        safeDOMUpdate(listViewContainerEl, el => el.style.display = 'none', "Failed to hide list view container for edit view");
        safeDOMUpdate(editViewContainerEl, el => el.style.display = 'block', "Failed to show edit view container");

        safeDOMUpdate(editingProjectTitleEl, 
          el => el.textContent = `Loading Project (ID: ${projectIdToEdit})...`,
          "Failed to update editing project title on view switch"
        );

        if (adminApp.state.fabricCanvasInstance) {
            adminApp.state.fabricCanvasInstance.dispose();
            adminApp.state.fabricCanvasInstance = null;
        }
        safeDOMUpdate(messageAreaEl, el => el.innerHTML = '', "Failed to clear message area for edit view");
        safeDOMUpdate(slideThumbnailsContainerEl, el => el.innerHTML = '', "Failed to clear slide thumbnails for edit view"); 

        const ensureEditViewListener = (elementVarName, id, eventType, handler, critical = false) => {
            let element = window[elementVarName]; 
            if (!element) {
                element = document.getElementById(id);
                window[elementVarName] = element; 
            }

            const listenerAttribute = `listener-${eventType}-attached`;
            if (element && !element.hasAttribute(listenerAttribute)) {
                element.addEventListener(eventType, handler);
                element.setAttribute(listenerAttribute, 'true');
                console.log(`Listener attached for ${eventType} on #${id} in switchToEditView.`);
            } else if (!element && critical) {
                 console.warn(`CRITICAL WARN: Element #${id} not found in switchToEditView! Cannot attach listener.`);
            }
        };

        fabricCanvasEl = document.getElementById('fabricCanvasElement');
        slideThumbnailsContainerEl = document.getElementById('slideThumbnailsContainer');
        adminMediaPlaceholderEl = document.getElementById('adminMediaPlaceholder');
        overlayPropertiesToolbarEl = document.getElementById('overlayPropertiesToolbar'); 

        ensureEditViewListener('backToProjectsListButtonEl', 'backToProjectsListButton', 'click', switchToListView, true);
        ensureEditViewListener('imageUploaderEl', 'imageUploader', 'change', handleImageUpload, true);
        ensureEditViewListener('addSlideButtonEl', 'addSlideButton', 'click', handleAddSlide, true);
        ensureEditViewListener('saveProjectButtonEl', 'saveProjectButton', 'click', handleSaveProject, true);
        
        ensureEditViewListener('addRectangleButtonEl', 'addRectangleButton', 'click', addRectangle, true);
        ensureEditViewListener('addCircleButtonEl', 'addCircleButton', 'click', addCircle, true);
        ensureEditViewListener('addTextboxButtonEl', 'addTextboxButton', 'click', addTextbox, true);

        ensureEditViewListener('setYoutubeBackgroundButtonEl', 'setYoutubeBackgroundButton', 'click', handleSetYoutubeBackground, true);
        ensureEditViewListener('audioUploaderEl', 'audioUploader', 'change', handleAudioUpload, true);
        ensureEditViewListener('removeAudioButtonEl', 'removeAudioButton', 'click', handleRemoveAudio, true);

        if (typeof fabric !== 'undefined' && fabricCanvasEl) {
            adminApp.state.fabricCanvasInstance = new fabric.Canvas('fabricCanvasElement', {
                width: adminApp.state.defaultCanvasWidth,
                height: adminApp.state.defaultCanvasHeight,
                backgroundColor: '#e9e9e9' 
            });
            fabricCanvasEl.width = adminApp.state.defaultCanvasWidth;
            fabricCanvasEl.height = adminApp.state.defaultCanvasHeight;
            console.log("Admin_JS: Fabric.js canvas initialized with default dimensions.");

            initToolbar(); 
            adminApp.resizeCanvasToFit(null); 
            
            adminApp.state.fabricCanvasInstance.off(); 
            adminApp.state.fabricCanvasInstance.on('object:modified', (e) => {
            if (e.target) {
                populateToolbar(e.target);
                saveCanvasStateForHistory(); // Save state on modification
            }
            });
            adminApp.state.fabricCanvasInstance.on('selection:created', (e) => {
                const activeObject = e.selected && e.selected.length === 1 ? e.selected[0] : null;
                populateToolbar(activeObject);
            });
            adminApp.state.fabricCanvasInstance.on('selection:updated', (e) => {
                const activeObject = e.selected && e.selected.length === 1 ? e.selected[0] : null;
                populateToolbar(activeObject);
            });
            adminApp.state.fabricCanvasInstance.on('selection:cleared', () => {
               populateToolbar(null);
            });
             adminApp.state.fabricCanvasInstance.on('object:added', () => saveCanvasStateForHistory()); // Save on add
             adminApp.state.fabricCanvasInstance.on('object:removed', () => saveCanvasStateForHistory()); // Save on remove


            safeDOMUpdate(overlayPropertiesToolbarEl, el => el.style.display = 'block', "Failed to show overlay properties toolbar in switchToEditView");
            populateToolbar(null); 
            hideActivePopover(); 

            if (!adminApp.state.isPasteListenerActive) {
                document.addEventListener('paste', handlePasteImage);
                adminApp.state.isPasteListenerActive = true;
                console.log("Admin_JS: Paste event listener for images attached to document.");
            }

            loadProjectForEditing(projectIdToEdit); 

        } else {
            console.error("Fabric.js library or canvas element #fabricCanvasElement not found in switchToEditView.");
            displayMessage("Critical error: Editor canvas could not be initialized.", false);
            showLoading(false); 
        }
    }

    // --- Popover Management ---
    function togglePopover(popoverId, triggerButtonEl) {
        if (adminApp.state.activePopoverId === popoverId) {
            hideActivePopover();
        } else {
            hideActivePopover(); 
            
            const popover = document.getElementById(popoverId);
            if (popover && triggerButtonEl) {
                safeDOMUpdate(popover, el => {
                    el.style.display = 'block';
                    el.style.position = 'absolute';
                    el.style.top = 'auto';
                    el.style.left = 'auto';

                    const btnRect = triggerButtonEl.getBoundingClientRect();
                    const popoverRect = el.getBoundingClientRect(); // Use el here
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    
                    let posTop = btnRect.bottom + 5;
                    let posLeft = btnRect.left;
                    
                    if (posLeft + popoverRect.width > viewportWidth) {
                        posLeft = Math.max(5, viewportWidth - popoverRect.width - 5); 
                    }
                    if (posLeft < 0) posLeft = 5; 

                    if (posTop + popoverRect.height > viewportHeight && btnRect.top - popoverRect.height - 5 > 0) { 
                        posTop = btnRect.top - popoverRect.height - 5;
                    } else if (posTop + popoverRect.height > viewportHeight) { 
                         posTop = Math.max(5, viewportHeight - popoverRect.height - 5);
                    }
                    if (posTop < 0) posTop = 5; 
                    
                    el.style.top = posTop + 'px';
                    el.style.left = posLeft + 'px';
                }, `Failed to display or position popover ${popoverId}`);
                
                adminApp.state.activePopoverId = popoverId;
                
                document.querySelectorAll('.toolbar-button').forEach(btn => {
                    btn.classList.remove('popover-active');
                });
                triggerButtonEl.classList.add('popover-active');

                if (popoverId === 'mediaToolsPopover') {
                   const activeTab = popover.querySelector('.media-tab-btn.active');
                   if (!activeTab) {
                       switchMediaTab('image-tab'); 
                   }
                   if (popover.querySelector('.media-tab-btn[data-tab="audio-tab"].active')) {
                       const currentSlide = getCurrentSlide();
                       const hasAudio = currentSlide && currentSlide.slideMedia && 
                                       currentSlide.slideMedia.type === 'audio' && 
                                       currentSlide.slideMedia.driveFileId;
                       const audioControlsEl = document.getElementById('audioControls');
                       safeDOMUpdate(audioControlsEl, audioEl => { // Changed el to audioEl for clarity
                           audioEl.style.display = hasAudio ? 'block' : 'none';
                           if (hasAudio) {
                               safeDOMUpdate(attachedAudioNameEl, 
                                 nameEl => nameEl.textContent = `Attached: ${currentSlide.slideMedia.originalName || 'Audio File'}`, // Changed el to nameEl
                                 "Failed to update attached audio name in popover");
                           }
                       }, "Failed to update audio controls display in popover");
                   }
                }
            } else {
                console.warn("togglePopover: Popover or trigger button not found for ID:", popoverId);
            }
        }
    }

    function hideActivePopover() {
        if (adminApp.state.activePopoverId) {
            const popover = document.getElementById(adminApp.state.activePopoverId);
            safeDOMUpdate(popover, el => el.style.display = 'none', "Failed to hide active popover in hideActivePopover");
            
            document.querySelectorAll('.toolbar-button.popover-active').forEach(btn => {
                btn.classList.remove('popover-active');
            });
            adminApp.state.activePopoverId = null;
        }
    }


    function switchMediaTab(tabId) {
        document.querySelectorAll('.media-tab-pane').forEach(pane => {
            pane.classList.remove('active');
        });
        document.querySelectorAll('.media-tab-btn').forEach(tab => {
            tab.classList.remove('active');
        });
        const tabPane = document.getElementById(tabId);
        if (tabPane) tabPane.classList.add('active');
        const activeTabBtn = document.querySelector(`.media-tab-btn[data-tab="${tabId}"]`);
        if (activeTabBtn) activeTabBtn.classList.add('active');
        
        if (tabId === 'audio-tab') {
            const currentSlide = getCurrentSlide();
            const hasAudio = currentSlide && currentSlide.slideMedia && 
                            currentSlide.slideMedia.type === 'audio' && 
                            currentSlide.slideMedia.driveFileId;
            const audioControlsEl = document.getElementById('audioControls');
            safeDOMUpdate(audioControlsEl, el => {
                el.style.display = hasAudio ? 'block' : 'none';
                if (hasAudio) {
                    safeDOMUpdate(attachedAudioNameEl, 
                      nameEl => nameEl.textContent = `Attached: ${currentSlide.slideMedia.originalName || 'Audio File'}`,
                      "Failed to update attached audio name in media tab (switchMediaTab)");
                }
            }, "Failed to update audio controls display in media tab (switchMediaTab)");
        }
    }

    function getCurrentSlide() {
        if (adminApp.state.currentSlideIndex === -1 || !adminApp.state.projectData || 
            !adminApp.state.projectData.slides || 
            !adminApp.state.projectData.slides[adminApp.state.currentSlideIndex]) {
            return null;
        }
        return adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
    }

    // --- Project Loading/Saving ---
    function loadProjectForEditing(projectId) {
      console.log(`loadProjectForEditing: Called for projectId: ${projectId}`);
      if (!projectId) { console.error("loadProjectForEditing: No projectId."); displayMessage("Error: Cannot load project.", false); return; }
      showLoading(true);
      displayMessage("Loading project data...", true);
      google.script.run
          .withSuccessHandler(onProjectDataLoaded)
          .withFailureHandler(onServerError)
          .getProjectDataForEditing(projectId);
    }

    function onProjectDataLoaded(jsonString) {
      console.log("onProjectDataLoaded: Received data:", jsonString);

      if (jsonString && typeof jsonString === 'object' && jsonString.error) {
          showLoading(false);
          console.error(`onProjectDataLoaded: Received error object from server: ${jsonString.error}`);
          displayMessage(`Error: Could not load project data. Server said: ${jsonString.error}`, false);
          adminApp.state.projectData = { projectId: adminApp.state.currentProjectId, title: "Error Loading", slides: [] };
          adminApp.state.currentSlideIndex = -1;
          safeDOMUpdate(editingProjectTitleEl, 
            el => el.textContent = `Error Loading Project (ID: ${adminApp.state.currentProjectId})`,
            "Failed to update editing project title on server error in onProjectDataLoaded");
          updateSlideThumbnailsUI();
          return;
      }

      if (jsonString === null || jsonString === undefined) {
          showLoading(false);
          console.error("onProjectDataLoaded: Received null or undefined data from server (Project or data file likely not found).");
          displayMessage("Error: Could not load project data. Project or its data file may not exist or the data is empty.", false);
          adminApp.state.projectData = { projectId: adminApp.state.currentProjectId, title: "Error Loading", slides: [] };
          adminApp.state.currentSlideIndex = -1;
          safeDOMUpdate(editingProjectTitleEl, 
            el => el.textContent = `Error Loading Project (ID: ${adminApp.state.currentProjectId})`,
            "Failed to update editing project title on null data in onProjectDataLoaded");
          updateSlideThumbnailsUI();
          return;
      }
      
      try {
          if (typeof jsonString !== 'string') {
            throw new Error("Received data is not a JSON string or a recognized error object.");
          }
          const loadedData = JSON.parse(jsonString);
          console.log("Parsed project data:", loadedData);

          if (!loadedData || typeof loadedData !== 'object') throw new Error("Parsed data is not a valid object.");
          if (!loadedData.projectId) throw new Error("Loaded project data is missing 'projectId'.");

          if (!Array.isArray(loadedData.slides)) {
               console.warn("Loaded data missing 'slides' array or it's invalid, defaulting to empty.");
               loadedData.slides = [];
          }

          loadedData.slides.forEach(slide => {
              if (!slide.slideMedia) {
                  slide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
              }
              // Ensure videoOverlays array exists for slideMedia
              if (slide.slideMedia && !Array.isArray(slide.slideMedia.videoOverlays)) {
                  slide.slideMedia.videoOverlays = [];
              }
              if (!slide.fabricCanvasJSON || !slide.fabricCanvasJSON.objects) {
              } else {
                slide.fabricCanvasJSON.objects.forEach(obj => {
                    if (!obj.customInteraction) {
                        obj.customInteraction = { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
                    }
                    if (!obj.customAnimation) {
                        obj.customAnimation = { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
                    }
                });
              }
          });

          adminApp.state.projectData = loadedData;

          safeDOMUpdate(editingProjectTitleEl, 
            el => el.textContent = `Editing Project: ${adminApp.state.projectData.title || '(Untitled)'}`,
            "Failed to update editing project title after data load in onProjectDataLoaded");

          updateSlideThumbnailsUI();

          if (adminApp.state.projectData.slides.length > 0) {
              selectSlide(0); 
              displayMessage("Project loaded successfully.", true);
          } else {
              displayMessage("Project loaded, but it has no slides. Adding one.", true);
              handleAddSlide(); 
          }
          showLoading(false); 

      } catch (e) {
          showLoading(false);
          console.error("onProjectDataLoaded: Error parsing JSON data or invalid structure:", e);
          console.error("Received JSON string that failed parsing:", jsonString);
          displayMessage(`Error: Failed to parse loaded project data. ${e.message}`, false);
          adminApp.state.projectData = { projectId: adminApp.state.currentProjectId, title: "Invalid Data", slides: [] };
          adminApp.state.currentSlideIndex = -1;
          safeDOMUpdate(editingProjectTitleEl, 
            el => el.textContent = `Invalid Project Data (ID: ${adminApp.state.currentProjectId})`,
            "Failed to update editing project title on parse error in onProjectDataLoaded");
          updateSlideThumbnailsUI(); 
      }
    }

    function saveCurrentSlideState() {
        if (adminApp.state.currentSlideIndex === -1 || !adminApp.state.fabricCanvasInstance || !adminApp.state.projectData || !adminApp.state.projectData.slides[adminApp.state.currentSlideIndex]) {
            console.log("saveCurrentSlideState: Skipping, no active slide/canvas/data.");
            return;
        }
        try {
          const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
          const canvas = adminApp.state.fabricCanvasInstance;
          canvas.getObjects().forEach(obj => {
              if (!obj.customInteraction) {
                  obj.customInteraction = { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
              }
              if (!obj.customAnimation) {
                  obj.customAnimation = { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
              }
          });

          const propsToInclude = ['slideId', 'canvasWidth', 'canvasHeight', 'customInteraction', 'customAnimation', 'sequenceOrder'];
          currentSlide.fabricCanvasJSON = canvas.toJSON(propsToInclude);
          currentSlide.canvasWidth = canvas.getWidth();
          currentSlide.canvasHeight = canvas.getHeight();
          if (!currentSlide.slideMedia) {
               currentSlide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
          }
          if(currentSlide.slideMedia.type !== 'image' && currentSlide.slideMedia.url && currentSlide.slideMedia.url.startsWith('data:image')) {
              currentSlide.slideMedia.url = null;
          }


          console.log(`Slide ${adminApp.state.currentSlideIndex + 1} state saved. Media:`, JSON.stringify(currentSlide.slideMedia));
        } catch(e) {
            console.error(`Error saving slide state for index ${adminApp.state.currentSlideIndex}:`, e);
            displayMessage(`Error saving current slide state: ${e.message}`, false);
        }
    }

    function handleSaveProject() {
        if (!adminApp.state.projectData || !adminApp.state.currentProjectId) { displayMessage("No project data to save.", false); return; }
        if (adminApp.state.isLoading) { console.log("handleSaveProject: Already saving."); return; }

        saveCurrentSlideState(); 

        showLoading(true); displayMessage("Saving project...", true);
        try {
            const projectDataToSave = JSON.parse(JSON.stringify(adminApp.state.projectData));

             projectDataToSave.slides.forEach(slide => {
                 if (slide.slideMedia && slide.slideMedia.type !== 'image' && 
                     slide.slideMedia.url && slide.slideMedia.url.startsWith('data:image')) {
                     slide.slideMedia.url = null; 
                 }
             });

            const jsonDataString = JSON.stringify(projectDataToSave);
            console.log("Saving projectData string length:", jsonDataString.length);

            google.script.run
                .withSuccessHandler(onProjectSaved)
                .withFailureHandler(onServerError)
                .saveProjectData(adminApp.state.currentProjectId, jsonDataString);
        } catch (e) {
             showLoading(false);
             console.error("Error stringifying project data for saving:", e);
             displayMessage("Error preparing data for saving.", false);
        }
    }

    function saveCanvasStateForHistory() {
        if (!adminApp.state.fabricCanvasInstance || adminApp.state.isApplyingHistory) {
            return;
        }
        const canvas = adminApp.state.fabricCanvasInstance;

        const propsToInclude = ['slideId', 'canvasWidth', 'canvasHeight', 'customInteraction', 'customAnimation', 'sequenceOrder']; 
        const currentState = canvas.toJSON(propsToInclude);

        if (adminApp.state.historyIndex < adminApp.state.history.length - 1) {
            adminApp.state.history = adminApp.state.history.slice(0, adminApp.state.historyIndex + 1);
        }

        adminApp.state.history.push(currentState);
        adminApp.state.historyIndex = adminApp.state.history.length - 1;

        const maxHistorySize = 20;
        if (adminApp.state.history.length > maxHistorySize) {
            adminApp.state.history.shift(); 
            adminApp.state.historyIndex--;
        }
        console.log("Canvas state saved to history. Index:", adminApp.state.historyIndex, "Total states:", adminApp.state.history.length);
        updateUndoRedoButtonStates();
    }

    function updateUndoRedoButtonStates() {
        if (undoButtonEl) undoButtonEl.disabled = adminApp.state.historyIndex <= 0;
        if (redoButtonEl) redoButtonEl.disabled = adminApp.state.historyIndex >= adminApp.state.history.length - 1;
    }

    function onProjectSaved(response) {
        showLoading(false);
        if (response && response.success) {
            showNotification(response.message || "Project saved successfully!", "success");
        } else {
            onServerError((response && response.error) ? response.error : "Failed to save.");
        }
    }

    // --- Slide Management ---
    function handleAddSlide() {
        console.log("handleAddSlide called");
        if (!adminApp.state.projectData) { console.error("handleAddSlide: projectData not initialized."); return; }
        saveCurrentSlideState(); 
        const newSlideId = 'slide_' + Utilities.getUuid();
        const newSlide = {
            slideId: newSlideId,
            canvasWidth: adminApp.state.defaultCanvasWidth,
            canvasHeight: adminApp.state.defaultCanvasHeight,
            fabricCanvasJSON: null, 
            slideMedia: { type: null, url: null, driveFileId: null, mimeType: null, originalName: null, videoQuestions: [], videoOverlays: [] }
        };
        if (!adminApp.state.projectData.slides) adminApp.state.projectData.slides = [];
        adminApp.state.projectData.slides.push(newSlide);
        const newSlideIndex = adminApp.state.projectData.slides.length - 1;
        selectSlide(newSlideIndex); 
        console.log("Added new slide. Total slides:", adminApp.state.projectData.slides.length);
    }

    function selectSlide(slideIndex) {
        if (!adminApp.state.projectData || !adminApp.state.projectData.slides || slideIndex < 0 || slideIndex >= adminApp.state.projectData.slides.length) { 
            console.error("selectSlide: Invalid index or slides array missing.", slideIndex); 
            return; 
        }
        console.log(`Selecting slide ${slideIndex + 1}`);

        if (adminApp.state.currentSlideIndex !== -1 && adminApp.state.currentSlideIndex < adminApp.state.projectData.slides.length) {
            saveCurrentSlideState();
        }

        adminApp.state.currentSlideIndex = slideIndex;
        const selectedSlideData = adminApp.state.projectData.slides[slideIndex];
        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas) { 
            console.error("selectSlide: Canvas not ready!"); 
            return; 
        }

        if (!selectedSlideData.slideMedia) {
            selectedSlideData.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null, videoQuestions: [] };
        } else if (selectedSlideData.slideMedia.type === 'youtube' && !Array.isArray(selectedSlideData.slideMedia.videoQuestions)) {
            selectedSlideData.slideMedia.videoQuestions = [];
        }
        // Add this:
        if (selectedSlideData.slideMedia && selectedSlideData.slideMedia.type === 'youtube' && !Array.isArray(selectedSlideData.slideMedia.videoOverlays)) {
          selectedSlideData.slideMedia.videoOverlays = [];
        }


        // In selectSlide() function, before setting up YouTube
        if (adminApp.state.adminYouTubePlayer) {
            stopAndDestroyAdminYouTubePlayer();
        }
        safeDOMUpdate(adminYouTubePlayerContainerEl, el => {
            el.style.display = 'none';
            el.innerHTML = ''; 
        }, "Failed to reset YouTube player container in selectSlide");
        
        safeDOMUpdate(fabricCanvasEl, el => el.style.opacity = '1', "Failed to set canvas opacity in selectSlide");

        canvas.clear(); 
        canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas)); 
        canvas.backgroundColor = '#e9e9e9'; 

        adminApp.resizeCanvasToFit(selectedSlideData);

        if (imageUploaderEl) imageUploaderEl.value = null;
        if (youtubeUrlInputEl) youtubeUrlInputEl.value = '';
        if (audioUploaderEl) audioUploaderEl.value = null;
        
        safeDOMUpdate(attachedAudioNameEl, el => el.textContent = '', "Failed to clear attached audio name in selectSlide");
        const audioControls = document.getElementById('audioControls');
        safeDOMUpdate(audioControls, el => el.style.display = 'none', "Failed to hide audio controls in selectSlide");
        safeDOMUpdate(removeAudioButtonEl, el => el.style.display = 'none', "Failed to hide remove audio button in selectSlide");
        safeDOMUpdate(adminMediaPlaceholderEl, el => el.style.display = 'none', "Failed to hide admin media placeholder in selectSlide");

        const media = selectedSlideData.slideMedia;
        updateVideoToolsVisibility(false);

        if (media && media.type === 'image' && media.driveFileId) {
            safeDOMUpdate(adminMediaPlaceholderEl, el => el.style.display = 'none', "Failed to hide admin media placeholder for image bg in selectSlide");
            console.log(`Background needs fetch from Drive ID for slide ${slideIndex + 1}:`, media.driveFileId);
            showLoading(true); 
            displayMessage("Loading slide background...", true);
            
            google.script.run.withSuccessHandler(function(response) {
                showLoading(false);
                if (adminApp.state.currentSlideIndex !== slideIndex) { 
                    console.log("Slide changed before background could be fetched for index", slideIndex); 
                    return; 
                }
                if (response && response.success && response.base64Data) {
                    fabric.Image.fromURL(response.base64Data, function(img) {
                        if (!adminApp.state.fabricCanvasInstance) return;
                        adminApp.state.fabricCanvasInstance.setBackgroundImage(img, canvas.renderAll.bind(canvas), { 
                            scaleX: canvas.width / img.width, 
                            scaleY: canvas.height / img.height 
                        });
                        console.log("Background fetched and loaded for slide", slideIndex);
                    }, { crossOrigin: 'anonymous' });
                } else { 
                    console.error("Failed to fetch background", response); 
                    displayMessage("Error loading slide background image.", false); 
                    canvas.backgroundColor = '#e9e9e9'; 
                    canvas.renderAll(); 
                }
            }).withFailureHandler(onServerError).getImageAsBase64(media.driveFileId);
            
        } else if (media && media.type === 'image' && !media.driveFileId) {
            console.warn("Image media type set but no driveFileId:", media); 
            canvas.backgroundColor = '#e9e9e9';
            canvas.renderAll(); 
            
        } else if (media && media.type === 'youtube' && media.url) {
            console.log("Attempting to load YouTube player for URL:", media.url);
            safeDOMUpdate(adminMediaPlaceholderEl, el => el.style.display = 'none', "Failed to hide admin media placeholder for YouTube bg in selectSlide");
            if (youtubeUrlInputEl) youtubeUrlInputEl.value = media.url;
            
            safeDOMUpdate(fabricCanvasEl, el => el.style.opacity = '1', "Failed to set canvas opacity for YouTube bg in selectSlide");
            canvas.backgroundColor = 'rgba(0,0,0,0)'; 

            const videoId = extractYouTubeVideoId(media.url);
            if (videoId && adminYouTubePlayerContainerEl) {
                if (validateYouTubeEnvironment()) { 
                    safeDOMUpdate(adminYouTubePlayerContainerEl, el => el.style.display = 'block', "Failed to show YouTube player container in selectSlide");
                    setupAdminYouTubePlayer(videoId); 
                } else {
                    console.warn("YouTube API not ready or environment invalid. Deferring setup for videoId:", videoId);
                    adminApp.state.deferredYouTubeSetup = { videoId, retryCount: 0 };
                    safeDOMUpdate(adminMediaPlaceholderEl, el => {
                        el.textContent = "YouTube player is loading...";
                        el.style.display = 'block';
                    }, "Failed to show YouTube loading placeholder in selectSlide");
                    if (adminApp.state.isYouTubeApiReady) {
                         onYouTubeIframeAPIReady();
                    }
                }
            } else {
                console.error("Invalid YouTube setup: Video ID could not be extracted or player container missing.", { videoId, container: !!adminYouTubePlayerContainerEl, url: media.url });
                updateVideoToolsVisibility(false);
                safeDOMUpdate(adminMediaPlaceholderEl, el => {
                    el.textContent = `Error: Could not load YouTube video. Check URL or player setup. URL: ${media.url}`;
                    el.style.display = 'block';
                }, "Failed to show YouTube error placeholder in selectSlide");
                safeDOMUpdate(fabricCanvasEl, el => el.style.opacity = '1', "Failed to set canvas opacity on YouTube error in selectSlide");
                canvas.backgroundColor = '#444';
            }
            canvas.renderAll();
            
        } else if (media && media.type === 'audio' && (media.driveFileId)) {
            safeDOMUpdate(adminMediaPlaceholderEl, el => el.style.display = 'block', "Failed to show admin media placeholder for audio in selectSlide"); 
            console.log("Indicating attached audio:", media.originalName || media.driveFileId);
            safeDOMUpdate(attachedAudioNameEl, el => {
                el.textContent = `Attached: ${media.originalName || 'Audio File'}`;
                const currentAudioControls = document.getElementById('audioControls'); // Re-fetch or ensure it's in scope
                safeDOMUpdate(currentAudioControls, audioEl => audioEl.style.display = 'block', "Failed to show audio controls for audio in selectSlide");
            }, "Failed to update attached audio name for audio in selectSlide");
            safeDOMUpdate(removeAudioButtonEl, el => el.style.display = 'inline-block', "Failed to show remove audio button for audio in selectSlide");
            
            safeDOMUpdate(adminMediaPlaceholderEl, el => {
                el.textContent = `Audio Attached: ${media.originalName || 'Audio File'}`;
                el.style.display = 'block';
            }, "Failed to update admin media placeholder for audio in selectSlide");
            canvas.backgroundColor = '#e9e9e9'; 
            canvas.renderAll();
            
        } else {
            console.log("No background media found or configured for slide", slideIndex);
            safeDOMUpdate(adminMediaPlaceholderEl, el => el.style.display = 'none', "Failed to hide admin media placeholder for no media in selectSlide");
            canvas.backgroundColor = '#e9e9e9'; 
            canvas.renderAll();
        }

        if (selectedSlideData.fabricCanvasJSON) {
        console.log("Loading fabricCanvasJSON for slide", slideIndex);
        canvas.loadFromJSON(selectedSlideData.fabricCanvasJSON, function() {
            if (!adminApp.state.fabricCanvasInstance || adminApp.state.currentSlideIndex !== slideIndex) return;
            
            adminApp.state.fabricCanvasInstance.getObjects().forEach(obj => {
                if (!obj.customInteraction) {
                    obj.customInteraction = { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
                }
                if (!obj.customAnimation) {
                    obj.customAnimation = { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
                }
            });

            adminApp.state.fabricCanvasInstance.renderAll();
            console.log("Finished loading canvas JSON for slide", slideIndex);
            const activeObj = adminApp.state.fabricCanvasInstance.getActiveObject();
            populateToolbar(activeObj); 
            }, function(o, object) { 
            });
        } else {
            console.log("No fabricCanvasJSON to load for slide", slideIndex);
            canvas.renderAll(); 
            populateToolbar(null); 
        }
        updateSlideThumbnailsUI();
        adminApp.state.history = [];
        adminApp.state.historyIndex = -1;
        setTimeout(() => {
            saveCanvasStateForHistory();
            updateUndoRedoButtonStates();
        }, 100); 
    }

    function updateSlideThumbnailsUI() {
        if (!adminApp.state.projectData) { 
            console.warn("updateSlideThumbnailsUI: Project data missing."); 
            // Ensure the container is cleared if there's no project data or no slides.
            safeDOMUpdate(slideThumbnailsContainerEl, el => el.innerHTML = '<p>No slides available.</p>', "Failed to clear slide thumbnails container on no project data");
            return; 
        }
        
        safeDOMUpdate(slideThumbnailsContainerEl, el => {
            el.innerHTML = ''; // Clear existing thumbnails
            if (!adminApp.state.projectData.slides || adminApp.state.projectData.slides.length === 0) {
                el.innerHTML = '<p>No slides. Click "Add Slide" to begin.</p>'; // Message when no slides exist
                return;
            }
            adminApp.state.projectData.slides.forEach((slide, index) => {
                const thumb = document.createElement('div'); thumb.className = 'slide-thumbnail';
                thumb.textContent = `Slide ${index + 1}`; thumb.title = `Select Slide ${index + 1}`;
                if (index === adminApp.state.currentSlideIndex) thumb.classList.add('active-slide');
                thumb.onclick = function() { selectSlide(index); };
                const deleteBtn = document.createElement('button'); deleteBtn.className = 'delete-slide-btn'; deleteBtn.innerHTML = ''; deleteBtn.title = "Delete slide";
                deleteBtn.onclick = function(event) { event.stopPropagation(); handleDeleteSlide(index); };
                thumb.appendChild(deleteBtn); 
                el.appendChild(thumb);
            });
        }, "Failed to update slide thumbnails UI");
    }

    function handleDeleteSlide(slideIndex) {
        if (!adminApp.state.projectData || !adminApp.state.projectData.slides || slideIndex < 0 || slideIndex >= adminApp.state.projectData.slides.length) { console.error("handleDeleteSlide: Invalid index."); return; }
        if (adminApp.state.projectData.slides.length <= 1) { displayMessage("Cannot delete the last slide.", false); return; }
        if (!confirm(`Are you sure you want to delete Slide ${slideIndex + 1}?`)) return;
        
        const wasCurrentSlide = adminApp.state.currentSlideIndex === slideIndex;
        adminApp.state.projectData.slides.splice(slideIndex, 1);
        console.log("Deleted slide at index:", slideIndex);

        if (wasCurrentSlide) {
            adminApp.state.currentSlideIndex = -1; 
            const newIndexToSelect = Math.max(0, Math.min(slideIndex, adminApp.state.projectData.slides.length - 1));
             if (adminApp.state.projectData.slides.length > 0) {
                selectSlide(newIndexToSelect);
            } else {
                if(adminApp.state.fabricCanvasInstance) adminApp.state.fabricCanvasInstance.clear();
                updateSlideThumbnailsUI();
                populateToolbar(null);
            }
        } else if (adminApp.state.currentSlideIndex > slideIndex) {
            adminApp.state.currentSlideIndex--; 
            updateSlideThumbnailsUI(); 
        } else {
             updateSlideThumbnailsUI(); 
        }
    }

    // --- Project Management (Status/Delete) ---
    function handleProjectStatusChange(projectId, newStatus, selectElement) {
        console.log(`Attempting to update status for project ${projectId} to ${newStatus}`);
        showLoading(true);
        const originalStatus = selectElement.getAttribute('data-original-status') ||
                               (adminApp.state.projectListCache.find(p => p.projectId === projectId) || {}).status;
        selectElement.setAttribute('data-original-status', originalStatus);

        google.script.run
            .withSuccessHandler(function(response) { onProjectStatusUpdated(response, projectId, newStatus, selectElement); })
            .withFailureHandler(function(error) {
                onServerError(error);
                if (selectElement) {
                    console.log("Reverting status dropdown due to server error for project:", projectId);
                    selectElement.value = originalStatus;
                }
            })
            .updateProjectStatus(projectId, newStatus);
    }

    function onProjectStatusUpdated(response, projectId, newStatus, selectElement) {
        showLoading(false);
        if (response && response.success) {
            displayMessage(response.message || "Project status updated successfully!", true);

            const projectInCache = adminApp.state.projectListCache.find(p => p.projectId === projectId);
            if (projectInCache) projectInCache.status = newStatus;
            selectElement.removeAttribute('data-original-status');

            const statusSpan = selectElement.closest('.project-item').querySelector('.status-text');
            if(statusSpan) statusSpan.textContent = `(${newStatus})`;

            if (adminApp.state.currentView === 'edit' && adminApp.state.currentProjectId === projectId && adminApp.state.projectData) {
                adminApp.state.projectData.status = newStatus;
            }
        } else {
            onServerError((response && response.error) ? response.error : "Failed to update status.");
            if (selectElement) {
                 console.log("Reverting status dropdown due to server failure for project:", projectId);
                 const originalStatus = selectElement.getAttribute('data-original-status');
                 if(originalStatus) selectElement.value = originalStatus;
            }
        }
    }

    function handleDeleteProject(projectId, projectTitle) {
        if (!confirm(`Are you sure you want to delete the project "${projectTitle}" (ID: ${projectId})? This action cannot be undone.`)) {
            return;
        }
        console.log(`Attempting to delete project ${projectId}`);
        showLoading(true);
        google.script.run
            .withSuccessHandler(onProjectDeleted)
            .withFailureHandler(onServerError)
            .deleteProject(projectId);
    }

    function onProjectDeleted(response) {
        showLoading(false);
        if (response && response.success) {
            displayMessage(response.message || "Project deleted successfully!", true);
            if (adminApp.state.currentView === 'edit' && adminApp.state.currentProjectId === response.deletedProjectId) {
                switchToListView();
            } else {
                loadAdminProjectsList();
            }
        } else {
            onServerError((response && response.error) ? response.error : "Failed to delete project.");
        }
    }

    // --- Error Handling & UI Utils ---
    function showLoading(show) {
        adminApp.state.isLoading = show;
        safeDOMUpdate(loadingSpinnerEl, 
          el => el.style.display = show ? 'flex' : 'none',
          "Failed to update loading spinner display"
        );
        if (show && !loadingSpinnerEl) console.warn("showLoading(true) loadingSpinnerEl not found."); // Keep console warn if element itself is missing.
    }

    function showNotification(message, type = 'info', duration = 5000) {
        let container = document.getElementById('notificationContainer');
        if (!container) {
            container = document.createElement('div');
            container.id = 'notificationContainer';
            document.body.appendChild(container);
        }
        
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.textContent = message;
        
        container.appendChild(notification);
        
        setTimeout(() => notification.classList.add('visible'), 10);
        
        setTimeout(() => {
            notification.classList.remove('visible');
            setTimeout(() => notification.remove(), 300); 
        }, duration);
    }

    function displayMessage(message, isSuccess) {
        showNotification(message, isSuccess ? 'success' : 'error');
        
        safeDOMUpdate(messageAreaEl, el => {
            el.innerHTML = ''; 
            const p = document.createElement('p'); 
            p.textContent = message; 
            el.appendChild(p); 
            el.className = isSuccess ? 'success' : 'error'; 
            setTimeout(() => { 
                safeDOMUpdate(el, innerEl => {
                    innerEl.innerHTML = ''; 
                    innerEl.className = ''; 
                }, "Failed to clear message area after timeout in displayMessage");
            }, 7000); 
        }, "Failed to display message in messageAreaEl");

        if (!messageAreaEl) { // Keep console warn if element itself is missing.
            console.warn("displayMessage messageAreaEl not found. Message:", message); 
        }
    }

// MODIFY onServerError function to check for session errors:
    function onServerError(errorObject) {
      console.error("onServerError triggered:", errorObject);
      showLoading(false);
      
      // Check if it's a session error first
      if (handleDriveSessionError(errorObject)) {
        return; // Session error handled
      }
      
      let errorMessage = "An unknown server error occurred.";
       if (typeof errorObject === 'string') { errorMessage = errorObject; }
       else if (errorObject && errorObject.message) { errorMessage = errorObject.message; }
       else if (errorObject && errorObject.error && typeof errorObject.error === 'string') { errorMessage = errorObject.error; }
      console.error('Formatted Server Error Message:', errorMessage);
      displayMessage('Server Error: ' + errorMessage, false);
    }

    function handleCreateProject() {
        if (adminApp.state.isLoading) return;
        const currentProjectTitle = projectTitleInputEl.value.trim();
        if (!currentProjectTitle) { displayMessage('Project title cannot be empty.', false); projectTitleInputEl.focus(); return; }
        showLoading(true);
        google.script.run.withSuccessHandler(onProjectCreated).withFailureHandler(onServerError).createProject(currentProjectTitle);
    }
    function onProjectCreated(response) {
        showLoading(false);
        if (response && response.success) { displayMessage(response.message || 'Project created!', true); if(projectTitleInputEl) projectTitleInputEl.value = ''; loadAdminProjectsList(); }
        else { onServerError((response && response.error) ? response.error : 'Failed to create project.'); }
    }

    function loadAdminProjectsList() {
      console.log("loadAdminProjectsList: Function called.");
      if (!adminProjectListContainerEl) { console.error("loadAdminProjectsList: adminProjectListContainerEl not found."); showLoading(false); return; }
      if (!google || !google.script || !google.script.run) { console.error("loadAdminProjectsList: google.script.run unavailable."); displayMessage("Error: Client-server bridge unavailable.", false); return; }
      showLoading(true);
      console.log("loadAdminProjectsList: Calling google.script.run.getAllProjectsForAdmin...");
      google.script.run
        .withSuccessHandler(displayAdminProjects)
        .withFailureHandler(onServerError)
        .getAllProjectsForAdmin();
       console.log("loadAdminProjectsList: google.script.run.getAllProjectsForAdmin call initiated.");
    }
    function displayAdminProjects(projectsArray) {
      console.log("displayAdminProjects (Success Handler) received data:", projectsArray);
      showLoading(false);
      
      safeDOMUpdate(adminProjectListContainerEl, el => {
          el.innerHTML = ''; // Clear previous projects
          if (!projectsArray || projectsArray.length === 0) { 
              el.innerHTML = '<p>No projects found. Create one above!</p>'; // Updated message
              return; 
          }

          adminApp.state.projectListCache = projectsArray;

          projectsArray.forEach(project => {
              if (!project || !project.projectId) return;
              const projectItem = document.createElement('div');
              projectItem.className = 'project-item';

              const titleAndStatusDiv = document.createElement('div');
              const titleSpan = document.createElement('span');
              titleSpan.textContent = project.projectTitle || 'Untitled Project';
              titleSpan.style.fontWeight = 'bold';
              const statusTextSpan = document.createElement('span');
              statusTextSpan.className = 'status-text';
              statusTextSpan.textContent = `(${project.status || 'N/A'})`;
              titleAndStatusDiv.appendChild(titleSpan);
              titleAndStatusDiv.appendChild(statusTextSpan);

              const controlsDiv = document.createElement('div');
              const statusSelect = document.createElement('select');
              statusSelect.className = 'project-status-select';
              statusSelect.setAttribute('data-project-id', project.projectId);
              statusSelect.setAttribute('data-original-status', project.status || "Draft");
              ['Draft', 'Active', 'Inactive'].forEach(statusValue => {
                  const option = document.createElement('option');
                  option.value = statusValue;
                  option.textContent = statusValue;
                  if (project.status === statusValue) { option.selected = true; }
                  statusSelect.appendChild(option);
              });
              statusSelect.onchange = function() { handleProjectStatusChange(project.projectId, this.value, this); };

              const editButton = document.createElement('button');
              editButton.textContent = 'Edit';
              editButton.className = 'edit-button';
              editButton.setAttribute('data-project-id', project.projectId);
              editButton.onclick = function() { console.log("Edit button clicked:", project.projectId); switchToEditView(project.projectId); };

              const deleteButton = document.createElement('button');
              deleteButton.textContent = 'Delete';
              deleteButton.className = 'danger-button';
              deleteButton.setAttribute('data-project-id', project.projectId);
              deleteButton.setAttribute('data-project-title', project.projectTitle || 'Untitled Project');
              deleteButton.style.marginLeft = '5px';
              deleteButton.onclick = function() { handleDeleteProject(project.projectId, project.projectTitle || 'Untitled Project'); };

              controlsDiv.appendChild(statusSelect);
              controlsDiv.appendChild(editButton);
              controlsDiv.appendChild(deleteButton);

              projectItem.appendChild(titleAndStatusDiv);
              projectItem.appendChild(controlsDiv);
              el.appendChild(projectItem);
           });
      }, "Failed to display admin projects in list container");
      console.log("displayAdminProjects: Finished rendering project list.");
    }

// ADD new function to handle Drive session errors:
function handleDriveSessionError(error) {
  console.error("Drive session error:", error);
  
  if (error && error.message && 
      (error.message.includes("authorization") || 
       error.message.includes("401") || 
       error.message.includes("403"))) {
    
    // Session expired
    displayMessage("Your session has expired. The page will reload to re-authenticate.", false);
    
    // Save current state if possible
    if (adminApp.state.projectData) {
      try {
        localStorage.setItem('adminTempProjectData', JSON.stringify({
          projectId: adminApp.state.currentProjectId,
          projectData: adminApp.state.projectData,
          slideIndex: adminApp.state.currentSlideIndex
        }));
      } catch (e) {
        console.error("Could not save temporary state:", e);
      }
    }
    
    // Reload after brief delay
    setTimeout(() => {
      window.location.reload();
    }, 2000);
    
    return true; // Handled
  }
  
  return false; // Not a session error
}

    // --- Media Handling ---
    function handleImageUpload(event) {
        if (adminApp.state.isLoading) { if (event.target) event.target.value = null; return; }
        const file = event.target.files[0];
        if (!file || !file.type.startsWith('image/')) { if(event.target) event.target.value = null; return; }

        saveCurrentSlideState(); 

        showLoading(true); displayMessage("Uploading image...", true);
        const reader = new FileReader();
        reader.onload = function(e) {
            const fileData = { fileName: file.name, mimeType: file.type, data: e.target.result.split(',')[1] };
            if (!adminApp.state.currentProjectId) { showLoading(false); displayMessage("Error: No project selected.", false); if(event.target) event.target.value = null; return; }
            google.script.run.withSuccessHandler(onImageUploaded).withFailureHandler(onServerError).uploadFileToDrive(fileData, adminApp.state.currentProjectId, 'image');
        };
        reader.onerror = function(error) { showLoading(false); displayMessage("Error reading file.", false); console.error(error); if(event.target) event.target.value = null; };
        reader.readAsDataURL(file);
    }

    function onImageUploaded(response) {
        showLoading(false);
        if (imageUploaderEl) imageUploaderEl.value = null;
        if (response && response.success && response.driveFileId) {
            displayMessage("Image processed. Fetching for preview...", true);
            showLoading(true);
            adminApp.state.lastUploadedDriveId = response.driveFileId;
            adminApp.state.lastUploadedMimeType = response.mimeType;
            adminApp.state.lastUploadedFileName = response.fileName;
            google.script.run
                .withSuccessHandler(onBase64ImageReceived)
                .withFailureHandler(onServerError)
                .getImageAsBase64(response.driveFileId);
        } else {
            onServerError({ message: (response && response.error) ? response.error : "Image processing failed." });
        }
    }

    function onBase64ImageReceived(response) {
        showLoading(false);
        if (response && response.success && response.base64Data) {
            if (!adminApp.state.fabricCanvasInstance || adminApp.state.currentSlideIndex === -1) { 
                displayMessage("Error: Canvas/Slide not ready.", false); 
                return; 
            }
            const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
            if (!currentSlide) { 
                displayMessage("Error: Slide data missing.", false); 
                return; 
            }

            fabric.Image.fromURL(response.base64Data, function(img) {
                if (!adminApp.state.fabricCanvasInstance || adminApp.state.currentSlideIndex === -1) return;
                const canvas = adminApp.state.fabricCanvasInstance;
                const imgWidth = img.width; 
                const imgHeight = img.height;
                const maxWidth = 960;
                let cvWidth = imgWidth; 
                let cvHeight = imgHeight; 
                const ratio = imgWidth / imgHeight;

                if (cvWidth > maxWidth) { 
                    cvWidth = maxWidth; 
                    cvHeight = Math.round(cvWidth / ratio); 
                }

                canvas.setWidth(cvWidth); 
                canvas.setHeight(cvHeight);
                if (fabricCanvasEl) { 
                    fabricCanvasEl.width = cvWidth; 
                    fabricCanvasEl.height = cvHeight; 
                }
                canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), { 
                    scaleX: cvWidth / imgWidth, 
                    scaleY: cvHeight / imgHeight 
                });
                displayMessage("Background image set.", true);

                if (!currentSlide.slideMedia) currentSlide.slideMedia = {};
                currentSlide.slideMedia.type = 'image';
                currentSlide.slideMedia.url = null; 
                currentSlide.slideMedia.driveFileId = adminApp.state.lastUploadedDriveId || null;
                currentSlide.slideMedia.mimeType = adminApp.state.lastUploadedMimeType || response.mimeType;
                currentSlide.slideMedia.originalName = adminApp.state.lastUploadedFileName || null;
                currentSlide.canvasWidth = cvWidth;
                currentSlide.canvasHeight = cvHeight;

                console.log(`Slide ${adminApp.state.currentSlideIndex + 1} media/dims updated for image.`);
                updateSlideThumbnailsUI();

                delete adminApp.state.lastUploadedDriveId;
                delete adminApp.state.lastUploadedMimeType;
                delete adminApp.state.lastUploadedFileName;

            }, { crossOrigin: 'anonymous' });
        } else {
            onServerError({ message: (response && response.error) ? response.error : "Failed to fetch image data." });
        }
    }

    function handleSetYoutubeBackground() {
        if (!adminApp.state.projectData || adminApp.state.currentSlideIndex < 0) {
            displayMessage("Please select a slide first.", false); return;
        }
        if (!youtubeUrlInputEl || !youtubeUrlInputEl.value) {
            displayMessage("Please enter a YouTube URL.", false); return;
        }
        const url = youtubeUrlInputEl.value.trim();
        if (!url.includes("youtube.com/") && !url.includes("youtu.be/")) { // Simplified check
            displayMessage("Please enter a valid YouTube URL.", false);
            return;
        }

        saveCurrentSlideState(); 

        const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
        if (!currentSlide.slideMedia) {
            currentSlide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
        }
        currentSlide.slideMedia.type = 'youtube';
        currentSlide.slideMedia.url = url;
        currentSlide.slideMedia.driveFileId = null; 
        currentSlide.slideMedia.mimeType = 'video/youtube';
        currentSlide.slideMedia.originalName = null;
        currentSlide.slideMedia.videoQuestions = currentSlide.slideMedia.videoQuestions || []; // Ensure array exists
        currentSlide.slideMedia.videoOverlays = currentSlide.slideMedia.videoOverlays || [];


        console.log(`Set YouTube background for slide ${adminApp.state.currentSlideIndex + 1} to: ${url}`);
        selectSlide(adminApp.state.currentSlideIndex); // Reload slide to show YouTube player
        displayMessage("YouTube background set for this slide.", true);
    }

    function handleAudioUpload(event) {
        if (adminApp.state.isLoading) { if (event.target) event.target.value = null; return; }
        const file = event.target.files[0];
        if (!file || !file.type.startsWith('audio/')) {
            if (event.target) event.target.value = null;
            return;
        }
        if (!adminApp.state.projectData || adminApp.state.currentSlideIndex < 0) {
             displayMessage("Please select a slide first before uploading audio.", false);
             if (event.target) event.target.value = null;
             return;
        }

        saveCurrentSlideState(); 

        showLoading(true); displayMessage("Uploading audio...", true);
        const reader = new FileReader();
        reader.onload = function(e) {
            const fileData = {
                fileName: file.name,
                mimeType: file.type,
                data: e.target.result.split(',')[1]
            };
            google.script.run
                .withSuccessHandler(onAudioUploaded)
                .withFailureHandler(onServerError)
                .uploadFileToDrive(fileData, adminApp.state.currentProjectId, 'audio');
        };
        reader.onerror = function(error) {
            showLoading(false);
            displayMessage("Error reading audio file.", false);
            console.error(error);
            if (event.target) event.target.value = null;
        };
        reader.readAsDataURL(file);
    }

     function onAudioUploaded(response) {
        showLoading(false);
        if (audioUploaderEl) audioUploaderEl.value = null;

        if (response && response.success && response.driveFileId) {
            displayMessage("Audio processed successfully.", true);

            const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
             if (!currentSlide.slideMedia) {
                currentSlide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
             }
            currentSlide.slideMedia.type = 'audio';
            currentSlide.slideMedia.url = null; 
            currentSlide.slideMedia.driveFileId = response.driveFileId;
            currentSlide.slideMedia.mimeType = response.mimeType;
            currentSlide.slideMedia.originalName = response.fileName;

            console.log(`Audio attached for slide ${adminApp.state.currentSlideIndex + 1}:`, currentSlide.slideMedia);
            
            safeDOMUpdate(attachedAudioNameEl, el => {
                el.textContent = `Attached: ${response.fileName}`;
                const currentAudioControls = document.getElementById('audioControls');
                safeDOMUpdate(currentAudioControls, audioEl => audioEl.style.display = 'block', "Failed to show audio controls on audio upload");
            }, "Failed to update attached audio name on upload");
            safeDOMUpdate(removeAudioButtonEl, el => el.style.display = 'inline-block', "Failed to show remove audio button on upload");

            if (youtubeUrlInputEl) youtubeUrlInputEl.value = '';
            if (imageUploaderEl) imageUploaderEl.value = null;
            if(adminApp.state.fabricCanvasInstance) {
                adminApp.state.fabricCanvasInstance.setBackgroundImage(null, adminApp.state.fabricCanvasInstance.renderAll.bind(adminApp.state.fabricCanvasInstance));
                adminApp.state.fabricCanvasInstance.backgroundColor = '#e9e9e9'; 
                adminApp.state.fabricCanvasInstance.renderAll();
            }
            safeDOMUpdate(adminMediaPlaceholderEl, el => {
                 el.textContent = `Audio Attached: ${response.fileName}`;
                 el.style.display = 'block';
            }, "Failed to update admin media placeholder on audio upload");

        } else {
            onServerError((response && response.error) ? response.error : "Failed to process audio.");
        }
    }

    function handleRemoveAudio() {
        if (!adminApp.state.projectData || adminApp.state.currentSlideIndex < 0) return;

        const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
        if (currentSlide.slideMedia && currentSlide.slideMedia.type === 'audio') {
            console.log(`Removing audio from slide ${adminApp.state.currentSlideIndex + 1}`);

            currentSlide.slideMedia.type = null;
            currentSlide.slideMedia.url = null;
            currentSlide.slideMedia.driveFileId = null;
            currentSlide.slideMedia.mimeType = null;
            currentSlide.slideMedia.originalName = null;

            safeDOMUpdate(attachedAudioNameEl, el => {
                el.textContent = '';
                const currentAudioControls = document.getElementById('audioControls');
                safeDOMUpdate(currentAudioControls, audioEl => audioEl.style.display = 'none', "Failed to hide audio controls on audio removal");
            }, "Failed to clear attached audio name on removal");
            safeDOMUpdate(removeAudioButtonEl, el => el.style.display = 'none', "Failed to hide remove audio button on removal");
            if (audioUploaderEl) audioUploaderEl.value = null; 
            safeDOMUpdate(adminMediaPlaceholderEl, el => el.style.display = 'none', "Failed to hide admin media placeholder on audio removal");
            
            if(adminApp.state.fabricCanvasInstance) {
                adminApp.state.fabricCanvasInstance.backgroundColor = '#e9e9e9';
                adminApp.state.fabricCanvasInstance.renderAll();
             }
            displayMessage("Audio removed from this slide.", true);
        }
    }

    function handlePasteImage(event) {
        if (adminApp.state.currentView !== 'edit' || !adminApp.state.currentProjectId || adminApp.state.isLoading) {
            return;
        }
        const items = (event.clipboardData || event.originalEvent.clipboardData).items;
        let imageFound = false;
        for (let i = 0; i < items.length; i++) {
            if (items[i].kind === 'file' && items[i].type.startsWith('image/')) {
                imageFound = true;
                const blob = items[i].getAsFile();
                if (!blob) continue;
                event.preventDefault();
                console.log("Image pasted from clipboard:", blob.name || 'pasted_image', blob.type);
                saveCurrentSlideState(); 
                showLoading(true);
                displayMessage("Processing pasted image...", true);
                const reader = new FileReader();
                reader.onload = function(e_reader) {
                    const fileData = {
                        fileName: blob.name || `pasted_image_${Date.now()}.${blob.type.split('/')[1] || 'png'}`, 
                        mimeType: blob.type,
                        data: e_reader.target.result.split(',')[1]
                    };
                    if (!adminApp.state.currentProjectId) {
                        showLoading(false);
                        displayMessage("Error: No project selected for pasted image.", false);
                        return;
                    }
                    google.script.run
                        .withSuccessHandler(onImageUploaded) 
                        .withFailureHandler(onServerError)
                        .uploadFileToDrive(fileData, adminApp.state.currentProjectId, 'image');
                };
                reader.onerror = function(error) {
                    showLoading(false);
                    displayMessage("Error reading pasted image data.", false);
                    console.error("FileReader error:", error);
                };
                reader.readAsDataURL(blob);
                break; 
            }
        }
        if (imageFound) {
            console.log("Handled pasted image.");
        } else {
            console.log("Paste event did not contain a direct image file.");
        }
    }

    function handleMediaSelection(mediaType) {
        if (adminApp.state.currentView !== 'edit' || !adminApp.state.currentProjectId || adminApp.state.isLoading) {
            showNotification("Cannot add media now. Please wait...", "error");
            return;
        }
        
        switch(mediaType) {
            case 'image':
                if (imageUploaderEl) {
                    imageUploaderEl.click();
                } else {
                    showNotification("Image upload not available", "error");
                }
                break;
            case 'audio':
                if (audioUploaderEl) {
                    audioUploaderEl.click();
                } else {
                    showNotification("Audio upload not available", "error");
                }
                break;
            case 'youtube':
                const youtubeUrl = prompt("Enter YouTube URL:");
                if (youtubeUrl) {
                    if (youtubeUrlInputEl) {
                        youtubeUrlInputEl.value = youtubeUrl;
                        handleSetYoutubeBackground();
                    } else {
                        showNotification("YouTube background functionality not available", "error");
                    }
                }
                break;
            default:
                showNotification("Unknown media type: " + mediaType, "error");
        }
    }

    function handleUndo() {
        if (adminApp.state.historyIndex <= 0) return; 

        adminApp.state.isApplyingHistory = true;
        adminApp.state.historyIndex--;
        const canvas = adminApp.state.fabricCanvasInstance;
        const stateToLoad = adminApp.state.history[adminApp.state.historyIndex];

        canvas.loadFromJSON(stateToLoad, () => {
            canvas.renderAll();
            canvas.getObjects().forEach(obj => {
                const originalObjState = stateToLoad.objects.find(sObj => sObj.slideId === obj.slideId );
                if (originalObjState) { 
                    obj.customInteraction = originalObjState.customInteraction || { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
                    obj.customAnimation = originalObjState.customAnimation || { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
                }
            });
            populateToolbar(canvas.getActiveObject()); 
            adminApp.state.isApplyingHistory = false;
            updateUndoRedoButtonStates();
            console.log("Undo applied. History index:", adminApp.state.historyIndex);
        });
    }

    function handleRedo() {
        if (adminApp.state.historyIndex >= adminApp.state.history.length - 1) return;

        adminApp.state.isApplyingHistory = true;
        adminApp.state.historyIndex++;
        const canvas = adminApp.state.fabricCanvasInstance;
        const stateToLoad = adminApp.state.history[adminApp.state.historyIndex];

        canvas.loadFromJSON(stateToLoad, () => {
            canvas.renderAll();
            canvas.getObjects().forEach(obj => {
                const originalObjState = stateToLoad.objects.find(sObj => sObj.slideId === obj.slideId);
                if (originalObjState) {
                    obj.customInteraction = originalObjState.customInteraction || { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
                    obj.customAnimation = originalObjState.customAnimation || { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
                }
            });
            populateToolbar(canvas.getActiveObject());
            adminApp.state.isApplyingHistory = false;
            updateUndoRedoButtonStates();
            console.log("Redo applied. History index:", adminApp.state.historyIndex);
        });
    }

    function handleDeleteObject() {
        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas) return;
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
            canvas.remove(activeObject);
            if (activeObject.type === 'activeSelection') { 
                activeObject.forEachObject(obj => canvas.remove(obj));
                canvas.discardActiveObject(); 
            }
            canvas.renderAll();
            saveCanvasStateForHistory(); 
            populateToolbar(null); 
            showNotification("Object deleted", "info");
        } else {
            showNotification("No object selected to delete.", "info");
        }
    }

// Overlay creation workflow
function initiateOverlayPlacement() {
    if (!isYouTubePlayerAvailable() || !adminApp.state.adminYouTubePlayer) return;
    
    // Pause video at current time
    adminApp.state.adminYouTubePlayer.pauseVideo();
    const currentTime = safeGetCurrentTime(adminApp.state.adminYouTubePlayer);
    
    // Show placement overlay
    const placementMode = document.getElementById('overlayPlacementMode');
    safeDOMUpdate(placementMode, el => el.style.display = 'block', "Failed to show overlay placement mode in initiateOverlayPlacement");
    
    // Store placement state
    adminApp.state.placingOverlay = {
        startTime: currentTime,
        position: null
    };
}

// Handle click on video to place overlay
function handleOverlayPlacement(event) {
    const container = document.getElementById('adminYouTubePlayerContainer');
    if (!container) { // Added null check
        console.warn('handleOverlayPlacement: adminYouTubePlayerContainer element not found.');
        return;
    }
    const rect = container.getBoundingClientRect();
    
    // Calculate percentage position
    const x = ((event.clientX - rect.left) / rect.width) * 100;
    const y = ((event.clientY - rect.top) / rect.height) * 100;
    
    adminApp.state.placingOverlay.position = { x, y };
    
    // Hide placement mode
    const placementMode = document.getElementById('overlayPlacementMode');
    safeDOMUpdate(placementMode, el => el.style.display = 'none', "Failed to hide overlay placement mode in handleOverlayPlacement");
    
    // Show editor modal
    showOverlayEditor();
}

// Show overlay editor modal
function showOverlayEditor(overlayId = null) {
    const modal = document.getElementById('overlayEditorModal');
    if (!modal) { // Added null check
        console.warn('showOverlayEditor: overlayEditorModal element not found.');
        return;
    }
    const overlay = overlayId ? findOverlayById(overlayId) : createNewOverlay();
    
    if (!overlay) { // Added null check for overlay object
        console.warn('showOverlayEditor: Overlay object could not be found or created.');
        return;
    }

    // Populate form fields
    const overlayTemplateEl = document.getElementById('overlayTemplate');
    if (overlayTemplateEl) overlayTemplateEl.value = overlay.template; // Input value
    
    const overlayStartTimeDisplayEl = document.getElementById('overlayStartTimeDisplay');
    safeDOMUpdate(overlayStartTimeDisplayEl, el => el.textContent = formatTime(overlay.startTime), "Failed to set overlay start time display in showOverlayEditor");
    
    const overlayDurationEl = document.getElementById('overlayDuration');
    if (overlayDurationEl) overlayDurationEl.value = overlay.duration; // Input value
    
    const overlayTextContentEl = document.getElementById('overlayTextContent'); // This is the one in the modal
    if (overlayTextContentEl) overlayTextContentEl.value = overlay.content.text || ''; // Input value
    
    const overlayPauseVideoEl = document.getElementById('overlayPauseVideo');
    if (overlayPauseVideoEl) overlayPauseVideoEl.checked = overlay.interaction.pauseVideo; // Input checked
    
    const overlayDismissibleEl = document.getElementById('overlayDismissible');
    if (overlayDismissibleEl) overlayDismissibleEl.checked = overlay.interaction.dismissible; // Input checked
    
    const overlayActionEl = document.getElementById('overlayAction');
    if (overlayActionEl) overlayActionEl.value = overlay.interaction.action; // Input value
    
    // Show position
    const overlayPositionDisplayEl = document.getElementById('overlayPositionDisplay');
    safeDOMUpdate(overlayPositionDisplayEl, el => {
        if (overlay.position) {
            el.textContent = `X: ${overlay.position.x.toFixed(0)}%, Y: ${overlay.position.y.toFixed(0)}%`;
        } else {
            el.textContent = 'Position not set';
        }
    }, "Failed to set overlay position display in showOverlayEditor");
    
    // Show/hide delete button
    const deleteOverlayBtnEl = document.getElementById('deleteOverlayBtn');
    safeDOMUpdate(deleteOverlayBtnEl, el => el.style.display = overlayId ? 'inline-block' : 'none', "Failed to update delete overlay button display in showOverlayEditor");
    
    safeDOMUpdate(modal, el => el.style.display = 'block', "Failed to show overlay editor modal in showOverlayEditor");
    adminApp.state.editingOverlayId = overlayId;
}

// Create new overlay object
function createNewOverlay() {
    // Ensure placingOverlay state is valid or provide defaults
    let startTime = 0;
    let position = { x: 50, y: 50 }; // Default position

    if (adminApp.state.placingOverlay) {
        startTime = adminApp.state.placingOverlay.startTime;
        // Use position from placingOverlay if it exists, otherwise keep default
        if (adminApp.state.placingOverlay.position) {
            position = adminApp.state.placingOverlay.position;
        }
    } else if (isYouTubePlayerAvailable() && adminApp.state.adminYouTubePlayer) {
        // Fallback if placingOverlay is not set, use current video time
        startTime = safeGetCurrentTime(adminApp.state.adminYouTubePlayer);
    }


    return {
        id: 'overlay_' + Utilities.generateUuid(),
        template: 'lowerThird',
        startTime: startTime,
        duration: 5,
        position: position,
        content: {
            text: '',
            backgroundColor: '#000000',
            textColor: '#FFFFFF'
        },
        interaction: {
            pauseVideo: false,
            dismissible: true,
            action: 'none',
            actionTarget: ''
        }
    };
}

// Save overlay
function saveOverlay() {
    const currentSlide = getCurrentSlide();
    if (!currentSlide || !currentSlide.slideMedia) { // Added null check for currentSlide and slideMedia
        console.warn("saveOverlay: Current slide or slide media not found.");
        return;
    }
    if (!currentSlide.slideMedia.videoOverlays) {
        currentSlide.slideMedia.videoOverlays = [];
    }
    
    const overlay = gatherOverlayFromForm();
    if (!overlay) { // Added null check for overlay data
        console.warn("saveOverlay: Could not gather overlay data from form.");
        return;
    }
    
    if (adminApp.state.editingOverlayId) {
        // Update existing
        const index = currentSlide.slideMedia.videoOverlays.findIndex(
            o => o.id === adminApp.state.editingOverlayId
        );
        if (index !== -1) {
            currentSlide.slideMedia.videoOverlays[index] = overlay;
        } else {
            // If for some reason the ID is not found, add as new to prevent data loss
            currentSlide.slideMedia.videoOverlays.push(overlay);
            console.warn("saveOverlay: Editing overlay ID not found, added as new.");
        }
    } else {
        // Add new
        currentSlide.slideMedia.videoOverlays.push(overlay);
    }
    
    // Sort by start time
    currentSlide.slideMedia.videoOverlays.sort((a, b) => a.startTime - b.startTime);
    
    hideOverlayEditor();
    renderOverlayTimeline();
    renderOverlayList();
    showNotification('Overlay saved.', 'success'); // Added user feedback
}

// Render overlay bars on timeline
function renderOverlayTimeline() {
    const track = document.getElementById('overlayTimelineTrack');
    if (!track) { // Added null check
        console.warn("renderOverlayTimeline: overlayTimelineTrack element not found.");
        return;
    }
    if (!isYouTubePlayerAvailable() || !adminApp.state.adminYouTubePlayer) {
        console.warn("renderOverlayTimeline: adminYouTubePlayer not available.");
        track.innerHTML = '<p>Video player not ready.</p>'; // User feedback
        return;
    }
    safeDOMUpdate(track, el => {
        el.innerHTML = ''; // Clear previous timeline
        const duration = adminApp.state.adminYouTubePlayer.getDuration(); // getDuration() is generally safe
        if (duration === 0) { // Handle case where duration might not be available yet
            el.innerHTML = '<p>Video duration not available.</p>'; // User feedback
            return;
        }

        const currentSlide = getCurrentSlide();
        // Ensure videoOverlays exists and is an array
        const overlays = (currentSlide && currentSlide.slideMedia && Array.isArray(currentSlide.slideMedia.videoOverlays)) 
                         ? currentSlide.slideMedia.videoOverlays 
                         : [];
        
        if (overlays.length === 0) {
            el.innerHTML = '<p style="text-align: center; margin-top: 10px;">No overlays on this slide.</p>'; // User feedback
            return;
        }

        overlays.forEach(overlay => {
        const bar = document.createElement('div');
        bar.className = 'overlay-timeline-bar';
        bar.dataset.overlayId = overlay.id;
        
        const startPercent = (overlay.startTime / duration) * 100;
        const widthPercent = (overlay.duration / duration) * 100;
        
        bar.style.cssText = `
            position: absolute;
            left: ${startPercent}%;
            width: ${widthPercent}%;
            height: 100%;
            background-color: ${getTemplateColor(overlay.template)};
            opacity: 0.8;
            cursor: pointer;
            border: 1px solid rgba(0,0,0,0.3);
            box-sizing: border-box; /* Added for better layout */
        `;
        
        bar.title = `${overlay.content.text || overlay.template} (${formatTime(overlay.startTime)})`;
        bar.onclick = () => showOverlayEditor(overlay.id);
        
        el.appendChild(bar); // Appending to el (the track)
        });
    }, "Failed to render overlay timeline");
}

// Helper to get color for template type
function getTemplateColor(template) {
    const colors = {
        lowerThird: '#2196F3',
        cornerCallout: '#4CAF50',
        centerCard: '#FF9800',
        hotspot: '#E91E63',
        quizBubble: '#9C27B0'
    };
    return colors[template] || '#607D8B'; // Default color
}

// Preview overlays (toggle preview mode)
function toggleOverlayPreview() {
    adminApp.state.previewingOverlays = !adminApp.state.previewingOverlays;
    const previewButton = document.getElementById('previewOverlaysBtn'); 

    if (adminApp.state.previewingOverlays) {
        renderVideoOverlaysAdmin();
        if (adminApp.state.overlayPreviewInterval) { 
            clearInterval(adminApp.state.overlayPreviewInterval);
        }
        adminApp.state.overlayPreviewInterval = setInterval(updateOverlayPreview, 100);
        safeDOMUpdate(previewButton, el => el.textContent = 'Stop Preview', "Failed to update preview button text to Stop in toggleOverlayPreview");
    } else {
        if (adminApp.state.overlayPreviewInterval) {
            clearInterval(adminApp.state.overlayPreviewInterval);
            adminApp.state.overlayPreviewInterval = null;
        }
        clearVideoOverlaysAdmin();
        safeDOMUpdate(previewButton, el => el.textContent = 'Preview Overlays', "Failed to update preview button text to Preview in toggleOverlayPreview");
    }
}

// --- Helper Functions for Overlay Management ---
function findOverlayById(overlayId) {
    const currentSlide = getCurrentSlide();
    if (!currentSlide || !currentSlide.slideMedia || !Array.isArray(currentSlide.slideMedia.videoOverlays)) { // Check if array
        return null;
    }
    return currentSlide.slideMedia.videoOverlays.find(o => o.id === overlayId);
}

function hideOverlayEditor() {
    const modal = document.getElementById('overlayEditorModal');
    safeDOMUpdate(modal, el => el.style.display = 'none', "Failed to hide overlay editor modal in hideOverlayEditor");
    adminApp.state.editingOverlayId = null;
}

function deleteCurrentOverlay() {
    if (!adminApp.state.editingOverlayId) {
        showNotification('No overlay selected to delete.', 'error');
        return;
    }

    const currentSlide = getCurrentSlide();
    if (!currentSlide || !currentSlide.slideMedia || !Array.isArray(currentSlide.slideMedia.videoOverlays)) { // Check if array
        showNotification('Cannot find overlay data for this slide.', 'error');
        return;
    }

    const overlayIdToDelete = adminApp.state.editingOverlayId;
    const initialLength = currentSlide.slideMedia.videoOverlays.length;
    currentSlide.slideMedia.videoOverlays = currentSlide.slideMedia.videoOverlays.filter(
        o => o.id !== overlayIdToDelete
    );

    if (currentSlide.slideMedia.videoOverlays.length < initialLength) {
        showNotification('Overlay deleted.', 'success');
    } else {
        showNotification('Could not delete overlay. Not found.', 'error');
    }

    hideOverlayEditor();
    renderOverlayTimeline();
    renderOverlayList();
}

function gatherOverlayFromForm() {
    const editingId = adminApp.state.editingOverlayId;
    const isNew = !editingId;
    const existingOverlay = editingId ? findOverlayById(editingId) : null;
    
    let startTime, position;

    if (isNew && adminApp.state.placingOverlay) {
        startTime = adminApp.state.placingOverlay.startTime;
        position = adminApp.state.placingOverlay.position;
    } else if (existingOverlay) {
        startTime = existingOverlay.startTime;
        position = existingOverlay.position;
    } else { 
        startTime = (adminApp.state.adminYouTubePlayer && typeof adminApp.state.adminYouTubePlayer.getCurrentTime === 'function') 
                      ? adminApp.state.adminYouTubePlayer.getCurrentTime() 
                      : 0;
        position = { x: 50, y: 50 }; // Default
        console.warn("gatherOverlayFromForm: Could not determine start time or position reliably, using defaults.");
    }
    
    if (!position) { // Ensure position is an object
        position = { x: 50, y: 50 };
    }
    
    // Get values from form elements, with null checks for each element
    const overlayTemplateEl = document.getElementById('overlayTemplate');
    const templateValue = overlayTemplateEl ? overlayTemplateEl.value : 'lowerThird';

    const overlayDurationEl = document.getElementById('overlayDuration');
    const durationValue = overlayDurationEl ? (parseInt(overlayDurationEl.value, 10) || 5) : 5;

    const overlayTextContentEl = document.getElementById('overlayTextContent');
    const textContentValue = overlayTextContentEl ? overlayTextContentEl.value : '';

    const overlayPauseVideoEl = document.getElementById('overlayPauseVideo');
    const pauseVideoValue = overlayPauseVideoEl ? overlayPauseVideoEl.checked : false;

    const overlayDismissibleEl = document.getElementById('overlayDismissible');
    const dismissibleValue = overlayDismissibleEl ? overlayDismissibleEl.checked : true;

    const overlayActionEl = document.getElementById('overlayAction');
    const actionValue = overlayActionEl ? overlayActionEl.value : 'none';

    return {
        id: editingId || ('overlay_' + Utilities.generateUuid()),
        template: templateValue,
        startTime: startTime,
        duration: durationValue,
        position: position, // Already ensured it's an object
        content: {
            text: textContentValue,
            backgroundColor: (existingOverlay && existingOverlay.content) ? existingOverlay.content.backgroundColor : '#000000',
            textColor: (existingOverlay && existingOverlay.content) ? existingOverlay.content.textColor : '#FFFFFF'
        },
        interaction: {
            pauseVideo: pauseVideoValue,
            dismissible: dismissibleValue,
            action: actionValue,
            actionTarget: (existingOverlay && existingOverlay.interaction) ? existingOverlay.interaction.actionTarget : ''
        }
    };
}

function renderOverlayList() {
    const listEl = document.getElementById('adminOverlayList'); 
    if (!listEl) {
        console.warn("renderOverlayList: adminOverlayList element not found.");
        return;
    }
    safeDOMUpdate(listEl, el => {
        el.innerHTML = ''; // Clear previous list
        const currentSlide = getCurrentSlide();
        const overlays = (currentSlide && currentSlide.slideMedia && Array.isArray(currentSlide.slideMedia.videoOverlays)) 
                         ? currentSlide.slideMedia.videoOverlays 
                         : [];

        if (overlays.length === 0) {
            el.innerHTML = '<li>No overlays added for this video.</li>';
            return;
        }

        overlays.forEach(overlay => {
            const item = document.createElement('li');
            item.className = 'overlay-list-item'; 
            item.setAttribute('data-overlay-id', overlay.id); 

            const textSpan = document.createElement('span');
            textSpan.textContent = `[${formatTime(overlay.startTime)}] ${overlay.content.text || overlay.template} (Duration: ${overlay.duration}s)`;
            
            const editButton = document.createElement('button');
            editButton.textContent = 'Edit';
            editButton.className = 'edit-overlay-list-btn'; 
            editButton.style.marginLeft = '10px';
            editButton.onclick = (e) => {
                e.stopPropagation(); 
                showOverlayEditor(overlay.id);
            };

            item.appendChild(textSpan);
            item.appendChild(editButton);
            el.appendChild(item);
        });
    }, "Failed to render overlay list in renderOverlayList");
}

function renderVideoOverlaysAdmin() {
    const playerContainer = document.getElementById('adminYouTubePlayerContainer');
    if (!playerContainer) {
        console.warn("renderVideoOverlaysAdmin: adminYouTubePlayerContainer not found.");
        return;
    }

    clearVideoOverlaysAdmin(false); 

    const currentSlide = getCurrentSlide();
    if (!currentSlide || !currentSlide.slideMedia || !Array.isArray(currentSlide.slideMedia.videoOverlays)) return;

    const overlaysToDisplay = currentSlide.slideMedia.videoOverlays; 

    overlaysToDisplay.forEach(overlay => {
        if (!overlay.position) { // Skip if position is somehow missing
            console.warn("renderVideoOverlaysAdmin: Overlay missing position data", overlay.id);
            return;
        }
        const overlayDiv = document.createElement('div');
        overlayDiv.className = `video-overlay-preview admin-preview-${overlay.template}`; 
        overlayDiv.setAttribute('data-preview-overlay-id', overlay.id);
        overlayDiv.style.position = 'absolute';
        overlayDiv.style.left = `${overlay.position.x}%`;
        overlayDiv.style.top = `${overlay.position.y}%`;
        overlayDiv.style.padding = '5px 10px';
        overlayDiv.style.backgroundColor = overlay.content.backgroundColor || 'rgba(0,0,0,0.7)';
        overlayDiv.style.color = overlay.content.textColor || 'white';
        overlayDiv.style.border = '1px dashed #ccc'; // Dashed to distinguish from real ones
        overlayDiv.style.zIndex = '1050'; // High z-index for admin preview
        overlayDiv.style.pointerEvents = 'none'; // Make them non-interactive for admin preview
        overlayDiv.textContent = overlay.content.text || `[${overlay.template}]`;
        
        playerContainer.appendChild(overlayDiv);
    });
    // After rendering all, explicitly call updateOverlayPreview to set initial visibility
    updateOverlayPreview(); 
}

function updateOverlayPreview() {
    if (!isYouTubePlayerAvailable() || !adminApp.state.adminYouTubePlayer || typeof adminApp.state.adminYouTubePlayer.getCurrentTime !== 'function') {
        // console.warn("updateOverlayPreview: YouTube player not ready or getCurrentTime not available.");
        return;
    }
    if (!adminApp.state.previewingOverlays) return; // Only run if previewing

    const currentTime = safeGetCurrentTime(adminApp.state.adminYouTubePlayer);
    const currentSlide = getCurrentSlide();
    if (!currentSlide || !currentSlide.slideMedia || !Array.isArray(currentSlide.slideMedia.videoOverlays)) return;

    const overlays = currentSlide.slideMedia.videoOverlays;
    const activeOverlaysContainer = document.getElementById('adminYouTubePlayerContainer'); 
    if (!activeOverlaysContainer) return;

    overlays.forEach(overlay => {
        const overlayEl = activeOverlaysContainer.querySelector(`.video-overlay-preview[data-preview-overlay-id="${overlay.id}"]`);
        if (!overlayEl) return; 

        const isVisible = currentTime >= overlay.startTime && currentTime < (overlay.startTime + overlay.duration);
        overlayEl.style.display = isVisible ? 'block' : 'none';
    });
}

function clearVideoOverlaysAdmin(stopPreviewLogicAndButtonUpdate = true) {
    const playerContainer = document.getElementById('adminYouTubePlayerContainer');
    safeDOMUpdate(playerContainer, el => {
        const previewOverlays = el.querySelectorAll('.video-overlay-preview');
        previewOverlays.forEach(previewEl => previewEl.remove());
    }, "Failed to clear video overlays from admin player container in clearVideoOverlaysAdmin");
    
    if (stopPreviewLogicAndButtonUpdate) {
        if (adminApp.state.overlayPreviewInterval) {
            clearInterval(adminApp.state.overlayPreviewInterval);
            adminApp.state.overlayPreviewInterval = null;
        }
        adminApp.state.previewingOverlays = false; 
        const previewButton = document.getElementById('previewOverlaysBtn');
        safeDOMUpdate(previewButton, btnEl => btnEl.textContent = 'Preview Overlays', "Failed to reset preview button text in clearVideoOverlaysAdmin");
    }
}

    // --- Overlay Creation ---
    function addRectangle() {
      if (!adminApp.state.fabricCanvasInstance) { console.error("addRectangle: Fabric canvas not initialized."); displayMessage("Error: Canvas not ready to add shapes.", false); return; }
      const canvas = adminApp.state.fabricCanvasInstance;
      const rect = new fabric.Rect({ 
          left: 50, top: 50, fill: 'rgba(255,0,0,0.7)', width: 150, height: 100, 
          stroke: 'black', strokeWidth: 1,
          customInteraction: { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 }, 
          customAnimation: { trigger: "", type: "", speed: "normal", strength: 5, loop: false }, 
          sequenceOrder: null 
      });
    canvas.add(rect); canvas.setActiveObject(rect); canvas.renderAll();
    saveCanvasStateForHistory(); 
    console.log("Rectangle added to canvas:", rect);
    hideActivePopover();
    }

    function addCircle() {
      if (!adminApp.state.fabricCanvasInstance) { console.error("addCircle: Fabric canvas not initialized."); displayMessage("Error: Canvas not ready to add shapes.", false); return; }
      const canvas = adminApp.state.fabricCanvasInstance;
      const circle = new fabric.Circle({ 
          left: 150, top: 150, radius: 50, fill: 'rgba(0,0,255,0.7)', 
          stroke: 'black', strokeWidth: 1, 
          customInteraction: { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 }, 
          customAnimation: { trigger: "", type: "", speed: "normal", strength: 5, loop: false }, 
          sequenceOrder: null 
      });
    canvas.add(circle); canvas.setActiveObject(circle); canvas.renderAll();
    saveCanvasStateForHistory(); 
    console.log("Circle added to canvas:", circle);
    hideActivePopover();
    }

    function addTextbox() {
      if (!adminApp.state.fabricCanvasInstance) { console.error("addTextbox: Fabric canvas not initialized."); displayMessage("Error: Canvas not ready to add text.", false); return; }
      const canvas = adminApp.state.fabricCanvasInstance;
      const textbox = new fabric.Textbox('Editable Text', {
          left: 100, top: 100, width: 200, fontSize: 24, fill: '#000000',
          fontFamily: 'Arial', fontWeight: 'normal', fontStyle: 'normal',
          textAlign: 'left', lineHeight: 1.16, charSpacing: 0,
          customInteraction: { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 },
          customAnimation: { trigger: "", type: "", speed: "normal", strength: 5, loop: false },
          sequenceOrder: null
      });
        canvas.add(textbox); canvas.setActiveObject(textbox); canvas.renderAll();
        saveCanvasStateForHistory(); 
        console.log("Textbox added to canvas:", textbox);
        hideActivePopover();
        }

    // --- Toolbar Logic (Significantly Reworked) ---
    function toHexColor(fabricColor) {
      if (!fabricColor) return '#000000'; 
      try {
        if (typeof fabricColor === 'string') {
            const colorInstance = new fabric.Color(fabricColor);
            const hex = colorInstance.toHex(); 
            return '#' + hex;
        }
        return '#000000'; 
      } catch (e) {
        console.warn("Could not convert color to HEX:", fabricColor, e);
        return '#000000'; 
      }
    }

    function initToolbar() {
        console.log("initToolbar: Attaching listeners to NEW toolbar inputs and popovers.");
        hideActivePopover(); 

        if(objFontFamilyEl) {
            objFontFamilyEl.innerHTML = ''; 
            FONT_FAMILIES.forEach(font => {
                const option = document.createElement('option'); option.value = font; option.textContent = font; objFontFamilyEl.appendChild(option);
            });
            if (!objFontFamilyEl.hasAttribute('listener-attached')) {
                objFontFamilyEl.addEventListener('change', (e) => updateFabricObjectFromToolbar('fontFamily', e.target.value));
                objFontFamilyEl.setAttribute('listener-attached', 'true');
            }
        } else { console.warn("initToolbar: objFontFamilyEl not found for populating fonts."); }

        const popoverTriggers = [
            { buttonEl: shadowSettingsButtonEl, popoverId: 'shadowPopover' },
            { buttonEl: interactionSettingsButtonEl, popoverId: 'interactionPopover' },
            { buttonEl: animationSettingsButtonEl, popoverId: 'animationPopover' },
            { buttonEl: fontFamilyButtonEl, popoverId: 'fontFamilyPopover' },
            { buttonEl: mediaToolsButtonEl, popoverId: 'mediaToolsPopover' },
            { buttonEl: addShapeButtonEl, popoverId: 'shapesPopover' }, 
            { buttonEl: positionToolsButtonEl, popoverId: 'positionToolsPopover' },
            { buttonEl: fillColorButtonEl, popoverId: 'fillColorPopover' },
            { buttonEl: strokeColorButtonEl, popoverId: 'strokeColorPopover' },
            { buttonEl: opacityButtonEl, popoverId: 'opacityPopover' }
        ];

        popoverTriggers.forEach(item => {
            if (item.buttonEl && !item.buttonEl.hasAttribute('listener-attached')) {
                item.buttonEl.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    togglePopover(item.popoverId, item.buttonEl);
                });
                item.buttonEl.setAttribute('listener-attached', 'true');
            } else if (!item.buttonEl) {
                console.warn(`initToolbar: Popover trigger button for ${item.popoverId} not found.`);
            }
        });

        if (mediaTabButtonsEl && mediaTabButtonsEl.length > 0) {
            mediaTabButtonsEl.forEach(tab => {
                if (!tab.hasAttribute('listener-attached')) {
                    tab.addEventListener('click', () => {
                        const tabId = tab.dataset.tab;
                        switchMediaTab(tabId);
                    });
                    tab.setAttribute('listener-attached', 'true');
                }
            });
        }

        const setupDropZone = (dropZoneEl, uploaderEl, fileTypePrefix, uploadHandler) => {
            if (dropZoneEl && !dropZoneEl.hasAttribute('listener-attached')) {
                dropZoneEl.addEventListener('click', () => {
                    if (uploaderEl) uploaderEl.click();
                });
                dropZoneEl.addEventListener('dragover', (e) => { e.preventDefault(); dropZoneEl.classList.add('drag-over'); });
                dropZoneEl.addEventListener('dragleave', () => { dropZoneEl.classList.remove('drag-over'); });
                dropZoneEl.addEventListener('drop', (e) => {
                    e.preventDefault(); dropZoneEl.classList.remove('drag-over');
                    if (e.dataTransfer.files.length > 0) {
                        const file = e.dataTransfer.files[0];
                        if (file.type.startsWith(fileTypePrefix)) {
                            const mockEvent = { target: { files: [file] } };
                            uploadHandler(mockEvent);
                        } else {
                            displayMessage(`Please drop a ${fileTypePrefix.split('/')[0]} file.`, false);
                        }
                    }
                });
                dropZoneEl.setAttribute('listener-attached', 'true');
            }
        };
        setupDropZone(imageDropZoneEl, imageUploaderEl, 'image/', handleImageUpload);
        setupDropZone(audioDropZoneEl, audioUploaderEl, 'audio/', handleAudioUpload);

        const directInputs = [
            {el: objStrokeWidthEl, prop: 'strokeWidth', type: 'number'}, 
            {el: objOpacityEl, prop: 'opacity', type: 'range'}, 
            {el: objFontSizeEl, prop: 'fontSize', type: 'number'},
            {el: objLineHeightEl, prop: 'lineHeight', type: 'number', isFloat: true},
            {el: objCharSpacingEl, prop: 'charSpacing', type: 'number'},
            {el: objTextContentEl, prop: 'text', type: 'textarea'}
        ];
        directInputs.forEach(inputConfig => {
            if (inputConfig.el && !inputConfig.el.hasAttribute('listener-attached')) {
                const eventType = (inputConfig.el.type === 'range' || inputConfig.el.type === 'textarea') ? 'input' : 'change';
                inputConfig.el.addEventListener(eventType, (e) => {
                    updateFabricObjectFromToolbar(inputConfig.prop, e.target.value, inputConfig.type, inputConfig.isFloat);
                });
                inputConfig.el.setAttribute('listener-attached', 'true');
            } else if (!inputConfig.el) {
                 console.warn(`initToolbar: Direct input element for prop "${inputConfig.prop}" not found (this may be ok if it's in a popover, e.g. opacityEl).`);
            }
        });

        if (objOpacityEl && objOpacityValueDisplayEl && !objOpacityEl.hasAttribute('listener-opacity-display')) {
            objOpacityEl.addEventListener('input', function(e) {
                objOpacityValueDisplayEl.textContent = Math.round(parseFloat(e.target.value) * 100) + '%';
            });
            objOpacityEl.setAttribute('listener-opacity-display', 'true');
        }
        
        const positionInputs = [
            {el: objXEl, prop: 'left', type: 'number'}, {el: objYEl, prop: 'top', type: 'number'},
            {el: objWidthEl, prop: 'width', type: 'number', targetProp: 'scaleX'}, 
            {el: objHeightEl, prop: 'height', type: 'number', targetProp: 'scaleY'},
            {el: objAngleEl, prop: 'angle', type: 'number'}
        ];
        positionInputs.forEach(inputConfig => {
            if (inputConfig.el && !inputConfig.el.hasAttribute('listener-attached')) {
                 inputConfig.el.addEventListener('change', (e) => { 
                    updateFabricObjectFromToolbar(inputConfig.prop, e.target.value, inputConfig.type);
                });
                inputConfig.el.setAttribute('listener-attached', 'true');
            } else if (!inputConfig.el) {
                console.warn(`initToolbar: Position input element for prop "${inputConfig.prop}" not found.`);
            }
        });

        const colorInputs = [
            {el: objFillEl, prop: 'fill'},
            {el: objStrokeColorEl, prop: 'stroke'}
        ];
        colorInputs.forEach(inputConfig => {
            if (inputConfig.el && !inputConfig.el.hasAttribute('listener-attached')) {
                inputConfig.el.addEventListener('input', (e) => updateFabricObjectFromToolbar(inputConfig.prop, e.target.value));
                inputConfig.el.setAttribute('listener-attached', 'true');
            } else if (!inputConfig.el) {
                console.warn(`initToolbar: Color input element for prop "${inputConfig.prop}" not found.`);
            }
        });

        if (fontWeightButtonEl && !fontWeightButtonEl.hasAttribute('listener-attached')) {
            fontWeightButtonEl.addEventListener('click', () => {
                const activeObject = adminApp.state.fabricCanvasInstance.getActiveObject();
                if (!activeObject || !(activeObject.type === 'textbox' || activeObject.type === 'i-text')) return;
                const newValue = activeObject.fontWeight === 'bold' ? 'normal' : 'bold';
                updateFabricObjectFromToolbar('fontWeight', newValue);
                populateToolbar(activeObject); 
            });
            fontWeightButtonEl.setAttribute('listener-attached', 'true');
        } else if(!fontWeightButtonEl) { console.warn("initToolbar: fontWeightButtonEl not found."); }

        if (fontStyleButtonEl && !fontStyleButtonEl.hasAttribute('listener-attached')) {
            fontStyleButtonEl.addEventListener('click', () => {
                const activeObject = adminApp.state.fabricCanvasInstance.getActiveObject();
                if (!activeObject || !(activeObject.type === 'textbox' || activeObject.type === 'i-text')) return;
                const newValue = activeObject.fontStyle === 'italic' ? 'normal' : 'italic';
                updateFabricObjectFromToolbar('fontStyle', newValue);
                populateToolbar(activeObject); 
            });
            fontStyleButtonEl.setAttribute('listener-attached', 'true');
        } else if(!fontStyleButtonEl) { console.warn("initToolbar: fontStyleButtonEl not found."); }

        if (textAlignGroupEl && !textAlignGroupEl.hasAttribute('listener-attached')) {
            const alignButtons = textAlignGroupEl.querySelectorAll('.toolbar-button[data-align]');
            alignButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const activeObject = adminApp.state.fabricCanvasInstance.getActiveObject();
                    if (!activeObject || !(activeObject.type === 'textbox' || activeObject.type === 'i-text')) return;
                    const alignValue = button.dataset.align;
                    updateFabricObjectFromToolbar('textAlign', alignValue);
                    populateToolbar(activeObject); 
                });
            });
            textAlignGroupEl.setAttribute('listener-attached', 'true');
        } else if(!textAlignGroupEl) { console.warn("initToolbar: textAlignGroupEl not found."); }

        const shadowInputs = [ 
            {el: objShadowColorEl, prop: 'shadow.color', type: 'color'},
            {el: objShadowBlurEl, prop: 'shadow.blur', type: 'range'},
            {el: objShadowOffsetXEl, prop: 'shadow.offsetX', type: 'number'},
            {el: objShadowOffsetYEl, prop: 'shadow.offsetY', type: 'number'},
            {el: objShadowAffectStrokeEl, prop: 'shadow.affectStroke', type: 'checkbox'},
            {el: objShadowNonScalingEl, prop: 'shadow.nonScaling', type: 'checkbox'}
        ];
        shadowInputs.forEach(inputConfig => {
            if (inputConfig.el && !inputConfig.el.hasAttribute('listener-attached')) {
                const eventType = (inputConfig.el.type === 'color' || inputConfig.el.type === 'range') ? 'input' : 'change';
                inputConfig.el.addEventListener(eventType, (e) => {
                    const value = inputConfig.el.type === 'checkbox' ? e.target.checked : e.target.value;
                    updateFabricObjectFromToolbar(inputConfig.prop, value, inputConfig.type);
                });
                inputConfig.el.setAttribute('listener-attached', 'true');
            } else if(!inputConfig.el) { console.warn(`initToolbar: Shadow input element for prop "${inputConfig.prop}" not found.`);}
        });

        const editActionButtons = [
            { el: undoButtonEl, handler: handleUndo, critical: false },
            { el: redoButtonEl, handler: handleRedo, critical: false },
            { el: deleteObjectButtonEl, handler: handleDeleteObject, critical: true }
        ];

        editActionButtons.forEach(config => {
            if (config.el && !config.el.hasAttribute('listener-attached')) {
                config.el.addEventListener('click', config.handler);
                config.el.setAttribute('listener-attached', 'true');
            } else if (!config.el && config.critical) {
                console.warn(`initToolbar: Critical edit action button element not found (e.g., delete).`);
            }
        });
        updateUndoRedoButtonStates(); 

        if (objInteractionTriggerEl && !objInteractionTriggerEl.hasAttribute('listener-attached')) {
            objInteractionTriggerEl.addEventListener('change', handleInteractionChange); objInteractionTriggerEl.setAttribute('listener-attached', 'true');
        } else if(!objInteractionTriggerEl) { console.warn("initToolbar: objInteractionTriggerEl not found.");}
        if (objInteractionActionEl && !objInteractionActionEl.hasAttribute('listener-attached')) {
            objInteractionActionEl.addEventListener('change', handleInteractionChange); objInteractionActionEl.setAttribute('listener-attached', 'true');
        } else if(!objInteractionActionEl) { console.warn("initToolbar: objInteractionActionEl not found.");}
        if (objModalContentEl && !objModalContentEl.hasAttribute('listener-attached')) { 
            objModalContentEl.addEventListener('input', handleInteractionChange); objModalContentEl.setAttribute('listener-attached', 'true');
        } else if(!objModalContentEl) { console.warn("initToolbar: objModalContentEl (popover) not found.");}
        if (objNavigateToEl && !objNavigateToEl.hasAttribute('listener-attached')) { 
            objNavigateToEl.addEventListener('input', handleInteractionChange); objNavigateToEl.setAttribute('listener-attached', 'true');
        } else if(!objNavigateToEl) { console.warn("initToolbar: objNavigateToEl (popover) not found.");}
         if (objPanZoomLevelEl && !objPanZoomLevelEl.hasAttribute('listener-attached')) { 
             objPanZoomLevelEl.addEventListener('input', handleInteractionChange); objPanZoomLevelEl.setAttribute('listener-attached', 'true');
        } else if(!objPanZoomLevelEl) { console.warn("initToolbar: objPanZoomLevelEl (popover) not found.");}

        if (objAnimationTriggerEl && !objAnimationTriggerEl.hasAttribute('listener-attached')) {
            objAnimationTriggerEl.addEventListener('change', handleAnimationChange); objAnimationTriggerEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationTriggerEl) { console.warn("initToolbar: objAnimationTriggerEl not found.");}
        if (objAnimationTypeEl && !objAnimationTypeEl.hasAttribute('listener-attached')) {
            objAnimationTypeEl.addEventListener('change', handleAnimationChange); objAnimationTypeEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationTypeEl) { console.warn("initToolbar: objAnimationTypeEl not found.");}
        if (objAnimationSpeedEl && !objAnimationSpeedEl.hasAttribute('listener-attached')) { 
            objAnimationSpeedEl.addEventListener('change', handleAnimationChange); objAnimationSpeedEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationSpeedEl) { console.warn("initToolbar: objAnimationSpeedEl not found.");}
        if (objAnimationStrengthEl && !objAnimationStrengthEl.hasAttribute('listener-attached')) {
             objAnimationStrengthEl.addEventListener('input', handleAnimationChange); objAnimationStrengthEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationStrengthEl) { console.warn("initToolbar: objAnimationStrengthEl not found.");}
        if (objAnimationLoopEl && !objAnimationLoopEl.hasAttribute('listener-attached')) {
            objAnimationLoopEl.addEventListener('change', handleAnimationChange);
            objAnimationLoopEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationLoopEl) { console.warn("initToolbar: objAnimationLoopEl not found.");}
        
        if (objAnimationLoopCountEl && !objAnimationLoopCountEl.hasAttribute('listener-attached')) {
            objAnimationLoopCountEl.addEventListener('input', handleAnimationChange);
            objAnimationLoopCountEl.setAttribute('listener-attached', 'true');
        }
        if (objAnimationLoopDelayEl && !objAnimationLoopDelayEl.hasAttribute('listener-attached')) {
            objAnimationLoopDelayEl.addEventListener('input', handleAnimationChange);
            objAnimationLoopDelayEl.setAttribute('listener-attached', 'true');
        }
    }
    
    function populateToolbar(activeObject) {
        safeDOMUpdate(overlayPropertiesToolbarEl, el => el.style.display = 'block', "Failed to show overlay properties toolbar in populateToolbar");
        if (!overlayPropertiesToolbarEl) { console.error("populateToolbar: overlayPropertiesToolbarEl not found."); return; }

        const isObjectSelected = !!activeObject;
        const isTextObject = isObjectSelected && (activeObject.type === 'textbox' || activeObject.type === 'i-text');

        safeDOMUpdate(deleteObjectButtonEl, el => el.disabled = !isObjectSelected, "Failed to set deleteObjectButtonEl disabled state in populateToolbar");
        
        if (mediaToolsButtonEl) mediaToolsButtonEl.disabled = false; // These are not selection dependent
        if (addShapeButtonEl) addShapeButtonEl.disabled = false;   // These are not selection dependent

        safeDOMUpdate(textSpecificControlsEl, el => el.style.display = isTextObject ? 'flex' : 'none', "Failed to set textSpecificControlsEl display in populateToolbar");

        const generalObjectControlsAndTriggers = [
            objFillEl, objStrokeColorEl, objStrokeWidthEl, objOpacityEl, 
            positionToolsButtonEl, shadowSettingsButtonEl, interactionSettingsButtonEl, animationSettingsButtonEl 
        ];
        generalObjectControlsAndTriggers.forEach(control => {
            if (control) control.disabled = !isObjectSelected;
        });

        const textPropertyControlsAndTriggers = [
            fontFamilyButtonEl, 
            objFontSizeEl, objLineHeightEl, objCharSpacingEl, objTextContentEl, 
            fontWeightButtonEl, fontStyleButtonEl 
        ];
        if (textAlignGroupEl) { 
            textAlignGroupEl.querySelectorAll('.toolbar-button[data-align]').forEach(btn => textPropertyControlsAndTriggers.push(btn));
        }
        textPropertyControlsAndTriggers.forEach(control => {
            if (control) control.disabled = !isTextObject;
        });

        if (!isObjectSelected) {
            hideActivePopover(); 

            const popoverTriggerButtons = [positionToolsButtonEl, shadowSettingsButtonEl, interactionSettingsButtonEl, animationSettingsButtonEl, fontFamilyButtonEl];
            popoverTriggerButtons.forEach(btn => {
                if (btn) btn.classList.remove('active', 'popover-active');
            });

            if (fontWeightButtonEl) fontWeightButtonEl.classList.remove('active');
            if (fontStyleButtonEl) fontStyleButtonEl.classList.remove('active');
            if (textAlignGroupEl) {
                textAlignGroupEl.querySelectorAll('.toolbar-button[data-align]').forEach(btn => btn.classList.remove('active'));
            }
            
            if (objOpacityEl) objOpacityEl.value = 1; 
            if (objOpacityValueDisplayEl) objOpacityValueDisplayEl.textContent = '100%';

            if (fillColorButtonEl) fillColorButtonEl.classList.remove('active');
            if (strokeColorButtonEl) strokeColorButtonEl.classList.remove('active');
            if (opacityButtonEl) opacityButtonEl.classList.remove('active');

            return; 
        }
        
        if (objXEl) objXEl.value = activeObject.left !== undefined ? activeObject.left.toFixed(0) : 0;
        if (objYEl) objYEl.value = activeObject.top !== undefined ? activeObject.top.toFixed(0) : 0;
        if (objWidthEl) objWidthEl.value = activeObject.getScaledWidth ? activeObject.getScaledWidth().toFixed(0) : (activeObject.width || 0);
        if (objHeightEl) objHeightEl.value = activeObject.getScaledHeight ? activeObject.getScaledHeight().toFixed(0) : (activeObject.height || 0);
        if (objAngleEl) objAngleEl.value = activeObject.angle !== undefined ? activeObject.angle.toFixed(0) : 0;
        
        if (objFillEl) objFillEl.value = toHexColor(activeObject.fill);
        if (objStrokeColorEl) objStrokeColorEl.value = toHexColor(activeObject.stroke);
        if (objStrokeWidthEl) objStrokeWidthEl.value = activeObject.strokeWidth === undefined ? 0 : activeObject.strokeWidth;
        if (objOpacityEl) { 
            objOpacityEl.value = activeObject.opacity === undefined ? 1 : activeObject.opacity; // Input value
            safeDOMUpdate(objOpacityValueDisplayEl, 
              el => el.textContent = Math.round(parseFloat(objOpacityEl.value) * 100) + '%',
              "Failed to update opacity value display in populateToolbar");
        }

        if (isTextObject) { 
            if (objTextContentEl) objTextContentEl.value = activeObject.text || ''; // Input value
            if (objFontFamilyEl) objFontFamilyEl.value = activeObject.fontFamily || 'Arial';  // Input value
            if (objFontSizeEl) objFontSizeEl.value = activeObject.fontSize || 24; // Input value
            if (objLineHeightEl) objLineHeightEl.value = activeObject.lineHeight === undefined ? 1.16 : activeObject.lineHeight; // Input value
            if (objCharSpacingEl) objCharSpacingEl.value = activeObject.charSpacing === undefined ? 0 : activeObject.charSpacing; // Input value

            if (fontWeightButtonEl) fontWeightButtonEl.classList.toggle('active', activeObject.fontWeight === 'bold');
            if (fontStyleButtonEl) fontStyleButtonEl.classList.toggle('active', activeObject.fontStyle === 'italic');
            if (textAlignGroupEl) {
                textAlignGroupEl.querySelectorAll('.toolbar-button[data-align]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.align === activeObject.textAlign);
                });
            }
            if (objFontWeightEl) objFontWeightEl.value = activeObject.fontWeight || 'normal'; // Input value
            if (objFontStyleEl) objFontStyleEl.value = activeObject.fontStyle || 'normal'; // Input value
            if (objTextAlignEl) objTextAlignEl.value = activeObject.textAlign || 'left'; // Input value
        }

        const shadow = activeObject.shadow instanceof fabric.Shadow ? activeObject.shadow : null;
        if (objShadowColorEl) objShadowColorEl.value = shadow ? toHexColor(shadow.color) : '#000000'; // Input value
        if (objShadowBlurEl) objShadowBlurEl.value = shadow ? shadow.blur : 0; // Input value
        if (objShadowOffsetXEl) objShadowOffsetXEl.value = shadow ? shadow.offsetX : 0; // Input value
        if (objShadowOffsetYEl) objShadowOffsetYEl.value = shadow ? shadow.offsetY : 0; // Input value
        if (objShadowAffectStrokeEl) objShadowAffectStrokeEl.checked = shadow ? !!shadow.affectStroke : false; // Input checked
        if (objShadowNonScalingEl) objShadowNonScalingEl.checked = shadow ? !!shadow.nonScaling : false; // Input checked
        if (shadowSettingsButtonEl) shadowSettingsButtonEl.classList.toggle('active', !!shadow);

        if (fillColorButtonEl) {
            const hasFill = activeObject.fill && activeObject.fill !== 'transparent' && 
                            (typeof activeObject.fill !== 'object' || activeObject.fill.type !== 'gradient' || activeObject.fill.colorStops.length > 0);
            fillColorButtonEl.classList.toggle('active', !!hasFill);
        }

        if (strokeColorButtonEl) {
            const hasStroke = activeObject.stroke && activeObject.strokeWidth > 0;
            strokeColorButtonEl.classList.toggle('active', hasStroke);
        }

        if (opacityButtonEl) {
            const isTranslucent = activeObject.opacity !== undefined && activeObject.opacity < 1;
            opacityButtonEl.classList.toggle('active', isTranslucent);
        }

        const interaction = activeObject.customInteraction || { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
        if (objInteractionTriggerEl) objInteractionTriggerEl.value = interaction.trigger || ""; // Input value
        if (objInteractionActionEl) objInteractionActionEl.value = interaction.action || ""; // Input value
        if (objModalContentEl) objModalContentEl.value = interaction.modalContent || ""; // Input value
        if (objNavigateToEl) objNavigateToEl.value = interaction.navigateTo || ""; // Input value
        if (objPanZoomLevelEl) objPanZoomLevelEl.value = interaction.panZoomLevel === undefined ? 1.5 : interaction.panZoomLevel; // Input value
        updateInteractionConfigVisibility(interaction.action);
        if (interactionSettingsButtonEl) interactionSettingsButtonEl.classList.toggle('active', !!(interaction.trigger && interaction.action));

        const animation = activeObject.customAnimation || { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
        if (objAnimationTriggerEl) objAnimationTriggerEl.value = animation.trigger || ""; // Input value
        if (objAnimationTypeEl) objAnimationTypeEl.value = animation.type || ""; // Input value
        const showAnimParams = !!(animation.trigger && animation.type);
        const animParamsConfig = animationPopoverEl ? animationPopoverEl.querySelector('#animationParamsConfig') : null;
        safeDOMUpdate(animParamsConfig, el => el.style.display = showAnimParams ? 'block' : 'none', "Failed to update animation params config display in populateToolbar");
        
        if (showAnimParams) {
            if (objAnimationSpeedEl) objAnimationSpeedEl.value = animation.speed || "normal"; // Input value
            if (objAnimationStrengthEl) objAnimationStrengthEl.value = animation.strength === undefined ? 5 : animation.strength; // Input value
            updateAnimationStrengthUnit(animation.type);
            if (objAnimationLoopEl) objAnimationLoopEl.value = animation.loop ? "true" : "false"; // Input value
        }
        if (animationSettingsButtonEl) animationSettingsButtonEl.classList.toggle('active', showAnimParams);
    }
    function handleInteractionChange() {
        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas) return;
        const activeObject = canvas.getActiveObject();
        if (!activeObject) return;
        if (!activeObject.customInteraction) { activeObject.customInteraction = { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 }; }

        if (objInteractionTriggerEl) activeObject.customInteraction.trigger = objInteractionTriggerEl.value;
        if (objInteractionActionEl) activeObject.customInteraction.action = objInteractionActionEl.value;
        if (objModalContentEl) activeObject.customInteraction.modalContent = objModalContentEl.value;
        if (objNavigateToEl) activeObject.customInteraction.navigateTo = objNavigateToEl.value;
        if (objPanZoomLevelEl) activeObject.customInteraction.panZoomLevel = parseFloat(objPanZoomLevelEl.value) || 1.5;

        updateInteractionConfigVisibility(activeObject.customInteraction.action);
        if (interactionSettingsButtonEl) interactionSettingsButtonEl.classList.toggle('active', !!(activeObject.customInteraction.trigger && activeObject.customInteraction.action));
        console.log("Interaction data updated for object:", activeObject.customInteraction);
        canvas.renderAll(); 
        saveCanvasStateForHistory();
    }

    function updateInteractionConfigVisibility(action) {
        const modalConfig = interactionPopoverEl ? interactionPopoverEl.querySelector('#modalContentConfig') : null;
        const navigateConfig = interactionPopoverEl ? interactionPopoverEl.querySelector('#navigateToConfig') : null;
        const panZoomConfig = interactionPopoverEl ? interactionPopoverEl.querySelector('#panZoomConfigEl') : null;

        const showModal = action === 'showModal';
        const showNavigate = action === 'navigateToSlide' || action === 'navigateToURL';
        const showPanZoomConfig = action === 'panZoomToTarget';

        safeDOMUpdate(modalConfig, el => el.style.display = showModal ? 'block' : 'none', "Failed to update modal config visibility in updateInteractionConfigVisibility");
        safeDOMUpdate(navigateConfig, el => el.style.display = showNavigate ? 'block' : 'none', "Failed to update navigate config visibility in updateInteractionConfigVisibility");
        safeDOMUpdate(panZoomConfig, el => el.style.display = showPanZoomConfig ? 'block' : 'none', "Failed to update pan/zoom config visibility in updateInteractionConfigVisibility");
    }

    function updateAnimationStrengthUnit(animationType) {
        const strengthUnitEl = animationPopoverEl ? animationPopoverEl.querySelector('#objAnimationStrengthUnit') : null;
        if (!strengthUnitEl) return;

        let unitText = "(pixels/degrees/scale)"; 
        switch(animationType) {
            case 'wiggle': unitText = "(degrees)"; break;
            case 'float': unitText = "(pixels)"; break;
            case 'growShrink': unitText = "(scale factor e.g., 1.2)"; break;
        }
        safeDOMUpdate(strengthUnitEl, el => el.textContent = unitText, "Failed to update animation strength unit text in updateAnimationStrengthUnit");
    }

    function handleAnimationChange() {
        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas) return;
        const activeObject = canvas.getActiveObject();
        if (!activeObject) return;

        if (!activeObject.customAnimation) {
            activeObject.customAnimation = { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
        }

        if (objAnimationTriggerEl) activeObject.customAnimation.trigger = objAnimationTriggerEl.value;
        if (objAnimationTypeEl) activeObject.customAnimation.type = objAnimationTypeEl.value;
        
        const showAnimParams = !!(activeObject.customAnimation.trigger && activeObject.customAnimation.type);
        const animParamsConfig = animationPopoverEl ? animationPopoverEl.querySelector('#animationParamsConfig') : null;
        safeDOMUpdate(animParamsConfig, el => el.style.display = showAnimParams ? 'block' : 'none', "Failed to update animation params config display on change in handleAnimationChange");

        if (showAnimParams) {
            if (objAnimationSpeedEl) activeObject.customAnimation.speed = objAnimationSpeedEl.value;
            switch(activeObject.customAnimation.speed) {
                case 'slow': activeObject.customAnimation.duration = 1500; break;
                case 'fast': activeObject.customAnimation.duration = 500; break;
                default: activeObject.customAnimation.duration = 1000; 
            }
            
            if (objAnimationStrengthEl) activeObject.customAnimation.strength = parseFloat(objAnimationStrengthEl.value) || 5;
            updateAnimationStrengthUnit(activeObject.customAnimation.type);
            if (objAnimationLoopEl) activeObject.customAnimation.loop = objAnimationLoopEl.value === "true";
            
            delete activeObject.customAnimation.loopCount;
            delete activeObject.customAnimation.loopDelay; 

        } else { 
            activeObject.customAnimation.trigger = "";
            activeObject.customAnimation.type = "";
            activeObject.customAnimation.speed = "normal";
            activeObject.customAnimation.duration = 1000;
            activeObject.customAnimation.strength = 5;
            activeObject.customAnimation.loop = false;
            delete activeObject.customAnimation.loopCount;
            delete activeObject.customAnimation.loopDelay;
            updateAnimationStrengthUnit(""); 
        }
        if (animationSettingsButtonEl) animationSettingsButtonEl.classList.toggle('active', showAnimParams);
        console.log("Animation data updated for object:", activeObject.customAnimation);
        canvas.renderAll();
        saveCanvasStateForHistory();
    }

    function updateFabricObjectFromToolbar(propertyName, value, inputType, isFloat = false) {
      const canvas = adminApp.state.fabricCanvasInstance;
      if (!canvas) return;
      const activeObject = canvas.getActiveObject();
      if (!activeObject) return;

      let parsedValue = value;
      if (inputType === 'number') {
          parsedValue = isFloat ? parseFloat(value) : parseInt(value, 10);
          if (isNaN(parsedValue)) {
              if ((propertyName === 'strokeWidth' || propertyName === 'charSpacing') && value === '') parsedValue = 0;
              else if (value === '') return; 
              else return; 
          }
      } else if (inputType === 'range') { 
          parsedValue = parseFloat(value);
          if (isNaN(parsedValue)) return;
      } else if (inputType === 'checkbox') { 
          parsedValue = !!value; 
      }

      if (propertyName === 'width') { 
          const newWidth = parseFloat(value);
          if (!isNaN(newWidth) && newWidth >= 0) {
            activeObject.scaleX = newWidth > 0 ? (newWidth / activeObject.width) : (activeObject.width > 0 ? 0.0001 / activeObject.width : 0.0001);
          }
      } else if (propertyName === 'height') { 
          const newHeight = parseFloat(value);
           if (!isNaN(newHeight) && newHeight >= 0) {
            activeObject.scaleY = newHeight > 0 ? (newHeight / activeObject.height) : (activeObject.height > 0 ? 0.0001 / activeObject.height : 0.0001);
           }
      } else if (propertyName.startsWith('shadow.')) {
        const shadowPropKey = propertyName.split('.')[1]; 
        let shadowOptions = activeObject.shadow instanceof fabric.Shadow ? activeObject.shadow.toObject() : {};
        
        shadowOptions[shadowPropKey] = parsedValue;

        if (shadowPopoverEl) { 
            const popoverShadowColorEl = shadowPopoverEl.querySelector('#objShadowColor');
            const popoverShadowBlurEl = shadowPopoverEl.querySelector('#objShadowBlur');
            const popoverShadowOffsetXEl = shadowPopoverEl.querySelector('#objShadowOffsetX');
            const popoverShadowOffsetYEl = shadowPopoverEl.querySelector('#objShadowOffsetY');
            const popoverShadowAffectStrokeEl = shadowPopoverEl.querySelector('#objShadowAffectStroke');
            const popoverShadowNonScalingEl = shadowPopoverEl.querySelector('#objShadowNonScaling');

            if (popoverShadowColorEl) shadowOptions.color = popoverShadowColorEl.value || '#000000';
            if (popoverShadowBlurEl) shadowOptions.blur = parseFloat(popoverShadowBlurEl.value) || 0;
            if (popoverShadowOffsetXEl) shadowOptions.offsetX = parseInt(popoverShadowOffsetXEl.value, 10) || 0;
            if (popoverShadowOffsetYEl) shadowOptions.offsetY = parseInt(popoverShadowOffsetYEl.value, 10) || 0;
            if (popoverShadowAffectStrokeEl) shadowOptions.affectStroke = popoverShadowAffectStrokeEl.checked;
            if (popoverShadowNonScalingEl) shadowOptions.nonScaling = popoverShadowNonScalingEl.checked;
        }
        
        if (shadowOptions.blur > 0 || shadowOptions.offsetX !== 0 || shadowOptions.offsetY !== 0 || 
            (shadowOptions.color && shadowOptions.color !== '#000000' && shadowOptions.color.toLowerCase() !== 'rgb(0,0,0)' && shadowOptions.color.toLowerCase() !== 'rgba(0,0,0,0)')) {
            activeObject.set('shadow', new fabric.Shadow(shadowOptions));
        } else {
            activeObject.set('shadow', null); 
        }
        if (shadowSettingsButtonEl) shadowSettingsButtonEl.classList.toggle('active', !!activeObject.shadow);

      } else {
        if (!propertyName.startsWith('customInteraction.') && !propertyName.startsWith('customAnimation.')) {
             activeObject.set(propertyName, parsedValue);
             if (propertyName === 'fontWeight' && objFontWeightEl) objFontWeightEl.value = parsedValue;
             if (propertyName === 'fontStyle' && objFontStyleEl) objFontStyleEl.value = parsedValue;
             if (propertyName === 'textAlign' && objTextAlignEl) objTextAlignEl.value = parsedValue;
        }
      }

      if ((activeObject.type === 'textbox' || activeObject.type === 'i-text') &&
          ['text', 'fontSize', 'fontWeight', 'fontStyle', 'fontFamily', 'lineHeight', 'charSpacing', 'textAlign'].includes(propertyName)) {
          activeObject.initDimensions(); 
      }
      activeObject.setCoords(); 
      canvas.renderAll();
      // Do NOT call populateToolbar here.
      // Call saveCanvasStateForHistory only if it's not a shadow property being actively dragged (range/color)
      // to avoid too many history states. For discrete changes (like number input 'change'), it's fine.
      if (inputType !== 'range' && inputType !== 'color' && !propertyName.startsWith('shadow.')) {
        saveCanvasStateForHistory();
      }
    }

    // --- Utilities ---
    var Utilities = { 
        getUuid: function() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); },
        generateUuid: function() { // Same implementation as getUuid or a new one if preferred
          return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); });
        } 
    };

    function extractYouTubeVideoId(url) {
        if (!url) return null;
        let videoId = null;
        try {
            const urlObj = new URL(url); // Try direct URL parsing first
            if ((urlObj.hostname === 'www.youtube.com' || urlObj.hostname === 'youtube.com') && urlObj.searchParams.has('v')) {
                videoId = urlObj.searchParams.get('v');
            } else if (urlObj.hostname === 'youtu.be') {
                videoId = urlObj.pathname.substring(1);
            }
        } catch (e) {
            // Fallback for simpler regex if URL parsing fails (e.g. not a full URL)
            // This regex is more robust for various YouTube URL formats.
            const regex = /(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
            const match = url.match(regex);
            if (match) videoId = match[1];
        }
        if (!videoId) console.warn("Could not extract YouTube Video ID from URL:", url);
        return videoId;
    }

    function debounce(func, delay) {
        let timeout;
        return function(...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), delay);
        };
    }

    function handleWindowResize() {
        if (adminApp.state.currentView === 'edit' && adminApp.state.fabricCanvasInstance) {
            console.log("Window resized, attempting to refit canvas.");
            const currentSlide = (adminApp.state.currentSlideIndex !== -1 && adminApp.state.projectData && adminApp.state.projectData.slides) ? 
                                 adminApp.state.projectData.slides[adminApp.state.currentSlideIndex] : 
                                 null;
            adminApp.resizeCanvasToFit(currentSlide);
        }
    }

    adminApp.attachVideoQuestionEventListeners = function() {
        if (videoTimelineSliderEl) {
            videoTimelineSliderEl.addEventListener('input', function() {
                if (adminApp.state.adminYouTubePlayer && typeof adminApp.state.adminYouTubePlayer.seekTo === 'function') {
                    adminApp.state.adminYouTubePlayer.seekTo(this.value, true);
                }
            });
        }

        if (addQuestionBtnEl) {
            addQuestionBtnEl.addEventListener('click', function() {
                if (isYouTubePlayerAvailable() && adminApp.state.adminYouTubePlayer && typeof adminApp.state.adminYouTubePlayer.pauseVideo === 'function') {
                    adminApp.state.adminYouTubePlayer.pauseVideo();
                }
                const currentTime = safeGetCurrentTime(adminApp.state.adminYouTubePlayer);
                safeDOMUpdate(questionTimestampDisplayEl, el => {
                    el.textContent = formatTime(currentTime);
                    if(questionModalEl) questionModalEl.dataset.rawTimestamp = currentTime;
                }, "Failed to set question timestamp display in addQuestionBtn click");

                if(questionTextEl) questionTextEl.value = '';
                optionInputsEl.forEach(input => { if(input) input.value = ''; });
                correctAnswerRadiosEl.forEach(radio => { if(radio) radio.checked = false; });
                if(editingQuestionIndexEl) editingQuestionIndexEl.value = '-1';

                safeDOMUpdate(questionModalEl, el => el.style.display = 'block', "Failed to show question modal in addQuestionBtn click");
            });
        }

        if (saveQuestionBtnEl) {
            saveQuestionBtnEl.addEventListener('click', function() {
                const currentSlide = getCurrentSlide();
                if (!currentSlide || !currentSlide.slideMedia || currentSlide.slideMedia.type !== 'youtube') {
                    displayMessage("Not a YouTube slide or slide data missing.", false);
                    return;
                }

                const questionText = questionTextEl ? questionTextEl.value.trim() : '';
                if (!questionText) {
                    displayMessage("Question text cannot be empty.", false);
                    return;
                }

                const options = optionInputsEl.map(input => input ? input.value.trim() : '').filter(opt => opt !== '');
                if (options.length < 2) { 
                    displayMessage("Please provide at least two options.", false);
                    return;
                }

                let correctOptionIndex = -1;
                for (let i = 0; i < correctAnswerRadiosEl.length; i++) {
                    if (correctAnswerRadiosEl[i] && correctAnswerRadiosEl[i].checked) {
                        correctOptionIndex = i;
                        break;
                    }
                }
                if (correctOptionIndex === -1 || correctOptionIndex >= options.length) { 
                    displayMessage("Please select a correct answer from the provided options.", false);
                    return;
                }
                
                const timestamp = questionModalEl && questionModalEl.dataset.rawTimestamp ? parseFloat(questionModalEl.dataset.rawTimestamp) : 0;

                const questionData = {
                    timestamp: timestamp,
                    questionText: questionText,
                    options: options,
                    correctOptionIndex: correctOptionIndex
                };

                const editIndex = editingQuestionIndexEl ? parseInt(editingQuestionIndexEl.value, 10) : -1;

                if (!Array.isArray(currentSlide.slideMedia.videoQuestions)) {
                    currentSlide.slideMedia.videoQuestions = [];
                }

                if (editIndex === -1) { 
                    currentSlide.slideMedia.videoQuestions.push(questionData);
                } else { 
                    currentSlide.slideMedia.videoQuestions[editIndex] = questionData;
                }
                
                currentSlide.slideMedia.videoQuestions.sort((a, b) => a.timestamp - b.timestamp);

                console.log("videoQuestions array after save:", currentSlide.slideMedia.videoQuestions); 

                displayMessage("Question saved!", true);
                safeDOMUpdate(questionModalEl, el => el.style.display = 'none', "Failed to hide question modal after save in saveQuestionBtn click");
                renderVideoQuestionsList(); 
            });
        }

        if (cancelQuestionBtnEl) {
            cancelQuestionBtnEl.addEventListener('click', function() {
                safeDOMUpdate(questionModalEl, el => el.style.display = 'none', "Failed to hide question modal on cancel in cancelQuestionBtn click");
            });
        }

        // --- Timestamp Overlay Modal Button Listeners ---
        // Removed event listeners for manageTimestampOverlaysButtonEl and addTimestampOverlayButtonEl as per plan
        
        // The close button for timestampOverlayModal already has an inline onclick in AdminView.html
        // If you prefer to manage it here:
        // if (closeTimestampOverlayModalBtnEl && !closeTimestampOverlayModalBtnEl.hasAttribute('listener-attached')) {
        //    closeTimestampOverlayModalBtnEl.onclick = null; // Remove inline listener if any
        //    closeTimestampOverlayModalBtnEl.addEventListener('click', () => {
        //        if (timestampOverlayModalEl) timestampOverlayModalEl.style.display = 'none';
        //        if (adminApp.state.activePopoverId === 'timestampOverlayModal') {
        //            adminApp.state.activePopoverId = null; // Clear active state
        //        }
        //    });
        //    closeTimestampOverlayModalBtnEl.setAttribute('listener-attached', 'true');
        // }

    // --- NEW Video Overlay Event Listeners ---
    const addVideoOverlayBtn = document.getElementById('addVideoOverlayBtn');
    if (addVideoOverlayBtn) {
        addVideoOverlayBtn.addEventListener('click', initiateOverlayPlacement);
    }

    const placementOverlay = document.getElementById('overlayPlacementOverlay');
    if (placementOverlay) {
        placementOverlay.addEventListener('click', handleOverlayPlacement);
    }

    const saveOverlayBtn = document.getElementById('saveOverlayBtn');
    if (saveOverlayBtn) {
        saveOverlayBtn.addEventListener('click', saveOverlay);
    }

    const cancelOverlayBtn = document.getElementById('cancelOverlayBtn');
    if (cancelOverlayBtn) {
        cancelOverlayBtn.addEventListener('click', hideOverlayEditor);
    }

    const deleteOverlayBtn = document.getElementById('deleteOverlayBtn');
    if (deleteOverlayBtn) {
        deleteOverlayBtn.addEventListener('click', deleteCurrentOverlay);
    }

    const previewOverlaysBtn = document.getElementById('previewOverlaysBtn');
    if (previewOverlaysBtn) {
        previewOverlaysBtn.addEventListener('click', toggleOverlayPreview);
    }
    
    console.log("Video overlay event listeners attached.");
    };

    function updateVideoToolsVisibility(show) {
        safeDOMUpdate(videoTimelineControlsEl, 
          el => el.style.display = show ? 'block' : 'none', 
          "Failed to update video timeline controls display in updateVideoToolsVisibility");
        if (show && !videoTimelineControlsEl) { 
            console.warn("updateVideoToolsVisibility: videoTimelineControlsEl not found.");
        }
        safeDOMUpdate(videoQuestionsListContainerEl, 
          el => el.style.display = show ? 'block' : 'none',
          "Failed to update video questions list container display in updateVideoToolsVisibility");
        if (show && !videoQuestionsListContainerEl) { 
            console.warn("updateVideoToolsVisibility: videoQuestionsListContainerEl not found.");
        }
    }

    function renderVideoQuestionsList() {
        if (!videoQuestionsListEl) {
            console.warn("renderVideoQuestionsList: videoQuestionsListEl not found.");
            return;
        }
        
        safeDOMUpdate(videoQuestionsListEl, el => {
            el.innerHTML = ''; // Clear existing list

            const currentSlide = getCurrentSlide();
            if (!currentSlide || !currentSlide.slideMedia || currentSlide.slideMedia.type !== 'youtube' || !currentSlide.slideMedia.videoQuestions || currentSlide.slideMedia.videoQuestions.length === 0) {
                const li = document.createElement('li');
                li.textContent = "No questions added yet.";
                li.style.fontStyle = "italic";
                el.appendChild(li);
                return;
            }

            const questions = currentSlide.slideMedia.videoQuestions;
            console.log("Rendering questions list:", questions); 

            questions.forEach((question, index) => {
                const li = document.createElement('li');
                li.style.marginBottom = "8px";
                li.style.padding = "5px";
                li.style.border = "1px solid #eee"; 
                li.style.borderRadius = "3px";
                li.style.display = "flex"; 
                li.style.justifyContent = "space-between"; 
                li.style.alignItems = "center"; 

                const questionTextSpan = document.createElement('span'); 
                questionTextSpan.textContent = `[${formatTime(question.timestamp)}] ${question.questionText.substring(0, 40)}${question.questionText.length > 40 ? '...' : ''}`;
                questionTextSpan.style.flexGrow = "1"; 
                
                const actionsDiv = document.createElement('div');
                actionsDiv.style.whiteSpace = "nowrap"; 

                const editBtn = document.createElement('button');
                editBtn.textContent = 'Edit';
                editBtn.style.marginLeft = '5px'; 
                editBtn.style.padding = '3px 8px';
                editBtn.style.fontSize = '0.8em';
                editBtn.className = 'edit-button'; 
                editBtn.onclick = function() {
                    console.log("Editing question index:", index, questions[index]); 

                    if (adminApp.state.adminYouTubePlayer && typeof adminApp.state.adminYouTubePlayer.pauseVideo === 'function') {
                        adminApp.state.adminYouTubePlayer.pauseVideo();
                    }
                    
                    safeDOMUpdate(questionTimestampDisplayEl, tsEl => tsEl.textContent = formatTime(question.timestamp), "Failed to set question timestamp display on edit in renderVideoQuestionsList");
                    if(questionModalEl) questionModalEl.dataset.rawTimestamp = question.timestamp;
                    if(questionTextEl) questionTextEl.value = question.questionText;

                    optionInputsEl.forEach((input, i) => {
                        if(input) input.value = question.options[i] || '';
                    });
                    correctAnswerRadiosEl.forEach((radio, i) => {
                        if(radio) radio.checked = (i === question.correctOptionIndex && i < question.options.length);
                    });
                    
                    if(editingQuestionIndexEl) editingQuestionIndexEl.value = index;
                    safeDOMUpdate(questionModalEl, modalEl => modalEl.style.display = 'block', "Failed to show question modal on edit in renderVideoQuestionsList");
                };

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.className = 'danger-button'; 
                deleteBtn.style.marginLeft = '5px';
                deleteBtn.style.padding = '3px 8px'; 
                deleteBtn.style.fontSize = '0.8em';
                deleteBtn.onclick = function() {
                    if (confirm(`Are you sure you want to delete the question: "${question.questionText.substring(0,30)}..."?`)) {
                        console.log("Deleting question index:", index); 

                        currentSlide.slideMedia.videoQuestions.splice(index, 1);
                        renderVideoQuestionsList(); 
                        displayMessage("Question deleted.", true);
                    }
                };
                
                actionsDiv.appendChild(editBtn);
                actionsDiv.appendChild(deleteBtn);
                
                li.appendChild(questionTextSpan);
                li.appendChild(actionsDiv);

                el.appendChild(li);
            });
        }, "Failed to render video questions list");
    }

    function formatTime(totalSeconds) {
        totalSeconds = Math.floor(totalSeconds);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    }
    // Removed handleAddTimestampOverlay, populateTimestampOverlayList, editTimestampOverlayTimes, and editTimestampOverlay functions

function stopAndDestroyAdminYouTubePlayer() {
    try {
        // Clear any running intervals
        if (adminApp.state.playerUpdateInterval) {
            clearInterval(adminApp.state.playerUpdateInterval);
            adminApp.state.playerUpdateInterval = null;
        }
        
        // Stop and destroy player
        if (adminApp.state.adminYouTubePlayer) {
            if (typeof adminApp.state.adminYouTubePlayer.stopVideo === 'function') {
                adminApp.state.adminYouTubePlayer.stopVideo();
            }
            if (typeof adminApp.state.adminYouTubePlayer.destroy === 'function') {
                adminApp.state.adminYouTubePlayer.destroy();
            }
        }
    } catch (e) {
        console.error("Error destroying admin YouTube player:", e);
    } finally {
        adminApp.state.adminYouTubePlayer = null;
        
        // Clean up container
        safeDOMUpdate(adminYouTubePlayerContainerEl, el => {
            el.innerHTML = '';
            el.style.display = 'none';
        }, "Failed to clean up YouTube player container on destroy in stopAndDestroyAdminYouTubePlayer");
        
        // Hide timeline controls
        updateVideoToolsVisibility(false);
    }
}
</script>