<script>
  // Namespace for the admin application
  window.adminApp = {};

  // --- Application State ---
  adminApp.state = {
    isLoading: false,
    currentProjectId: null,
    currentView: 'list',
    projectData: null, // Will be populated by loadProjectForEditing
    currentSlideIndex: -1, // Index of the active slide in projectData.slides
    fabricCanvasInstance: null,
    defaultCanvasWidth: 960, // Default new slide width
    defaultCanvasHeight: 540  // Default new slide height (16:9)
  };

  // --- DOM Element References ---
  let projectTitleInputEl, createProjectButtonEl, messageAreaEl, loadingSpinnerEl;
  let listViewContainerEl, adminProjectListContainerEl;
  let editViewContainerEl, editingProjectTitleEl, backToProjectsListButtonEl, fabricCanvasEl;
  let imageUploaderEl;
  let addSlideButtonEl, slideThumbnailsContainerEl, saveProjectButtonEl; // Step 9
  let addRectangleButtonEl, addCircleButtonEl; // Step 11
  let addTextboxButtonEl; // Step 12

  // Sidebar Element References (Step 13)
  let overlaySidebarEl, objXEl, objYEl, objWidthEl, objHeightEl, objAngleEl,
      objFillEl, objStrokeColorEl, objStrokeWidthEl, objOpacityEl,
      textSpecificControlsEl, objTextContentEl,
      objShadowColorEl, objShadowBlurEl, objShadowOffsetXEl, objShadowOffsetYEl;

  // --- Initialization ---
  document.addEventListener('DOMContentLoaded', function() {
    console.log("Admin_JS: DOMContentLoaded event fired!");
    adminApp.setupDOMReferences();
    adminApp.attachEventListeners();
    switchToListView();
    loadAdminProjectsList(); // Load project list on initial view
    console.log("Admin_JS: Initialization complete.");
  });

  // --- Setup and Listeners ---
  adminApp.setupDOMReferences = function() {
    messageAreaEl = document.getElementById('messageArea');
    loadingSpinnerEl = document.getElementById('loadingSpinner');
    listViewContainerEl = document.getElementById('listViewContainer');
    projectTitleInputEl = document.getElementById('projectTitleInput');
    createProjectButtonEl = document.getElementById('createProjectButton');
    adminProjectListContainerEl = document.getElementById('adminProjectListContainer');
    editViewContainerEl = document.getElementById('editViewContainer');
    editingProjectTitleEl = document.getElementById('editingProjectTitle');
    backToProjectsListButtonEl = document.getElementById('backToProjectsListButton');
    fabricCanvasEl = document.getElementById('fabricCanvasElement');
    imageUploaderEl = document.getElementById('imageUploader');
    addSlideButtonEl = document.getElementById('addSlideButton');
    slideThumbnailsContainerEl = document.getElementById('slideThumbnailsContainer');
    saveProjectButtonEl = document.getElementById('saveProjectButton');
    
    // Step 11: Overlay tool buttons
    addRectangleButtonEl = document.getElementById('addRectangleButton');
    addCircleButtonEl = document.getElementById('addCircleButton');
    // Step 12: Textbox button
    addTextboxButtonEl = document.getElementById('addTextboxButton');

    // Step 13: Sidebar elements
    overlaySidebarEl = document.getElementById('overlaySidebar');
    objXEl = document.getElementById('objX');
    objYEl = document.getElementById('objY');
    objWidthEl = document.getElementById('objWidth');
    objHeightEl = document.getElementById('objHeight');
    objAngleEl = document.getElementById('objAngle');
    objFillEl = document.getElementById('objFill');
    objStrokeColorEl = document.getElementById('objStrokeColor');
    objStrokeWidthEl = document.getElementById('objStrokeWidth');
    objOpacityEl = document.getElementById('objOpacity');
    textSpecificControlsEl = document.getElementById('textSpecificControls');
    objTextContentEl = document.getElementById('objTextContent');
    objShadowColorEl = document.getElementById('objShadowColor');
    objShadowBlurEl = document.getElementById('objShadowBlur');
    objShadowOffsetXEl = document.getElementById('objShadowOffsetX');
    objShadowOffsetYEl = document.getElementById('objShadowOffsetY');

    // Add warnings for elements only expected in edit view
    if (!addSlideButtonEl) console.warn("addSlideButtonEl not found during initial setup.");
    if (!slideThumbnailsContainerEl) console.warn("slideThumbnailsContainerEl not found during initial setup.");
    if (!saveProjectButtonEl) console.warn("saveProjectButtonEl not found during initial setup.");
    if (!imageUploaderEl) console.warn("imageUploaderEl not found during initial setup.");
    if (!fabricCanvasEl) console.warn("fabricCanvasEl not found during initial setup.");
    console.log("Admin_JS: DOM references set up.");
  };

  adminApp.attachEventListeners = function() {
    const safelyAddListener = (element, eventType, handler, elementName) => {
        if (element) {
            element.addEventListener(eventType, handler);
        } else {
            // Log warning only if element is expected globally (like create button)
            if (elementName === 'createProjectButtonEl') console.warn(`Could not attach listener - ${elementName} not found initially.`);
        }
    };
    safelyAddListener(createProjectButtonEl, 'click', handleCreateProject, 'createProjectButtonEl');
    // Listeners for edit view elements will be attached/re-attached in switchToEditView
    console.log("Admin_JS: Initial event listeners attached.");
  };

  // --- UI View Management ---
  function switchToListView() {
    console.log("Switching to List View");
    adminApp.state.currentView = 'list';
    adminApp.state.currentProjectId = null;
    adminApp.state.projectData = null; // Clear project data
    adminApp.state.currentSlideIndex = -1;
    if (adminApp.state.fabricCanvasInstance) {
        adminApp.state.fabricCanvasInstance.dispose();
        adminApp.state.fabricCanvasInstance = null;
        console.log("Admin_JS: Disposed fabric canvas instance.");
    }
    if(listViewContainerEl) listViewContainerEl.style.display = 'block';
    if(editViewContainerEl) editViewContainerEl.style.display = 'none';
    if (messageAreaEl) messageAreaEl.innerHTML = '';
    // Reload list in case status changed etc.
    loadAdminProjectsList();
  }

  function switchToEditView(projectIdToEdit) {
      console.log("Switching to Edit View for project ID:", projectIdToEdit);
      adminApp.state.currentView = 'edit';
      adminApp.state.currentProjectId = projectIdToEdit;
      // Clear previous project state BUT DO NOT initialize projectData here anymore
      adminApp.state.projectData = null;
      adminApp.state.currentSlideIndex = -1;

      if(listViewContainerEl) listViewContainerEl.style.display = 'none';
      if(editViewContainerEl) editViewContainerEl.style.display = 'block';

      if(editingProjectTitleEl) { // Set temporary title
          editingProjectTitleEl.textContent = `Loading Project (ID: ${projectIdToEdit})...`;
      }

      if (adminApp.state.fabricCanvasInstance) {
          adminApp.state.fabricCanvasInstance.dispose();
          adminApp.state.fabricCanvasInstance = null;
      }
      if (messageAreaEl) messageAreaEl.innerHTML = '';
      if (slideThumbnailsContainerEl) slideThumbnailsContainerEl.innerHTML = ''; // Clear old thumbnails

      // Helper to ensure elements are found and listeners attached ONLY ONCE for edit view
      const ensureEditViewListener = (elementVar, id, eventType, handler) => {
          if (!window[elementVar]) { // Check if global variable needs assignment
              window[elementVar] = document.getElementById(id);
          }
          const element = window[elementVar];
          if (element && !element.hasAttribute('listener-attached')) {
              element.addEventListener(eventType, handler);
              element.setAttribute('listener-attached', 'true'); // Mark as attached
              console.log(`Listener attached for ${eventType} on #${id} in switchToEditView.`);
          } else if (!element) {
              console.error(`CRITICAL: Element #${id} not found in switchToEditView!`);
          }
      };

      // Ensure elements are referenced (some don't need listeners checked here)
      fabricCanvasEl = document.getElementById('fabricCanvasElement'); // Ensure reference
      slideThumbnailsContainerEl = document.getElementById('slideThumbnailsContainer'); // Ensure reference

      // Attach listeners for edit view buttons if not already attached
      ensureEditViewListener('backToProjectsListButtonEl', 'backToProjectsListButton', 'click', switchToListView);
      ensureEditViewListener('imageUploaderEl', 'imageUploader', 'change', handleImageUpload);
      ensureEditViewListener('addSlideButtonEl', 'addSlideButton', 'click', handleAddSlide);
      ensureEditViewListener('saveProjectButtonEl', 'saveProjectButton', 'click', handleSaveProject);
      // Step 11: Listeners for overlay tools
      ensureEditViewListener('addRectangleButtonEl', 'addRectangleButton', 'click', addRectangle);
      ensureEditViewListener('addCircleButtonEl', 'addCircleButton', 'click', addCircle);
      // Step 12: Listener for textbox tool
      ensureEditViewListener('addTextboxButtonEl', 'addTextboxButton', 'click', addTextbox);


      // Initialize Fabric Canvas with defaults
      if (typeof fabric !== 'undefined' && fabricCanvasEl) {
          adminApp.state.fabricCanvasInstance = new fabric.Canvas('fabricCanvasElement', {
              width: adminApp.state.defaultCanvasWidth,
              height: adminApp.state.defaultCanvasHeight,
              backgroundColor: '#e9e9e9'
          });
          fabricCanvasEl.width = adminApp.state.defaultCanvasWidth;
          fabricCanvasEl.height = adminApp.state.defaultCanvasHeight;
          console.log("Admin_JS: Fabric.js canvas initialized with default dimensions.");

          // Step 13: Initialize sidebar and canvas event listeners
          initSidebar(); // Setup listeners for sidebar inputs
          
          adminApp.state.fabricCanvasInstance.on('object:modified', (e) => {
            if (e.target) populateSidebar(e.target);
          });
          adminApp.state.fabricCanvasInstance.on('selection:created', (e) => { // When a new selection is made
            if (e.selected && e.selected.length > 0) populateSidebar(e.selected[0]); // Fabric 5.x sends e.selected
          });
          adminApp.state.fabricCanvasInstance.on('selection:updated', (e) => { // When an existing selection is changed
             if (e.selected && e.selected.length > 0) populateSidebar(e.selected[0]);
          });
          adminApp.state.fabricCanvasInstance.on('selection:cleared', () => {
            populateSidebar(null);
          });
          // Initially hide sidebar
          if(overlaySidebarEl) overlaySidebarEl.style.display = 'none';

          // ** NOW CALL LOAD PROJECT DATA **
          loadProjectForEditing(projectIdToEdit); // Load the actual project data

      } else { /* Error handling */
          console.error("Fabric.js or canvas element not ready in switchToEditView.");
          displayMessage("Critical error: Editor components not ready.", false);
          showLoading(false);
      }
  }

  // --- Project Loading (Step 10) ---
  function loadProjectForEditing(projectId) {
    console.log(`loadProjectForEditing: Called for projectId: ${projectId}`);
    if (!projectId) { console.error("loadProjectForEditing: No projectId."); displayMessage("Error: Cannot load project.", false); return; }
    showLoading(true);
    displayMessage("Loading project data...", true);
    google.script.run
        .withSuccessHandler(onProjectDataLoaded)
        .withFailureHandler(onServerError) // Handles showLoading(false) on error
        .getProjectDataForEditing(projectId);
  }

  function onProjectDataLoaded(jsonString) {
    console.log("onProjectDataLoaded: Received data string length:", jsonString ? jsonString.length : 'null');
    // Note: showLoading(false) will be called within this function or in onServerError

    if (jsonString === null || jsonString === undefined) { // Check specifically for null from server
        showLoading(false);
        console.error("onProjectDataLoaded: Received null data string from server (Project or data file likely not found).");
        displayMessage("Error: Could not load project data. Project or its data file may not exist.", false);
        adminApp.state.projectData = { projectId: adminApp.state.currentProjectId, title: "Error Loading", slides: [] };
        adminApp.state.currentSlideIndex = -1;
        if (editingProjectTitleEl) editingProjectTitleEl.textContent = `Error Loading Project (ID: ${adminApp.state.currentProjectId})`;
        updateSlideThumbnailsUI(); // Show empty state
        // Optionally add a default slide if you want the user to start fresh on error
        // handleAddSlide();
        return;
    }

    try {
        const loadedData = JSON.parse(jsonString);
        console.log("Parsed project data:", loadedData);

        if (!loadedData || typeof loadedData !== 'object') throw new Error("Parsed data is not a valid object.");
        if (!loadedData.projectId) throw new Error("Loaded project data is missing 'projectId'.");
        
        // Ensure slides property is an array, default to empty if missing or invalid
        if (!Array.isArray(loadedData.slides)) {
             console.warn("Loaded data missing 'slides' array or it's invalid, defaulting to empty.");
             loadedData.slides = [];
        }

        adminApp.state.projectData = loadedData; // Assign loaded data to state

        if (editingProjectTitleEl) {
            editingProjectTitleEl.textContent = `Editing Project: ${adminApp.state.projectData.title || '(Untitled)'}`;
        }

        updateSlideThumbnailsUI(); // Render thumbnails

        if (adminApp.state.projectData.slides.length > 0) {
            selectSlide(0); // Select and load the first slide
            displayMessage("Project loaded successfully.", true);
        } else {
            displayMessage("Project loaded, but it has no slides. Adding one.", true);
            handleAddSlide(); // Add an initial slide if the loaded project was empty
        }
        showLoading(false); // Success path loading finished

    } catch (e) {
        showLoading(false);
        console.error("onProjectDataLoaded: Error parsing JSON data or invalid structure:", e);
        console.error("Received JSON string that failed parsing:", jsonString); // Log the bad string
        displayMessage(`Error: Failed to parse loaded project data. ${e.message}`, false);
        adminApp.state.projectData = { projectId: adminApp.state.currentProjectId, title: "Invalid Data", slides: [] };
        adminApp.state.currentSlideIndex = -1;
        if (editingProjectTitleEl) editingProjectTitleEl.textContent = `Invalid Project Data (ID: ${adminApp.state.currentProjectId})`;
        updateSlideThumbnailsUI(); // Clear thumbnails
    }
  }


  // --- Slide Management (Step 9 & 10) ---
  function handleAddSlide() {
      console.log("handleAddSlide called");
      if (!adminApp.state.projectData) { console.error("handleAddSlide: projectData not initialized."); return; }
      saveCurrentSlideState();
      const newSlideId = 'slide_' + Utilities.getUuid();
      const newSlide = { slideId: newSlideId, canvasWidth: adminApp.state.defaultCanvasWidth, canvasHeight: adminApp.state.defaultCanvasHeight, fabricCanvasJSON: null, slideMedia: { type: null, url: null, driveFileId: null, mimeType: null } };
      // Ensure slides array exists before pushing
      if (!adminApp.state.projectData.slides) adminApp.state.projectData.slides = []; 
      adminApp.state.projectData.slides.push(newSlide);
      const newSlideIndex = adminApp.state.projectData.slides.length - 1;
      selectSlide(newSlideIndex);
      console.log("Added new slide. Total slides:", adminApp.state.projectData.slides.length);
  }

  // MODIFIED selectSlide to handle potential re-fetch if URL is not base64
  function selectSlide(slideIndex) {
      if (!adminApp.state.projectData || !adminApp.state.projectData.slides || slideIndex < 0 || slideIndex >= adminApp.state.projectData.slides.length) { console.error("selectSlide: Invalid index or slides array missing.", slideIndex); return; }
      console.log(`Selecting slide ${slideIndex + 1}`);
      saveCurrentSlideState();

      adminApp.state.currentSlideIndex = slideIndex;
      const selectedSlideData = adminApp.state.projectData.slides[slideIndex];
      const canvas = adminApp.state.fabricCanvasInstance;
      if (!canvas) { console.error("selectSlide: Canvas not ready!"); return; }

      // 1. Set canvas dimensions from loaded data
      const slideWidth = selectedSlideData.canvasWidth || adminApp.state.defaultCanvasWidth;
      const slideHeight = selectedSlideData.canvasHeight || adminApp.state.defaultCanvasHeight;
      canvas.setWidth(slideWidth);
      canvas.setHeight(slideHeight);
      if (fabricCanvasEl) { fabricCanvasEl.width = slideWidth; fabricCanvasEl.height = slideHeight; }
      console.log(`Canvas set to dimensions for slide ${slideIndex + 1}: ${slideWidth}x${slideHeight}`);

      // 2. Clear canvas & background
      canvas.clear();
      canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas)); // Explicitly clear background
      canvas.backgroundColor = '#e9e9e9';

      // 3. Load Background Image
      const media = selectedSlideData.slideMedia;
      if (media && media.type === 'image' && media.url) {
          if (media.url.startsWith('data:image')) { // It's base64
              console.log("Loading background from base64 data URI.");
              fabric.Image.fromURL(media.url, function(img) {
                  if (!adminApp.state.fabricCanvasInstance) return;
                  // Check if we are still on the same slide index in case of async race condition
                  if (adminApp.state.currentSlideIndex !== slideIndex) {
                      console.log("Slide changed before background loaded for index", slideIndex);
                      return;
                  }
                  adminApp.state.fabricCanvasInstance.setBackgroundImage(img, canvas.renderAll.bind(canvas), { scaleX: canvas.width / img.width, scaleY: canvas.height / img.height });
                  console.log("Background loaded for slide", slideIndex);
              }, { crossOrigin: 'anonymous' }); // Keep crossOrigin just in case url isn't base64 but some other direct link
          } else if (media.driveFileId) { // If you stored driveFileId (more robust for saving)
               console.log(`Background needs fetch from Drive ID for slide ${slideIndex + 1}:`, media.driveFileId);
               showLoading(true); displayMessage("Loading slide background...", true);
               google.script.run
                   .withSuccessHandler(function(response) { // Anonymous handler for background fetch
                        showLoading(false);
                        // Check if we are still on the same slide index
                        if (adminApp.state.currentSlideIndex !== slideIndex) {
                            console.log("Slide changed before background could be fetched for index", slideIndex);
                            return;
                        }
                        if (response && response.success && response.base64Data) {
                            fabric.Image.fromURL(response.base64Data, function(img) { 
                                if (!adminApp.state.fabricCanvasInstance) return;
                                adminApp.state.fabricCanvasInstance.setBackgroundImage(img, canvas.renderAll.bind(canvas), { scaleX: canvas.width / img.width, scaleY: canvas.height / img.height });
                                console.log("Background fetched and loaded for slide", slideIndex);
                            });
                        } else { 
                            console.error("Failed to re-fetch background", response);
                            displayMessage("Error loading slide background image.", false); 
                            canvas.renderAll(); // Render default background
                        }
                   })
                   .withFailureHandler(onServerError) // Use existing handler
                   .getImageAsBase64(media.driveFileId);
           } else {
              console.warn("Slide media URL/ID not suitable for loading:", media);
              canvas.renderAll();
          }
      } else {
          console.log("No background media found for slide", slideIndex);
          canvas.renderAll();
      }

      // 4. Load Fabric Canvas JSON (overlays)
      if (selectedSlideData.fabricCanvasJSON) {
          console.log("Loading fabricCanvasJSON for slide", slideIndex);
          // Ensure canvas background is set before loading JSON which might rely on dimensions/state
          canvas.renderAll(); // Render background first
          canvas.loadFromJSON(selectedSlideData.fabricCanvasJSON, function() {
              if (!adminApp.state.fabricCanvasInstance) return;
              // Check if we are still on the same slide index
              if (adminApp.state.currentSlideIndex !== slideIndex) {
                  console.log("Slide changed before overlays loaded for index", slideIndex);
                  return;
              }
              adminApp.state.fabricCanvasInstance.renderAll();
              console.log("Finished loading canvas JSON for slide", slideIndex);
          }, function(o, object) { /* Revival */ });
      } else {
           console.log("No fabricCanvasJSON to load for slide", slideIndex);
      }

      updateSlideThumbnailsUI(); // Highlight active thumbnail
      if (imageUploaderEl) imageUploaderEl.value = null; // Reset file input
        populateSidebar(null); // Step 13: Clear/hide sidebar when slide changes
  }

  function updateSlideThumbnailsUI() {
      if (!slideThumbnailsContainerEl || !adminApp.state.projectData) { console.warn("updateSlideThumbnailsUI: Container or project data missing."); return; }
      slideThumbnailsContainerEl.innerHTML = '';
      if (!adminApp.state.projectData.slides) adminApp.state.projectData.slides = []; // Safety check
      adminApp.state.projectData.slides.forEach((slide, index) => {
          const thumb = document.createElement('div'); thumb.className = 'slide-thumbnail';
          thumb.textContent = `Slide ${index + 1}`; thumb.title = `Select Slide ${index + 1}`;
          if (index === adminApp.state.currentSlideIndex) thumb.classList.add('active-slide');
          thumb.onclick = function() { selectSlide(index); };
          const deleteBtn = document.createElement('button'); deleteBtn.className = 'delete-slide-btn'; deleteBtn.innerHTML = '×'; deleteBtn.title = "Delete slide";
          deleteBtn.onclick = function(event) { event.stopPropagation(); handleDeleteSlide(index); };
          thumb.appendChild(deleteBtn); slideThumbnailsContainerEl.appendChild(thumb);
      });
  }

  function handleDeleteSlide(slideIndex) {
      if (!adminApp.state.projectData || !adminApp.state.projectData.slides || slideIndex < 0 || slideIndex >= adminApp.state.projectData.slides.length) { console.error("handleDeleteSlide: Invalid index."); return; }
      if (adminApp.state.projectData.slides.length <= 1) { displayMessage("Cannot delete the last slide.", false); return; }
      if (!confirm(`Are you sure you want to delete Slide ${slideIndex + 1}?`)) return;
      adminApp.state.projectData.slides.splice(slideIndex, 1);
      console.log("Deleted slide at index:", slideIndex);
      // Determine new index to select
      const newIndex = Math.min(Math.max(0, slideIndex - 1), adminApp.state.projectData.slides.length - 1);
      // Need to handle case where index 0 was deleted
      const indexToSelect = (slideIndex === 0 && adminApp.state.projectData.slides.length > 0) ? 0 : Math.max(0, slideIndex - 1);

      // Update currentSlideIndex BEFORE calling selectSlide if the deleted slide was the active one or before it
      if (adminApp.state.currentSlideIndex === slideIndex) {
          adminApp.state.currentSlideIndex = -1; // Temporarily unset while selecting new
          selectSlide(indexToSelect);
      } else if (adminApp.state.currentSlideIndex > slideIndex) {
          adminApp.state.currentSlideIndex--; // Adjust index
          updateSlideThumbnailsUI(); // Update highlighting
      } else {
           updateSlideThumbnailsUI(); // Just update highlighting
      }
  }


  function saveCurrentSlideState() {
      if (adminApp.state.currentSlideIndex === -1 || !adminApp.state.fabricCanvasInstance || !adminApp.state.projectData || !adminApp.state.projectData.slides[adminApp.state.currentSlideIndex]) { return; }
      try {
        const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
        const canvas = adminApp.state.fabricCanvasInstance;
        const propsToInclude = ['slideId', 'canvasWidth', 'canvasHeight']; // Add custom properties used on objects later
        currentSlide.fabricCanvasJSON = canvas.toJSON(propsToInclude);
        currentSlide.canvasWidth = canvas.getWidth();
        currentSlide.canvasHeight = canvas.getHeight();
        // Ensure slideMedia exists before potentially modifying it
        if (!currentSlide.slideMedia) {
             currentSlide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null };
        }
        // Decide if we save base64 or driveFileId in slideMedia.url
        // For now, onBase64ImageReceived saves base64 to slideMedia.url
        // If you want to save driveFileId instead, modify onBase64ImageReceived and add re-fetch logic to selectSlide
        console.log(`Slide ${adminApp.state.currentSlideIndex + 1} state saved.`);
      } catch(e) {
          console.error("Error saving slide state:", e);
      }
  }

  // --- Project Saving (Step 9) ---
  function handleSaveProject() {
      if (!adminApp.state.projectData || !adminApp.state.currentProjectId) { displayMessage("No project data to save.", false); return; }
      if (adminApp.state.isLoading) return;
      saveCurrentSlideState();
      showLoading(true); displayMessage("Saving project...", true);
      // Use try/catch for JSON.stringify just in case projectData has circular refs (unlikely here)
      try {
          const jsonDataString = JSON.stringify(adminApp.state.projectData);
          console.log("Saving projectData string length:", jsonDataString.length); 
          google.script.run
              .withSuccessHandler(onProjectSaved)
              .withFailureHandler(onServerError)
              .saveProjectData(adminApp.state.currentProjectId, jsonDataString);
      } catch (e) {
           showLoading(false);
           console.error("Error stringifying project data:", e);
           displayMessage("Error preparing data for saving.", false);
      }
  }

  function onProjectSaved(response) {
      showLoading(false);
      if (response && response.success) { displayMessage(response.message || "Project saved!", true); }
      else { onServerError((response && response.error) ? response.error : "Failed to save."); }
  }

  // --- General UI Functions ---
  function showLoading(show) {
    adminApp.state.isLoading = show;
    if (loadingSpinnerEl) loadingSpinnerEl.style.display = show ? 'flex' : 'none';
    else if (show) console.warn("showLoading(true) loadingSpinnerEl not found.");
  }
  function displayMessage(message, isSuccess) {
      if (messageAreaEl) { messageAreaEl.innerHTML = ''; const p = document.createElement('p'); p.textContent = message; messageAreaEl.appendChild(p); messageAreaEl.className = isSuccess ? 'success' : 'error'; setTimeout(() => { if (messageAreaEl) { messageAreaEl.innerHTML = ''; messageAreaEl.className = ''; } }, 7000); } else { console.warn("displayMessage messageAreaEl not found. Message:", message); }
  }
  function onServerError(errorObject) {
    console.error("onServerError triggered:", errorObject);
    showLoading(false);
    let errorMessage = "An unknown server error occurred.";
    // Detailed parsing logic...
     if (typeof errorObject === 'string') { errorMessage = errorObject; }
     else if (errorObject && errorObject.message) { errorMessage = errorObject.message; /* ... more detail parsing ... */ }
    console.error('Formatted Server Error Message:', errorMessage);
    displayMessage('Server Error: ' + errorMessage, false);
  }

  // --- Project Creation (Step 3) ---
  function handleCreateProject() {
      if (adminApp.state.isLoading) return;
      const currentProjectTitle = projectTitleInputEl.value.trim();
      if (!currentProjectTitle) { displayMessage('Project title cannot be empty.', false); projectTitleInputEl.focus(); return; }
      showLoading(true);
      google.script.run.withSuccessHandler(onProjectCreated).withFailureHandler(onServerError).createProject(currentProjectTitle);
  }
  function onProjectCreated(response) {
      showLoading(false);
      if (response && response.success) { displayMessage(response.message || 'Project created!', true); if(projectTitleInputEl) projectTitleInputEl.value = ''; loadAdminProjectsList(); }
      else { onServerError((response && response.error) ? response.error : 'Failed to create project.'); }
  }

  // --- Project List (Step 4) ---
  function loadAdminProjectsList() {
    console.log("loadAdminProjectsList: Function called.");
    if (!adminProjectListContainerEl) { console.error("loadAdminProjectsList: adminProjectListContainerEl not found."); showLoading(false); return; }
    if (!google || !google.script || !google.script.run) { console.error("loadAdminProjectsList: google.script.run unavailable."); displayMessage("Error: Client-server bridge unavailable.", false); return; }
    showLoading(true);
    console.log("loadAdminProjectsList: Calling google.script.run.getAllProjectsForAdmin...");
    google.script.run
      .withSuccessHandler(displayAdminProjects)
      .withFailureHandler(onServerError)
      .getAllProjectsForAdmin();
     console.log("loadAdminProjectsList: google.script.run.getAllProjectsForAdmin call initiated.");
  }
  function displayAdminProjects(projectsArray) {
    console.log("displayAdminProjects (Success Handler) received data:", projectsArray);
    showLoading(false);
    if (!adminProjectListContainerEl) { console.error("displayAdminProjects: adminProjectListContainerEl not found."); return; }
    adminProjectListContainerEl.innerHTML = '';
    if (!projectsArray || projectsArray.length === 0) { adminProjectListContainerEl.innerHTML = '<p>No projects found.</p>'; return; }
    projectsArray.forEach(project => { /* ... rendering logic as before ... */
        if (!project || !project.projectId) return; const projectItem = document.createElement('div'); projectItem.className = 'project-item'; const titleSpan = document.createElement('span'); titleSpan.textContent = project.projectTitle || 'Untitled Project'; const statusSpan = document.createElement('span'); statusSpan.className = 'status'; statusSpan.textContent = `(${project.status || 'N/A'})`; const titleAndStatusDiv = document.createElement('div'); titleAndStatusDiv.appendChild(titleSpan); titleAndStatusDiv.appendChild(statusSpan); const editButton = document.createElement('button'); editButton.textContent = 'Edit'; editButton.className = 'edit-button'; editButton.setAttribute('data-project-id', project.projectId); editButton.onclick = function() { console.log("Edit button clicked:", project.projectId); switchToEditView(project.projectId); }; projectItem.appendChild(titleAndStatusDiv); projectItem.appendChild(editButton); adminProjectListContainerEl.appendChild(projectItem);
     });
    console.log("displayAdminProjects: Finished rendering project list.");
  }

  // --- Image Upload Handling (Step 8) ---
  function handleImageUpload(event) {
      if (adminApp.state.isLoading) { if(event.target) event.target.value = null; return; }
      const file = event.target.files[0];
      if (!file || !file.type.startsWith('image/')) { if(event.target) event.target.value = null; return; }
      showLoading(true); displayMessage("Uploading image...", true);
      const reader = new FileReader();
      reader.onload = function(e) {
          const fileData = { fileName: file.name, mimeType: file.type, data: e.target.result.split(',')[1] };
          if (!adminApp.state.currentProjectId) { showLoading(false); displayMessage("Error: No project.", false); if(event.target) event.target.value = null; return; }
          google.script.run.withSuccessHandler(onImageUploaded).withFailureHandler(onServerError).uploadFileToDrive(fileData, adminApp.state.currentProjectId, 'image');
      };
      reader.onerror = function(error) { showLoading(false); displayMessage("Error reading file.", false); console.error(error); if(event.target) event.target.value = null; };
      reader.readAsDataURL(file);
  }
  function onImageUploaded(response) { // From uploadFileToDrive
      showLoading(false); if (imageUploaderEl) imageUploaderEl.value = null;
      if (response && response.success && response.driveFileId) {
          displayMessage("Image uploaded. Fetching...", true); showLoading(true);
          // Store driveFileId temporarily if needed before calling getImageAsBase64
          adminApp.state.lastUploadedDriveId = response.driveFileId; // Example temporary storage
          google.script.run.withSuccessHandler(onBase64ImageReceived).withFailureHandler(onServerError).getImageAsBase64(response.driveFileId);
      } else { onServerError({ message: (response && response.error) ? response.error : "Upload failed." }); }
  }
  function onBase64ImageReceived(response) { // From getImageAsBase64
      showLoading(false);
      if (response && response.success && response.base64Data) {
          if (!adminApp.state.fabricCanvasInstance || adminApp.state.currentSlideIndex === -1) { displayMessage("Error: Canvas/Slide not ready.", false); return; }
          const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
          if (!currentSlide) { displayMessage("Error: Slide data missing.", false); return; }
          fabric.Image.fromURL(response.base64Data, function(img) {
              if (!adminApp.state.fabricCanvasInstance) return;
              if (adminApp.state.currentSlideIndex === -1) return; // Check if slide changed
              const canvas = adminApp.state.fabricCanvasInstance; const imgWidth = img.width; const imgHeight = img.height; const maxWidth = 960;
              let cvWidth = imgWidth; let cvHeight = imgHeight; const ratio = imgWidth / imgHeight;
              if (cvWidth > maxWidth) { cvWidth = maxWidth; cvHeight = Math.round(cvWidth / ratio); }
              canvas.setWidth(cvWidth); canvas.setHeight(cvHeight);
              if (fabricCanvasEl) { fabricCanvasEl.width = cvWidth; fabricCanvasEl.height = cvHeight; }
              canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), { scaleX: cvWidth / imgWidth, scaleY: cvHeight / imgHeight });
              canvas.renderAll(); displayMessage("Background set.", true);
              // Update current slide data
              if (!currentSlide.slideMedia) currentSlide.slideMedia = {}; // Ensure object exists
              currentSlide.slideMedia.type = 'image';
              // **** CHOICE: Store base64 or Drive ID? ****
              // Option 1: Store base64 (simpler loading, larger JSON)
              currentSlide.slideMedia.url = response.base64Data; 
              currentSlide.slideMedia.driveFileId = adminApp.state.lastUploadedDriveId || null; // Store ID too if needed
              // Option 2: Store Drive ID (smaller JSON, needs re-fetch on load)
              // currentSlide.slideMedia.url = null; // Or maybe store the view link?
              // currentSlide.slideMedia.driveFileId = adminApp.state.lastUploadedDriveId; 
              
              currentSlide.slideMedia.mimeType = response.mimeType;
              currentSlide.canvasWidth = cvWidth; currentSlide.canvasHeight = cvHeight;
              console.log(`Slide ${adminApp.state.currentSlideIndex + 1} media/dims updated.`);
              updateSlideThumbnailsUI();
              delete adminApp.state.lastUploadedDriveId; // Clean up temp state
                        });
                    } else { onServerError({ message: (response && response.error) ? response.error : "Failed to fetch image." }); }
                }

                // --- Overlay Creation Functions (Step 11) ---
                function addRectangle() {
                    if (!adminApp.state.fabricCanvasInstance) {
                    console.error("addRectangle: Fabric canvas not initialized.");
                    displayMessage("Error: Canvas not ready to add shapes.", false);
                    return;
                    }
                    const canvas = adminApp.state.fabricCanvasInstance;

                    const rect = new fabric.Rect({
                    left: 50,
                    top: 50,
                    fill: 'rgba(255,0,0,0.7)', // Default red with some transparency
                    width: 150,
                    height: 100,
                    stroke: 'black',
                    strokeWidth: 1,
                    // Custom properties initialization as per plan
                    customInteraction: { trigger: null, action: null, modalContent: "", navigateTo: "" },
                    customAnimation: { type: null, duration: 500, strength: 5, trigger: null },
                    sequenceOrder: null 
                    });

                    canvas.add(rect);
                    canvas.setActiveObject(rect); // Make the new rectangle active
                    canvas.renderAll();
                    console.log("Rectangle added to canvas:", rect);
                }

                function addCircle() {
                    if (!adminApp.state.fabricCanvasInstance) {
                    console.error("addCircle: Fabric canvas not initialized.");
                    displayMessage("Error: Canvas not ready to add shapes.", false);
                    return;
                    }
                    const canvas = adminApp.state.fabricCanvasInstance;

                    const circle = new fabric.Circle({
                    left: 150,
                    top: 150,
                    radius: 50,
                    fill: 'rgba(0,0,255,0.7)', // Default blue with some transparency
                    stroke: 'black',
                    strokeWidth: 1,
                    // Custom properties initialization as per plan
                    customInteraction: { trigger: null, action: null, modalContent: "", navigateTo: "" },
                    customAnimation: { type: null, duration: 500, strength: 5, trigger: null },
                    sequenceOrder: null
                    });

                    canvas.add(circle);
                        canvas.setActiveObject(circle); // Make the new circle active
                        canvas.renderAll();
                        console.log("Circle added to canvas:", circle);
                    }

                    function addTextbox() {
                        if (!adminApp.state.fabricCanvasInstance) {
                        console.error("addTextbox: Fabric canvas not initialized.");
                        displayMessage("Error: Canvas not ready to add text.", false);
                        return;
                        }
                        const canvas = adminApp.state.fabricCanvasInstance;

                        const textbox = new fabric.Textbox('Editable Text', {
                        left: 100,
                        top: 100,
                        width: 200, // Initial width for the textbox
                        fontSize: 24,
                        fill: '#000000', // Default black text
                        // Custom properties initialization
                        customInteraction: { trigger: null, action: null, modalContent: "", navigateTo: "" },
                        customAnimation: { type: null, duration: 500, strength: 5, trigger: null },
                        sequenceOrder: null
                        });

                        canvas.add(textbox);
                        canvas.setActiveObject(textbox); // Make the new textbox active
                        canvas.renderAll();
                        // Textbox often benefits from being brought to front if other elements exist
                        canvas.bringToFront(textbox); 
                            console.log("Textbox added to canvas:", textbox);
                        }

                        // --- Sidebar Management Functions (Step 13) ---
                        function initSidebar() {
                            console.log("initSidebar: Attaching listeners to sidebar inputs.");
                            const inputs = [
                            {el: objXEl, prop: 'left', type: 'number'}, {el: objYEl, prop: 'top', type: 'number'},
                            {el: objWidthEl, prop: 'width', type: 'number', targetProp: 'scaleX'}, // Width/Height also affect scale for some objects
                            {el: objHeightEl, prop: 'height', type: 'number', targetProp: 'scaleY'},
                            {el: objAngleEl, prop: 'angle', type: 'number'},
                            {el: objFillEl, prop: 'fill', type: 'color'},
                            {el: objStrokeColorEl, prop: 'stroke', type: 'color'},
                            {el: objStrokeWidthEl, prop: 'strokeWidth', type: 'number'},
                            {el: objOpacityEl, prop: 'opacity', type: 'range'},
                            {el: objTextContentEl, prop: 'text', type: 'textarea'},
                            // Shadow inputs
                            {el: objShadowColorEl, prop: 'shadow.color', type: 'color'},
                            {el: objShadowBlurEl, prop: 'shadow.blur', type: 'range'},
                            {el: objShadowOffsetXEl, prop: 'shadow.offsetX', type: 'number'},
                            {el: objShadowOffsetYEl, prop: 'shadow.offsetY', type: 'number'}
                            ];

                            inputs.forEach(inputConfig => {
                            if (inputConfig.el) {
                                // Remove existing listener before adding, to prevent duplicates if initSidebar is ever called multiple times
                                // A more robust way would be to use a flag or ensure initSidebar is truly called only once per canvas instance.
                                // For now, a simple named function approach for removal might be too complex.
                                // Let's rely on ensureEditViewListener for buttons and assume initSidebar called once per edit view setup.
                                inputConfig.el.addEventListener('input', (e) => { // 'input' for live updates, 'change' for color pickers might be better after selection
                                updateFabricObjectFromSidebar(inputConfig.prop, e.target.value, inputConfig.type);
                                });
                                if (inputConfig.el.type === 'color') { // Color pickers update on 'change' typically
                                    inputConfig.el.addEventListener('change', (e) => {
                                        updateFabricObjectFromSidebar(inputConfig.prop, e.target.value, inputConfig.type);
                                    });
                                }
                            } else {
                                console.warn(`initSidebar: Element for property "${inputConfig.prop}" not found.`);
                            }
                            });
                        }

                        function populateSidebar(activeObject) {
                            if (!overlaySidebarEl) { console.error("populateSidebar: overlaySidebarEl not found."); return; }

                            if (!activeObject) {
                            overlaySidebarEl.style.display = 'none';
                            return;
                            }
                            overlaySidebarEl.style.display = 'block';

                            // General Properties
                            if (objXEl) objXEl.value = activeObject.left ? activeObject.left.toFixed(0) : 0;
                            if (objYEl) objYEl.value = activeObject.top ? activeObject.top.toFixed(0) : 0;
                            // For width/height, consider object's scale. Fabric's width/height are unscaled.
                            // We'll set the visual width/height.
                            if (objWidthEl) objWidthEl.value = activeObject.getScaledWidth ? activeObject.getScaledWidth().toFixed(0) : (activeObject.width || 0);
                            if (objHeightEl) objHeightEl.value = activeObject.getScaledHeight ? activeObject.getScaledHeight().toFixed(0) : (activeObject.height || 0);
                            if (objAngleEl) objAngleEl.value = activeObject.angle ? activeObject.angle.toFixed(0) : 0;

                            if (objFillEl) objFillEl.value = activeObject.fill || '#ffffff';
                            if (objStrokeColorEl) objStrokeColorEl.value = activeObject.stroke || '#000000';
                            if (objStrokeWidthEl) objStrokeWidthEl.value = activeObject.strokeWidth || 0;
                            if (objOpacityEl) objOpacityEl.value = activeObject.opacity === undefined ? 1 : activeObject.opacity;

                            // Text Specific
                            if (textSpecificControlsEl) {
                            if (activeObject.type === 'textbox' || activeObject.type === 'i-text') { // i-text is interactive text
                                textSpecificControlsEl.style.display = 'block';
                                if (objTextContentEl) objTextContentEl.value = activeObject.text || '';
                            } else {
                                textSpecificControlsEl.style.display = 'none';
                            }
                            }
                            
                            // Shadow
                            const shadow = activeObject.shadow;
                            if (objShadowColorEl) objShadowColorEl.value = shadow ? shadow.color : '#000000';
                            if (objShadowBlurEl) objShadowBlurEl.value = shadow ? shadow.blur : 0;
                            if (objShadowOffsetXEl) objShadowOffsetXEl.value = shadow ? shadow.offsetX : 0;
                            if (objShadowOffsetYEl) objShadowOffsetYEl.value = shadow ? shadow.offsetY : 0;
                        }

                        function updateFabricObjectFromSidebar(propertyName, value, inputType) {
                            const canvas = adminApp.state.fabricCanvasInstance;
                            if (!canvas) return;
                            const activeObject = canvas.getActiveObject();
                            if (!activeObject) return;

                            let parsedValue = value;
                            if (inputType === 'number' || inputType === 'range') {
                            parsedValue = inputType === 'range' ? parseFloat(value) : parseInt(value, 10);
                            if (isNaN(parsedValue)) {
                                // For properties like strokeWidth, 0 is valid, but NaN isn't
                                if (propertyName === 'strokeWidth' && value === '') parsedValue = 0;
                                else if (value === '') return; // Don't update if number input is cleared, wait for valid number
                                else return; // Or handle as 0 if preferred: parsedValue = 0;
                            }
                            }
                            
                            // Special handling for width/height to adjust scale
                            if (propertyName === 'width') {
                                activeObject.scaleX = parsedValue / activeObject.width;
                            } else if (propertyName === 'height') {
                                activeObject.scaleY = parsedValue / activeObject.height;
                            } else if (propertyName.startsWith('shadow.')) {
                            const shadowProp = propertyName.split('.')[1];
                            let shadowOptions = activeObject.shadow instanceof fabric.Shadow ? activeObject.shadow.toObject() : {};
                            shadowOptions[shadowProp] = parsedValue;
                            // Ensure blur, offsetX, offsetY are numbers
                            shadowOptions.blur = parseInt(objShadowBlurEl.value, 10) || 0;
                            shadowOptions.offsetX = parseInt(objShadowOffsetXEl.value, 10) || 0;
                            shadowOptions.offsetY = parseInt(objShadowOffsetYEl.value, 10) || 0;
                            shadowOptions.color = objShadowColorEl.value || '#000000';

                            activeObject.set('shadow', new fabric.Shadow(shadowOptions));
                            } else {
                            activeObject.set(propertyName, parsedValue);
                            }

                            // If it's a textbox and content changed, fabric might need a nudge for width/height recalculation
                            if ((activeObject.type === 'textbox' || activeObject.type === 'i-text') && propertyName === 'text') {
                                activeObject.initDimensions(); // Recalculate dimensions if text content changes
                            }

                            activeObject.setCoords(); // Update controls position
                            canvas.renderAll();
                            // After updating from sidebar, re-populate to ensure consistency (e.g. for scaled width/height)
                            // This can cause an infinite loop if not careful, especially with 'input' event.
                            // Consider calling populateSidebar only on 'change' or deferring it slightly.
                            // For now, let's see if this is problematic.
                            // populateSidebar(activeObject); 
                        }


  // Client-side UUID generator
  Utilities = { getUuid: function() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); } };

</script>