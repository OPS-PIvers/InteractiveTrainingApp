<script>
    // Namespace for the admin application
    window.adminApp = {};

    // --- Constants ---
    const FONT_FAMILIES = ["Arial", "Verdana", "Times New Roman", "Georgia", "Courier New", "Comic Sans MS", "Impact", "Tahoma"];

    // --- Application State ---
    adminApp.state = {
      isLoading: false,
      currentProjectId: null,
      currentView: 'list',
      projectData: null,
      currentSlideIndex: -1,
      fabricCanvasInstance: null,
      defaultCanvasWidth: 960,
      defaultCanvasHeight: 540,
      projectListCache: [], // Added to cache project list for status updates/reverts
      lastUploadedDriveId: null, // Temp store for image uploads before base64 fetch
      lastUploadedMimeType: null,
      lastUploadedFileName: null,
      isPasteListenerActive: false, // To manage listener attachment for pasting images
      activePopoverId: null // To track the currently open popover
    };

    // --- DOM Element References ---
    let projectTitleInputEl, createProjectButtonEl, messageAreaEl, loadingSpinnerEl;
    let listViewContainerEl, adminProjectListContainerEl;
    let editViewContainerEl, editingProjectTitleEl, backToProjectsListButtonEl, fabricCanvasEl;
    let imageUploaderEl;
    let addSlideButtonEl, slideThumbnailsContainerEl, saveProjectButtonEl;
    let addRectangleButtonEl, addCircleButtonEl;
    let addTextboxButtonEl;

    // Toolbar Elements (existing and new)
    let overlayPropertiesToolbarEl, objXEl, objYEl, objWidthEl, objHeightEl, objAngleEl,
        objFillEl, objStrokeColorEl, objStrokeWidthEl, objOpacityEl,
        textSpecificControlsEl, objTextContentEl, // Text specific row
        objFontFamilyEl, objFontSizeEl, objFontWeightEl, objFontStyleEl, objTextAlignEl, objLineHeightEl, objCharSpacingEl, // Core text inputs (some hidden, some direct)
        objShadowColorEl, objShadowBlurEl, objShadowOffsetXEl, objShadowOffsetYEl, objShadowAffectStrokeEl, objShadowNonScalingEl, // Shadow inputs
        objInteractionTriggerEl, objInteractionActionEl, modalContentConfigEl, objModalContentEl, navigateToConfigEl, objNavigateToEl, panZoomConfigEl, objPanZoomLevelEl, // Interaction inputs
        objAnimationTriggerEl, objAnimationTypeEl, animationParamsConfigEl, objAnimationDurationEl, objAnimationStrengthEl, objAnimationStrengthUnitEl, // Animation inputs
        objAnimationLoopEl, animationLoopCountConfigEl, objAnimationLoopCountEl, objAnimationLoopDelayEl;

    // New Popover and Toolbar Button DOM elements
    let fillColorButtonEl, strokeColorButtonEl, opacityButtonEl, // Direct action buttons for color/opacity that might reveal inputs
        shadowSettingsButtonEl, interactionSettingsButtonEl, animationSettingsButtonEl, fontFamilyButtonEl, // Popover triggers
        shadowPopoverEl, interactionPopoverEl, animationPopoverEl, fontFamilyPopoverEl, // Popover containers
        fontWeightButtonEl, fontStyleButtonEl, textAlignGroupEl; // Text style toggle buttons

    // Step 20 Media Elements
    let youtubeUrlInputEl, setYoutubeBackgroundButtonEl,
        audioUploaderEl, attachedAudioNameEl, removeAudioButtonEl,
        adminMediaPlaceholderEl;
    
    // New toolbar buttons
    let mediaToolsButtonEl, addShapeButtonEl, positionToolsButtonEl;
    // New popovers
    let mediaToolsPopoverEl, shapesPopoverEl, positionToolsPopoverEl;
    // Media tab elements
    let mediaTabButtonsEl, mediaTabPanesEl;
    // Drag and drop zones
    let imageDropZoneEl, audioDropZoneEl;

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function() {
      console.log("Admin_JS: DOMContentLoaded event fired!");
      adminApp.setupDOMReferences();
      adminApp.attachEventListeners();
      switchToListView();
      loadAdminProjectsList();
      console.log("Admin_JS: Initialization complete.");
    });

    // --- Setup and Listeners ---
    adminApp.setupDOMReferences = function() {
      messageAreaEl = document.getElementById('messageArea');
      loadingSpinnerEl = document.getElementById('loadingSpinner');
      listViewContainerEl = document.getElementById('listViewContainer');
      projectTitleInputEl = document.getElementById('projectTitleInput');
      createProjectButtonEl = document.getElementById('createProjectButton');
      adminProjectListContainerEl = document.getElementById('adminProjectListContainer');
      editViewContainerEl = document.getElementById('editViewContainer');
      editingProjectTitleEl = document.getElementById('editingProjectTitle');
      backToProjectsListButtonEl = document.getElementById('backToProjectsListButton');
      fabricCanvasEl = document.getElementById('fabricCanvasElement');
      imageUploaderEl = document.getElementById('imageUploader');
      addSlideButtonEl = document.getElementById('addSlideButton');
      slideThumbnailsContainerEl = document.getElementById('slideThumbnailsContainer');
      saveProjectButtonEl = document.getElementById('saveProjectButton');

      addRectangleButtonEl = document.getElementById('addRectangleButton');
      addCircleButtonEl = document.getElementById('addCircleButton');
      addTextboxButtonEl = document.getElementById('addTextboxButton');

      // Main Toolbar container
      overlayPropertiesToolbarEl  = document.getElementById('overlayPropertiesToolbar');

      // Direct input elements (some might be hidden or styled differently)
      objXEl = document.getElementById('objX');
      objYEl = document.getElementById('objY');
      objWidthEl = document.getElementById('objWidth');
      objHeightEl = document.getElementById('objHeight');
      objAngleEl = document.getElementById('objAngle');
      objFillEl = document.getElementById('objFill'); // The color input itself
      objStrokeColorEl = document.getElementById('objStrokeColor'); // The color input itself
      objStrokeWidthEl = document.getElementById('objStrokeWidth');
      objOpacityEl = document.getElementById('objOpacity'); // The range input itself

      // Text specific controls row and core inputs
      textSpecificControlsEl = document.getElementById('textSpecificControls');
      objTextContentEl = document.getElementById('objTextContent');
      objFontFamilyEl = document.getElementById('objFontFamily'); // The <select> for fonts (likely in a popover)
      objFontSizeEl = document.getElementById('objFontSize');
      objFontWeightEl = document.getElementById('objFontWeight'); // Hidden <select>
      objFontStyleEl = document.getElementById('objFontStyle');   // Hidden <select>
      objTextAlignEl = document.getElementById('objTextAlign');   // Hidden <select>
      objLineHeightEl = document.getElementById('objLineHeight');
      objCharSpacingEl = document.getElementById('objCharSpacing');

      // Shadow inputs (will be in shadowPopoverEl)
      objShadowColorEl = document.getElementById('objShadowColor');
      objShadowBlurEl = document.getElementById('objShadowBlur');
      objShadowOffsetXEl = document.getElementById('objShadowOffsetX');
      objShadowOffsetYEl = document.getElementById('objShadowOffsetY');
      objShadowAffectStrokeEl = document.getElementById('objShadowAffectStroke');
      objShadowNonScalingEl = document.getElementById('objShadowNonScaling');

      // Interaction inputs (will be in interactionPopoverEl)
      objInteractionTriggerEl = document.getElementById('objInteractionTrigger');
      objInteractionActionEl = document.getElementById('objInteractionAction');
      modalContentConfigEl = document.getElementById('modalContentConfig');
      objModalContentEl = document.getElementById('objModalContent');
      navigateToConfigEl = document.getElementById('navigateToConfig');
      objNavigateToEl = document.getElementById('objNavigateTo');
      panZoomConfigEl = document.getElementById('panZoomConfigEl'); // Corrected from panZoomConfigEl to panZoomConfigEl
      objPanZoomLevelEl = document.getElementById('objPanZoomLevel');

      // Animation inputs (will be in animationPopoverEl)
      objAnimationTriggerEl = document.getElementById('objAnimationTrigger');
      objAnimationTypeEl = document.getElementById('objAnimationType');
      animationParamsConfigEl = document.getElementById('animationParamsConfig');
      objAnimationDurationEl = document.getElementById('objAnimationDuration');
      objAnimationStrengthEl = document.getElementById('objAnimationStrength');
      objAnimationStrengthUnitEl = document.getElementById('objAnimationStrengthUnit');
      objAnimationLoopEl = document.getElementById('objAnimationLoop');
      animationLoopCountConfigEl = document.getElementById('animationLoopCountConfig');
      objAnimationLoopCountEl = document.getElementById('objAnimationLoopCount');
      objAnimationLoopDelayEl = document.getElementById('objAnimationLoopDelay');

      // New Popover Trigger Buttons
      fillColorButtonEl = document.getElementById('fillColorButton');
      strokeColorButtonEl = document.getElementById('strokeColorButton');
      opacityButtonEl = document.getElementById('opacityButton');
      shadowSettingsButtonEl = document.getElementById('shadowSettingsButton');
      interactionSettingsButtonEl = document.getElementById('interactionSettingsButton');
      animationSettingsButtonEl = document.getElementById('animationSettingsButton');
      fontFamilyButtonEl = document.getElementById('fontFamilyButton');

      // New Popover Container Elements
      shadowPopoverEl = document.getElementById('shadowPopover');
      interactionPopoverEl = document.getElementById('interactionPopover');
      animationPopoverEl = document.getElementById('animationPopover');
      fontFamilyPopoverEl = document.getElementById('fontFamilyPopover');

      // New Text Style Toggle Buttons
      fontWeightButtonEl = document.getElementById('fontWeightButton'); // Bold
      fontStyleButtonEl = document.getElementById('fontStyleButton');   // Italic
      textAlignGroupEl = document.getElementById('textAlignGroup');     // Container for align buttons


      // Step 20 Elements
      youtubeUrlInputEl = document.getElementById('youtubeUrlInput');
      setYoutubeBackgroundButtonEl = document.getElementById('setYoutubeBackgroundButton');
      audioUploaderEl = document.getElementById('audioUploader');
      attachedAudioNameEl = document.getElementById('attachedAudioName');
      removeAudioButtonEl = document.getElementById('removeAudioButton');
      adminMediaPlaceholderEl = document.getElementById('adminMediaPlaceholder');

      // New toolbar buttons
      mediaToolsButtonEl = document.getElementById('mediaToolsButton');
      addShapeButtonEl = document.getElementById('addShapeButton');
      positionToolsButtonEl = document.getElementById('positionToolsButton');

      // New popovers
      mediaToolsPopoverEl = document.getElementById('mediaToolsPopover');
      shapesPopoverEl = document.getElementById('shapesPopover');
      positionToolsPopoverEl = document.getElementById('positionToolsPopover');

      // Media tab elements
      mediaTabButtonsEl = document.querySelectorAll('.media-tab-btn');
      mediaTabPanesEl = document.querySelectorAll('.media-tab-pane');

      // Drag and drop zones
      imageDropZoneEl = document.getElementById('imageDropZone');
      audioDropZoneEl = document.getElementById('audioDropZone');

      // Check for essential elements - only warn if globally expected elements are missing
      if (!messageAreaEl) console.warn("setupDOMReferences: messageAreaEl not found.");
      if (!loadingSpinnerEl) console.warn("setupDOMReferences: loadingSpinnerEl not found.");
      if (!listViewContainerEl) console.warn("setupDOMReferences: listViewContainerEl not found.");
      if (!editViewContainerEl) console.warn("setupDOMReferences: editViewContainerEl not found.");
      if (!createProjectButtonEl) console.warn("setupDOMReferences: createProjectButtonEl not found.");
      if (!overlayPropertiesToolbarEl) console.warn("setupDOMReferences: overlayPropertiesToolbarEl (new toolbar) not found.");
      if (!shadowPopoverEl || !interactionPopoverEl || !animationPopoverEl || !fontFamilyPopoverEl) {
          console.warn("setupDOMReferences: One or more popover elements not found.");
      }

      console.log("Admin_JS: DOM references set up.");
    };

    adminApp.attachEventListeners = function() {
      const safelyAddListener = (element, eventType, handler, elementName) => {
          if (element) {
              element.addEventListener(eventType, handler);
          } else {
              if (elementName === 'createProjectButtonEl') console.warn(`Could not attach listener - ${elementName} not found initially.`);
          }
      };
      safelyAddListener(createProjectButtonEl, 'click', handleCreateProject, 'createProjectButtonEl');
      console.log("Admin_JS: Initial event listeners attached.");
      // Edit view listeners attached in switchToEditView

      // Global listener for closing popovers when clicking outside
      document.addEventListener('click', function(event) {
        if (adminApp.state.activePopoverId && adminApp.state.currentView === 'edit') {
            const popover = document.getElementById(adminApp.state.activePopoverId);
            // Construct potential trigger button IDs (e.g., shadowPopover -> shadowSettingsButton or shadowButton)
            let triggerButton = null;
            const baseId = adminApp.state.activePopoverId.replace('Popover', ''); // e.g., "shadow"
            const possibleTriggerIds = [
                baseId + 'SettingsButton', // shadowSettingsButton
                baseId + 'Button'         // fontFamilyButton
            ];
            for (const id of possibleTriggerIds) {
                triggerButton = document.getElementById(id);
                if (triggerButton) break;
            }

            if (popover && !popover.contains(event.target) && (!triggerButton || !triggerButton.contains(event.target))) {
                hideActivePopover();
            }
        }
      }, true); // Use capture phase to catch clicks early
    };

    // --- UI View Management ---
    function switchToListView() {
      console.log("Switching to List View");
      adminApp.state.currentView = 'list';
      adminApp.state.currentProjectId = null;
      adminApp.state.projectData = null;
      adminApp.state.currentSlideIndex = -1;
      hideActivePopover(); // Ensure popovers are closed

      if (adminApp.state.fabricCanvasInstance) {
          adminApp.state.fabricCanvasInstance.dispose();
          adminApp.state.fabricCanvasInstance = null;
          console.log("Admin_JS: Disposed fabric canvas instance.");
      }
      if(listViewContainerEl) listViewContainerEl.style.display = 'block';
      if(editViewContainerEl) editViewContainerEl.style.display = 'none';
      if (messageAreaEl) messageAreaEl.innerHTML = '';
      // Hide the old media and overlay sections if they still exist
      const h3Elements = document.querySelectorAll('.edit-controls-group h3');
      h3Elements.forEach(h3 => {
          if (h3.textContent.includes('Current Slide Settings / Media')) {
              const oldMediaSection = h3.closest('.edit-controls-group');
              if (oldMediaSection) oldMediaSection.style.display = 'none';
          }
          if (h3.textContent.includes('Overlay Tools')) {
              const oldOverlaySection = h3.closest('.edit-controls-group');
              if (oldOverlaySection) oldOverlaySection.style.display = 'none';
          }
      });

      // Remove paste listener if it was active
      if (adminApp.state.isPasteListenerActive) {
          document.removeEventListener('paste', handlePasteImage);
          adminApp.state.isPasteListenerActive = false;
          console.log("Admin_JS: Paste event listener for images removed from document.");
      }
      loadAdminProjectsList(); // Reload list in case status changed etc.
    }

    function switchToEditView(projectIdToEdit) {
        console.log("Switching to Edit View for project ID:", projectIdToEdit);
        adminApp.state.currentView = 'edit';
        adminApp.state.currentProjectId = projectIdToEdit;
        adminApp.state.projectData = null; // Clear previous project data
        adminApp.state.currentSlideIndex = -1; // Reset slide index
        hideActivePopover(); // Ensure popovers are closed

        if(listViewContainerEl) listViewContainerEl.style.display = 'none';
        if(editViewContainerEl) editViewContainerEl.style.display = 'block';

        if(editingProjectTitleEl) { // Set temporary title
            editingProjectTitleEl.textContent = `Loading Project (ID: ${projectIdToEdit})...`;
        }

        // Clear previous canvas instance if exists
        if (adminApp.state.fabricCanvasInstance) {
            adminApp.state.fabricCanvasInstance.dispose();
            adminApp.state.fabricCanvasInstance = null;
        }
        if (messageAreaEl) messageAreaEl.innerHTML = '';
        const h3Elements = document.querySelectorAll('.edit-controls-group h3');
        h3Elements.forEach(h3 => {
            if (h3.textContent.includes('Current Slide Settings / Media')) {
                const oldMediaSection = h3.closest('.edit-controls-group');
                if (oldMediaSection) oldMediaSection.style.display = 'none';
            }
            if (h3.textContent.includes('Overlay Tools')) {
                const oldOverlaySection = h3.closest('.edit-controls-group');
                if (oldOverlaySection) oldOverlaySection.style.display = 'none';
            }
        });
        if (slideThumbnailsContainerEl) slideThumbnailsContainerEl.innerHTML = ''; // Clear old thumbnails

        // Helper to ensure elements are found and listeners attached ONLY ONCE for edit view
        const ensureEditViewListener = (elementVar, id, eventType, handler, critical = false) => {
            // Assign element reference if not already assigned in setupDOMReferences (might be null initially)
             if (!window[elementVar]) { // Check if the global variable (e.g., backToProjectsListButtonEl) is already set
                window[elementVar] = document.getElementById(id);
             }
            const element = window[elementVar]; // Use the global variable
            // Ensure listener isn't attached multiple times if view is switched back and forth rapidly
            const listenerAttribute = `listener-${eventType}-attached`;
            if (element && !element.hasAttribute(listenerAttribute)) {
                element.addEventListener(eventType, handler);
                element.setAttribute(listenerAttribute, 'true');
                console.log(`Listener attached for ${eventType} on #${id} in switchToEditView.`);
            } else if (!element && critical) { // Log warning only for elements we absolutely expect
                 console.warn(`CRITICAL WARN: Element #${id} not found in switchToEditView! Cannot attach listener.`);
            }
        };

        // Ensure references are fresh (needed after potential view switches)
        fabricCanvasEl = document.getElementById('fabricCanvasElement');
        slideThumbnailsContainerEl = document.getElementById('slideThumbnailsContainer');
        adminMediaPlaceholderEl = document.getElementById('adminMediaPlaceholder');
        overlayPropertiesToolbarEl = document.getElementById('overlayPropertiesToolbar'); // Ensure this is fresh

        // Attach listeners for edit view buttons and controls
        ensureEditViewListener('backToProjectsListButtonEl', 'backToProjectsListButton', 'click', switchToListView, true);
        ensureEditViewListener('imageUploaderEl', 'imageUploader', 'change', handleImageUpload, true);
        ensureEditViewListener('addSlideButtonEl', 'addSlideButton', 'click', handleAddSlide, true);
        ensureEditViewListener('saveProjectButtonEl', 'saveProjectButton', 'click', handleSaveProject, true);
        ensureEditViewListener('addRectangleButtonEl', 'addRectangleButton', 'click', addRectangle, true);
        ensureEditViewListener('addCircleButtonEl', 'addCircleButton', 'click', addCircle, true);
        ensureEditViewListener('addTextboxButtonEl', 'addTextboxButton', 'click', addTextbox, true);
        ensureEditViewListener('setYoutubeBackgroundButtonEl', 'setYoutubeBackgroundButton', 'click', handleSetYoutubeBackground, true);
        ensureEditViewListener('audioUploaderEl', 'audioUploader', 'change', handleAudioUpload, true); // Auto-upload on change
        ensureEditViewListener('removeAudioButtonEl', 'removeAudioButton', 'click', handleRemoveAudio, true);

        // Initialize Fabric Canvas with defaults
        if (typeof fabric !== 'undefined' && fabricCanvasEl) {
            adminApp.state.fabricCanvasInstance = new fabric.Canvas('fabricCanvasElement', {
                width: adminApp.state.defaultCanvasWidth,
                height: adminApp.state.defaultCanvasHeight,
                backgroundColor: '#e9e9e9' // Default background
            });
            // Set initial size of the HTML canvas element itself
            fabricCanvasEl.width = adminApp.state.defaultCanvasWidth;
            fabricCanvasEl.height = adminApp.state.defaultCanvasHeight;
            console.log("Admin_JS: Fabric.js canvas initialized with default dimensions.");

            initToolbar(); // IMPORTANT: Initialize new toolbar structure and listeners

            // Attach Fabric canvas event listeners
            adminApp.state.fabricCanvasInstance.off(); // Remove previous listeners first
            adminApp.state.fabricCanvasInstance.on('object:modified', (e) => {
              if (e.target) populateToolbar(e.target);
            });
            adminApp.state.fabricCanvasInstance.on('selection:created', (e) => {
              if (e.selected && e.selected.length === 1) populateToolbar(e.selected[0]);
              else populateToolbar(null); // Handle multi-select or empty selection
            });
            adminApp.state.fabricCanvasInstance.on('selection:updated', (e) => {
               if (e.selected && e.selected.length === 1) populateToolbar(e.selected[0]);
               else populateToolbar(null);
            });
            adminApp.state.fabricCanvasInstance.on('selection:cleared', () => {
              populateToolbar(null);
            });

            // Initially hide toolbar (new one)
            if(overlayPropertiesToolbarEl) overlayPropertiesToolbarEl.style.display = 'none';
            hideActivePopover(); // Make sure all popovers are hidden initially

            // Attach paste listener for images
            if (!adminApp.state.isPasteListenerActive) {
                document.addEventListener('paste', handlePasteImage);
                adminApp.state.isPasteListenerActive = true;
                console.log("Admin_JS: Paste event listener for images attached to document.");
            }

            loadProjectForEditing(projectIdToEdit); // Load the actual project data

        } else {
            console.error("Fabric.js library or canvas element #fabricCanvasElement not found in switchToEditView.");
            displayMessage("Critical error: Editor canvas could not be initialized.", false);
            showLoading(false); // Ensure spinner hidden
        }
    }

    // --- Popover Management ---
    function togglePopover(popoverId, triggerButtonEl) {
        if (adminApp.state.activePopoverId === popoverId) {
            hideActivePopover();
        } else {
            hideActivePopover(); // Hide any currently open popover
            const popover = document.getElementById(popoverId);
            if (popover && triggerButtonEl) {
                // First, reset any positioning to get natural size
                popover.style.display = 'block';
                popover.style.position = 'absolute';
                popover.style.top = 'auto';
                popover.style.left = 'auto';
                
                // Get positions after element is visible
                const btnRect = triggerButtonEl.getBoundingClientRect();
                const popoverRect = popover.getBoundingClientRect();
                
                // Get viewport dimensions
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // Calculate initial position (below button)
                let posTop = btnRect.bottom + 5;
                let posLeft = btnRect.left;
                
                // Adjust if popover would go off-screen
                if (posLeft + popoverRect.width > viewportWidth) {
                    posLeft = btnRect.right - popoverRect.width;
                }
                
                // If popover would go below viewport, position it above the button instead
                if (posTop + popoverRect.height > viewportHeight) {
                    posTop = btnRect.top - popoverRect.height - 5;
                }
                
                // Apply final position
                popover.style.top = posTop + 'px';
                popover.style.left = posLeft + 'px';
                
                // Set active states
                adminApp.state.activePopoverId = popoverId;
                
                // Add active class to button
                document.querySelectorAll('.toolbar-button').forEach(btn => {
                    btn.classList.remove('popover-active');
                });
                triggerButtonEl.classList.add('popover-active');
            } else {
                console.warn("togglePopover: Popover or trigger button not found for ID:", popoverId);
            }
        }
    }

    function hideActivePopover() {
        if (adminApp.state.activePopoverId) {
            const popover = document.getElementById(adminApp.state.activePopoverId);
            if (popover) popover.style.display = 'none';
            adminApp.state.activePopoverId = null;
        }
    }

    function switchMediaTab(tabId) {
        // Hide all tab panes
        document.querySelectorAll('.media-tab-pane').forEach(pane => {
            pane.classList.remove('active');
        });
        
        // Remove active class from all tab buttons
        document.querySelectorAll('.media-tab-btn').forEach(tab => {
            tab.classList.remove('active');
        });
        
        // Show the selected tab pane
        const tabPane = document.getElementById(tabId);
        if (tabPane) tabPane.classList.add('active');
        
        // Add active class to the clicked tab button
        const activeTabBtn = document.querySelector(`.media-tab-btn[data-tab="${tabId}"]`);
        if (activeTabBtn) activeTabBtn.classList.add('active');
        
        // Display audio controls if we're on the audio tab and there's an attached audio
        if (tabId === 'audio-tab') {
            const currentSlide = getCurrentSlide();
            const hasAudio = currentSlide && currentSlide.slideMedia && 
                            currentSlide.slideMedia.type === 'audio' && 
                            currentSlide.slideMedia.driveFileId;
            if (document.getElementById('audioControls')) {
                document.getElementById('audioControls').style.display = hasAudio ? 'block' : 'none';
            }
        }
    }

    // Helper function to get current slide
    function getCurrentSlide() {
        if (adminApp.state.currentSlideIndex === -1 || !adminApp.state.projectData || 
            !adminApp.state.projectData.slides || 
            !adminApp.state.projectData.slides[adminApp.state.currentSlideIndex]) {
            return null;
        }
        return adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
    }

    // --- Project Loading/Saving ---
    function loadProjectForEditing(projectId) {
      console.log(`loadProjectForEditing: Called for projectId: ${projectId}`);
      if (!projectId) { console.error("loadProjectForEditing: No projectId."); displayMessage("Error: Cannot load project.", false); return; }
      showLoading(true);
      displayMessage("Loading project data...", true);
      google.script.run
          .withSuccessHandler(onProjectDataLoaded)
          .withFailureHandler(onServerError)
          .getProjectDataForEditing(projectId);
    }

    function onProjectDataLoaded(jsonString) {
      console.log("onProjectDataLoaded: Received data string length:", jsonString ? jsonString.length : 'null');

      if (jsonString === null || jsonString === undefined) {
          showLoading(false);
          console.error("onProjectDataLoaded: Received null data string from server (Project or data file likely not found).");
          displayMessage("Error: Could not load project data. Project or its data file may not exist.", false);
          adminApp.state.projectData = { projectId: adminApp.state.currentProjectId, title: "Error Loading", slides: [] };
          adminApp.state.currentSlideIndex = -1;
          if (editingProjectTitleEl) editingProjectTitleEl.textContent = `Error Loading Project (ID: ${adminApp.state.currentProjectId})`;
          updateSlideThumbnailsUI();
          return;
      }

      try {
          const loadedData = JSON.parse(jsonString);
          console.log("Parsed project data:", loadedData);

          if (!loadedData || typeof loadedData !== 'object') throw new Error("Parsed data is not a valid object.");
          if (!loadedData.projectId) throw new Error("Loaded project data is missing 'projectId'.");

          if (!Array.isArray(loadedData.slides)) {
               console.warn("Loaded data missing 'slides' array or it's invalid, defaulting to empty.");
               loadedData.slides = [];
          }

          loadedData.slides.forEach(slide => {
              if (!slide.slideMedia) {
                  slide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
              }
          });

          adminApp.state.projectData = loadedData;

          if (editingProjectTitleEl) {
              editingProjectTitleEl.textContent = `Editing Project: ${adminApp.state.projectData.title || '(Untitled)'}`;
          }

          updateSlideThumbnailsUI();

          if (adminApp.state.projectData.slides.length > 0) {
              selectSlide(0); // Select and load the first slide
              displayMessage("Project loaded successfully.", true);
          } else {
              displayMessage("Project loaded, but it has no slides. Adding one.", true);
              handleAddSlide(); // Add an initial slide if the loaded project was empty
          }
          showLoading(false); // Success path loading finished

      } catch (e) {
          showLoading(false);
          console.error("onProjectDataLoaded: Error parsing JSON data or invalid structure:", e);
          console.error("Received JSON string that failed parsing:", jsonString);
          displayMessage(`Error: Failed to parse loaded project data. ${e.message}`, false);
          adminApp.state.projectData = { projectId: adminApp.state.currentProjectId, title: "Invalid Data", slides: [] };
          adminApp.state.currentSlideIndex = -1;
          if (editingProjectTitleEl) editingProjectTitleEl.textContent = `Invalid Project Data (ID: ${adminApp.state.currentProjectId})`;
          updateSlideThumbnailsUI(); // Clear thumbnails
      }
    }

    function saveCurrentSlideState() {
        if (adminApp.state.currentSlideIndex === -1 || !adminApp.state.fabricCanvasInstance || !adminApp.state.projectData || !adminApp.state.projectData.slides[adminApp.state.currentSlideIndex]) {
            console.log("saveCurrentSlideState: Skipping, no active slide/canvas/data.");
            return;
        }
        try {
          const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
          const canvas = adminApp.state.fabricCanvasInstance;
          const propsToInclude = ['slideId', 'canvasWidth', 'canvasHeight', 'customInteraction', 'customAnimation', 'sequenceOrder'];
          currentSlide.fabricCanvasJSON = canvas.toJSON(propsToInclude);
          currentSlide.canvasWidth = canvas.getWidth();
          currentSlide.canvasHeight = canvas.getHeight();
          if (!currentSlide.slideMedia) {
               currentSlide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
          }
          if(currentSlide.slideMedia.type !== 'image' && currentSlide.slideMedia.url && currentSlide.slideMedia.url.startsWith('data:image')) {
              currentSlide.slideMedia.url = null;
          }

          console.log(`Slide ${adminApp.state.currentSlideIndex + 1} state saved. Media:`, JSON.stringify(currentSlide.slideMedia));
        } catch(e) {
            console.error(`Error saving slide state for index ${adminApp.state.currentSlideIndex}:`, e);
            displayMessage(`Error saving current slide state: ${e.message}`, false);
        }
    }

    function handleSaveProject() {
        if (!adminApp.state.projectData || !adminApp.state.currentProjectId) { displayMessage("No project data to save.", false); return; }
        if (adminApp.state.isLoading) { console.log("handleSaveProject: Already saving."); return; }

        saveCurrentSlideState(); // Ensure latest slide state is captured before saving entire project

        showLoading(true); displayMessage("Saving project...", true);
        try {
            const projectDataToSave = JSON.parse(JSON.stringify(adminApp.state.projectData));

             projectDataToSave.slides.forEach(slide => {
                 if (slide.slideMedia && slide.slideMedia.type !== 'image' && slide.slideMedia.url && slide.slideMedia.url.startsWith('data:image')) {
                     slide.slideMedia.url = null;
                 }
             });

            const jsonDataString = JSON.stringify(projectDataToSave);
            console.log("Saving projectData string length:", jsonDataString.length);

            google.script.run
                .withSuccessHandler(onProjectSaved)
                .withFailureHandler(onServerError)
                .saveProjectData(adminApp.state.currentProjectId, jsonDataString);
        } catch (e) {
             showLoading(false);
             console.error("Error stringifying project data for saving:", e);
             displayMessage("Error preparing data for saving.", false);
        }
    }

    function onProjectSaved(response) {
        showLoading(false);
        if (response && response.success) { displayMessage(response.message || "Project saved!", true); }
        else { onServerError((response && response.error) ? response.error : "Failed to save."); }
    }

    // --- Slide Management ---
    function handleAddSlide() {
        console.log("handleAddSlide called");
        if (!adminApp.state.projectData) { console.error("handleAddSlide: projectData not initialized."); return; }
        saveCurrentSlideState(); // Save previous slide first
        const newSlideId = 'slide_' + Utilities.getUuid();
        const newSlide = {
            slideId: newSlideId,
            canvasWidth: adminApp.state.defaultCanvasWidth,
            canvasHeight: adminApp.state.defaultCanvasHeight,
            fabricCanvasJSON: null,
            slideMedia: { type: null, url: null, driveFileId: null, mimeType: null, originalName: null }
        };
        if (!adminApp.state.projectData.slides) adminApp.state.projectData.slides = [];
        adminApp.state.projectData.slides.push(newSlide);
        const newSlideIndex = adminApp.state.projectData.slides.length - 1;
        selectSlide(newSlideIndex); // Select the new slide
        console.log("Added new slide. Total slides:", adminApp.state.projectData.slides.length);
    }

    function selectSlide(slideIndex) {
        if (!adminApp.state.projectData || !adminApp.state.projectData.slides || slideIndex < 0 || slideIndex >= adminApp.state.projectData.slides.length) { console.error("selectSlide: Invalid index or slides array missing.", slideIndex); return; }
        console.log(`Selecting slide ${slideIndex + 1}`);

        if (adminApp.state.currentSlideIndex !== -1 && adminApp.state.currentSlideIndex < adminApp.state.projectData.slides.length) {
             saveCurrentSlideState();
        }

        adminApp.state.currentSlideIndex = slideIndex;
        const selectedSlideData = adminApp.state.projectData.slides[slideIndex];
        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas) { console.error("selectSlide: Canvas not ready!"); return; }

        if (!selectedSlideData.slideMedia) {
            selectedSlideData.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
        }

        const slideWidth = selectedSlideData.canvasWidth || adminApp.state.defaultCanvasWidth;
        const slideHeight = selectedSlideData.canvasHeight || adminApp.state.defaultCanvasHeight;
        canvas.setWidth(slideWidth);
        canvas.setHeight(slideHeight);
        if (fabricCanvasEl) { fabricCanvasEl.width = slideWidth; fabricCanvasEl.height = slideHeight; }
        console.log(`Canvas set to dimensions for slide ${slideIndex + 1}: ${slideWidth}x${slideHeight}`);

        canvas.clear();
        canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas));
        canvas.backgroundColor = '#e9e9e9';

        if (imageUploaderEl) imageUploaderEl.value = null;
        if (youtubeUrlInputEl) youtubeUrlInputEl.value = '';
        if (audioUploaderEl) audioUploaderEl.value = null;
        if (attachedAudioNameEl) attachedAudioNameEl.textContent = '';
        if (removeAudioButtonEl) removeAudioButtonEl.style.display = 'none';
        if (adminMediaPlaceholderEl) adminMediaPlaceholderEl.style.display = 'none';

        const media = selectedSlideData.slideMedia;
        if (media && media.type === 'image' && (media.url || media.driveFileId)) {
            if (media.url && media.url.startsWith('data:image')) {
                console.log("Loading background from base64 data URI.");
                fabric.Image.fromURL(media.url, function(img) {
                    if (!adminApp.state.fabricCanvasInstance || adminApp.state.currentSlideIndex !== slideIndex) return;
                    adminApp.state.fabricCanvasInstance.setBackgroundImage(img, canvas.renderAll.bind(canvas), { scaleX: canvas.width / img.width, scaleY: canvas.height / img.height });
                    console.log("Background loaded for slide", slideIndex);
                }, { crossOrigin: 'anonymous' });
                 if (adminMediaPlaceholderEl) adminMediaPlaceholderEl.style.display = 'none';
            } else if (media.driveFileId) {
                 console.log(`Background needs fetch from Drive ID for slide ${slideIndex + 1}:`, media.driveFileId);
                 showLoading(true); displayMessage("Loading slide background...", true);
                 google.script.run.withSuccessHandler(function(response) {
                     showLoading(false);
                     if (adminApp.state.currentSlideIndex !== slideIndex) { console.log("Slide changed before background could be fetched for index", slideIndex); return; }
                     if (response && response.success && response.base64Data) {
                          media.url = response.base64Data;
                         fabric.Image.fromURL(response.base64Data, function(img) {
                             if (!adminApp.state.fabricCanvasInstance) return;
                             adminApp.state.fabricCanvasInstance.setBackgroundImage(img, canvas.renderAll.bind(canvas), { scaleX: canvas.width / img.width, scaleY: canvas.height / img.height });
                             console.log("Background fetched and loaded for slide", slideIndex);
                         });
                         if (adminMediaPlaceholderEl) adminMediaPlaceholderEl.style.display = 'none';
                     } else { console.error("Failed to re-fetch background", response); displayMessage("Error loading slide background image.", false); canvas.renderAll(); }
                 }).withFailureHandler(onServerError).getImageAsBase64(media.driveFileId);
             } else { console.warn("Slide media URL/ID not suitable for loading:", media); canvas.renderAll(); }
        } else if (media && media.type === 'youtube' && media.url) {
            console.log("Displaying YouTube placeholder for URL:", media.url);
             if (adminMediaPlaceholderEl) {
                 adminMediaPlaceholderEl.textContent = `YouTube BG: ${media.url}`;
                 adminMediaPlaceholderEl.style.display = 'block';
             }
             if (youtubeUrlInputEl) youtubeUrlInputEl.value = media.url;
             canvas.backgroundColor = '#444';
             canvas.renderAll();
        } else if (media && media.type === 'audio' && (media.driveFileId)) {
             console.log("Indicating attached audio:", media.originalName || media.driveFileId);
             if (attachedAudioNameEl) attachedAudioNameEl.textContent = `Attached: ${media.originalName || 'Audio File'}`;
             if (removeAudioButtonEl) removeAudioButtonEl.style.display = 'inline-block';
             if (document.getElementById('audioControls')) {
                 document.getElementById('audioControls').style.display = 'block';
             }
             if (adminMediaPlaceholderEl) {
                 adminMediaPlaceholderEl.textContent = `Audio Attached: ${media.originalName || 'Audio File'}`;
                 adminMediaPlaceholderEl.style.display = 'block';
             }
             canvas.renderAll();
        } else {
            console.log("No background media found or configured for slide", slideIndex);
             if (adminMediaPlaceholderEl) adminMediaPlaceholderEl.style.display = 'none';
             canvas.backgroundColor = '#e9e9e9';
             canvas.renderAll();
        }

        if (selectedSlideData.fabricCanvasJSON) {
          console.log("Loading fabricCanvasJSON for slide", slideIndex);
          canvas.loadFromJSON(selectedSlideData.fabricCanvasJSON, function() {
              if (!adminApp.state.fabricCanvasInstance || adminApp.state.currentSlideIndex !== slideIndex) return;
              adminApp.state.fabricCanvasInstance.renderAll();
              console.log("Finished loading canvas JSON for slide", slideIndex);
              const activeObj = adminApp.state.fabricCanvasInstance.getActiveObject();
              populateToolbar(activeObj); // Update new toolbar
            }, function(o, object) { /* Revival function if needed */ });
            } else {
            console.log("No fabricCanvasJSON to load for slide", slideIndex);
            canvas.renderAll();
            populateToolbar(null); // Clear new toolbar
        }
        updateSlideThumbnailsUI();
    }

    function updateSlideThumbnailsUI() {
        if (!slideThumbnailsContainerEl || !adminApp.state.projectData) { console.warn("updateSlideThumbnailsUI: Container or project data missing."); return; }
        slideThumbnailsContainerEl.innerHTML = '';
        if (!adminApp.state.projectData.slides) adminApp.state.projectData.slides = [];
        adminApp.state.projectData.slides.forEach((slide, index) => {
            const thumb = document.createElement('div'); thumb.className = 'slide-thumbnail';
            thumb.textContent = `Slide ${index + 1}`; thumb.title = `Select Slide ${index + 1}`;
            if (index === adminApp.state.currentSlideIndex) thumb.classList.add('active-slide');
            thumb.onclick = function() { selectSlide(index); };
            const deleteBtn = document.createElement('button'); deleteBtn.className = 'delete-slide-btn'; deleteBtn.innerHTML = '×'; deleteBtn.title = "Delete slide";
            deleteBtn.onclick = function(event) { event.stopPropagation(); handleDeleteSlide(index); };
            thumb.appendChild(deleteBtn); slideThumbnailsContainerEl.appendChild(thumb);
        });
    }

    function handleDeleteSlide(slideIndex) {
        if (!adminApp.state.projectData || !adminApp.state.projectData.slides || slideIndex < 0 || slideIndex >= adminApp.state.projectData.slides.length) { console.error("handleDeleteSlide: Invalid index."); return; }
        if (adminApp.state.projectData.slides.length <= 1) { displayMessage("Cannot delete the last slide.", false); return; }
        if (!confirm(`Are you sure you want to delete Slide ${slideIndex + 1}?`)) return;
        adminApp.state.projectData.slides.splice(slideIndex, 1);
        console.log("Deleted slide at index:", slideIndex);
        const indexToSelect = (slideIndex === 0 && adminApp.state.projectData.slides.length > 0) ? 0 : Math.max(0, slideIndex - 1);

        if (adminApp.state.currentSlideIndex === slideIndex) {
            adminApp.state.currentSlideIndex = -1;
            selectSlide(indexToSelect);
        } else if (adminApp.state.currentSlideIndex > slideIndex) {
            adminApp.state.currentSlideIndex--;
            updateSlideThumbnailsUI();
        } else {
             updateSlideThumbnailsUI();
        }
    }

    // --- Project Management (Status/Delete) ---
    function handleProjectStatusChange(projectId, newStatus, selectElement) {
        console.log(`Attempting to update status for project ${projectId} to ${newStatus}`);
        showLoading(true);
        const originalStatus = selectElement.getAttribute('data-original-status') ||
                               (adminApp.state.projectListCache.find(p => p.projectId === projectId) || {}).status;
        selectElement.setAttribute('data-original-status', originalStatus);

        google.script.run
            .withSuccessHandler(function(response) { onProjectStatusUpdated(response, projectId, newStatus, selectElement); })
            .withFailureHandler(function(error) {
                onServerError(error);
                if (selectElement) {
                    console.log("Reverting status dropdown due to server error for project:", projectId);
                    selectElement.value = originalStatus;
                }
            })
            .updateProjectStatus(projectId, newStatus);
    }

    function onProjectStatusUpdated(response, projectId, newStatus, selectElement) {
        showLoading(false);
        if (response && response.success) {
            displayMessage(response.message || "Project status updated successfully!", true);

            const projectInCache = adminApp.state.projectListCache.find(p => p.projectId === projectId);
            if (projectInCache) projectInCache.status = newStatus;
            selectElement.removeAttribute('data-original-status');

            const statusSpan = selectElement.closest('.project-item').querySelector('.status-text');
            if(statusSpan) statusSpan.textContent = `(${newStatus})`;

            if (adminApp.state.currentView === 'edit' && adminApp.state.currentProjectId === projectId && adminApp.state.projectData) {
                adminApp.state.projectData.status = newStatus;
            }
        } else {
            onServerError((response && response.error) ? response.error : "Failed to update status.");
            if (selectElement) {
                 console.log("Reverting status dropdown due to server failure for project:", projectId);
                 const originalStatus = selectElement.getAttribute('data-original-status');
                 if(originalStatus) selectElement.value = originalStatus;
            }
        }
    }

    function handleDeleteProject(projectId, projectTitle) {
        if (!confirm(`Are you sure you want to delete the project "${projectTitle}" (ID: ${projectId})? This action cannot be undone.`)) {
            return;
        }
        console.log(`Attempting to delete project ${projectId}`);
        showLoading(true);
        google.script.run
            .withSuccessHandler(onProjectDeleted)
            .withFailureHandler(onServerError)
            .deleteProject(projectId);
    }

    function onProjectDeleted(response) {
        showLoading(false);
        if (response && response.success) {
            displayMessage(response.message || "Project deleted successfully!", true);
            if (adminApp.state.currentView === 'edit' && adminApp.state.currentProjectId === response.deletedProjectId) {
                switchToListView();
            } else {
                loadAdminProjectsList();
            }
        } else {
            onServerError((response && response.error) ? response.error : "Failed to delete project.");
        }
    }

    // --- Error Handling & UI Utils ---
    function showLoading(show) {
      adminApp.state.isLoading = show;
      if (loadingSpinnerEl) loadingSpinnerEl.style.display = show ? 'flex' : 'none';
      else if (show) console.warn("showLoading(true) loadingSpinnerEl not found.");
    }
    function displayMessage(message, isSuccess) {
        if (messageAreaEl) { messageAreaEl.innerHTML = ''; const p = document.createElement('p'); p.textContent = message; messageAreaEl.appendChild(p); messageAreaEl.className = isSuccess ? 'success' : 'error'; setTimeout(() => { if (messageAreaEl) { messageAreaEl.innerHTML = ''; messageAreaEl.className = ''; } }, 7000); } else { console.warn("displayMessage messageAreaEl not found. Message:", message); }
    }

    function onServerError(errorObject) {
      console.error("onServerError triggered:", errorObject);
      showLoading(false);
      let errorMessage = "An unknown server error occurred.";
       if (typeof errorObject === 'string') { errorMessage = errorObject; }
       else if (errorObject && errorObject.message) { errorMessage = errorObject.message; }
       else if (errorObject && errorObject.error && typeof errorObject.error === 'string') { errorMessage = errorObject.error; }
      console.error('Formatted Server Error Message:', errorMessage);
      displayMessage('Server Error: ' + errorMessage, false);
    }

    function handleCreateProject() {
        if (adminApp.state.isLoading) return;
        const currentProjectTitle = projectTitleInputEl.value.trim();
        if (!currentProjectTitle) { displayMessage('Project title cannot be empty.', false); projectTitleInputEl.focus(); return; }
        showLoading(true);
        google.script.run.withSuccessHandler(onProjectCreated).withFailureHandler(onServerError).createProject(currentProjectTitle);
    }
    function onProjectCreated(response) {
        showLoading(false);
        if (response && response.success) { displayMessage(response.message || 'Project created!', true); if(projectTitleInputEl) projectTitleInputEl.value = ''; loadAdminProjectsList(); }
        else { onServerError((response && response.error) ? response.error : 'Failed to create project.'); }
    }

    function loadAdminProjectsList() {
      console.log("loadAdminProjectsList: Function called.");
      if (!adminProjectListContainerEl) { console.error("loadAdminProjectsList: adminProjectListContainerEl not found."); showLoading(false); return; }
      if (!google || !google.script || !google.script.run) { console.error("loadAdminProjectsList: google.script.run unavailable."); displayMessage("Error: Client-server bridge unavailable.", false); return; }
      showLoading(true);
      console.log("loadAdminProjectsList: Calling google.script.run.getAllProjectsForAdmin...");
      google.script.run
        .withSuccessHandler(displayAdminProjects)
        .withFailureHandler(onServerError)
        .getAllProjectsForAdmin();
       console.log("loadAdminProjectsList: google.script.run.getAllProjectsForAdmin call initiated.");
    }
    function displayAdminProjects(projectsArray) {
      console.log("displayAdminProjects (Success Handler) received data:", projectsArray);
      showLoading(false);
      if (!adminProjectListContainerEl) { console.error("displayAdminProjects: adminProjectListContainerEl not found."); return; }
      adminProjectListContainerEl.innerHTML = '';
      if (!projectsArray || projectsArray.length === 0) { adminProjectListContainerEl.innerHTML = '<p>No projects found.</p>'; return; }

      adminApp.state.projectListCache = projectsArray;

      projectsArray.forEach(project => {
          if (!project || !project.projectId) return;
          const projectItem = document.createElement('div');
          projectItem.className = 'project-item';

          const titleAndStatusDiv = document.createElement('div');
          const titleSpan = document.createElement('span');
          titleSpan.textContent = project.projectTitle || 'Untitled Project';
          titleSpan.style.fontWeight = 'bold';
          const statusTextSpan = document.createElement('span');
          statusTextSpan.className = 'status-text';
          statusTextSpan.textContent = `(${project.status || 'N/A'})`;
          titleAndStatusDiv.appendChild(titleSpan);
          titleAndStatusDiv.appendChild(statusTextSpan);

          const controlsDiv = document.createElement('div');
          const statusSelect = document.createElement('select');
          statusSelect.className = 'project-status-select';
          statusSelect.setAttribute('data-project-id', project.projectId);
          statusSelect.setAttribute('data-original-status', project.status || "Draft");
          ['Draft', 'Active', 'Inactive'].forEach(statusValue => {
              const option = document.createElement('option');
              option.value = statusValue;
              option.textContent = statusValue;
              if (project.status === statusValue) { option.selected = true; }
              statusSelect.appendChild(option);
          });
          statusSelect.onchange = function() { handleProjectStatusChange(project.projectId, this.value, this); };

          const editButton = document.createElement('button');
          editButton.textContent = 'Edit';
          editButton.className = 'edit-button';
          editButton.setAttribute('data-project-id', project.projectId);
          editButton.onclick = function() { console.log("Edit button clicked:", project.projectId); switchToEditView(project.projectId); };

          const deleteButton = document.createElement('button');
          deleteButton.textContent = 'Delete';
          deleteButton.className = 'danger-button';
          deleteButton.setAttribute('data-project-id', project.projectId);
          deleteButton.setAttribute('data-project-title', project.projectTitle || 'Untitled Project');
          deleteButton.style.marginLeft = '5px';
          deleteButton.onclick = function() { handleDeleteProject(project.projectId, project.projectTitle || 'Untitled Project'); };

          controlsDiv.appendChild(statusSelect);
          controlsDiv.appendChild(editButton);
          controlsDiv.appendChild(deleteButton);

          projectItem.appendChild(titleAndStatusDiv);
          projectItem.appendChild(controlsDiv);
          adminProjectListContainerEl.appendChild(projectItem);
       });
      console.log("displayAdminProjects: Finished rendering project list.");
    }

    // --- Media Handling ---
    function handleImageUpload(event) {
        if (adminApp.state.isLoading) { if (event.target) event.target.value = null; return; }
        const file = event.target.files[0];
        if (!file || !file.type.startsWith('image/')) { if(event.target) event.target.value = null; return; }

        saveCurrentSlideState();

        showLoading(true); displayMessage("Uploading image...", true);
        const reader = new FileReader();
        reader.onload = function(e) {
            const fileData = { fileName: file.name, mimeType: file.type, data: e.target.result.split(',')[1] };
            if (!adminApp.state.currentProjectId) { showLoading(false); displayMessage("Error: No project selected.", false); if(event.target) event.target.value = null; return; }
            google.script.run.withSuccessHandler(onImageUploaded).withFailureHandler(onServerError).uploadFileToDrive(fileData, adminApp.state.currentProjectId, 'image');
        };
        reader.onerror = function(error) { showLoading(false); displayMessage("Error reading file.", false); console.error(error); if(event.target) event.target.value = null; };
        reader.readAsDataURL(file);
    }

    function onImageUploaded(response) {
        showLoading(false);
        if (imageUploaderEl) imageUploaderEl.value = null;
        if (response && response.success && response.driveFileId) {
            displayMessage("Image processed. Fetching for preview...", true);
            showLoading(true);
            adminApp.state.lastUploadedDriveId = response.driveFileId;
            adminApp.state.lastUploadedMimeType = response.mimeType;
            adminApp.state.lastUploadedFileName = response.fileName;
            google.script.run
                .withSuccessHandler(onBase64ImageReceived)
                .withFailureHandler(onServerError)
                .getImageAsBase64(response.driveFileId);
        } else {
            onServerError({ message: (response && response.error) ? response.error : "Image processing failed." });
        }
    }

    function onBase64ImageReceived(response) {
        showLoading(false);
        if (response && response.success && response.base64Data) {
            if (!adminApp.state.fabricCanvasInstance || adminApp.state.currentSlideIndex === -1) { displayMessage("Error: Canvas/Slide not ready.", false); return; }
            const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
            if (!currentSlide) { displayMessage("Error: Slide data missing.", false); return; }

            fabric.Image.fromURL(response.base64Data, function(img) {
                if (!adminApp.state.fabricCanvasInstance || adminApp.state.currentSlideIndex === -1) return;
                const canvas = adminApp.state.fabricCanvasInstance;
                const imgWidth = img.width; const imgHeight = img.height;
                const maxWidth = 960;
                let cvWidth = imgWidth; let cvHeight = imgHeight; const ratio = imgWidth / imgHeight;
                if (cvWidth > maxWidth) { cvWidth = maxWidth; cvHeight = Math.round(cvWidth / ratio); }

                canvas.setWidth(cvWidth); canvas.setHeight(cvHeight);
                if (fabricCanvasEl) { fabricCanvasEl.width = cvWidth; fabricCanvasEl.height = cvHeight; }
                canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), { scaleX: cvWidth / imgWidth, scaleY: cvHeight / imgHeight });
                canvas.renderAll();
                displayMessage("Background image set.", true);

                if (!currentSlide.slideMedia) currentSlide.slideMedia = {};
                currentSlide.slideMedia.type = 'image';
                currentSlide.slideMedia.url = response.base64Data;
                currentSlide.slideMedia.driveFileId = adminApp.state.lastUploadedDriveId || null;
                currentSlide.slideMedia.mimeType = adminApp.state.lastUploadedMimeType || response.mimeType;
                currentSlide.slideMedia.originalName = adminApp.state.lastUploadedFileName || null;
                currentSlide.canvasWidth = cvWidth;
                currentSlide.canvasHeight = cvHeight;

                console.log(`Slide ${adminApp.state.currentSlideIndex + 1} media/dims updated for image.`);
                updateSlideThumbnailsUI();

                if (youtubeUrlInputEl) youtubeUrlInputEl.value = '';
                if (attachedAudioNameEl) attachedAudioNameEl.textContent = '';
                if (removeAudioButtonEl) removeAudioButtonEl.style.display = 'none';
                if (document.getElementById('audioControls')) {
                    document.getElementById('audioControls').style.display = 'none';
                }
                if (adminMediaPlaceholderEl) adminMediaPlaceholderEl.style.display = 'none';

                delete adminApp.state.lastUploadedDriveId;
                delete adminApp.state.lastUploadedMimeType;
                delete adminApp.state.lastUploadedFileName;

            }, { crossOrigin: 'anonymous' });
        } else {
            onServerError({ message: (response && response.error) ? response.error : "Failed to fetch image data." });
            delete adminApp.state.lastUploadedDriveId;
            delete adminApp.state.lastUploadedMimeType;
            delete adminApp.state.lastUploadedFileName;
        }
    }

    function handleSetYoutubeBackground() {
        if (!adminApp.state.projectData || adminApp.state.currentSlideIndex < 0) {
            displayMessage("Please select a slide first.", false); return;
        }
        if (!youtubeUrlInputEl || !youtubeUrlInputEl.value) {
            displayMessage("Please enter a YouTube URL.", false); return;
        }
        const url = youtubeUrlInputEl.value.trim();
        if (!url.includes("youtube.com/") && !url.includes("youtu.be/")) {
            displayMessage("Please enter a valid YouTube URL.", false);
            return;
        }

        saveCurrentSlideState();

        const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
        if (!currentSlide.slideMedia) {
            currentSlide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
        }
        currentSlide.slideMedia.type = 'youtube';
        currentSlide.slideMedia.url = url;
        currentSlide.slideMedia.driveFileId = null;
        currentSlide.slideMedia.mimeType = 'video/youtube';
        currentSlide.slideMedia.originalName = null;

        console.log(`Set YouTube background for slide ${adminApp.state.currentSlideIndex + 1} to: ${url}`);

        if(adminApp.state.fabricCanvasInstance) {
             adminApp.state.fabricCanvasInstance.setBackgroundImage(null, adminApp.state.fabricCanvasInstance.renderAll.bind(adminApp.state.fabricCanvasInstance));
             adminApp.state.fabricCanvasInstance.backgroundColor = '#444';
             adminApp.state.fabricCanvasInstance.renderAll();
        }
       if (adminMediaPlaceholderEl) {
           adminMediaPlaceholderEl.textContent = `YouTube BG: ${url}`;
           adminMediaPlaceholderEl.style.display = 'block';
       }
       if (imageUploaderEl) imageUploaderEl.value = null;
       if (audioUploaderEl) audioUploaderEl.value = null;
       if (attachedAudioNameEl) attachedAudioNameEl.textContent = '';
       if (removeAudioButtonEl) removeAudioButtonEl.style.display = 'none';

       displayMessage("YouTube background set for this slide.", true);
    }

    function handleAudioUpload(event) {
        if (adminApp.state.isLoading) { if (event.target) event.target.value = null; return; }
        const file = event.target.files[0];
        if (!file || !file.type.startsWith('audio/')) {
            if (event.target) event.target.value = null;
            return;
        }
        if (!adminApp.state.projectData || adminApp.state.currentSlideIndex < 0) {
             displayMessage("Please select a slide first before uploading audio.", false);
             if (event.target) event.target.value = null;
             return;
        }

        saveCurrentSlideState();

        showLoading(true); displayMessage("Uploading audio...", true);
        const reader = new FileReader();
        reader.onload = function(e) {
            const fileData = {
                fileName: file.name,
                mimeType: file.type,
                data: e.target.result.split(',')[1]
            };
            google.script.run
                .withSuccessHandler(onAudioUploaded)
                .withFailureHandler(onServerError)
                .uploadFileToDrive(fileData, adminApp.state.currentProjectId, 'audio');
        };
        reader.onerror = function(error) {
            showLoading(false);
            displayMessage("Error reading audio file.", false);
            console.error(error);
            if (event.target) event.target.value = null;
        };
        reader.readAsDataURL(file);
    }

     function onAudioUploaded(response) {
        showLoading(false);
        if (audioUploaderEl) audioUploaderEl.value = null;

        if (response && response.success && response.driveFileId) {
            displayMessage("Audio processed successfully.", true);

            const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
             if (!currentSlide.slideMedia) {
                currentSlide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
             }
            currentSlide.slideMedia.type = 'audio';
            currentSlide.slideMedia.url = null;
            currentSlide.slideMedia.driveFileId = response.driveFileId;
            currentSlide.slideMedia.mimeType = response.mimeType;
            currentSlide.slideMedia.originalName = response.fileName;

            console.log(`Audio attached for slide ${adminApp.state.currentSlideIndex + 1}:`, currentSlide.slideMedia);

            if (attachedAudioNameEl) attachedAudioNameEl.textContent = `Attached: ${response.fileName}`;
            if (removeAudioButtonEl) removeAudioButtonEl.style.display = 'inline-block';
            if (youtubeUrlInputEl) youtubeUrlInputEl.value = '';
            if (imageUploaderEl) imageUploaderEl.value = null;
            if(adminApp.state.fabricCanvasInstance) {
                adminApp.state.fabricCanvasInstance.setBackgroundImage(null, adminApp.state.fabricCanvasInstance.renderAll.bind(adminApp.state.fabricCanvasInstance));
                adminApp.state.fabricCanvasInstance.backgroundColor = '#e9e9e9';
                adminApp.state.fabricCanvasInstance.renderAll();
            }
            if (adminMediaPlaceholderEl) {
                 adminMediaPlaceholderEl.textContent = `Audio Attached: ${response.fileName}`;
                 adminMediaPlaceholderEl.style.display = 'block';
             }

        } else {
            onServerError((response && response.error) ? response.error : "Failed to process audio.");
        }
    }

    function handleRemoveAudio() {
        if (!adminApp.state.projectData || adminApp.state.currentSlideIndex < 0) return;

        const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
        if (currentSlide.slideMedia && currentSlide.slideMedia.type === 'audio') {
            console.log(`Removing audio from slide ${adminApp.state.currentSlideIndex + 1}`);

            currentSlide.slideMedia.type = null;
            currentSlide.slideMedia.url = null;
            currentSlide.slideMedia.driveFileId = null;
            currentSlide.slideMedia.mimeType = null;
            currentSlide.slideMedia.originalName = null;

            if (attachedAudioNameEl) attachedAudioNameEl.textContent = '';
            if (removeAudioButtonEl) removeAudioButtonEl.style.display = 'none';
            if (audioUploaderEl) audioUploaderEl.value = null;
            if (adminMediaPlaceholderEl) adminMediaPlaceholderEl.style.display = 'none';
            if(adminApp.state.fabricCanvasInstance) {
                adminApp.state.fabricCanvasInstance.backgroundColor = '#e9e9e9';
                adminApp.state.fabricCanvasInstance.renderAll();
             }
            displayMessage("Audio removed from this slide.", true);
        }
    }

    function handlePasteImage(event) {
        if (adminApp.state.currentView !== 'edit' || !adminApp.state.currentProjectId || adminApp.state.isLoading) {
            return;
        }
        const items = (event.clipboardData || event.originalEvent.clipboardData).items;
        let imageFound = false;
        for (let i = 0; i < items.length; i++) {
            if (items[i].kind === 'file' && items[i].type.startsWith('image/')) {
                imageFound = true;
                const blob = items[i].getAsFile();
                if (!blob) continue;
                event.preventDefault();
                console.log("Image pasted from clipboard:", blob.name, blob.type);
                saveCurrentSlideState();
                showLoading(true);
                displayMessage("Processing pasted image...", true);
                const reader = new FileReader();
                reader.onload = function(e_reader) {
                    const fileData = {
                        fileName: 'pasted_image.png',
                        mimeType: blob.type,
                        data: e_reader.target.result.split(',')[1]
                    };
                    if (!adminApp.state.currentProjectId) {
                        showLoading(false);
                        displayMessage("Error: No project selected for pasted image.", false);
                        return;
                    }
                    google.script.run
                        .withSuccessHandler(onImageUploaded)
                        .withFailureHandler(onServerError)
                        .uploadFileToDrive(fileData, adminApp.state.currentProjectId, 'image');
                };
                reader.onerror = function(error) {
                    showLoading(false);
                    displayMessage("Error reading pasted image data.", false);
                    console.error("FileReader error:", error);
                };
                reader.readAsDataURL(blob);
                break;
            }
        }
        if (imageFound) {
            console.log("Handled pasted image.");
        } else {
            console.log("Paste event did not contain a direct image file.");
        }
    }

    // --- Overlay Creation ---
    function addRectangle() {
      if (!adminApp.state.fabricCanvasInstance) { console.error("addRectangle: Fabric canvas not initialized."); displayMessage("Error: Canvas not ready to add shapes.", false); return; }
      const canvas = adminApp.state.fabricCanvasInstance;
      const rect = new fabric.Rect({ left: 50, top: 50, fill: 'rgba(255,0,0,0.7)', width: 150, height: 100, stroke: 'black', strokeWidth: 1, customInteraction: { trigger: "", action: "", modalContent: "", navigateTo: "" }, customAnimation: { type: null, duration: 500, strength: 5, trigger: null }, sequenceOrder: null });
      canvas.add(rect); canvas.setActiveObject(rect); canvas.renderAll(); console.log("Rectangle added to canvas:", rect);
    }

    function addCircle() {
      if (!adminApp.state.fabricCanvasInstance) { console.error("addCircle: Fabric canvas not initialized."); displayMessage("Error: Canvas not ready to add shapes.", false); return; }
      const canvas = adminApp.state.fabricCanvasInstance;
      const circle = new fabric.Circle({ left: 150, top: 150, radius: 50, fill: 'rgba(0,0,255,0.7)', stroke: 'black', strokeWidth: 1, customInteraction: { trigger: "", action: "", modalContent: "", navigateTo: "" }, customAnimation: { type: null, duration: 500, strength: 5, trigger: null }, sequenceOrder: null });
      canvas.add(circle); canvas.setActiveObject(circle); canvas.renderAll(); console.log("Circle added to canvas:", circle);
    }

    function addTextbox() {
      if (!adminApp.state.fabricCanvasInstance) { console.error("addTextbox: Fabric canvas not initialized."); displayMessage("Error: Canvas not ready to add text.", false); return; }
      const canvas = adminApp.state.fabricCanvasInstance;
      const textbox = new fabric.Textbox('Editable Text', {
          left: 100, top: 100, width: 200, fontSize: 24, fill: '#000000',
          fontFamily: 'Arial', fontWeight: 'normal', fontStyle: 'normal',
          textAlign: 'left', lineHeight: 1.16, charSpacing: 0,
          customInteraction: { trigger: "", action: "", modalContent: "", navigateTo: "" },
          customAnimation: { type: null, duration: 500, strength: 5, trigger: null },
          sequenceOrder: null
      });
      canvas.add(textbox); canvas.setActiveObject(textbox); canvas.renderAll(); canvas.bringToFront(textbox); console.log("Textbox added to canvas:", textbox);
    }

    // --- Toolbar Logic (Significantly Reworked) ---
    function toHexColor(fabricColor) {
      if (!fabricColor) return '#000000';
      try {
        if (typeof fabricColor === 'string') {
            const colorInstance = new fabric.Color(fabricColor);
            const hex = colorInstance.toHex();
            return '#' + hex;
        }
        return '#000000';
      } catch (e) {
        console.warn("Could not convert color to HEX:", fabricColor, e);
        return '#000000';
      }
    }

    function initToolbar() {
        console.log("initToolbar: Attaching listeners to NEW toolbar inputs and popovers.");
        hideActivePopover(); // Ensure all popovers start hidden

        // Populate Font Family Select (inside its popover)
        if(objFontFamilyEl) {
            objFontFamilyEl.innerHTML = ''; // Clear existing options
            FONT_FAMILIES.forEach(font => {
                const option = document.createElement('option'); option.value = font; option.textContent = font; objFontFamilyEl.appendChild(option);
            });
             // Listener for the font family select itself
            if (!objFontFamilyEl.hasAttribute('listener-attached')) {
                objFontFamilyEl.addEventListener('change', (e) => updateFabricObjectFromToolbar('fontFamily', e.target.value));
                objFontFamilyEl.setAttribute('listener-attached', 'true');
            }
        } else { console.warn("initToolbar: objFontFamilyEl not found for populating fonts."); }


        // --- Event Listeners for Popover Trigger Buttons ---
        const popoverTriggers = [
            { buttonEl: shadowSettingsButtonEl, popoverId: 'shadowPopover' },
            { buttonEl: interactionSettingsButtonEl, popoverId: 'interactionPopover' },
            { buttonEl: animationSettingsButtonEl, popoverId: 'animationPopover' },
            { buttonEl: fontFamilyButtonEl, popoverId: 'fontFamilyPopover' }
        ];
        popoverTriggers.forEach(item => {
            if (item.buttonEl && !item.buttonEl.hasAttribute('listener-attached')) {
                item.buttonEl.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent this click from immediately closing popover via document listener
                    togglePopover(item.popoverId, item.buttonEl);
                });
                item.buttonEl.setAttribute('listener-attached', 'true');
            } else if (!item.buttonEl) {
                console.warn(`initToolbar: Popover trigger button for ${item.popoverId} not found.`);
            }
        });

        // Add the new toolbar buttons to the popover triggers array
        const newTriggers = [
            { buttonEl: mediaToolsButtonEl, popoverId: 'mediaToolsPopover' },
            { buttonEl: addShapeButtonEl, popoverId: 'shapesPopover' },
            { buttonEl: positionToolsButtonEl, popoverId: 'positionToolsPopover' }
        ];

        newTriggers.forEach(item => {
            if (item.buttonEl && !item.buttonEl.hasAttribute('listener-attached')) {
                item.buttonEl.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent this click from immediately closing popover via document listener
                    togglePopover(item.popoverId, item.buttonEl);
                });
                item.buttonEl.setAttribute('listener-attached', 'true');
            } else if (!item.buttonEl) {
                console.warn(`initToolbar: Popover trigger button for ${item.popoverId} not found.`);
            }
        });

        // Media tab buttons event listeners
        if (mediaTabButtonsEl && mediaTabButtonsEl.length > 0) {
            mediaTabButtonsEl.forEach(tab => {
                if (!tab.hasAttribute('listener-attached')) {
                    tab.addEventListener('click', () => {
                        const tabId = tab.dataset.tab;
                        switchMediaTab(tabId);
                    });
                    tab.setAttribute('listener-attached', 'true');
                }
            });
        }

        // Drag and drop zone event listeners
        if (imageDropZoneEl && !imageDropZoneEl.hasAttribute('listener-attached')) {
            // Click to open file selector
            imageDropZoneEl.addEventListener('click', () => {
                if (imageUploaderEl) imageUploaderEl.click();
            });
            
            // Drag and drop events
            imageDropZoneEl.addEventListener('dragover', (e) => {
                e.preventDefault();
                imageDropZoneEl.classList.add('drag-over');
            });
            
            imageDropZoneEl.addEventListener('dragleave', () => {
                imageDropZoneEl.classList.remove('drag-over');
            });
            
            imageDropZoneEl.addEventListener('drop', (e) => {
                e.preventDefault();
                imageDropZoneEl.classList.remove('drag-over');
                
                if (e.dataTransfer.files.length > 0) {
                    const file = e.dataTransfer.files[0];
                    if (file.type.startsWith('image/')) {
                        // Create a mock event with files property for the handler
                        const mockEvent = { target: { files: [file] } };
                        handleImageUpload(mockEvent);
                    } else {
                        displayMessage("Please drop an image file.", false);
                    }
                }
            });
            
            imageDropZoneEl.setAttribute('listener-attached', 'true');
        }

        if (audioDropZoneEl && !audioDropZoneEl.hasAttribute('listener-attached')) {
            // Click to open file selector
            audioDropZoneEl.addEventListener('click', () => {
                if (audioUploaderEl) audioUploaderEl.click();
            });
            
            // Drag and drop events
            audioDropZoneEl.addEventListener('dragover', (e) => {
                e.preventDefault();
                audioDropZoneEl.classList.add('drag-over');
            });
            
            audioDropZoneEl.addEventListener('dragleave', () => {
                audioDropZoneEl.classList.remove('drag-over');
            });
            
            audioDropZoneEl.addEventListener('drop', (e) => {
                e.preventDefault();
                audioDropZoneEl.classList.remove('drag-over');
                
                if (e.dataTransfer.files.length > 0) {
                    const file = e.dataTransfer.files[0];
                    if (file.type.startsWith('audio/')) {
                        // Create a mock event with files property for the handler
                        const mockEvent = { target: { files: [file] } };
                        handleAudioUpload(mockEvent);
                    } else {
                        displayMessage("Please drop an audio file.", false);
                    }
                }
            });
            
            audioDropZoneEl.setAttribute('listener-attached', 'true');
        }

        // --- Event Listeners for Direct Toolbar Inputs (X, Y, Width, Height, Angle, StrokeWidth, Opacity, FontSize, LineHeight, CharSpacing) ---
        const directInputs = [
            {el: objXEl, prop: 'left', type: 'number'}, {el: objYEl, prop: 'top', type: 'number'},
            {el: objWidthEl, prop: 'width', type: 'number', targetProp: 'scaleX'},
            {el: objHeightEl, prop: 'height', type: 'number', targetProp: 'scaleY'},
            {el: objAngleEl, prop: 'angle', type: 'number'},
            {el: objStrokeWidthEl, prop: 'strokeWidth', type: 'number'},
            {el: objOpacityEl, prop: 'opacity', type: 'range'}, // Range input for opacity
            {el: objFontSizeEl, prop: 'fontSize', type: 'number'},
            {el: objLineHeightEl, prop: 'lineHeight', type: 'number', isFloat: true}, // lineHeight can be float
            {el: objCharSpacingEl, prop: 'charSpacing', type: 'number'},
            {el: objTextContentEl, prop: 'text', type: 'textarea'} // Textarea for content
        ];
        directInputs.forEach(inputConfig => {
            if (inputConfig.el && !inputConfig.el.hasAttribute('listener-attached')) {
                const eventType = (inputConfig.el.type === 'range' || inputConfig.el.type === 'textarea') ? 'input' : 'change'; // Use 'input' for live updates on range/textarea
                inputConfig.el.addEventListener(eventType, (e) => {
                    let value = e.target.value;
                    // For width/height, updateFabricObjectFromToolbar handles scaling
                    updateFabricObjectFromToolbar(inputConfig.prop, value, inputConfig.type); // Pass type for parsing
                });
                inputConfig.el.setAttribute('listener-attached', 'true');
            } else if (!inputConfig.el) {
                 console.warn(`initToolbar: Direct input element for prop "${inputConfig.prop}" not found.`);
            }
        });

        // --- Event Listeners for Color Inputs (Fill, Stroke) ---
        const colorInputs = [
            {el: objFillEl, prop: 'fill'},
            {el: objStrokeColorEl, prop: 'stroke'}
        ];
        colorInputs.forEach(inputConfig => {
            if (inputConfig.el && !inputConfig.el.hasAttribute('listener-attached')) {
                inputConfig.el.addEventListener('input', (e) => updateFabricObjectFromToolbar(inputConfig.prop, e.target.value)); // Use 'input' for live color update
                inputConfig.el.setAttribute('listener-attached', 'true');
            } else if (!inputConfig.el) {
                console.warn(`initToolbar: Color input element for prop "${inputConfig.prop}" not found.`);
            }
        });


        // --- Event Listeners for Text Style Toggle Buttons (Bold, Italic, Align) ---
        if (fontWeightButtonEl && !fontWeightButtonEl.hasAttribute('listener-attached')) { // Bold
            fontWeightButtonEl.addEventListener('click', () => {
                const activeObject = adminApp.state.fabricCanvasInstance.getActiveObject();
                if (!activeObject) return;
                const newValue = activeObject.fontWeight === 'bold' ? 'normal' : 'bold';
                updateFabricObjectFromToolbar('fontWeight', newValue);
                populateToolbar(activeObject);
            });
            fontWeightButtonEl.setAttribute('listener-attached', 'true');
        } else if(!fontWeightButtonEl) { console.warn("initToolbar: fontWeightButtonEl not found."); }

        if (fontStyleButtonEl && !fontStyleButtonEl.hasAttribute('listener-attached')) { // Italic
            fontStyleButtonEl.addEventListener('click', () => {
                const activeObject = adminApp.state.fabricCanvasInstance.getActiveObject();
                if (!activeObject) return;
                const newValue = activeObject.fontStyle === 'italic' ? 'normal' : 'italic';
                updateFabricObjectFromToolbar('fontStyle', newValue);
                populateToolbar(activeObject);
            });
            fontStyleButtonEl.setAttribute('listener-attached', 'true');
        } else if(!fontStyleButtonEl) { console.warn("initToolbar: fontStyleButtonEl not found."); }

        if (textAlignGroupEl && !textAlignGroupEl.hasAttribute('listener-attached')) { // Text Align
            const alignButtons = textAlignGroupEl.querySelectorAll('.toolbar-button');
            alignButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const alignValue = button.dataset.align;
                    updateFabricObjectFromToolbar('textAlign', alignValue);
                    populateToolbar(adminApp.state.fabricCanvasInstance.getActiveObject());
                });
            });
            textAlignGroupEl.setAttribute('listener-attached', 'true');
        } else if(!textAlignGroupEl) { console.warn("initToolbar: textAlignGroupEl not found."); }


        // --- Event Listeners for Inputs INSIDE Popovers (Shadow, Interaction, Animation) ---
        const shadowInputs = [
            {el: objShadowColorEl, prop: 'shadow.color', type: 'color'},
            {el: objShadowBlurEl, prop: 'shadow.blur', type: 'range'},
            {el: objShadowOffsetXEl, prop: 'shadow.offsetX', type: 'number'},
            {el: objShadowOffsetYEl, prop: 'shadow.offsetY', type: 'number'},
            {el: objShadowAffectStrokeEl, prop: 'shadow.affectStroke', type: 'checkbox'},
            {el: objShadowNonScalingEl, prop: 'shadow.nonScaling', type: 'checkbox'}
        ];
        shadowInputs.forEach(inputConfig => {
            if (inputConfig.el && !inputConfig.el.hasAttribute('listener-attached')) {
                const eventType = (inputConfig.el.type === 'color' || inputConfig.el.type === 'checkbox' || inputConfig.el.type === 'range') ? 'change' : 'input';
                inputConfig.el.addEventListener(eventType, (e) => {
                    const value = inputConfig.el.type === 'checkbox' ? e.target.checked : e.target.value;
                    updateFabricObjectFromToolbar(inputConfig.prop, value, inputConfig.type);
                });
                inputConfig.el.setAttribute('listener-attached', 'true');
            } else if(!inputConfig.el) { console.warn(`initToolbar: Shadow input element for prop "${inputConfig.prop}" not found.`);}
        });

        if (objInteractionTriggerEl && !objInteractionTriggerEl.hasAttribute('listener-attached')) {
            objInteractionTriggerEl.addEventListener('change', handleInteractionChange); objInteractionTriggerEl.setAttribute('listener-attached', 'true');
        } else if(!objInteractionTriggerEl) { console.warn("initToolbar: objInteractionTriggerEl not found.");}
        if (objInteractionActionEl && !objInteractionActionEl.hasAttribute('listener-attached')) {
            objInteractionActionEl.addEventListener('change', handleInteractionChange); objInteractionActionEl.setAttribute('listener-attached', 'true');
        } else if(!objInteractionActionEl) { console.warn("initToolbar: objInteractionActionEl not found.");}
        if (objModalContentEl && !objModalContentEl.hasAttribute('listener-attached')) {
            objModalContentEl.addEventListener('input', handleInteractionChange); objModalContentEl.setAttribute('listener-attached', 'true');
        } else if(!objModalContentEl) { console.warn("initToolbar: objModalContentEl not found.");}
        if (objNavigateToEl && !objNavigateToEl.hasAttribute('listener-attached')) {
            objNavigateToEl.addEventListener('input', handleInteractionChange); objNavigateToEl.setAttribute('listener-attached', 'true');
        } else if(!objNavigateToEl) { console.warn("initToolbar: objNavigateToEl not found.");}
        if (objPanZoomLevelEl && !objPanZoomLevelEl.hasAttribute('listener-attached')) {
             objPanZoomLevelEl.addEventListener('input', handleInteractionChange); objPanZoomLevelEl.setAttribute('listener-attached', 'true');
        } else if(!objPanZoomLevelEl) { console.warn("initToolbar: objPanZoomLevelEl not found.");}

        if (objAnimationTriggerEl && !objAnimationTriggerEl.hasAttribute('listener-attached')) {
            objAnimationTriggerEl.addEventListener('change', handleAnimationChange); objAnimationTriggerEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationTriggerEl) { console.warn("initToolbar: objAnimationTriggerEl not found.");}
        if (objAnimationTypeEl && !objAnimationTypeEl.hasAttribute('listener-attached')) {
            objAnimationTypeEl.addEventListener('change', handleAnimationChange); objAnimationTypeEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationTypeEl) { console.warn("initToolbar: objAnimationTypeEl not found.");}
        if (objAnimationDurationEl && !objAnimationDurationEl.hasAttribute('listener-attached')) {
            objAnimationDurationEl.addEventListener('input', handleAnimationChange); objAnimationDurationEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationDurationEl) { console.warn("initToolbar: objAnimationDurationEl not found.");}
        
        if (objAnimationLoopEl && !objAnimationLoopEl.hasAttribute('listener-attached')) {
            objAnimationLoopEl.addEventListener('change', handleAnimationChange);
            objAnimationLoopEl.setAttribute('listener-attached', 'true');
        }
        if (objAnimationLoopCountEl && !objAnimationLoopCountEl.hasAttribute('listener-attached')) {
            objAnimationLoopCountEl.addEventListener('input', handleAnimationChange);
            objAnimationLoopCountEl.setAttribute('listener-attached', 'true');
        }
        if (objAnimationLoopDelayEl && !objAnimationLoopDelayEl.hasAttribute('listener-attached')) {
            objAnimationLoopDelayEl.addEventListener('input', handleAnimationChange);
            objAnimationLoopDelayEl.setAttribute('listener-attached', 'true');
        }
    }

    function populateToolbar(activeObject) {
        if (!overlayPropertiesToolbarEl) { console.error("populateToolbar: overlayPropertiesToolbarEl not found."); return; }
        hideActivePopover();

        if (!activeObject) {
            overlayPropertiesToolbarEl.style.display = 'none';
            if (textSpecificControlsEl) textSpecificControlsEl.style.display = 'none';
            return;
        }
        overlayPropertiesToolbarEl.style.display = 'block';

        // We still need to initialize the values in the position popover
        // but we'll only set them if the elements exist
        if (document.getElementById('objX')) document.getElementById('objX').value = activeObject.left ? activeObject.left.toFixed(0) : 0;
        if (document.getElementById('objY')) document.getElementById('objY').value = activeObject.top ? activeObject.top.toFixed(0) : 0;
        if (document.getElementById('objWidth')) document.getElementById('objWidth').value = activeObject.getScaledWidth ? activeObject.getScaledWidth().toFixed(0) : (activeObject.width || 0);
        if (document.getElementById('objHeight')) document.getElementById('objHeight').value = activeObject.getScaledHeight ? activeObject.getScaledHeight().toFixed(0) : (activeObject.height || 0);
        if (document.getElementById('objAngle')) document.getElementById('objAngle').value = activeObject.angle ? activeObject.angle.toFixed(0) : 0;
        if (objFillEl) objFillEl.value = toHexColor(activeObject.fill);
        if (objStrokeColorEl) objStrokeColorEl.value = toHexColor(activeObject.stroke);
        if (objStrokeWidthEl) objStrokeWidthEl.value = activeObject.strokeWidth === undefined ? 0 : activeObject.strokeWidth;
        if (objOpacityEl) objOpacityEl.value = activeObject.opacity === undefined ? 1 : activeObject.opacity;

        const isTextObject = activeObject.type === 'textbox' || activeObject.type === 'i-text';
        if (textSpecificControlsEl) {
            textSpecificControlsEl.style.display = isTextObject ? 'flex' : 'none';
            if (isTextObject) {
                if (objTextContentEl) objTextContentEl.value = activeObject.text || '';
                if (objFontFamilyEl) objFontFamilyEl.value = activeObject.fontFamily || 'Arial';
                if (objFontSizeEl) objFontSizeEl.value = activeObject.fontSize || 24;
                if (objLineHeightEl) objLineHeightEl.value = activeObject.lineHeight || 1.16;
                if (objCharSpacingEl) objCharSpacingEl.value = activeObject.charSpacing || 0;

                if (fontWeightButtonEl) fontWeightButtonEl.classList.toggle('active', activeObject.fontWeight === 'bold');
                if (fontStyleButtonEl) fontStyleButtonEl.classList.toggle('active', activeObject.fontStyle === 'italic');

                if (textAlignGroupEl) {
                    textAlignGroupEl.querySelectorAll('.toolbar-button').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.align === activeObject.textAlign);
                    });
                }
                if (objFontWeightEl) objFontWeightEl.value = activeObject.fontWeight || 'normal';
                if (objFontStyleEl) objFontStyleEl.value = activeObject.fontStyle || 'normal';
                if (objTextAlignEl) objTextAlignEl.value = activeObject.textAlign || 'left';
            }
        }

        const shadow = activeObject.shadow;
        if (objShadowColorEl) objShadowColorEl.value = shadow ? toHexColor(shadow.color) : '#000000';
        if (objShadowBlurEl) objShadowBlurEl.value = shadow ? shadow.blur : 0;
        if (objShadowOffsetXEl) objShadowOffsetXEl.value = shadow ? shadow.offsetX : 0;
        if (objShadowOffsetYEl) objShadowOffsetYEl.value = shadow ? shadow.offsetY : 0;
        if (objShadowAffectStrokeEl) objShadowAffectStrokeEl.checked = shadow ? !!shadow.affectStroke : false;
        if (objShadowNonScalingEl) objShadowNonScalingEl.checked = shadow ? !!shadow.nonScaling : false;
        if (shadowSettingsButtonEl) shadowSettingsButtonEl.classList.toggle('active', !!shadow && (shadow.blur > 0 || shadow.offsetX !== 0 || shadow.offsetY !== 0 || shadow.color !== '#000000'));


        const interaction = activeObject.customInteraction || { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
        if (objInteractionTriggerEl) objInteractionTriggerEl.value = interaction.trigger || "";
        if (objInteractionActionEl) objInteractionActionEl.value = interaction.action || "";
        if (objModalContentEl) objModalContentEl.value = interaction.modalContent || "";
        if (objNavigateToEl) objNavigateToEl.value = interaction.navigateTo || "";
        if (objPanZoomLevelEl) objPanZoomLevelEl.value = interaction.panZoomLevel === undefined ? 1.5 : interaction.panZoomLevel;
        updateInteractionConfigVisibility(interaction.action);
        if (interactionSettingsButtonEl) interactionSettingsButtonEl.classList.toggle('active', !!(interaction.trigger && interaction.action));


        const animation = activeObject.customAnimation || { trigger: "", type: "", duration: 500, strength: 5 };
        if (objAnimationTriggerEl) objAnimationTriggerEl.value = animation.trigger || "";
        if (objAnimationTypeEl) objAnimationTypeEl.value = animation.type || "";
        const showAnimParams = !!(animation.trigger && animation.type);
        if (animationParamsConfigEl) animationParamsConfigEl.style.display = showAnimParams ? 'block' : 'none';
        if (showAnimParams) {
            if (objAnimationDurationEl) objAnimationDurationEl.value = animation.duration || 500;
            if (objAnimationStrengthEl) objAnimationStrengthEl.value = animation.strength === undefined ? 5 : animation.strength;
            updateAnimationStrengthUnit(animation.type);
                // Loop properties
            if (objAnimationLoopEl) {
                if (animation.loop === true) { // Check for explicit true for infinite
                    objAnimationLoopEl.value = "true";
                } else if (typeof animation.loopCount === 'number' && animation.loopCount > 0) {
                    objAnimationLoopEl.value = "count";
                } else {
                    objAnimationLoopEl.value = "false"; // Default to No
                }
            }
        const showLoopCount = objAnimationLoopEl && objAnimationLoopEl.value === "count";
        if (animationLoopCountConfigEl) animationLoopCountConfigEl.style.display = showLoopCount ? 'block' : 'none';
        
        if (objAnimationLoopCountEl) objAnimationLoopCountEl.value = animation.loopCount || 3;
        if (objAnimationLoopDelayEl) objAnimationLoopDelayEl.value = animation.loopDelay === undefined ? 100 : animation.loopDelay;
            }
        if (animationSettingsButtonEl) animationSettingsButtonEl.classList.toggle('active', showAnimParams);
    }

    function handleInteractionChange() {
        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas) return;
        const activeObject = canvas.getActiveObject();
        if (!activeObject) return;
        if (!activeObject.customInteraction) { activeObject.customInteraction = { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 }; }

        if (objInteractionTriggerEl) activeObject.customInteraction.trigger = objInteractionTriggerEl.value;
        if (objInteractionActionEl) activeObject.customInteraction.action = objInteractionActionEl.value;
        if (objModalContentEl) activeObject.customInteraction.modalContent = objModalContentEl.value;
        if (objNavigateToEl) activeObject.customInteraction.navigateTo = objNavigateToEl.value;
        if (objPanZoomLevelEl) activeObject.customInteraction.panZoomLevel = parseFloat(objPanZoomLevelEl.value) || 1.5;

        updateInteractionConfigVisibility(activeObject.customInteraction.action);
        if (interactionSettingsButtonEl) interactionSettingsButtonEl.classList.toggle('active', !!(activeObject.customInteraction.trigger && activeObject.customInteraction.action));
        console.log("Interaction data updated for object:", activeObject.customInteraction);
    }

    function updateInteractionConfigVisibility(action) {
        const showModal = action === 'showModal';
        const showNavigate = action === 'navigateToSlide' || action === 'navigateToURL';
        const showPanZoomConfig = action === 'panZoomToTarget';

        if (modalContentConfigEl) modalContentConfigEl.style.display = showModal ? 'block' : 'none';
        if (navigateToConfigEl) navigateToConfigEl.style.display = showNavigate ? 'block' : 'none';
        if (panZoomConfigEl) panZoomConfigEl.style.display = showPanZoomConfig ? 'block' : 'none';
    }

    function handleAnimationChange() {
        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas) return;
        const activeObject = canvas.getActiveObject();
        if (!activeObject) return;

        if (!activeObject.customAnimation) {
            activeObject.customAnimation = { 
                trigger: "", 
                type: "", 
                duration: 500, 
                strength: 5,
                loop: false, // Default loop state
                loopDelay: 100 // Default loop delay
                // loopCount is undefined by default
            };
        }

        if (objAnimationTriggerEl) activeObject.customAnimation.trigger = objAnimationTriggerEl.value;
        if (objAnimationTypeEl) activeObject.customAnimation.type = objAnimationTypeEl.value;
        
        const showAnimParams = !!(activeObject.customAnimation.trigger && activeObject.customAnimation.type);
        if (animationParamsConfigEl) animationParamsConfigEl.style.display = showAnimParams ? 'block' : 'none';

        if (showAnimParams) {
            if (objAnimationDurationEl) activeObject.customAnimation.duration = parseInt(objAnimationDurationEl.value, 10) || 500;
            if (objAnimationStrengthEl) activeObject.customAnimation.strength = parseFloat(objAnimationStrengthEl.value) || 5;
            updateAnimationStrengthUnit(activeObject.customAnimation.type);

            // Loop properties
            if (objAnimationLoopEl) {
                const loopType = objAnimationLoopEl.value;
                if (loopType === "true") {
                    activeObject.customAnimation.loop = true; // Explicitly true for infinite
                    delete activeObject.customAnimation.loopCount; 
                } else if (loopType === "count") {
                    activeObject.customAnimation.loop = false; // Not infinitely looping but count-based
                    activeObject.customAnimation.loopCount = parseInt(objAnimationLoopCountEl.value, 10) || 3;
                } else { // "false" or empty
                    activeObject.customAnimation.loop = false;
                    delete activeObject.customAnimation.loopCount;
                }
            }
            // Update visibility of loop count input based on selection
            const showLoopCount = objAnimationLoopEl && objAnimationLoopEl.value === "count";
            if (animationLoopCountConfigEl) animationLoopCountConfigEl.style.display = showLoopCount ? 'block' : 'none';
            
            if (objAnimationLoopDelayEl) activeObject.customAnimation.loopDelay = parseInt(objAnimationLoopDelayEl.value, 10);
            // Ensure loopDelay is a non-negative number, default to 0 if invalid
            if (isNaN(activeObject.customAnimation.loopDelay) || activeObject.customAnimation.loopDelay < 0) {
                 activeObject.customAnimation.loopDelay = 0; 
            }

        } else {
            // If trigger or type is none, effectively clear/reset animation params for consistency
            activeObject.customAnimation.duration = 500; // Reset to default
            activeObject.customAnimation.strength = 5;  // Reset to default
            activeObject.customAnimation.loop = false;
            delete activeObject.customAnimation.loopCount;
            activeObject.customAnimation.loopDelay = 100; // Default loop delay
            if (animationLoopCountConfigEl) animationLoopCountConfigEl.style.display = 'none'; // Hide count config
            updateAnimationStrengthUnit(""); // Reset unit display
        }
        console.log("Animation data updated for object:", activeObject.customAnimation);
    }

    function updateAnimationStrengthUnit(animationType) {
        if (!objAnimationStrengthUnitEl) return;
        let unitText = "(pixels/degrees/scale)";
            switch(animationType) {
                case 'wiggle': unitText = "(degrees)"; break;
                case 'float': unitText = "(pixels)"; break;
                case 'growShrink': unitText = "(scale factor e.g., 1.2)"; break;
            }
        objAnimationStrengthUnitEl.textContent = unitText;
    }

    function updateFabricObjectFromToolbar(propertyName, value, inputType) { // inputType is still useful for parsing
      const canvas = adminApp.state.fabricCanvasInstance;
      if (!canvas) return;
      const activeObject = canvas.getActiveObject();
      if (!activeObject) return;

      let parsedValue = value;
      if (inputType === 'number') {
          parsedValue = parseInt(value, 10);
          if (isNaN(parsedValue)) {
              if ((propertyName === 'strokeWidth' || propertyName === 'charSpacing') && value === '') parsedValue = 0;
              else if (value === '') return; // Don't set if empty and not a special case
              else return; // Don't set if NaN
          }
      } else if (inputType === 'number' && inputType === 'float') { // My HTML used 'isFloat' not inputType='float'
          parsedValue = parseFloat(value);
           if (isNaN(parsedValue)) return;
      } else if (inputType === 'range') { // Opacity, shadow.blur
          parsedValue = parseFloat(value);
          if (isNaN(parsedValue)) return;
      } else if (inputType === 'checkbox') {
          parsedValue = !!value;
      }
      // For properties like 'fontWeight', 'fontStyle', 'textAlign', 'fontFamily', 'fill', 'stroke', 'text' value is string and used directly.

      if (propertyName === 'width') { activeObject.scaleX = parsedValue > 0 ? (parsedValue / activeObject.width) : (activeObject.width > 0 ? 0.0001 / activeObject.width : 0.0001); }
      else if (propertyName === 'height') { activeObject.scaleY = parsedValue > 0 ? (parsedValue / activeObject.height) : (activeObject.height > 0 ? 0.0001 / activeObject.height : 0.0001); }
      else if (propertyName.startsWith('shadow.')) {
        const shadowProp = propertyName.split('.')[1];
        let shadowOptions = activeObject.shadow instanceof fabric.Shadow ? activeObject.shadow.toObject() : {};

        // Always re-read all shadow properties from the popover to build the shadow object
        if (objShadowColorEl) shadowOptions.color = objShadowColorEl.value || '#000000';
        if (objShadowBlurEl) shadowOptions.blur = parseFloat(objShadowBlurEl.value) || 0;
        if (objShadowOffsetXEl) shadowOptions.offsetX = parseInt(objShadowOffsetXEl.value, 10) || 0;
        if (objShadowOffsetYEl) shadowOptions.offsetY = parseInt(objShadowOffsetYEl.value, 10) || 0;
        if (objShadowAffectStrokeEl) shadowOptions.affectStroke = objShadowAffectStrokeEl.checked;
        if (objShadowNonScalingEl) shadowOptions.nonScaling = objShadowNonScalingEl.checked;

        // Update the specific property that triggered this call if it's different
        if (shadowOptions[shadowProp] !== parsedValue) {
            shadowOptions[shadowProp] = parsedValue;
        }
        
        // Only set shadow if it has meaningful values
        if (shadowOptions.blur > 0 || shadowOptions.offsetX !== 0 || shadowOptions.offsetY !== 0 || (shadowOptions.color && shadowOptions.color !== '#000000' && shadowOptions.color !== 'rgb(0,0,0)')) {
            activeObject.set('shadow', new fabric.Shadow(shadowOptions));
        } else {
            activeObject.set('shadow', null);
        }
        // Update active state of main shadow button
        if (shadowSettingsButtonEl) shadowSettingsButtonEl.classList.toggle('active', !!activeObject.shadow);

      } else {
        // Exclude interaction and animation properties as they are handled by their specific functions
        // (handleInteractionChange, handleAnimationChange) which update the object's custom properties directly.
        if (!propertyName.startsWith('interaction.') && !propertyName.startsWith('animation.')) {
             activeObject.set(propertyName, parsedValue);
             // Sync hidden selects for text properties
             if (propertyName === 'fontWeight' && objFontWeightEl) objFontWeightEl.value = parsedValue;
             if (propertyName === 'fontStyle' && objFontStyleEl) objFontStyleEl.value = parsedValue;
             if (propertyName === 'textAlign' && objTextAlignEl) objTextAlignEl.value = parsedValue;
        }
      }

      if ((activeObject.type === 'textbox' || activeObject.type === 'i-text') &&
          ['text', 'fontSize', 'fontWeight', 'fontStyle', 'fontFamily', 'lineHeight', 'charSpacing', 'width', 'textAlign'].includes(propertyName)) {
          activeObject.initDimensions();
      }
      activeObject.setCoords();
      canvas.renderAll();
      // Repopulate toolbar to reflect any dependent changes or active states (e.g. button active states)
      // Be careful with calling this too often, can lead to infinite loops or sluggishness.
      // populateToolbar(activeObject); // Better to call this from the primary event handler (bold button click, etc.)
    }

    Utilities = { getUuid: function() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); } };

</script>