<script>
    // Namespace for the admin application
    window.adminApp = {};

    // --- Constants ---
    const FONT_FAMILIES = ["Arial", "Verdana", "Times New Roman", "Georgia", "Courier New", "Comic Sans MS", "Impact", "Tahoma"];

    // --- Application State ---
    adminApp.state = {
      isLoading: false,
      currentProjectId: null,
      currentView: 'list',
      projectData: null,
      currentSlideIndex: -1,
      fabricCanvasInstance: null,
      defaultCanvasWidth: 960,
      defaultCanvasHeight: 540,
      projectListCache: [], // Added to cache project list for status updates/reverts
      lastUploadedDriveId: null, // Temp store for image uploads before base64 fetch
      lastUploadedMimeType: null,
      lastUploadedFileName: null,
      isPasteListenerActive: false, // To manage listener attachment for pasting images
      activePopoverId: null, // To track the currently open popover
      history: [],
      historyIndex: -1,
      isApplyingHistory: false, // Flag to prevent re-saving state during undo/redo
      adminYouTubePlayer: null, // Reference to the admin's YouTube player instance
      isYouTubeApiReady: false // Flag for YouTube API readiness
    };

// --- Global function for YouTube API ---
function onYouTubeIframeAPIReady() {
  adminApp.state.isYouTubeApiReady = true;
  console.log('Admin YouTube API Ready.');
}
    // --- DOM Element References ---
    let projectTitleInputEl, createProjectButtonEl, messageAreaEl, loadingSpinnerEl;
    let listViewContainerEl, adminProjectListContainerEl;
    let editViewContainerEl, editingProjectTitleEl, backToProjectsListButtonEl, fabricCanvasEl;
    let imageUploaderEl;
    let addSlideButtonEl, slideThumbnailsContainerEl, saveProjectButtonEl;
    let addRectangleButtonEl, addCircleButtonEl;
    let addTextboxButtonEl;

    // Toolbar Elements (existing and new)
    let overlayPropertiesToolbarEl, objXEl, objYEl, objWidthEl, objHeightEl, objAngleEl,
        objFillEl, objStrokeColorEl, objStrokeWidthEl, objOpacityEl,
        textSpecificControlsEl, objTextContentEl, // Text specific row
        objFontFamilyEl, objFontSizeEl, objFontWeightEl, objFontStyleEl, objTextAlignEl, objLineHeightEl, objCharSpacingEl, // Core text inputs (some hidden, some direct)
        objShadowColorEl, objShadowBlurEl, objShadowOffsetXEl, objShadowOffsetYEl, objShadowAffectStrokeEl, objShadowNonScalingEl, // Shadow inputs
        objInteractionTriggerEl, objInteractionActionEl, modalContentConfigEl, objModalContentEl, navigateToConfigEl, objNavigateToEl, panZoomConfigEl, objPanZoomLevelEl, // Interaction inputs
        objAnimationTriggerEl, objAnimationTypeEl, animationParamsConfigEl, objAnimationDurationEl, objAnimationStrengthEl, objAnimationStrengthUnitEl, // Animation inputs
        objAnimationLoopEl, animationLoopCountConfigEl, objAnimationLoopCountEl, objAnimationLoopDelayEl;

    // New Popover and Toolbar Button DOM elements
    let fillColorButtonEl, strokeColorButtonEl, opacityButtonEl, // Direct action buttons for color/opacity that might reveal inputs
        shadowSettingsButtonEl, interactionSettingsButtonEl, animationSettingsButtonEl, fontFamilyButtonEl, // Popover triggers
        shadowPopoverEl, interactionPopoverEl, animationPopoverEl, fontFamilyPopoverEl, // Popover containers
        fillColorPopoverEl, strokeColorPopoverEl, opacityPopoverEl, // NEW POPOVERS for color/opacity
        objOpacityValueDisplayEl, // Span to show opacity percentage
        fontWeightButtonEl, fontStyleButtonEl, textAlignGroupEl; // Text style toggle buttons

    // Step 20 Media Elements
    let youtubeUrlInputEl, setYoutubeBackgroundButtonEl,
        audioUploaderEl, attachedAudioNameEl, removeAudioButtonEl,
        adminMediaPlaceholderEl, adminYouTubePlayerContainerEl; // Added adminYouTubePlayerContainerEl
    
    // New toolbar buttons
    let mediaToolsButtonEl, addShapeButtonEl, positionToolsButtonEl;
    // New popovers
    let mediaToolsPopoverEl, shapesPopoverEl, positionToolsPopoverEl;
    // Media tab elements
    let mediaTabButtonsEl, mediaTabPanesEl;
    // Drag and drop zones
    let imageDropZoneEl, audioDropZoneEl;

    // Video Question/Timeline Elements
    let videoTimelineControlsEl, videoTimelineSliderEl, videoCurrentTimeDisplayEl, videoTotalDurationDisplayEl,
        addQuestionBtnEl, questionModalEl, questionTimestampDisplayEl, questionTextEl,
        saveQuestionBtnEl, cancelQuestionBtnEl, editingQuestionIndexEl,
        videoQuestionsListContainerEl, videoQuestionsListEl; // Added question list elements
    let optionInputsEl = [], correctAnswerRadiosEl = [];


    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function() {
      console.log("Admin_JS: DOMContentLoaded event fired!");
      adminApp.setupDOMReferences();
      adminApp.attachEventListeners();
      adminApp.attachVideoQuestionEventListeners(); // New function call
      switchToListView();
      loadAdminProjectsList();
      console.log("Admin_JS: Initialization complete.");
    });

    // --- Setup and Listeners ---
    adminApp.resizeCanvasToFit = function(slideData) {
        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas || !fabricCanvasEl) {
            console.warn("resizeCanvasToFit: Canvas or fabricCanvasEl not ready.");
            return;
        }

        const fabricCanvasContainer = document.getElementById('fabricCanvasContainer');
        if (!fabricCanvasContainer) {
            console.warn("resizeCanvasToFit: fabricCanvasContainer not found.");
            return;
        }

        const containerWidth = fabricCanvasContainer.clientWidth;
        const containerHeight = fabricCanvasContainer.clientHeight;

        // If container has no size yet, defer (e.g. it's hidden)
        if (containerWidth === 0 || containerHeight === 0) {
            console.log("resizeCanvasToFit: Container has no dimensions, skipping resize.");
            return;
        }
        
        let contentWidth = (slideData && slideData.canvasWidth) ? slideData.canvasWidth : adminApp.state.defaultCanvasWidth;
        let contentHeight = (slideData && slideData.canvasHeight) ? slideData.canvasHeight : adminApp.state.defaultCanvasHeight;

        if (!contentWidth || contentWidth <= 0) contentWidth = adminApp.state.defaultCanvasWidth;
        if (!contentHeight || contentHeight <= 0) contentHeight = adminApp.state.defaultCanvasHeight;

        canvas.setWidth(contentWidth);
        canvas.setHeight(contentHeight);

        fabricCanvasEl.width = contentWidth;
        fabricCanvasEl.height = contentHeight;
        
        const zoomX = containerWidth / contentWidth;
        const zoomY = containerHeight / contentHeight;
        // Ensure zoom is not zero or negative if content dimensions are larger than container
        const finalZoom = Math.max(0.01, Math.min(zoomX, zoomY)); 


        canvas.zoomToPoint(new fabric.Point(contentWidth / 2, contentHeight / 2), finalZoom);
        
        console.log(`Resized canvas. Logical: ${contentWidth}x${contentHeight}. Container: ${containerWidth}x${containerHeight}. Zoom: ${finalZoom}`);
    };

    adminApp.setupDOMReferences = function() {
      messageAreaEl = document.getElementById('messageArea');
      loadingSpinnerEl = document.getElementById('loadingSpinner');
      listViewContainerEl = document.getElementById('listViewContainer');
      projectTitleInputEl = document.getElementById('projectTitleInput');
      createProjectButtonEl = document.getElementById('createProjectButton');
      adminProjectListContainerEl = document.getElementById('adminProjectListContainer');
      editViewContainerEl = document.getElementById('editViewContainer');
      editingProjectTitleEl = document.getElementById('editingProjectTitle');
      backToProjectsListButtonEl = document.getElementById('backToProjectsListButton');
      fabricCanvasEl = document.getElementById('fabricCanvasElement');
      imageUploaderEl = document.getElementById('imageUploader');
      addSlideButtonEl = document.getElementById('addSlideButton');
      slideThumbnailsContainerEl = document.getElementById('slideThumbnailsContainer');
      saveProjectButtonEl = document.getElementById('saveProjectButton');

      addRectangleButtonEl = document.getElementById('addRectangleButton');
      addCircleButtonEl = document.getElementById('addCircleButton');
      addTextboxButtonEl = document.getElementById('addTextboxButton');

      // Main Toolbar container
      overlayPropertiesToolbarEl  = document.getElementById('overlayPropertiesToolbar');

      // Direct input elements (some might be hidden or styled differently)
      objXEl = document.getElementById('objX');
      objYEl = document.getElementById('objY');
      objWidthEl = document.getElementById('objWidth');
      objHeightEl = document.getElementById('objHeight');
      objAngleEl = document.getElementById('objAngle');
      objFillEl = document.getElementById('objFill'); // The color input itself
      objStrokeColorEl = document.getElementById('objStrokeColor'); // The color input itself
      objStrokeWidthEl = document.getElementById('objStrokeWidth');
      objOpacityEl = document.getElementById('objOpacity'); // The range input itself

      // Text specific controls row and core inputs
      textSpecificControlsEl = document.getElementById('textSpecificControls');
      objTextContentEl = document.getElementById('objTextContent');
      objFontFamilyEl = document.getElementById('objFontFamily'); // The <select> for fonts (likely in a popover)
      objFontSizeEl = document.getElementById('objFontSize');
      objFontWeightEl = document.getElementById('objFontWeight'); // Hidden <select>
      objFontStyleEl = document.getElementById('objFontStyle');   // Hidden <select>
      objTextAlignEl = document.getElementById('objTextAlign');   // Hidden <select>
      objLineHeightEl = document.getElementById('objLineHeight');
      objCharSpacingEl = document.getElementById('objCharSpacing');

      // Shadow inputs (will be in shadowPopoverEl)
      objShadowColorEl = document.getElementById('objShadowColor');
      objShadowBlurEl = document.getElementById('objShadowBlur');
      objShadowOffsetXEl = document.getElementById('objShadowOffsetX');
      objShadowOffsetYEl = document.getElementById('objShadowOffsetY');
      objShadowAffectStrokeEl = document.getElementById('objShadowAffectStroke');
      objShadowNonScalingEl = document.getElementById('objShadowNonScaling');

      // Interaction inputs (will be in interactionPopoverEl)
      objInteractionTriggerEl = document.getElementById('objInteractionTrigger');
      objInteractionActionEl = document.getElementById('objInteractionAction');
      modalContentConfigEl = document.getElementById('modalContentConfig');
      objModalContentEl = document.getElementById('objModalContent');
      navigateToConfigEl = document.getElementById('navigateToConfig');
      objNavigateToEl = document.getElementById('objNavigateTo');
      panZoomConfigEl = document.getElementById('panZoomConfigEl'); 
      objPanZoomLevelEl = document.getElementById('objPanZoomLevel');

      // Animation inputs (will be in animationPopoverEl)
      objAnimationTriggerEl = document.getElementById('objAnimationTrigger');
      objAnimationTypeEl = document.getElementById('objAnimationType');
      animationParamsConfigEl = document.getElementById('animationParamsConfig');
      objAnimationSpeedEl = document.getElementById('objAnimationSpeed'); // New speed dropdown
      objAnimationStrengthEl = document.getElementById('objAnimationStrength');
      objAnimationStrengthUnitEl = document.getElementById('objAnimationStrengthUnit');
      objAnimationLoopEl = document.getElementById('objAnimationLoop');
      // Keep references for backward compatibility
      animationLoopCountConfigEl = document.getElementById('animationLoopCountConfig'); // Will be hidden
      objAnimationLoopCountEl = document.getElementById('objAnimationLoopCount'); // Will be hidden
      objAnimationLoopDelayEl = document.getElementById('objAnimationLoopDelay'); // Will be hidden

      // New Popover Trigger Buttons
      fillColorButtonEl = document.getElementById('fillColorButton');
      strokeColorButtonEl = document.getElementById('strokeColorButton');
      opacityButtonEl = document.getElementById('opacityButton');
      shadowSettingsButtonEl = document.getElementById('shadowSettingsButton');
      interactionSettingsButtonEl = document.getElementById('interactionSettingsButton');
      animationSettingsButtonEl = document.getElementById('animationSettingsButton');
      fontFamilyButtonEl = document.getElementById('fontFamilyButton');

      // New Popover Container Elements
      shadowPopoverEl = document.getElementById('shadowPopover');
      interactionPopoverEl = document.getElementById('interactionPopover');
      animationPopoverEl = document.getElementById('animationPopover');
      fontFamilyPopoverEl = document.getElementById('fontFamilyPopover');
      
      // New Popovers for Fill, Stroke, Opacity
      fillColorPopoverEl = document.getElementById('fillColorPopover');
      strokeColorPopoverEl = document.getElementById('strokeColorPopover');
      opacityPopoverEl = document.getElementById('opacityPopover');
      objOpacityValueDisplayEl = document.getElementById('objOpacityValueDisplay');


      // New Text Style Toggle Buttons
      fontWeightButtonEl = document.getElementById('fontWeightButton'); // Bold
      fontStyleButtonEl = document.getElementById('fontStyleButton');   // Italic
      textAlignGroupEl = document.getElementById('textAlignGroup');     // Container for align buttons

      undoButtonEl = document.getElementById('undoButton');
      redoButtonEl = document.getElementById('redoButton');
      deleteObjectButtonEl = document.getElementById('deleteObjectButton');


      // Step 20 Elements
      youtubeUrlInputEl = document.getElementById('youtubeUrlInput');
      setYoutubeBackgroundButtonEl = document.getElementById('setYoutubeBackgroundButton');
      audioUploaderEl = document.getElementById('audioUploader');
      attachedAudioNameEl = document.getElementById('attachedAudioName');
      removeAudioButtonEl = document.getElementById('removeAudioButton');
      adminMediaPlaceholderEl = document.getElementById('adminMediaPlaceholder');
      adminYouTubePlayerContainerEl = document.getElementById('adminYouTubePlayerContainer'); // Added adminYouTubePlayerContainerEl

      // New toolbar buttons
      mediaToolsButtonEl = document.getElementById('mediaToolsButton');
      addShapeButtonEl = document.getElementById('addShapeButton'); // Singular, for new toolbar
      positionToolsButtonEl = document.getElementById('positionToolsButton');

      // New popovers
      mediaToolsPopoverEl = document.getElementById('mediaToolsPopover');
      shapesPopoverEl = document.getElementById('shapesPopover');
      positionToolsPopoverEl = document.getElementById('positionToolsPopover');

      // Media tab elements
      mediaTabButtonsEl = document.querySelectorAll('.media-tab-btn');
      mediaTabPanesEl = document.querySelectorAll('.media-tab-pane');

      // Drag and drop zones
      imageDropZoneEl = document.getElementById('imageDropZone');
      audioDropZoneEl = document.getElementById('audioDropZone');

      // Video Question/Timeline elements
      videoTimelineControlsEl = document.getElementById('videoTimelineControls');
      videoTimelineSliderEl = document.getElementById('videoTimelineSlider');
      videoCurrentTimeDisplayEl = document.getElementById('videoCurrentTimeDisplay');
      videoTotalDurationDisplayEl = document.getElementById('videoTotalDurationDisplay');
      addQuestionBtnEl = document.getElementById('addQuestionBtn');
      questionModalEl = document.getElementById('questionModal');
      questionTimestampDisplayEl = document.getElementById('questionTimestampDisplay');
      questionTextEl = document.getElementById('questionText');
      saveQuestionBtnEl = document.getElementById('saveQuestionBtn');
      cancelQuestionBtnEl = document.getElementById('cancelQuestionBtn');
      editingQuestionIndexEl = document.getElementById('editingQuestionIndex');
      videoQuestionsListContainerEl = document.getElementById('videoQuestionsListContainer'); // Added
      videoQuestionsListEl = document.getElementById('videoQuestionsList'); // Added
      for (let i = 0; i < 4; i++) {
          optionInputsEl.push(document.getElementById(`option${i+1}`));
          correctAnswerRadiosEl.push(document.getElementById(`correctAnswer${i}`));
      }


      // Check for essential elements - only warn if globally expected elements are missing
      if (!messageAreaEl) console.warn("setupDOMReferences: messageAreaEl not found.");
      if (!loadingSpinnerEl) console.warn("setupDOMReferences: loadingSpinnerEl not found.");
      if (!listViewContainerEl) console.warn("setupDOMReferences: listViewContainerEl not found.");
      if (!editViewContainerEl) console.warn("setupDOMReferences: editViewContainerEl not found.");
      if (!createProjectButtonEl) console.warn("setupDOMReferences: createProjectButtonEl not found.");
      if (!overlayPropertiesToolbarEl) console.warn("setupDOMReferences: overlayPropertiesToolbarEl (new toolbar) not found.");
      if (!shadowPopoverEl || !interactionPopoverEl || !animationPopoverEl || !fontFamilyPopoverEl) {
          console.warn("setupDOMReferences: One or more popover elements not found.");
      }

      console.log("Admin_JS: DOM references set up.");
    };

    adminApp.attachEventListeners = function() {
      const safelyAddListener = (element, eventType, handler, elementName) => {
          if (element) {
              element.addEventListener(eventType, handler);
          } else {
              if (elementName === 'createProjectButtonEl') console.warn(`Could not attach listener - ${elementName} not found initially.`);
          }
      };
      safelyAddListener(createProjectButtonEl, 'click', handleCreateProject, 'createProjectButtonEl');
      
      // Window resize listener
      window.addEventListener('resize', debounce(handleWindowResize, 250));

      console.log("Admin_JS: Initial event listeners attached.");
      // Edit view listeners attached in switchToEditView

      // Global listener for closing popovers when clicking outside
      document.addEventListener('click', function(event) {
        if (adminApp.state.activePopoverId && adminApp.state.currentView === 'edit') {
            const popover = document.getElementById(adminApp.state.activePopoverId);
            // Construct potential trigger button IDs (e.g., shadowPopover -> shadowSettingsButton or shadowButton)
            let triggerButton = null;
            const baseId = adminApp.state.activePopoverId.replace('Popover', ''); // e.g., "shadow"
            const possibleTriggerIds = [
                baseId + 'SettingsButton', // shadowSettingsButton
                baseId + 'Button',         // fontFamilyButton
                baseId + 'ToolsButton'     // mediaToolsButton, positionToolsButton
            ];

            for (const id of possibleTriggerIds) {
                const btn = document.getElementById(id);
                // A special check for addShapeButton which triggers shapesPopover
                if (id === 'addShapeButton' && adminApp.state.activePopoverId === 'shapesPopover') {
                    triggerButton = document.getElementById('addShapeButton');
                    if (triggerButton) break;
                }
                if (btn) {
                    triggerButton = btn;
                    break;
                }
            }


            if (popover && !popover.contains(event.target) && (!triggerButton || !triggerButton.contains(event.target))) {
                hideActivePopover();
            }
        }
      }, true); // Use capture phase to catch clicks early
    };

    // --- UI View Management ---
    function switchToListView() {
      console.log("Switching to List View");
      adminApp.state.currentView = 'list';
      adminApp.state.currentProjectId = null;
      adminApp.state.projectData = null;
      adminApp.state.currentSlideIndex = -1;
      hideActivePopover(); // Ensure popovers are closed

      if (adminApp.state.fabricCanvasInstance) {
          adminApp.state.fabricCanvasInstance.dispose();
          adminApp.state.fabricCanvasInstance = null;
          console.log("Admin_JS: Disposed fabric canvas instance.");
      }
      if(listViewContainerEl) listViewContainerEl.style.display = 'block';
      if(editViewContainerEl) editViewContainerEl.style.display = 'none';
      if (messageAreaEl) messageAreaEl.innerHTML = '';
      
      // No need to hide old .edit-controls-group as they should be removed from HTML

      // Remove paste listener if it was active
      if (adminApp.state.isPasteListenerActive) {
          document.removeEventListener('paste', handlePasteImage);
          adminApp.state.isPasteListenerActive = false;
          console.log("Admin_JS: Paste event listener for images removed from document.");
      }
      loadAdminProjectsList(); // Reload list in case status changed etc.
    }

    function switchToEditView(projectIdToEdit) {
        console.log("Switching to Edit View for project ID:", projectIdToEdit);
        adminApp.state.currentView = 'edit';
        adminApp.state.currentProjectId = projectIdToEdit;
        adminApp.state.projectData = null; // Clear previous project data
        adminApp.state.currentSlideIndex = -1; // Reset slide index
        hideActivePopover(); // Ensure popovers are closed

        if(listViewContainerEl) listViewContainerEl.style.display = 'none';
        if(editViewContainerEl) editViewContainerEl.style.display = 'block';

        if(editingProjectTitleEl) { // Set temporary title
            editingProjectTitleEl.textContent = `Loading Project (ID: ${projectIdToEdit})...`;
        }

        // Clear previous canvas instance if exists
        if (adminApp.state.fabricCanvasInstance) {
            adminApp.state.fabricCanvasInstance.dispose();
            adminApp.state.fabricCanvasInstance = null;
        }
        if (messageAreaEl) messageAreaEl.innerHTML = '';
        // No need to hide old .edit-controls-group as they should be removed from HTML
        if (slideThumbnailsContainerEl) slideThumbnailsContainerEl.innerHTML = ''; // Clear old thumbnails

        // Helper to ensure elements are found and listeners attached ONLY ONCE for edit view
        const ensureEditViewListener = (elementVarName, id, eventType, handler, critical = false) => {
            let element = window[elementVarName]; // Use the global variable like objXEl
            if (!element) {
                element = document.getElementById(id);
                window[elementVarName] = element; // Assign if freshly found
            }

            const listenerAttribute = `listener-${eventType}-attached`;
            if (element && !element.hasAttribute(listenerAttribute)) {
                element.addEventListener(eventType, handler);
                element.setAttribute(listenerAttribute, 'true');
                console.log(`Listener attached for ${eventType} on #${id} in switchToEditView.`);
            } else if (!element && critical) {
                 console.warn(`CRITICAL WARN: Element #${id} not found in switchToEditView! Cannot attach listener.`);
            }
        };

        // Ensure references are fresh (needed after potential view switches)
        fabricCanvasEl = document.getElementById('fabricCanvasElement');
        slideThumbnailsContainerEl = document.getElementById('slideThumbnailsContainer');
        adminMediaPlaceholderEl = document.getElementById('adminMediaPlaceholder');
        overlayPropertiesToolbarEl = document.getElementById('overlayPropertiesToolbar'); // Ensure this is fresh

        // Attach listeners for edit view buttons and controls
        ensureEditViewListener('backToProjectsListButtonEl', 'backToProjectsListButton', 'click', switchToListView, true);
        ensureEditViewListener('imageUploaderEl', 'imageUploader', 'change', handleImageUpload, true);
        ensureEditViewListener('addSlideButtonEl', 'addSlideButton', 'click', handleAddSlide, true);
        ensureEditViewListener('saveProjectButtonEl', 'saveProjectButton', 'click', handleSaveProject, true);
        
        // These listeners are for buttons inside the 'shapesPopoverEl', which is handled by initToolbar -> togglePopover
        // and their click handlers are attached directly in 'initToolbar' or their respective popover setup.
        // However, the function calls themselves still need to be callable.
        ensureEditViewListener('addRectangleButtonEl', 'addRectangleButton', 'click', addRectangle, true);
        ensureEditViewListener('addCircleButtonEl', 'addCircleButton', 'click', addCircle, true);
        ensureEditViewListener('addTextboxButtonEl', 'addTextboxButton', 'click', addTextbox, true);

        ensureEditViewListener('setYoutubeBackgroundButtonEl', 'setYoutubeBackgroundButton', 'click', handleSetYoutubeBackground, true);
        ensureEditViewListener('audioUploaderEl', 'audioUploader', 'change', handleAudioUpload, true);
        ensureEditViewListener('removeAudioButtonEl', 'removeAudioButton', 'click', handleRemoveAudio, true);

        // Initialize Fabric Canvas with defaults
        if (typeof fabric !== 'undefined' && fabricCanvasEl) {
            adminApp.state.fabricCanvasInstance = new fabric.Canvas('fabricCanvasElement', {
                width: adminApp.state.defaultCanvasWidth,
                height: adminApp.state.defaultCanvasHeight,
                backgroundColor: '#e9e9e9' // Default background
            });
            // Set initial size of the HTML canvas element itself
            fabricCanvasEl.width = adminApp.state.defaultCanvasWidth;
            fabricCanvasEl.height = adminApp.state.defaultCanvasHeight;
            console.log("Admin_JS: Fabric.js canvas initialized with default dimensions.");

            initToolbar(); // Initialize toolbar structure, popovers, and their listeners
            adminApp.resizeCanvasToFit(null); // Initial resize before loading project
            
            // Attach Fabric canvas event listeners
            adminApp.state.fabricCanvasInstance.off(); // Remove previous listeners first
            adminApp.state.fabricCanvasInstance.on('object:modified', (e) => {
            if (e.target) {
                populateToolbar(e.target);
            }
            });
            adminApp.state.fabricCanvasInstance.on('selection:created', (e) => {
                const activeObject = e.selected && e.selected.length === 1 ? e.selected[0] : null;
                populateToolbar(activeObject);
            });
            adminApp.state.fabricCanvasInstance.on('selection:updated', (e) => {
                const activeObject = e.selected && e.selected.length === 1 ? e.selected[0] : null;
                populateToolbar(activeObject);
            });
            adminApp.state.fabricCanvasInstance.on('selection:cleared', () => {
               populateToolbar(null);
            });

            // Make toolbar visible and set initial state for no selection
            if(overlayPropertiesToolbarEl) overlayPropertiesToolbarEl.style.display = 'block';
            populateToolbar(null); // Set initial state for an empty canvas
            hideActivePopover(); // Make sure all popovers are hidden initially

            // Attach paste listener for images
            if (!adminApp.state.isPasteListenerActive) {
                document.addEventListener('paste', handlePasteImage);
                adminApp.state.isPasteListenerActive = true;
                console.log("Admin_JS: Paste event listener for images attached to document.");
            }

            loadProjectForEditing(projectIdToEdit); // Load the actual project data

        } else {
            console.error("Fabric.js library or canvas element #fabricCanvasElement not found in switchToEditView.");
            displayMessage("Critical error: Editor canvas could not be initialized.", false);
            showLoading(false); // Ensure spinner hidden
        }
    }

    // --- Popover Management ---
    function togglePopover(popoverId, triggerButtonEl) {
        if (adminApp.state.activePopoverId === popoverId) {
            hideActivePopover();
        } else {
            hideActivePopover(); // Hide any currently open popover
            const popover = document.getElementById(popoverId);
            if (popover && triggerButtonEl) {
                // First, reset any positioning to get natural size
                popover.style.display = 'block';
                popover.style.position = 'absolute';
                popover.style.top = 'auto';
                popover.style.left = 'auto';
                
                // Get positions after element is visible
                const btnRect = triggerButtonEl.getBoundingClientRect();
                const popoverRect = popover.getBoundingClientRect();
                
                // Get viewport dimensions
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // Calculate initial position (below button)
                let posTop = btnRect.bottom + 5;
                let posLeft = btnRect.left;
                
                // Adjust if popover would go off-screen horizontally
                if (posLeft + popoverRect.width > viewportWidth) {
                    posLeft = Math.max(5, viewportWidth - popoverRect.width - 5); // Ensure it doesn't go off left either
                }
                 if (posLeft < 0) posLeft = 5; // Prevent going off left screen edge

                // If popover would go below viewport, position it above the button instead
                if (posTop + popoverRect.height > viewportHeight && btnRect.top - popoverRect.height - 5 > 0) { // also check if there is space above
                    posTop = btnRect.top - popoverRect.height - 5;
                } else if (posTop + popoverRect.height > viewportHeight) { // if no space above either, stick to bottom of button and allow scroll
                     posTop = Math.max(5, viewportHeight - popoverRect.height - 5);
                }
                if (posTop < 0) posTop = 5; // Prevent going off top screen edge
                
                // Apply final position
                popover.style.top = posTop + 'px';
                popover.style.left = posLeft + 'px';
                
                // Set active states
                adminApp.state.activePopoverId = popoverId;
                
                // Add active class to button
                document.querySelectorAll('.toolbar-button').forEach(btn => {
                    btn.classList.remove('popover-active');
                });
                triggerButtonEl.classList.add('popover-active');

                // Special handling for media popover: initialize tab state
                if (popoverId === 'mediaToolsPopover') {
                   // Check if a tab is already active, if not, make the first one active
                   const activeTab = popover.querySelector('.media-tab-btn.active');
                   if (!activeTab) {
                       switchMediaTab('image-tab'); // Default to image tab
                   }
                   // Populate audio info if audio tab is active
                   if (popover.querySelector('.media-tab-btn[data-tab="audio-tab"].active')) {
                       const currentSlide = getCurrentSlide();
                       const hasAudio = currentSlide && currentSlide.slideMedia && 
                                       currentSlide.slideMedia.type === 'audio' && 
                                       currentSlide.slideMedia.driveFileId;
                       const audioControlsEl = document.getElementById('audioControls');
                       if (audioControlsEl) {
                           audioControlsEl.style.display = hasAudio ? 'block' : 'none';
                           if (hasAudio && attachedAudioNameEl) {
                               attachedAudioNameEl.textContent = `Attached: ${currentSlide.slideMedia.originalName || 'Audio File'}`;
                           }
                       }
                   }
                }

            } else {
                console.warn("togglePopover: Popover or trigger button not found for ID:", popoverId);
            }
        }
    }

    function hideActivePopover() {
        if (adminApp.state.activePopoverId) {
            const popover = document.getElementById(adminApp.state.activePopoverId);
            if (popover) popover.style.display = 'none';
            
            // Remove active class from all toolbar buttons that might have triggered a popover
            document.querySelectorAll('.toolbar-button.popover-active').forEach(btn => {
                btn.classList.remove('popover-active');
            });
            adminApp.state.activePopoverId = null;
        }
    }

    function switchMediaTab(tabId) {
        // Hide all tab panes
        document.querySelectorAll('.media-tab-pane').forEach(pane => {
            pane.classList.remove('active');
        });
        
        // Remove active class from all tab buttons
        document.querySelectorAll('.media-tab-btn').forEach(tab => {
            tab.classList.remove('active');
        });
        
        // Show the selected tab pane
        const tabPane = document.getElementById(tabId);
        if (tabPane) tabPane.classList.add('active');
        
        // Add active class to the clicked tab button
        const activeTabBtn = document.querySelector(`.media-tab-btn[data-tab="${tabId}"]`);
        if (activeTabBtn) activeTabBtn.classList.add('active');
        
        // Display audio controls if we're on the audio tab and there's an attached audio
        if (tabId === 'audio-tab') {
            const currentSlide = getCurrentSlide();
            const hasAudio = currentSlide && currentSlide.slideMedia && 
                            currentSlide.slideMedia.type === 'audio' && 
                            currentSlide.slideMedia.driveFileId;
            const audioControlsEl = document.getElementById('audioControls');
            if (audioControlsEl) { // Ensure element exists
                audioControlsEl.style.display = hasAudio ? 'block' : 'none';
                if (hasAudio && attachedAudioNameEl) {
                     attachedAudioNameEl.textContent = `Attached: ${currentSlide.slideMedia.originalName || 'Audio File'}`;
                }
            }
        }
    }

    // Helper function to get current slide
    function getCurrentSlide() {
        if (adminApp.state.currentSlideIndex === -1 || !adminApp.state.projectData || 
            !adminApp.state.projectData.slides || 
            !adminApp.state.projectData.slides[adminApp.state.currentSlideIndex]) {
            return null;
        }
        return adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
    }

    // --- Project Loading/Saving ---
    function loadProjectForEditing(projectId) {
      console.log(`loadProjectForEditing: Called for projectId: ${projectId}`);
      if (!projectId) { console.error("loadProjectForEditing: No projectId."); displayMessage("Error: Cannot load project.", false); return; }
      showLoading(true);
      displayMessage("Loading project data...", true);
      google.script.run
          .withSuccessHandler(onProjectDataLoaded)
          .withFailureHandler(onServerError)
          .getProjectDataForEditing(projectId);
    }

    function onProjectDataLoaded(jsonString) {
      console.log("onProjectDataLoaded: Received data string length:", jsonString ? jsonString.length : 'null');

      if (jsonString === null || jsonString === undefined) {
          showLoading(false);
          console.error("onProjectDataLoaded: Received null data string from server (Project or data file likely not found).");
          displayMessage("Error: Could not load project data. Project or its data file may not exist.", false);
          adminApp.state.projectData = { projectId: adminApp.state.currentProjectId, title: "Error Loading", slides: [] };
          adminApp.state.currentSlideIndex = -1;
          if (editingProjectTitleEl) editingProjectTitleEl.textContent = `Error Loading Project (ID: ${adminApp.state.currentProjectId})`;
          updateSlideThumbnailsUI();
          return;
      }

      try {
          const loadedData = JSON.parse(jsonString);
          console.log("Parsed project data:", loadedData);

          if (!loadedData || typeof loadedData !== 'object') throw new Error("Parsed data is not a valid object.");
          if (!loadedData.projectId) throw new Error("Loaded project data is missing 'projectId'.");

          if (!Array.isArray(loadedData.slides)) {
               console.warn("Loaded data missing 'slides' array or it's invalid, defaulting to empty.");
               loadedData.slides = [];
          }

          loadedData.slides.forEach(slide => {
              if (!slide.slideMedia) {
                  slide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
              }
              // Ensure customInteraction and customAnimation objects exist with defaults if missing
              if (!slide.fabricCanvasJSON || !slide.fabricCanvasJSON.objects) {
                // If no fabric JSON or objects, nothing to iterate
              } else {
                slide.fabricCanvasJSON.objects.forEach(obj => {
                    if (!obj.customInteraction) {
                        obj.customInteraction = { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
                    }
                    if (!obj.customAnimation) {
                        obj.customAnimation = { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
                    }
                });
              }
          });

          adminApp.state.projectData = loadedData;

          if (editingProjectTitleEl) {
              editingProjectTitleEl.textContent = `Editing Project: ${adminApp.state.projectData.title || '(Untitled)'}`;
          }

          updateSlideThumbnailsUI();

          if (adminApp.state.projectData.slides.length > 0) {
              selectSlide(0); // Select and load the first slide
              displayMessage("Project loaded successfully.", true);
          } else {
              displayMessage("Project loaded, but it has no slides. Adding one.", true);
              handleAddSlide(); // Add an initial slide if the loaded project was empty
          }
          showLoading(false); // Success path loading finished

      } catch (e) {
          showLoading(false);
          console.error("onProjectDataLoaded: Error parsing JSON data or invalid structure:", e);
          console.error("Received JSON string that failed parsing:", jsonString);
          displayMessage(`Error: Failed to parse loaded project data. ${e.message}`, false);
          adminApp.state.projectData = { projectId: adminApp.state.currentProjectId, title: "Invalid Data", slides: [] };
          adminApp.state.currentSlideIndex = -1;
          if (editingProjectTitleEl) editingProjectTitleEl.textContent = `Invalid Project Data (ID: ${adminApp.state.currentProjectId})`;
          updateSlideThumbnailsUI(); // Clear thumbnails
      }
    }

    function saveCurrentSlideState() {
        if (adminApp.state.currentSlideIndex === -1 || !adminApp.state.fabricCanvasInstance || !adminApp.state.projectData || !adminApp.state.projectData.slides[adminApp.state.currentSlideIndex]) {
            console.log("saveCurrentSlideState: Skipping, no active slide/canvas/data.");
            return;
        }
        try {
          const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
          const canvas = adminApp.state.fabricCanvasInstance;
          // Ensure custom properties are on the objects before serializing
          canvas.getObjects().forEach(obj => {
              if (!obj.customInteraction) {
                  obj.customInteraction = { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
              }
              if (!obj.customAnimation) {
                  obj.customAnimation = { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
              }
          });

          const propsToInclude = ['slideId', 'canvasWidth', 'canvasHeight', 'customInteraction', 'customAnimation', 'sequenceOrder'];
          currentSlide.fabricCanvasJSON = canvas.toJSON(propsToInclude);
          currentSlide.canvasWidth = canvas.getWidth();
          currentSlide.canvasHeight = canvas.getHeight();
          if (!currentSlide.slideMedia) {
               currentSlide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
          }
          if(currentSlide.slideMedia.type !== 'image' && currentSlide.slideMedia.url && currentSlide.slideMedia.url.startsWith('data:image')) {
              // This case seems unlikely for non-image types but kept for safety
              currentSlide.slideMedia.url = null;
          }

          console.log(`Slide ${adminApp.state.currentSlideIndex + 1} state saved. Media:`, JSON.stringify(currentSlide.slideMedia));
        } catch(e) {
            console.error(`Error saving slide state for index ${adminApp.state.currentSlideIndex}:`, e);
            displayMessage(`Error saving current slide state: ${e.message}`, false);
        }
    }

    function handleSaveProject() {
        if (!adminApp.state.projectData || !adminApp.state.currentProjectId) { displayMessage("No project data to save.", false); return; }
        if (adminApp.state.isLoading) { console.log("handleSaveProject: Already saving."); return; }

        saveCurrentSlideState(); // Ensure latest slide state is captured before saving entire project

        showLoading(true); displayMessage("Saving project...", true);
        try {
            const projectDataToSave = JSON.parse(JSON.stringify(adminApp.state.projectData));

             projectDataToSave.slides.forEach(slide => {
                 // Clean up slideMedia.url if it's a base64 data URI for non-image types
                 // (though this state should ideally not occur if logic elsewhere is correct)
                 if (slide.slideMedia && slide.slideMedia.type !== 'image' && 
                     slide.slideMedia.url && slide.slideMedia.url.startsWith('data:image')) {
                     slide.slideMedia.url = null; 
                 }
             });

            const jsonDataString = JSON.stringify(projectDataToSave);
            console.log("Saving projectData string length:", jsonDataString.length);

            google.script.run
                .withSuccessHandler(onProjectSaved)
                .withFailureHandler(onServerError)
                .saveProjectData(adminApp.state.currentProjectId, jsonDataString);
        } catch (e) {
             showLoading(false);
             console.error("Error stringifying project data for saving:", e);
             displayMessage("Error preparing data for saving.", false);
        }
    }

    function saveCanvasStateForHistory() {
        if (!adminApp.state.fabricCanvasInstance || adminApp.state.isApplyingHistory) {
            return;
        }
        const canvas = adminApp.state.fabricCanvasInstance;
        // Only save state if it has changed since the last save or if explicitly needed
        // For simplicity now, we save on object modification and additions/deletions.

        const propsToInclude = ['slideId', 'canvasWidth', 'canvasHeight', 'customInteraction', 'customAnimation', 'sequenceOrder']; // Match saveCurrentSlideState
        const currentState = canvas.toJSON(propsToInclude);

        // If we are at an older history point and make a new change, clear the "redo" future.
        if (adminApp.state.historyIndex < adminApp.state.history.length - 1) {
            adminApp.state.history = adminApp.state.history.slice(0, adminApp.state.historyIndex + 1);
        }

        adminApp.state.history.push(currentState);
        adminApp.state.historyIndex = adminApp.state.history.length - 1;

        // Limit history size (optional)
        const maxHistorySize = 20;
        if (adminApp.state.history.length > maxHistorySize) {
            adminApp.state.history.shift(); // Remove the oldest state
            adminApp.state.historyIndex--;
        }
        console.log("Canvas state saved to history. Index:", adminApp.state.historyIndex, "Total states:", adminApp.state.history.length);
        updateUndoRedoButtonStates();
    }

    function updateUndoRedoButtonStates() {
        if (undoButtonEl) undoButtonEl.disabled = adminApp.state.historyIndex <= 0;
        if (redoButtonEl) redoButtonEl.disabled = adminApp.state.historyIndex >= adminApp.state.history.length - 1;
    }

    function onProjectSaved(response) {
        showLoading(false);
        if (response && response.success) {
            showNotification(response.message || "Project saved successfully!", "success");
        } else {
            onServerError((response && response.error) ? response.error : "Failed to save.");
        }
    }

    // --- Slide Management ---
    function handleAddSlide() {
        console.log("handleAddSlide called");
        if (!adminApp.state.projectData) { console.error("handleAddSlide: projectData not initialized."); return; }
        saveCurrentSlideState(); // Save previous slide first
        const newSlideId = 'slide_' + Utilities.getUuid();
        const newSlide = {
            slideId: newSlideId,
            canvasWidth: adminApp.state.defaultCanvasWidth,
            canvasHeight: adminApp.state.defaultCanvasHeight,
            fabricCanvasJSON: null, // Will be empty JSON for a new slide
            slideMedia: { type: null, url: null, driveFileId: null, mimeType: null, originalName: null, videoQuestions: [] } // Added videoQuestions
        };
        if (!adminApp.state.projectData.slides) adminApp.state.projectData.slides = [];
        adminApp.state.projectData.slides.push(newSlide);
        const newSlideIndex = adminApp.state.projectData.slides.length - 1;
        selectSlide(newSlideIndex); // Select the new slide
        console.log("Added new slide. Total slides:", adminApp.state.projectData.slides.length);
    }

    function selectSlide(slideIndex) {
        if (!adminApp.state.projectData || !adminApp.state.projectData.slides || slideIndex < 0 || slideIndex >= adminApp.state.projectData.slides.length) { console.error("selectSlide: Invalid index or slides array missing.", slideIndex); return; }
        console.log(`Selecting slide ${slideIndex + 1}`);

        if (adminApp.state.currentSlideIndex !== -1 && adminApp.state.currentSlideIndex < adminApp.state.projectData.slides.length) {
             saveCurrentSlideState();
        }

        adminApp.state.currentSlideIndex = slideIndex;
        const selectedSlideData = adminApp.state.projectData.slides[slideIndex];
        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas) { console.error("selectSlide: Canvas not ready!"); return; }

        if (!selectedSlideData.slideMedia) {
            selectedSlideData.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null, videoQuestions: [] };
        } else if (selectedSlideData.slideMedia.type === 'youtube' && !Array.isArray(selectedSlideData.slideMedia.videoQuestions)) {
            selectedSlideData.slideMedia.videoQuestions = [];
        }

        // Destroy existing YouTube player if any
        if (adminApp.state.adminYouTubePlayer) {
            adminApp.state.adminYouTubePlayer.destroy();
            adminApp.state.adminYouTubePlayer = null;
        }
        if (adminYouTubePlayerContainerEl) {
            adminYouTubePlayerContainerEl.style.display = 'none';
            adminYouTubePlayerContainerEl.innerHTML = ''; // Clear any previous player
        }
        if(fabricCanvasEl) { // Ensure canvas is visible by default
            fabricCanvasEl.style.opacity = '1';
        }


        canvas.clear(); // Clears objects
        canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas)); // Clears background image
        canvas.backgroundColor = '#e9e9e9'; // Reset background color

        // Resize and zoom canvas to fit the container
        adminApp.resizeCanvasToFit(selectedSlideData);

        // Reset UI elements related to slide media
        if (imageUploaderEl) imageUploaderEl.value = null;
        if (youtubeUrlInputEl) youtubeUrlInputEl.value = '';
        if (audioUploaderEl) audioUploaderEl.value = null;
        if (attachedAudioNameEl) {
             attachedAudioNameEl.textContent = '';
             const audioControls = document.getElementById('audioControls');
             if(audioControls) audioControls.style.display = 'none';
        }
        if (removeAudioButtonEl) removeAudioButtonEl.style.display = 'none';
        if (adminMediaPlaceholderEl) adminMediaPlaceholderEl.style.display = 'none';


        const media = selectedSlideData.slideMedia;
        // Update video tools visibility - hide by default
        updateVideoToolsVisibility(false);

        if (media && media.type === 'image' && (media.url || media.driveFileId)) {
            if (adminMediaPlaceholderEl) adminMediaPlaceholderEl.style.display = 'none';
            if (media.url && media.url.startsWith('data:image')) {
                console.log("Loading background from base64 data URI.");
                fabric.Image.fromURL(media.url, function(img) {
                    if (!adminApp.state.fabricCanvasInstance || adminApp.state.currentSlideIndex !== slideIndex) return; // Check if slide changed
                    adminApp.state.fabricCanvasInstance.setBackgroundImage(img, canvas.renderAll.bind(canvas), { scaleX: canvas.width / img.width, scaleY: canvas.height / img.height });
                    console.log("Background loaded for slide", slideIndex);
                }, { crossOrigin: 'anonymous' });
            } else if (media.driveFileId) {
                 console.log(`Background needs fetch from Drive ID for slide ${slideIndex + 1}:`, media.driveFileId);
                 showLoading(true); displayMessage("Loading slide background...", true);
                 google.script.run.withSuccessHandler(function(response) {
                     showLoading(false);
                     if (adminApp.state.currentSlideIndex !== slideIndex) { console.log("Slide changed before background could be fetched for index", slideIndex); return; }
                     if (response && response.success && response.base64Data) {
                          media.url = response.base64Data; // Cache it
                         fabric.Image.fromURL(response.base64Data, function(img) {
                             if (!adminApp.state.fabricCanvasInstance) return;
                             adminApp.state.fabricCanvasInstance.setBackgroundImage(img, canvas.renderAll.bind(canvas), { scaleX: canvas.width / img.width, scaleY: canvas.height / img.height });
                             console.log("Background fetched and loaded for slide", slideIndex);
                         }, { crossOrigin: 'anonymous' });
                     } else { 
                        console.error("Failed to re-fetch background", response); 
                        displayMessage("Error loading slide background image.", false); 
                        canvas.backgroundColor = '#e9e9e9'; // Fallback color
                        canvas.renderAll(); 
                    }
                 }).withFailureHandler(onServerError).getImageAsBase64(media.driveFileId);
             } else { 
                console.warn("Slide media URL/ID not suitable for loading:", media); 
                canvas.backgroundColor = '#e9e9e9';
                canvas.renderAll(); 
            }
        } else if (media && media.type === 'youtube' && media.url) {
            console.log("Attempting to load YouTube player for URL:", media.url);
            if (adminMediaPlaceholderEl) adminMediaPlaceholderEl.style.display = 'none';
            if (youtubeUrlInputEl) youtubeUrlInputEl.value = media.url;
            
            const videoId = extractYouTubeVideoId(media.url);
            if (videoId && adminYouTubePlayerContainerEl && typeof YT !== 'undefined' && YT.Player) {
                adminYouTubePlayerContainerEl.style.display = 'block';
                if(fabricCanvasEl) fabricCanvasEl.style.opacity = '0.5'; // Make canvas semi-transparent
                canvas.backgroundColor = 'rgba(0,0,0,0)'; // Make canvas background transparent

                adminApp.state.adminYouTubePlayer = new YT.Player('adminYouTubePlayerContainer', {
                    height: '100%', // Fill the container
                    width: '100%',
                    videoId: videoId,
                    playerVars: {
                        'playsinline': 1,
                        'controls': 1, // Show controls for admin
                        'modestbranding': 1,
                        'rel': 0
                    },
                    events: {
                        'onReady': (event) => {
                            console.log("Admin YouTube player ready.");
                            updateVideoToolsVisibility(true);
                            renderVideoQuestionsList(); // Render questions when player is ready
                            const duration = event.target.getDuration();
                            if (videoTotalDurationDisplayEl) videoTotalDurationDisplayEl.textContent = formatTime(duration);
                            if (videoTimelineSliderEl) videoTimelineSliderEl.max = duration;
                            event.target.playVideo();
                        },
                        'onStateChange': (event) => {
                            if (adminApp.state.playerUpdateInterval) {
                                clearInterval(adminApp.state.playerUpdateInterval);
                                adminApp.state.playerUpdateInterval = null;
                            }
                            if (event.data === YT.PlayerState.PLAYING) {
                                adminApp.state.playerUpdateInterval = setInterval(() => {
                                    const currentTime = adminApp.state.adminYouTubePlayer.getCurrentTime();
                                    if (videoCurrentTimeDisplayEl) videoCurrentTimeDisplayEl.textContent = formatTime(currentTime);
                                    if (videoTimelineSliderEl) videoTimelineSliderEl.value = currentTime;
                                }, 250);
                            }
                        },
                        'onError': (event) => {
                            console.error("Admin YouTube player error", event.data);
                            updateVideoToolsVisibility(false); // Hide timeline on error
                            if (adminMediaPlaceholderEl) {
                                adminMediaPlaceholderEl.textContent = `Error loading YouTube video. Code: ${event.data}. URL: ${media.url}`;
                                adminMediaPlaceholderEl.style.display = 'block';
                            }
                            if(fabricCanvasEl) fabricCanvasEl.style.opacity = '1'; // Restore canvas opacity
                            canvas.backgroundColor = '#444'; // Fallback
                            canvas.renderAll();
                        }
                    }
                });
            } else {
                console.error("YouTube Player API not ready or videoId invalid or container missing.");
                updateVideoToolsVisibility(false); // Hide timeline if player fails to load
                if (adminMediaPlaceholderEl) {
                    adminMediaPlaceholderEl.textContent = `Error loading YouTube video. Check URL or API. URL: ${media.url}`;
                    adminMediaPlaceholderEl.style.display = 'block';
                }
                canvas.backgroundColor = '#444'; // Fallback
            }
            canvas.renderAll();
        } else if (media && media.type === 'audio' && (media.driveFileId)) {
             if (adminMediaPlaceholderEl) adminMediaPlaceholderEl.style.display = 'block'; // Keep placeholder for audio
             console.log("Indicating attached audio:", media.originalName || media.driveFileId);
             if (attachedAudioNameEl) {
                attachedAudioNameEl.textContent = `Attached: ${media.originalName || 'Audio File'}`;
                const audioControls = document.getElementById('audioControls');
                if(audioControls) audioControls.style.display = 'block';
             }
             if (removeAudioButtonEl) removeAudioButtonEl.style.display = 'inline-block';
             
             if (adminMediaPlaceholderEl) {
                 adminMediaPlaceholderEl.textContent = `Audio Attached: ${media.originalName || 'Audio File'}`;
                 adminMediaPlaceholderEl.style.display = 'block';
             }
             canvas.backgroundColor = '#e9e9e9'; // Default bg color
             canvas.renderAll();
        } else {
            console.log("No background media found or configured for slide", slideIndex);
             if (adminMediaPlaceholderEl) adminMediaPlaceholderEl.style.display = 'none';
             canvas.backgroundColor = '#e9e9e9'; // Default bg color
             canvas.renderAll();
        }

        if (selectedSlideData.fabricCanvasJSON) {
          console.log("Loading fabricCanvasJSON for slide", slideIndex);
          // Ensure customInteraction and customAnimation properties are revived if necessary
          canvas.loadFromJSON(selectedSlideData.fabricCanvasJSON, function() {
              if (!adminApp.state.fabricCanvasInstance || adminApp.state.currentSlideIndex !== slideIndex) return;
              
              // Post-load processing to ensure custom properties are on objects
              adminApp.state.fabricCanvasInstance.getObjects().forEach(obj => {
                  // The `fabricCanvasJSON` should already have these if saved correctly.
                  // This is more of a safeguard or for older data.
                  if (!obj.customInteraction) {
                      obj.customInteraction = { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
                  }
                  if (!obj.customAnimation) {
                      obj.customAnimation = { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
                  }
              });

              adminApp.state.fabricCanvasInstance.renderAll();
              console.log("Finished loading canvas JSON for slide", slideIndex);
              const activeObj = adminApp.state.fabricCanvasInstance.getActiveObject();
              populateToolbar(activeObj); // Update new toolbar
            }, function(o, object) { 
                /* Revival function if needed for complex object types, not typically for custom props */ 
                // console.log("Reviving object:", o, object);
            });
        } else {
            console.log("No fabricCanvasJSON to load for slide", slideIndex);
            canvas.renderAll(); // Render the empty canvas (with background if any)
            populateToolbar(null); // Clear new toolbar as no objects are selected
        }
        updateSlideThumbnailsUI();
        // Initialize/Reset history for the current slide
        adminApp.state.history = [];
        adminApp.state.historyIndex = -1;
        // A short timeout to ensure canvas is fully rendered before saving initial state
        setTimeout(() => {
            saveCanvasStateForHistory();
            updateUndoRedoButtonStates();
        }, 100); // Adjust timeout if needed
    }

    function updateSlideThumbnailsUI() {
        if (!slideThumbnailsContainerEl || !adminApp.state.projectData) { console.warn("updateSlideThumbnailsUI: Container or project data missing."); return; }
        slideThumbnailsContainerEl.innerHTML = '';
        if (!adminApp.state.projectData.slides) adminApp.state.projectData.slides = [];
        adminApp.state.projectData.slides.forEach((slide, index) => {
            const thumb = document.createElement('div'); thumb.className = 'slide-thumbnail';
            thumb.textContent = `Slide ${index + 1}`; thumb.title = `Select Slide ${index + 1}`;
            if (index === adminApp.state.currentSlideIndex) thumb.classList.add('active-slide');
            thumb.onclick = function() { selectSlide(index); };
            const deleteBtn = document.createElement('button'); deleteBtn.className = 'delete-slide-btn'; deleteBtn.innerHTML = ''; deleteBtn.title = "Delete slide";
            deleteBtn.onclick = function(event) { event.stopPropagation(); handleDeleteSlide(index); };
            thumb.appendChild(deleteBtn); slideThumbnailsContainerEl.appendChild(thumb);
        });
    }

    function handleDeleteSlide(slideIndex) {
        if (!adminApp.state.projectData || !adminApp.state.projectData.slides || slideIndex < 0 || slideIndex >= adminApp.state.projectData.slides.length) { console.error("handleDeleteSlide: Invalid index."); return; }
        if (adminApp.state.projectData.slides.length <= 1) { displayMessage("Cannot delete the last slide.", false); return; }
        if (!confirm(`Are you sure you want to delete Slide ${slideIndex + 1}?`)) return;
        
        const wasCurrentSlide = adminApp.state.currentSlideIndex === slideIndex;
        adminApp.state.projectData.slides.splice(slideIndex, 1);
        console.log("Deleted slide at index:", slideIndex);

        if (wasCurrentSlide) {
            adminApp.state.currentSlideIndex = -1; // Force re-selection
            const newIndexToSelect = Math.max(0, Math.min(slideIndex, adminApp.state.projectData.slides.length - 1));
             if (adminApp.state.projectData.slides.length > 0) {
                selectSlide(newIndexToSelect);
            } else {
                // This case should not be reached due to "Cannot delete the last slide" check
                // but as a fallback, clear canvas and UI.
                if(adminApp.state.fabricCanvasInstance) adminApp.state.fabricCanvasInstance.clear();
                updateSlideThumbnailsUI();
                populateToolbar(null);
            }
        } else if (adminApp.state.currentSlideIndex > slideIndex) {
            adminApp.state.currentSlideIndex--; // Adjust current index if a preceding slide was deleted
            updateSlideThumbnailsUI(); // Update UI to reflect new active slide
        } else {
             updateSlideThumbnailsUI(); // Just update thumbnails if a non-active, non-preceding slide was deleted
        }
    }

    // --- Project Management (Status/Delete) ---
    function handleProjectStatusChange(projectId, newStatus, selectElement) {
        console.log(`Attempting to update status for project ${projectId} to ${newStatus}`);
        showLoading(true);
        const originalStatus = selectElement.getAttribute('data-original-status') ||
                               (adminApp.state.projectListCache.find(p => p.projectId === projectId) || {}).status;
        selectElement.setAttribute('data-original-status', originalStatus);

        google.script.run
            .withSuccessHandler(function(response) { onProjectStatusUpdated(response, projectId, newStatus, selectElement); })
            .withFailureHandler(function(error) {
                onServerError(error);
                if (selectElement) {
                    console.log("Reverting status dropdown due to server error for project:", projectId);
                    selectElement.value = originalStatus;
                }
            })
            .updateProjectStatus(projectId, newStatus);
    }

    function onProjectStatusUpdated(response, projectId, newStatus, selectElement) {
        showLoading(false);
        if (response && response.success) {
            displayMessage(response.message || "Project status updated successfully!", true);

            const projectInCache = adminApp.state.projectListCache.find(p => p.projectId === projectId);
            if (projectInCache) projectInCache.status = newStatus;
            selectElement.removeAttribute('data-original-status');

            const statusSpan = selectElement.closest('.project-item').querySelector('.status-text');
            if(statusSpan) statusSpan.textContent = `(${newStatus})`;

            if (adminApp.state.currentView === 'edit' && adminApp.state.currentProjectId === projectId && adminApp.state.projectData) {
                adminApp.state.projectData.status = newStatus;
            }
        } else {
            onServerError((response && response.error) ? response.error : "Failed to update status.");
            if (selectElement) {
                 console.log("Reverting status dropdown due to server failure for project:", projectId);
                 const originalStatus = selectElement.getAttribute('data-original-status');
                 if(originalStatus) selectElement.value = originalStatus;
            }
        }
    }

    function handleDeleteProject(projectId, projectTitle) {
        if (!confirm(`Are you sure you want to delete the project "${projectTitle}" (ID: ${projectId})? This action cannot be undone.`)) {
            return;
        }
        console.log(`Attempting to delete project ${projectId}`);
        showLoading(true);
        google.script.run
            .withSuccessHandler(onProjectDeleted)
            .withFailureHandler(onServerError)
            .deleteProject(projectId);
    }

    function onProjectDeleted(response) {
        showLoading(false);
        if (response && response.success) {
            displayMessage(response.message || "Project deleted successfully!", true);
            if (adminApp.state.currentView === 'edit' && adminApp.state.currentProjectId === response.deletedProjectId) {
                switchToListView();
            } else {
                loadAdminProjectsList();
            }
        } else {
            onServerError((response && response.error) ? response.error : "Failed to delete project.");
        }
    }

    // --- Error Handling & UI Utils ---
    function showLoading(show) {
        adminApp.state.isLoading = show;
        if (loadingSpinnerEl) loadingSpinnerEl.style.display = show ? 'flex' : 'none';
        else if (show) console.warn("showLoading(true) loadingSpinnerEl not found.");
    }

    // Improved notification system
    function showNotification(message, type = 'info', duration = 5000) {
        // Create notification container if it doesn't exist
        let container = document.getElementById('notificationContainer');
        if (!container) {
            container = document.createElement('div');
            container.id = 'notificationContainer';
            document.body.appendChild(container);
        }
        
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.textContent = message;
        
        container.appendChild(notification);
        
        // Animate in
        setTimeout(() => notification.classList.add('visible'), 10);
        
        // Remove after duration
        setTimeout(() => {
            notification.classList.remove('visible');
            setTimeout(() => notification.remove(), 300); // After fade out transition
        }, duration);
    }

    function displayMessage(message, isSuccess) {
        // Show in the new notification system
        showNotification(message, isSuccess ? 'success' : 'error');
        
        // Also update the original message area for backward compatibility
        if (messageAreaEl) { 
            messageAreaEl.innerHTML = ''; 
            const p = document.createElement('p'); 
            p.textContent = message; 
            messageAreaEl.appendChild(p); 
            messageAreaEl.className = isSuccess ? 'success' : 'error'; 
            setTimeout(() => { 
            if (messageAreaEl) { 
                messageAreaEl.innerHTML = ''; 
                messageAreaEl.className = ''; 
            } 
            }, 7000); 
        } else { 
            console.warn("displayMessage messageAreaEl not found. Message:", message); 
        }
    }

    function onServerError(errorObject) {
      console.error("onServerError triggered:", errorObject);
      showLoading(false);
      let errorMessage = "An unknown server error occurred.";
       if (typeof errorObject === 'string') { errorMessage = errorObject; }
       else if (errorObject && errorObject.message) { errorMessage = errorObject.message; }
       else if (errorObject && errorObject.error && typeof errorObject.error === 'string') { errorMessage = errorObject.error; }
      console.error('Formatted Server Error Message:', errorMessage);
      displayMessage('Server Error: ' + errorMessage, false);
    }

    function handleCreateProject() {
        if (adminApp.state.isLoading) return;
        const currentProjectTitle = projectTitleInputEl.value.trim();
        if (!currentProjectTitle) { displayMessage('Project title cannot be empty.', false); projectTitleInputEl.focus(); return; }
        showLoading(true);
        google.script.run.withSuccessHandler(onProjectCreated).withFailureHandler(onServerError).createProject(currentProjectTitle);
    }
    function onProjectCreated(response) {
        showLoading(false);
        if (response && response.success) { displayMessage(response.message || 'Project created!', true); if(projectTitleInputEl) projectTitleInputEl.value = ''; loadAdminProjectsList(); }
        else { onServerError((response && response.error) ? response.error : 'Failed to create project.'); }
    }

    function loadAdminProjectsList() {
      console.log("loadAdminProjectsList: Function called.");
      if (!adminProjectListContainerEl) { console.error("loadAdminProjectsList: adminProjectListContainerEl not found."); showLoading(false); return; }
      if (!google || !google.script || !google.script.run) { console.error("loadAdminProjectsList: google.script.run unavailable."); displayMessage("Error: Client-server bridge unavailable.", false); return; }
      showLoading(true);
      console.log("loadAdminProjectsList: Calling google.script.run.getAllProjectsForAdmin...");
      google.script.run
        .withSuccessHandler(displayAdminProjects)
        .withFailureHandler(onServerError)
        .getAllProjectsForAdmin();
       console.log("loadAdminProjectsList: google.script.run.getAllProjectsForAdmin call initiated.");
    }
    function displayAdminProjects(projectsArray) {
      console.log("displayAdminProjects (Success Handler) received data:", projectsArray);
      showLoading(false);
      if (!adminProjectListContainerEl) { console.error("displayAdminProjects: adminProjectListContainerEl not found."); return; }
      adminProjectListContainerEl.innerHTML = '';
      if (!projectsArray || projectsArray.length === 0) { adminProjectListContainerEl.innerHTML = '<p>No projects found.</p>'; return; }

      adminApp.state.projectListCache = projectsArray;

      projectsArray.forEach(project => {
          if (!project || !project.projectId) return;
          const projectItem = document.createElement('div');
          projectItem.className = 'project-item';

          const titleAndStatusDiv = document.createElement('div');
          const titleSpan = document.createElement('span');
          titleSpan.textContent = project.projectTitle || 'Untitled Project';
          titleSpan.style.fontWeight = 'bold';
          const statusTextSpan = document.createElement('span');
          statusTextSpan.className = 'status-text';
          statusTextSpan.textContent = `(${project.status || 'N/A'})`;
          titleAndStatusDiv.appendChild(titleSpan);
          titleAndStatusDiv.appendChild(statusTextSpan);

          const controlsDiv = document.createElement('div');
          const statusSelect = document.createElement('select');
          statusSelect.className = 'project-status-select';
          statusSelect.setAttribute('data-project-id', project.projectId);
          statusSelect.setAttribute('data-original-status', project.status || "Draft");
          ['Draft', 'Active', 'Inactive'].forEach(statusValue => {
              const option = document.createElement('option');
              option.value = statusValue;
              option.textContent = statusValue;
              if (project.status === statusValue) { option.selected = true; }
              statusSelect.appendChild(option);
          });
          statusSelect.onchange = function() { handleProjectStatusChange(project.projectId, this.value, this); };

          const editButton = document.createElement('button');
          editButton.textContent = 'Edit';
          editButton.className = 'edit-button';
          editButton.setAttribute('data-project-id', project.projectId);
          editButton.onclick = function() { console.log("Edit button clicked:", project.projectId); switchToEditView(project.projectId); };

          const deleteButton = document.createElement('button');
          deleteButton.textContent = 'Delete';
          deleteButton.className = 'danger-button';
          deleteButton.setAttribute('data-project-id', project.projectId);
          deleteButton.setAttribute('data-project-title', project.projectTitle || 'Untitled Project');
          deleteButton.style.marginLeft = '5px';
          deleteButton.onclick = function() { handleDeleteProject(project.projectId, project.projectTitle || 'Untitled Project'); };

          controlsDiv.appendChild(statusSelect);
          controlsDiv.appendChild(editButton);
          controlsDiv.appendChild(deleteButton);

          projectItem.appendChild(titleAndStatusDiv);
          projectItem.appendChild(controlsDiv);
          adminProjectListContainerEl.appendChild(projectItem);
       });
      console.log("displayAdminProjects: Finished rendering project list.");
    }

    // --- Media Handling ---
    function handleImageUpload(event) {
        if (adminApp.state.isLoading) { if (event.target) event.target.value = null; return; }
        const file = event.target.files[0];
        if (!file || !file.type.startsWith('image/')) { if(event.target) event.target.value = null; return; }

        saveCurrentSlideState(); // Save current slide state before modifying its media

        showLoading(true); displayMessage("Uploading image...", true);
        const reader = new FileReader();
        reader.onload = function(e) {
            const fileData = { fileName: file.name, mimeType: file.type, data: e.target.result.split(',')[1] };
            if (!adminApp.state.currentProjectId) { showLoading(false); displayMessage("Error: No project selected.", false); if(event.target) event.target.value = null; return; }
            google.script.run.withSuccessHandler(onImageUploaded).withFailureHandler(onServerError).uploadFileToDrive(fileData, adminApp.state.currentProjectId, 'image');
        };
        reader.onerror = function(error) { showLoading(false); displayMessage("Error reading file.", false); console.error(error); if(event.target) event.target.value = null; };
        reader.readAsDataURL(file);
    }

    function onImageUploaded(response) {
        showLoading(false);
        if (imageUploaderEl) imageUploaderEl.value = null;
        if (response && response.success && response.driveFileId) {
            displayMessage("Image processed. Fetching for preview...", true);
            showLoading(true);
            adminApp.state.lastUploadedDriveId = response.driveFileId;
            adminApp.state.lastUploadedMimeType = response.mimeType;
            adminApp.state.lastUploadedFileName = response.fileName;
            google.script.run
                .withSuccessHandler(onBase64ImageReceived)
                .withFailureHandler(onServerError)
                .getImageAsBase64(response.driveFileId);
        } else {
            onServerError({ message: (response && response.error) ? response.error : "Image processing failed." });
        }
    }

    function onBase64ImageReceived(response) {
        showLoading(false);
        if (response && response.success && response.base64Data) {
            if (!adminApp.state.fabricCanvasInstance || adminApp.state.currentSlideIndex === -1) { displayMessage("Error: Canvas/Slide not ready.", false); return; }
            const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
            if (!currentSlide) { displayMessage("Error: Slide data missing.", false); return; }

            fabric.Image.fromURL(response.base64Data, function(img) {
                if (!adminApp.state.fabricCanvasInstance || adminApp.state.currentSlideIndex === -1) return; // Check slide again
                const canvas = adminApp.state.fabricCanvasInstance;
                const imgWidth = img.width; const imgHeight = img.height;
                // Determine canvas size based on image, but cap at maxWidth
                const maxWidth = 960; // Max width for the canvas
                let cvWidth = imgWidth; 
                let cvHeight = imgHeight; 
                const ratio = imgWidth / imgHeight;

                if (cvWidth > maxWidth) { 
                    cvWidth = maxWidth; 
                    cvHeight = Math.round(cvWidth / ratio); 
                }
                // Optionally, you might also want a maxHeight constraint

                canvas.setWidth(cvWidth); canvas.setHeight(cvHeight);
                if (fabricCanvasEl) { fabricCanvasEl.width = cvWidth; fabricCanvasEl.height = cvHeight; }
                canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), { scaleX: cvWidth / imgWidth, scaleY: cvHeight / imgHeight });
                // No need to call canvas.renderAll() here, setBackgroundImage does it.
                displayMessage("Background image set.", true);

                if (!currentSlide.slideMedia) currentSlide.slideMedia = {};
                currentSlide.slideMedia.type = 'image';
                currentSlide.slideMedia.url = response.base64Data; // Store base64 for immediate use
                currentSlide.slideMedia.driveFileId = adminApp.state.lastUploadedDriveId || null;
                currentSlide.slideMedia.mimeType = adminApp.state.lastUploadedMimeType || response.mimeType; // mimeType from uploadFileToDrive is better
                currentSlide.slideMedia.originalName = adminApp.state.lastUploadedFileName || null;
                currentSlide.canvasWidth = cvWidth; // Update slide dimensions
                currentSlide.canvasHeight = cvHeight;

                console.log(`Slide ${adminApp.state.currentSlideIndex + 1} media/dims updated for image.`);
                updateSlideThumbnailsUI(); // Reflect potential dimension changes in any thumbnail logic

                // Clear other media UI states
                if (youtubeUrlInputEl) youtubeUrlInputEl.value = '';
                if (attachedAudioNameEl) {
                    attachedAudioNameEl.textContent = '';
                    const audioControls = document.getElementById('audioControls');
                    if(audioControls) audioControls.style.display = 'none';
                }
                if (removeAudioButtonEl) removeAudioButtonEl.style.display = 'none';
                if (adminMediaPlaceholderEl) adminMediaPlaceholderEl.style.display = 'none';

                delete adminApp.state.lastUploadedDriveId;
                delete adminApp.state.lastUploadedMimeType;
                delete adminApp.state.lastUploadedFileName;

            }, { crossOrigin: 'anonymous' });
        } else {
            onServerError({ message: (response && response.error) ? response.error : "Failed to fetch image data." });
            delete adminApp.state.lastUploadedDriveId;
            delete adminApp.state.lastUploadedMimeType;
            delete adminApp.state.lastUploadedFileName;
        }
    }

    function handleSetYoutubeBackground() {
        if (!adminApp.state.projectData || adminApp.state.currentSlideIndex < 0) {
            displayMessage("Please select a slide first.", false); return;
        }
        if (!youtubeUrlInputEl || !youtubeUrlInputEl.value) {
            displayMessage("Please enter a YouTube URL.", false); return;
        }
        const url = youtubeUrlInputEl.value.trim();
        if (!url.includes("youtube.com/") && !url.includes("youtu.be/")) {
            displayMessage("Please enter a valid YouTube URL.", false);
            return;
        }

        saveCurrentSlideState(); // Save current slide state before modifying its media

        const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
        if (!currentSlide.slideMedia) {
            currentSlide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
        }
        currentSlide.slideMedia.type = 'youtube';
        currentSlide.slideMedia.url = url;
        currentSlide.slideMedia.driveFileId = null; // YouTube videos are not Drive files
        currentSlide.slideMedia.mimeType = 'video/youtube';
        currentSlide.slideMedia.originalName = null;

        console.log(`Set YouTube background for slide ${adminApp.state.currentSlideIndex + 1} to: ${url}`);

        if(adminApp.state.fabricCanvasInstance) {
             adminApp.state.fabricCanvasInstance.setBackgroundImage(null, adminApp.state.fabricCanvasInstance.renderAll.bind(adminApp.state.fabricCanvasInstance));
             adminApp.state.fabricCanvasInstance.backgroundColor = '#444'; // Darker bg for YouTube
             adminApp.state.fabricCanvasInstance.renderAll();
        }
       if (adminMediaPlaceholderEl) {
           adminMediaPlaceholderEl.textContent = `YouTube BG: ${url}`;
           adminMediaPlaceholderEl.style.display = 'block';
       }
       // Clear other media UI states
       if (imageUploaderEl) imageUploaderEl.value = null;
       if (audioUploaderEl) audioUploaderEl.value = null;
       if (attachedAudioNameEl) {
            attachedAudioNameEl.textContent = '';
            const audioControls = document.getElementById('audioControls');
            if(audioControls) audioControls.style.display = 'none';
        }
       if (removeAudioButtonEl) removeAudioButtonEl.style.display = 'none';

       displayMessage("YouTube background set for this slide.", true);
    }

    function handleAudioUpload(event) {
        if (adminApp.state.isLoading) { if (event.target) event.target.value = null; return; }
        const file = event.target.files[0];
        if (!file || !file.type.startsWith('audio/')) {
            if (event.target) event.target.value = null;
            return;
        }
        if (!adminApp.state.projectData || adminApp.state.currentSlideIndex < 0) {
             displayMessage("Please select a slide first before uploading audio.", false);
             if (event.target) event.target.value = null;
             return;
        }

        saveCurrentSlideState(); // Save current slide state before modifying its media

        showLoading(true); displayMessage("Uploading audio...", true);
        const reader = new FileReader();
        reader.onload = function(e) {
            const fileData = {
                fileName: file.name,
                mimeType: file.type,
                data: e.target.result.split(',')[1]
            };
            google.script.run
                .withSuccessHandler(onAudioUploaded)
                .withFailureHandler(onServerError)
                .uploadFileToDrive(fileData, adminApp.state.currentProjectId, 'audio');
        };
        reader.onerror = function(error) {
            showLoading(false);
            displayMessage("Error reading audio file.", false);
            console.error(error);
            if (event.target) event.target.value = null;
        };
        reader.readAsDataURL(file);
    }

     function onAudioUploaded(response) {
        showLoading(false);
        if (audioUploaderEl) audioUploaderEl.value = null;

        if (response && response.success && response.driveFileId) {
            displayMessage("Audio processed successfully.", true);

            const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
             if (!currentSlide.slideMedia) {
                currentSlide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
             }
            currentSlide.slideMedia.type = 'audio';
            currentSlide.slideMedia.url = null; // Audio is not displayed visually from URL on canvas bg
            currentSlide.slideMedia.driveFileId = response.driveFileId;
            currentSlide.slideMedia.mimeType = response.mimeType;
            currentSlide.slideMedia.originalName = response.fileName;

            console.log(`Audio attached for slide ${adminApp.state.currentSlideIndex + 1}:`, currentSlide.slideMedia);
            
            // Update UI
            if (attachedAudioNameEl) {
                attachedAudioNameEl.textContent = `Attached: ${response.fileName}`;
                const audioControls = document.getElementById('audioControls');
                if(audioControls) audioControls.style.display = 'block';
            }
            if (removeAudioButtonEl) removeAudioButtonEl.style.display = 'inline-block';

            // Clear other media UI states and canvas background
            if (youtubeUrlInputEl) youtubeUrlInputEl.value = '';
            if (imageUploaderEl) imageUploaderEl.value = null;
            if(adminApp.state.fabricCanvasInstance) {
                adminApp.state.fabricCanvasInstance.setBackgroundImage(null, adminApp.state.fabricCanvasInstance.renderAll.bind(adminApp.state.fabricCanvasInstance));
                adminApp.state.fabricCanvasInstance.backgroundColor = '#e9e9e9'; // Default BG
                adminApp.state.fabricCanvasInstance.renderAll();
            }
            if (adminMediaPlaceholderEl) {
                 adminMediaPlaceholderEl.textContent = `Audio Attached: ${response.fileName}`;
                 adminMediaPlaceholderEl.style.display = 'block';
             }

        } else {
            onServerError((response && response.error) ? response.error : "Failed to process audio.");
        }
    }

    function handleRemoveAudio() {
        if (!adminApp.state.projectData || adminApp.state.currentSlideIndex < 0) return;

        const currentSlide = adminApp.state.projectData.slides[adminApp.state.currentSlideIndex];
        if (currentSlide.slideMedia && currentSlide.slideMedia.type === 'audio') {
            console.log(`Removing audio from slide ${adminApp.state.currentSlideIndex + 1}`);

            // Clear audio properties from slideMedia
            currentSlide.slideMedia.type = null;
            currentSlide.slideMedia.url = null;
            currentSlide.slideMedia.driveFileId = null;
            currentSlide.slideMedia.mimeType = null;
            currentSlide.slideMedia.originalName = null;

            // Update UI
            if (attachedAudioNameEl) {
                attachedAudioNameEl.textContent = '';
                const audioControls = document.getElementById('audioControls');
                if(audioControls) audioControls.style.display = 'none';
            }
            if (removeAudioButtonEl) removeAudioButtonEl.style.display = 'none';
            if (audioUploaderEl) audioUploaderEl.value = null; // Clear file input
            if (adminMediaPlaceholderEl) adminMediaPlaceholderEl.style.display = 'none';
            
            // Reset canvas background color if it was changed for audio indication
            if(adminApp.state.fabricCanvasInstance) {
                adminApp.state.fabricCanvasInstance.backgroundColor = '#e9e9e9';
                adminApp.state.fabricCanvasInstance.renderAll();
             }
            displayMessage("Audio removed from this slide.", true);
        }
    }

    function handlePasteImage(event) {
        if (adminApp.state.currentView !== 'edit' || !adminApp.state.currentProjectId || adminApp.state.isLoading) {
            return;
        }
        const items = (event.clipboardData || event.originalEvent.clipboardData).items;
        let imageFound = false;
        for (let i = 0; i < items.length; i++) {
            if (items[i].kind === 'file' && items[i].type.startsWith('image/')) {
                imageFound = true;
                const blob = items[i].getAsFile();
                if (!blob) continue;
                event.preventDefault();
                console.log("Image pasted from clipboard:", blob.name || 'pasted_image', blob.type);
                saveCurrentSlideState(); // Save current slide state before potentially changing its background
                showLoading(true);
                displayMessage("Processing pasted image...", true);
                const reader = new FileReader();
                reader.onload = function(e_reader) {
                    const fileData = {
                        fileName: blob.name || `pasted_image_${Date.now()}.${blob.type.split('/')[1] || 'png'}`, // Generate a name if needed
                        mimeType: blob.type,
                        data: e_reader.target.result.split(',')[1]
                    };
                    if (!adminApp.state.currentProjectId) {
                        showLoading(false);
                        displayMessage("Error: No project selected for pasted image.", false);
                        return;
                    }
                    google.script.run
                        .withSuccessHandler(onImageUploaded) // Reuses the existing image upload flow
                        .withFailureHandler(onServerError)
                        .uploadFileToDrive(fileData, adminApp.state.currentProjectId, 'image');
                };
                reader.onerror = function(error) {
                    showLoading(false);
                    displayMessage("Error reading pasted image data.", false);
                    console.error("FileReader error:", error);
                };
                reader.readAsDataURL(blob);
                break; // Process first image found
            }
        }
        if (imageFound) {
            console.log("Handled pasted image.");
        } else {
            console.log("Paste event did not contain a direct image file.");
        }
    }

    // Unified media handling for toolbar buttons (if added later, not currently used by this plan)
    function handleMediaSelection(mediaType) {
        if (adminApp.state.currentView !== 'edit' || !adminApp.state.currentProjectId || adminApp.state.isLoading) {
            showNotification("Cannot add media now. Please wait...", "error");
            return;
        }
        
        switch(mediaType) {
            case 'image':
                if (imageUploaderEl) {
                    imageUploaderEl.click();
                } else {
                    showNotification("Image upload not available", "error");
                }
                break;
            case 'audio':
                if (audioUploaderEl) {
                    audioUploaderEl.click();
                } else {
                    showNotification("Audio upload not available", "error");
                }
                break;
            case 'youtube':
                const youtubeUrl = prompt("Enter YouTube URL:");
                if (youtubeUrl) {
                    if (youtubeUrlInputEl) {
                        youtubeUrlInputEl.value = youtubeUrl;
                        handleSetYoutubeBackground();
                    } else {
                        showNotification("YouTube background functionality not available", "error");
                    }
                }
                break;
            default:
                showNotification("Unknown media type: " + mediaType, "error");
        }
    }

    // Place these with other toolbar action functions
    function handleUndo() {
        if (adminApp.state.historyIndex <= 0) return; // Cannot undo further than the initial state

        adminApp.state.isApplyingHistory = true;
        adminApp.state.historyIndex--;
        const canvas = adminApp.state.fabricCanvasInstance;
        const stateToLoad = adminApp.state.history[adminApp.state.historyIndex];

        canvas.loadFromJSON(stateToLoad, () => {
            canvas.renderAll();
            // Ensure custom properties are revived correctly after load (if necessary)
            canvas.getObjects().forEach(obj => {
                const originalObjState = stateToLoad.objects.find(sObj => sObj.slideId === obj.slideId /* or another unique id if you have one */);
                if (originalObjState) { // This matching needs to be robust
                    obj.customInteraction = originalObjState.customInteraction || { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
                    obj.customAnimation = originalObjState.customAnimation || { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
                }
            });
            populateToolbar(canvas.getActiveObject()); // Update toolbar based on current selection
            adminApp.state.isApplyingHistory = false;
            updateUndoRedoButtonStates();
            console.log("Undo applied. History index:", adminApp.state.historyIndex);
        });
    }

    function handleRedo() {
        if (adminApp.state.historyIndex >= adminApp.state.history.length - 1) return;

        adminApp.state.isApplyingHistory = true;
        adminApp.state.historyIndex++;
        const canvas = adminApp.state.fabricCanvasInstance;
        const stateToLoad = adminApp.state.history[adminApp.state.historyIndex];

        canvas.loadFromJSON(stateToLoad, () => {
            canvas.renderAll();
            // Ensure custom properties are revived
            canvas.getObjects().forEach(obj => {
                const originalObjState = stateToLoad.objects.find(sObj => sObj.slideId === obj.slideId);
                if (originalObjState) {
                    obj.customInteraction = originalObjState.customInteraction || { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
                    obj.customAnimation = originalObjState.customAnimation || { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
                }
            });
            populateToolbar(canvas.getActiveObject());
            adminApp.state.isApplyingHistory = false;
            updateUndoRedoButtonStates();
            console.log("Redo applied. History index:", adminApp.state.historyIndex);
        });
    }

    function handleDeleteObject() {
        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas) return;
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
            canvas.remove(activeObject);
            // If it was a group, also remove individual items if needed, or handle groups directly
            if (activeObject.type === 'activeSelection') { // Fabric's term for a multi-selection group
                activeObject.forEachObject(obj => canvas.remove(obj));
                canvas.discardActiveObject(); // Clear the activeSelection object
            }
            canvas.renderAll();
            saveCanvasStateForHistory(); // Save state after deletion
            populateToolbar(null); // Update toolbar since object is gone
            showNotification("Object deleted", "info");
        } else {
            showNotification("No object selected to delete.", "info");
        }
    }
    // --- Overlay Creation ---
    function addRectangle() {
      if (!adminApp.state.fabricCanvasInstance) { console.error("addRectangle: Fabric canvas not initialized."); displayMessage("Error: Canvas not ready to add shapes.", false); return; }
      const canvas = adminApp.state.fabricCanvasInstance;
      const rect = new fabric.Rect({ 
          left: 50, top: 50, fill: 'rgba(255,0,0,0.7)', width: 150, height: 100, 
          stroke: 'black', strokeWidth: 1,
          customInteraction: { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 }, 
          customAnimation: { trigger: "", type: "", speed: "normal", strength: 5, loop: false }, 
          sequenceOrder: null 
      });
    canvas.add(rect); canvas.setActiveObject(rect); canvas.renderAll();
    saveCanvasStateForHistory(); // <-- ADD
    console.log("Rectangle added to canvas:", rect);
    hideActivePopover();
    }

    function addCircle() {
      if (!adminApp.state.fabricCanvasInstance) { console.error("addCircle: Fabric canvas not initialized."); displayMessage("Error: Canvas not ready to add shapes.", false); return; }
      const canvas = adminApp.state.fabricCanvasInstance;
      const circle = new fabric.Circle({ 
          left: 150, top: 150, radius: 50, fill: 'rgba(0,0,255,0.7)', 
          stroke: 'black', strokeWidth: 1, 
          customInteraction: { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 }, 
          customAnimation: { trigger: "", type: "", speed: "normal", strength: 5, loop: false }, 
          sequenceOrder: null 
      });
    canvas.add(circle); canvas.setActiveObject(circle); canvas.renderAll();
    saveCanvasStateForHistory(); // <-- ADD
    console.log("Circle added to canvas:", circle);
    hideActivePopover();
    }

    function addTextbox() {
      if (!adminApp.state.fabricCanvasInstance) { console.error("addTextbox: Fabric canvas not initialized."); displayMessage("Error: Canvas not ready to add text.", false); return; }
      const canvas = adminApp.state.fabricCanvasInstance;
      const textbox = new fabric.Textbox('Editable Text', {
          left: 100, top: 100, width: 200, fontSize: 24, fill: '#000000',
          fontFamily: 'Arial', fontWeight: 'normal', fontStyle: 'normal',
          textAlign: 'left', lineHeight: 1.16, charSpacing: 0,
          customInteraction: { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 },
          customAnimation: { trigger: "", type: "", speed: "normal", strength: 5, loop: false },
          sequenceOrder: null
      });
        canvas.add(textbox); canvas.setActiveObject(textbox); canvas.renderAll();
        saveCanvasStateForHistory(); // <-- ADD
        console.log("Textbox added to canvas:", textbox);
        hideActivePopover();
        }

    // --- Toolbar Logic (Significantly Reworked) ---
    function toHexColor(fabricColor) {
      if (!fabricColor) return '#000000'; // Default for undefined or null
      try {
        // If it's already a hex string (potentially with alpha), fabric.Color can handle it.
        // If it's an object (like a gradient), toHex() might not be what we want for a simple color picker.
        // For simplicity, we assume solid colors for these pickers.
        if (typeof fabricColor === 'string') {
            const colorInstance = new fabric.Color(fabricColor);
            const hex = colorInstance.toHex(); // Gets 6-digit hex
            return '#' + hex;
        }
        return '#000000'; // Fallback for unexpected types
      } catch (e) {
        console.warn("Could not convert color to HEX:", fabricColor, e);
        return '#000000'; // Fallback on error
      }
    }

    function initToolbar() {
        console.log("initToolbar: Attaching listeners to NEW toolbar inputs and popovers.");
        hideActivePopover(); // Ensure all popovers start hidden

        // Populate Font Family Select (inside its popover)
        if(objFontFamilyEl) {
            objFontFamilyEl.innerHTML = ''; // Clear existing options
            FONT_FAMILIES.forEach(font => {
                const option = document.createElement('option'); option.value = font; option.textContent = font; objFontFamilyEl.appendChild(option);
            });
             // Listener for the font family select itself
            if (!objFontFamilyEl.hasAttribute('listener-attached')) {
                objFontFamilyEl.addEventListener('change', (e) => updateFabricObjectFromToolbar('fontFamily', e.target.value));
                objFontFamilyEl.setAttribute('listener-attached', 'true');
            }
        } else { console.warn("initToolbar: objFontFamilyEl not found for populating fonts."); }


        // --- Event Listeners for Popover Trigger Buttons ---
        const popoverTriggers = [
            { buttonEl: shadowSettingsButtonEl, popoverId: 'shadowPopover' },
            { buttonEl: interactionSettingsButtonEl, popoverId: 'interactionPopover' },
            { buttonEl: animationSettingsButtonEl, popoverId: 'animationPopover' },
            { buttonEl: fontFamilyButtonEl, popoverId: 'fontFamilyPopover' },
            // New toolbar buttons integrated here
            { buttonEl: mediaToolsButtonEl, popoverId: 'mediaToolsPopover' },
            { buttonEl: addShapeButtonEl, popoverId: 'shapesPopover' }, // Singular 'addShapeButtonEl'
            { buttonEl: positionToolsButtonEl, popoverId: 'positionToolsPopover' },
            // Popovers for Fill, Stroke, Opacity
            { buttonEl: fillColorButtonEl, popoverId: 'fillColorPopover' },
            { buttonEl: strokeColorButtonEl, popoverId: 'strokeColorPopover' },
            { buttonEl: opacityButtonEl, popoverId: 'opacityPopover' }
        ];

        popoverTriggers.forEach(item => {
            if (item.buttonEl && !item.buttonEl.hasAttribute('listener-attached')) {
                item.buttonEl.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent this click from immediately closing popover via document listener
                    togglePopover(item.popoverId, item.buttonEl);
                });
                item.buttonEl.setAttribute('listener-attached', 'true');
            } else if (!item.buttonEl) {
                console.warn(`initToolbar: Popover trigger button for ${item.popoverId} not found.`);
            }
        });

        // Media tab buttons event listeners (inside mediaToolsPopover)
        if (mediaTabButtonsEl && mediaTabButtonsEl.length > 0) {
            mediaTabButtonsEl.forEach(tab => {
                if (!tab.hasAttribute('listener-attached')) {
                    tab.addEventListener('click', () => {
                        const tabId = tab.dataset.tab;
                        switchMediaTab(tabId);
                    });
                    tab.setAttribute('listener-attached', 'true');
                }
            });
        }

        // Drag and drop zone event listeners (inside mediaToolsPopover)
        const setupDropZone = (dropZoneEl, uploaderEl, fileTypePrefix, uploadHandler) => {
            if (dropZoneEl && !dropZoneEl.hasAttribute('listener-attached')) {
                dropZoneEl.addEventListener('click', () => {
                    if (uploaderEl) uploaderEl.click();
                });
                dropZoneEl.addEventListener('dragover', (e) => { e.preventDefault(); dropZoneEl.classList.add('drag-over'); });
                dropZoneEl.addEventListener('dragleave', () => { dropZoneEl.classList.remove('drag-over'); });
                dropZoneEl.addEventListener('drop', (e) => {
                    e.preventDefault(); dropZoneEl.classList.remove('drag-over');
                    if (e.dataTransfer.files.length > 0) {
                        const file = e.dataTransfer.files[0];
                        if (file.type.startsWith(fileTypePrefix)) {
                            const mockEvent = { target: { files: [file] } };
                            uploadHandler(mockEvent);
                        } else {
                            displayMessage(`Please drop a ${fileTypePrefix.split('/')[0]} file.`, false);
                        }
                    }
                });
                dropZoneEl.setAttribute('listener-attached', 'true');
            }
        };
        setupDropZone(imageDropZoneEl, imageUploaderEl, 'image/', handleImageUpload);
        setupDropZone(audioDropZoneEl, audioUploaderEl, 'audio/', handleAudioUpload);


        // --- Event Listeners for Direct Toolbar Inputs (X, Y, Width, Height, Angle, StrokeWidth, Opacity, FontSize, LineHeight, CharSpacing, TextContent) ---
        // Note: objFill, objStrokeColor, objStrokeWidth, objOpacity are now in popovers.
        // Their listeners are attached here but they operate on elements within those popovers.
        const directInputs = [
            // Position inputs are inside positionToolsPopover, handled there.
            {el: objStrokeWidthEl, prop: 'strokeWidth', type: 'number'}, // In strokeColorPopover
            {el: objOpacityEl, prop: 'opacity', type: 'range'}, // In opacityPopover
            {el: objFontSizeEl, prop: 'fontSize', type: 'number'},
            {el: objLineHeightEl, prop: 'lineHeight', type: 'number', isFloat: true},
            {el: objCharSpacingEl, prop: 'charSpacing', type: 'number'},
            {el: objTextContentEl, prop: 'text', type: 'textarea'}
        ];
        directInputs.forEach(inputConfig => {
            if (inputConfig.el && !inputConfig.el.hasAttribute('listener-attached')) {
                const eventType = (inputConfig.el.type === 'range' || inputConfig.el.type === 'textarea') ? 'input' : 'change';
                inputConfig.el.addEventListener(eventType, (e) => {
                    updateFabricObjectFromToolbar(inputConfig.prop, e.target.value, inputConfig.type, inputConfig.isFloat);
                });
                inputConfig.el.setAttribute('listener-attached', 'true');
            } else if (!inputConfig.el) {
                 console.warn(`initToolbar: Direct input element for prop "${inputConfig.prop}" not found (this may be ok if it's in a popover, e.g. opacityEl).`);
            }
        });

        // Listener for Opacity display update (objOpacityEl is in opacityPopover)
        if (objOpacityEl && objOpacityValueDisplayEl && !objOpacityEl.hasAttribute('listener-opacity-display')) {
            objOpacityEl.addEventListener('input', function(e) {
                objOpacityValueDisplayEl.textContent = Math.round(parseFloat(e.target.value) * 100) + '%';
            });
            objOpacityEl.setAttribute('listener-opacity-display', 'true');
        }
        
        // Listeners for inputs within positionToolsPopover
        const positionInputs = [
            {el: objXEl, prop: 'left', type: 'number'}, {el: objYEl, prop: 'top', type: 'number'},
            {el: objWidthEl, prop: 'width', type: 'number', targetProp: 'scaleX'}, // Special handling for width/height
            {el: objHeightEl, prop: 'height', type: 'number', targetProp: 'scaleY'},
            {el: objAngleEl, prop: 'angle', type: 'number'}
        ];
        positionInputs.forEach(inputConfig => {
            if (inputConfig.el && !inputConfig.el.hasAttribute('listener-attached')) {
                 inputConfig.el.addEventListener('change', (e) => { // Use 'change' for number inputs to avoid excessive updates while typing
                    updateFabricObjectFromToolbar(inputConfig.prop, e.target.value, inputConfig.type);
                });
                inputConfig.el.setAttribute('listener-attached', 'true');
            } else if (!inputConfig.el) {
                console.warn(`initToolbar: Position input element for prop "${inputConfig.prop}" not found.`);
            }
        });


        // --- Event Listeners for Color Inputs (Fill, Stroke) ---
        const colorInputs = [
            {el: objFillEl, prop: 'fill'},
            {el: objStrokeColorEl, prop: 'stroke'}
        ];
        colorInputs.forEach(inputConfig => {
            if (inputConfig.el && !inputConfig.el.hasAttribute('listener-attached')) {
                inputConfig.el.addEventListener('input', (e) => updateFabricObjectFromToolbar(inputConfig.prop, e.target.value));
                inputConfig.el.setAttribute('listener-attached', 'true');
            } else if (!inputConfig.el) {
                console.warn(`initToolbar: Color input element for prop "${inputConfig.prop}" not found.`);
            }
        });


        // --- Event Listeners for Text Style Toggle Buttons (Bold, Italic, Align) ---
        if (fontWeightButtonEl && !fontWeightButtonEl.hasAttribute('listener-attached')) {
            fontWeightButtonEl.addEventListener('click', () => {
                const activeObject = adminApp.state.fabricCanvasInstance.getActiveObject();
                if (!activeObject || !(activeObject.type === 'textbox' || activeObject.type === 'i-text')) return;
                const newValue = activeObject.fontWeight === 'bold' ? 'normal' : 'bold';
                updateFabricObjectFromToolbar('fontWeight', newValue);
                populateToolbar(activeObject); // Repopulate to update button state
            });
            fontWeightButtonEl.setAttribute('listener-attached', 'true');
        } else if(!fontWeightButtonEl) { console.warn("initToolbar: fontWeightButtonEl not found."); }

        if (fontStyleButtonEl && !fontStyleButtonEl.hasAttribute('listener-attached')) {
            fontStyleButtonEl.addEventListener('click', () => {
                const activeObject = adminApp.state.fabricCanvasInstance.getActiveObject();
                if (!activeObject || !(activeObject.type === 'textbox' || activeObject.type === 'i-text')) return;
                const newValue = activeObject.fontStyle === 'italic' ? 'normal' : 'italic';
                updateFabricObjectFromToolbar('fontStyle', newValue);
                populateToolbar(activeObject); // Repopulate to update button state
            });
            fontStyleButtonEl.setAttribute('listener-attached', 'true');
        } else if(!fontStyleButtonEl) { console.warn("initToolbar: fontStyleButtonEl not found."); }

        if (textAlignGroupEl && !textAlignGroupEl.hasAttribute('listener-attached')) {
            const alignButtons = textAlignGroupEl.querySelectorAll('.toolbar-button[data-align]');
            alignButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const activeObject = adminApp.state.fabricCanvasInstance.getActiveObject();
                    if (!activeObject || !(activeObject.type === 'textbox' || activeObject.type === 'i-text')) return;
                    const alignValue = button.dataset.align;
                    updateFabricObjectFromToolbar('textAlign', alignValue);
                    populateToolbar(activeObject); // Repopulate to update button states
                });
            });
            textAlignGroupEl.setAttribute('listener-attached', 'true');
        } else if(!textAlignGroupEl) { console.warn("initToolbar: textAlignGroupEl not found."); }


        // --- Event Listeners for Inputs INSIDE Popovers (Shadow, Interaction, Animation) ---
        const shadowInputs = [ // These are inside shadowPopover
            {el: objShadowColorEl, prop: 'shadow.color', type: 'color'},
            {el: objShadowBlurEl, prop: 'shadow.blur', type: 'range'},
            {el: objShadowOffsetXEl, prop: 'shadow.offsetX', type: 'number'},
            {el: objShadowOffsetYEl, prop: 'shadow.offsetY', type: 'number'},
            {el: objShadowAffectStrokeEl, prop: 'shadow.affectStroke', type: 'checkbox'},
            {el: objShadowNonScalingEl, prop: 'shadow.nonScaling', type: 'checkbox'}
        ];
        shadowInputs.forEach(inputConfig => {
            if (inputConfig.el && !inputConfig.el.hasAttribute('listener-attached')) {
                const eventType = (inputConfig.el.type === 'color' || inputConfig.el.type === 'range') ? 'input' : 'change';
                inputConfig.el.addEventListener(eventType, (e) => {
                    const value = inputConfig.el.type === 'checkbox' ? e.target.checked : e.target.value;
                    updateFabricObjectFromToolbar(inputConfig.prop, value, inputConfig.type);
                });
                inputConfig.el.setAttribute('listener-attached', 'true');
            } else if(!inputConfig.el) { console.warn(`initToolbar: Shadow input element for prop "${inputConfig.prop}" not found.`);}
        });

        const editActionButtons = [
            { el: undoButtonEl, handler: handleUndo, critical: false },
            { el: redoButtonEl, handler: handleRedo, critical: false },
            { el: deleteObjectButtonEl, handler: handleDeleteObject, critical: true }
        ];

        editActionButtons.forEach(config => {
            if (config.el && !config.el.hasAttribute('listener-attached')) {
                config.el.addEventListener('click', config.handler);
                config.el.setAttribute('listener-attached', 'true');
            } else if (!config.el && config.critical) {
                console.warn(`initToolbar: Critical edit action button element not found (e.g., delete).`);
            }
        });
        updateUndoRedoButtonStates(); // Set initial state of undo/redo buttons

        // Interaction inputs (inside interactionPopover)
        if (objInteractionTriggerEl && !objInteractionTriggerEl.hasAttribute('listener-attached')) {
            objInteractionTriggerEl.addEventListener('change', handleInteractionChange); objInteractionTriggerEl.setAttribute('listener-attached', 'true');
        } else if(!objInteractionTriggerEl) { console.warn("initToolbar: objInteractionTriggerEl not found.");}
        if (objInteractionActionEl && !objInteractionActionEl.hasAttribute('listener-attached')) {
            objInteractionActionEl.addEventListener('change', handleInteractionChange); objInteractionActionEl.setAttribute('listener-attached', 'true');
        } else if(!objInteractionActionEl) { console.warn("initToolbar: objInteractionActionEl not found.");}
        if (objModalContentEl && !objModalContentEl.hasAttribute('listener-attached')) { // This is textarea inside popover
            objModalContentEl.addEventListener('input', handleInteractionChange); objModalContentEl.setAttribute('listener-attached', 'true');
        } else if(!objModalContentEl) { console.warn("initToolbar: objModalContentEl (popover) not found.");}
        if (objNavigateToEl && !objNavigateToEl.hasAttribute('listener-attached')) { // This is input inside popover
            objNavigateToEl.addEventListener('input', handleInteractionChange); objNavigateToEl.setAttribute('listener-attached', 'true');
        } else if(!objNavigateToEl) { console.warn("initToolbar: objNavigateToEl (popover) not found.");}
         if (objPanZoomLevelEl && !objPanZoomLevelEl.hasAttribute('listener-attached')) { // This is input inside popover
             objPanZoomLevelEl.addEventListener('input', handleInteractionChange); objPanZoomLevelEl.setAttribute('listener-attached', 'true');
        } else if(!objPanZoomLevelEl) { console.warn("initToolbar: objPanZoomLevelEl (popover) not found.");}


        // Animation inputs (inside animationPopover)
        if (objAnimationTriggerEl && !objAnimationTriggerEl.hasAttribute('listener-attached')) {
            objAnimationTriggerEl.addEventListener('change', handleAnimationChange); objAnimationTriggerEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationTriggerEl) { console.warn("initToolbar: objAnimationTriggerEl not found.");}
        if (objAnimationTypeEl && !objAnimationTypeEl.hasAttribute('listener-attached')) {
            objAnimationTypeEl.addEventListener('change', handleAnimationChange); objAnimationTypeEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationTypeEl) { console.warn("initToolbar: objAnimationTypeEl not found.");}
        if (objAnimationSpeedEl && !objAnimationSpeedEl.hasAttribute('listener-attached')) { // Note: this is objAnimationSpeedEl from setupDOMReferences
            objAnimationSpeedEl.addEventListener('change', handleAnimationChange); objAnimationSpeedEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationSpeedEl) { console.warn("initToolbar: objAnimationSpeedEl not found.");}
        if (objAnimationStrengthEl && !objAnimationStrengthEl.hasAttribute('listener-attached')) {
             objAnimationStrengthEl.addEventListener('input', handleAnimationChange); objAnimationStrengthEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationStrengthEl) { console.warn("initToolbar: objAnimationStrengthEl not found.");}
        if (objAnimationLoopEl && !objAnimationLoopEl.hasAttribute('listener-attached')) {
            objAnimationLoopEl.addEventListener('change', handleAnimationChange);
            objAnimationLoopEl.setAttribute('listener-attached', 'true');
        } else if(!objAnimationLoopEl) { console.warn("initToolbar: objAnimationLoopEl not found.");}
        
        // Hidden animation elements - listeners kept for potential backward compatibility if data has them.
        // Their config sections are hidden.
        if (objAnimationLoopCountEl && !objAnimationLoopCountEl.hasAttribute('listener-attached')) {
            objAnimationLoopCountEl.addEventListener('input', handleAnimationChange);
            objAnimationLoopCountEl.setAttribute('listener-attached', 'true');
        }
        if (objAnimationLoopDelayEl && !objAnimationLoopDelayEl.hasAttribute('listener-attached')) {
            objAnimationLoopDelayEl.addEventListener('input', handleAnimationChange);
            objAnimationLoopDelayEl.setAttribute('listener-attached', 'true');
        }
    }
    
    function populateToolbar(activeObject) {
        if (!overlayPropertiesToolbarEl) { console.error("populateToolbar: overlayPropertiesToolbarEl not found."); return; }
        overlayPropertiesToolbarEl.style.display = 'block'; // Toolbar container always visible

        const isObjectSelected = !!activeObject;
        const isTextObject = isObjectSelected && (activeObject.type === 'textbox' || activeObject.type === 'i-text');

        if (deleteObjectButtonEl) deleteObjectButtonEl.disabled = !isObjectSelected;

        // --- Manage Enabled/Disabled States ---

        // Buttons for adding elements or slide-level changes - always enabled in edit view
        if (mediaToolsButtonEl) mediaToolsButtonEl.disabled = false;
        if (addShapeButtonEl) addShapeButtonEl.disabled = false;

        // Text-specific controls row visibility
        if (textSpecificControlsEl) {
            textSpecificControlsEl.style.display = isTextObject ? 'flex' : 'none';
        }

        // General object property controls (inputs and popover triggers)
        const generalObjectControlsAndTriggers = [
            objFillEl, objStrokeColorEl, objStrokeWidthEl, objOpacityEl, // Direct inputs
            positionToolsButtonEl, shadowSettingsButtonEl, interactionSettingsButtonEl, animationSettingsButtonEl // Popover triggers
        ];
        generalObjectControlsAndTriggers.forEach(control => {
            if (control) control.disabled = !isObjectSelected;
        });

        // Text-specific property controls (font family popover trigger and inputs/buttons within textSpecificControls row)
        const textPropertyControlsAndTriggers = [
            fontFamilyButtonEl, // Popover trigger
            objFontSizeEl, objLineHeightEl, objCharSpacingEl, objTextContentEl, // Inputs in text row
            fontWeightButtonEl, fontStyleButtonEl // Buttons in text row
        ];
        if (textAlignGroupEl) { // Buttons in text row
            textAlignGroupEl.querySelectorAll('.toolbar-button[data-align]').forEach(btn => textPropertyControlsAndTriggers.push(btn));
        }
        textPropertyControlsAndTriggers.forEach(control => {
            if (control) control.disabled = !isTextObject;
        });


        // --- If NO object is selected, clean up and return ---
        if (!isObjectSelected) {
            hideActivePopover(); // Close any object-property popovers

            // Visually deactivate popover trigger buttons
            const popoverTriggerButtons = [positionToolsButtonEl, shadowSettingsButtonEl, interactionSettingsButtonEl, animationSettingsButtonEl, fontFamilyButtonEl];
            popoverTriggerButtons.forEach(btn => {
                if (btn) btn.classList.remove('active', 'popover-active');
            });

            // Visually deactivate text style buttons
            if (fontWeightButtonEl) fontWeightButtonEl.classList.remove('active');
            if (fontStyleButtonEl) fontStyleButtonEl.classList.remove('active');
            if (textAlignGroupEl) {
                textAlignGroupEl.querySelectorAll('.toolbar-button[data-align]').forEach(btn => btn.classList.remove('active'));
            }
            
            // Optionally, reset some input values to defaults or placeholders if they are not disabled styling enough
            // For example:
            // if (objFillEl) objFillEl.value = '#dddddd'; 
            if (objOpacityEl) objOpacityEl.value = 1; // Reset opacity slider
            if (objOpacityValueDisplayEl) objOpacityValueDisplayEl.textContent = '100%';

            // Remove 'active' class from Fill, Stroke, Opacity buttons
            if (fillColorButtonEl) fillColorButtonEl.classList.remove('active');
            if (strokeColorButtonEl) strokeColorButtonEl.classList.remove('active');
            if (opacityButtonEl) opacityButtonEl.classList.remove('active');


            return; // Stop further population
        }

        // --- If an object IS selected, proceed to populate its properties into the (now enabled) controls ---
        
        // Populate Position Popover Inputs (objX, objY, etc.) - these are enabled if isObjectSelected
        if (objXEl) objXEl.value = activeObject.left !== undefined ? activeObject.left.toFixed(0) : 0;
        if (objYEl) objYEl.value = activeObject.top !== undefined ? activeObject.top.toFixed(0) : 0;
        if (objWidthEl) objWidthEl.value = activeObject.getScaledWidth ? activeObject.getScaledWidth().toFixed(0) : (activeObject.width || 0);
        if (objHeightEl) objHeightEl.value = activeObject.getScaledHeight ? activeObject.getScaledHeight().toFixed(0) : (activeObject.height || 0);
        if (objAngleEl) objAngleEl.value = activeObject.angle !== undefined ? activeObject.angle.toFixed(0) : 0;
        
        // Populate Main Toolbar Direct Inputs - these are enabled if isObjectSelected
        // objFillEl, objStrokeColorEl, objStrokeWidthEl, objOpacityEl are now in popovers,
        // but their values are still populated here.
        if (objFillEl) objFillEl.value = toHexColor(activeObject.fill);
        if (objStrokeColorEl) objStrokeColorEl.value = toHexColor(activeObject.stroke);
        if (objStrokeWidthEl) objStrokeWidthEl.value = activeObject.strokeWidth === undefined ? 0 : activeObject.strokeWidth;
        if (objOpacityEl) { // In opacityPopover
            objOpacityEl.value = activeObject.opacity === undefined ? 1 : activeObject.opacity;
            if (objOpacityValueDisplayEl) { // Update the percentage display
                objOpacityValueDisplayEl.textContent = Math.round(parseFloat(objOpacityEl.value) * 100) + '%';
            }
        }


        // Populate Text Specific Controls (if applicable and visible)
        if (isTextObject) { // These controls are already enabled if isTextObject is true
            if (objTextContentEl) objTextContentEl.value = activeObject.text || '';
            if (objFontFamilyEl) objFontFamilyEl.value = activeObject.fontFamily || 'Arial'; // Inside fontFamilyPopover
            if (objFontSizeEl) objFontSizeEl.value = activeObject.fontSize || 24;
            if (objLineHeightEl) objLineHeightEl.value = activeObject.lineHeight === undefined ? 1.16 : activeObject.lineHeight;
            if (objCharSpacingEl) objCharSpacingEl.value = activeObject.charSpacing === undefined ? 0 : activeObject.charSpacing;

            if (fontWeightButtonEl) fontWeightButtonEl.classList.toggle('active', activeObject.fontWeight === 'bold');
            if (fontStyleButtonEl) fontStyleButtonEl.classList.toggle('active', activeObject.fontStyle === 'italic');
            if (textAlignGroupEl) {
                textAlignGroupEl.querySelectorAll('.toolbar-button[data-align]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.align === activeObject.textAlign);
                });
            }
            // Sync hidden selects (inside fontFamilyPopover)
            if (objFontWeightEl) objFontWeightEl.value = activeObject.fontWeight || 'normal';
            if (objFontStyleEl) objFontStyleEl.value = activeObject.fontStyle || 'normal';
            if (objTextAlignEl) objTextAlignEl.value = activeObject.textAlign || 'left';
        }

        // Populate Shadow Popover Inputs - shadowSettingsButtonEl is enabled if isObjectSelected
        const shadow = activeObject.shadow instanceof fabric.Shadow ? activeObject.shadow : null;
        if (objShadowColorEl) objShadowColorEl.value = shadow ? toHexColor(shadow.color) : '#000000';
        if (objShadowBlurEl) objShadowBlurEl.value = shadow ? shadow.blur : 0;
        if (objShadowOffsetXEl) objShadowOffsetXEl.value = shadow ? shadow.offsetX : 0;
        if (objShadowOffsetYEl) objShadowOffsetYEl.value = shadow ? shadow.offsetY : 0;
        if (objShadowAffectStrokeEl) objShadowAffectStrokeEl.checked = shadow ? !!shadow.affectStroke : false;
        if (objShadowNonScalingEl) objShadowNonScalingEl.checked = shadow ? !!shadow.nonScaling : false;
        if (shadowSettingsButtonEl) shadowSettingsButtonEl.classList.toggle('active', !!shadow);

        // Fill button active state
        if (fillColorButtonEl) {
            const hasFill = activeObject.fill && activeObject.fill !== 'transparent' && 
                            (typeof activeObject.fill !== 'object' || activeObject.fill.type !== 'gradient' || activeObject.fill.colorStops.length > 0);
            fillColorButtonEl.classList.toggle('active', !!hasFill);
        }

        // Stroke button active state
        if (strokeColorButtonEl) {
            const hasStroke = activeObject.stroke && activeObject.strokeWidth > 0;
            strokeColorButtonEl.classList.toggle('active', hasStroke);
        }

        // Opacity button active state
        if (opacityButtonEl) {
            const isTranslucent = activeObject.opacity !== undefined && activeObject.opacity < 1;
            opacityButtonEl.classList.toggle('active', isTranslucent);
        }


        // Populate Interaction Popover Inputs - interactionSettingsButtonEl is enabled if isObjectSelected
        const interaction = activeObject.customInteraction || { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 };
        if (objInteractionTriggerEl) objInteractionTriggerEl.value = interaction.trigger || "";
        if (objInteractionActionEl) objInteractionActionEl.value = interaction.action || "";
        if (objModalContentEl) objModalContentEl.value = interaction.modalContent || "";
        if (objNavigateToEl) objNavigateToEl.value = interaction.navigateTo || "";
        if (objPanZoomLevelEl) objPanZoomLevelEl.value = interaction.panZoomLevel === undefined ? 1.5 : interaction.panZoomLevel;
        updateInteractionConfigVisibility(interaction.action);
        if (interactionSettingsButtonEl) interactionSettingsButtonEl.classList.toggle('active', !!(interaction.trigger && interaction.action));

        // Populate Animation Popover Inputs - animationSettingsButtonEl is enabled if isObjectSelected
        const animation = activeObject.customAnimation || { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
        if (objAnimationTriggerEl) objAnimationTriggerEl.value = animation.trigger || "";
        if (objAnimationTypeEl) objAnimationTypeEl.value = animation.type || "";
        const showAnimParams = !!(animation.trigger && animation.type);
        const animParamsConfig = animationPopoverEl ? animationPopoverEl.querySelector('#animationParamsConfig') : null;
        if (animParamsConfig) animParamsConfig.style.display = showAnimParams ? 'block' : 'none';
        
        if (showAnimParams) {
            if (objAnimationSpeedEl) objAnimationSpeedEl.value = animation.speed || "normal";
            if (objAnimationStrengthEl) objAnimationStrengthEl.value = animation.strength === undefined ? 5 : animation.strength;
            updateAnimationStrengthUnit(animation.type);
            if (objAnimationLoopEl) objAnimationLoopEl.value = animation.loop ? "true" : "false";
        }
        if (animationSettingsButtonEl) animationSettingsButtonEl.classList.toggle('active', showAnimParams);
    }
    function handleInteractionChange() {
        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas) return;
        const activeObject = canvas.getActiveObject();
        if (!activeObject) return;
        if (!activeObject.customInteraction) { activeObject.customInteraction = { trigger: "", action: "", modalContent: "", navigateTo: "", panZoomLevel: 1.5 }; }

        if (objInteractionTriggerEl) activeObject.customInteraction.trigger = objInteractionTriggerEl.value;
        if (objInteractionActionEl) activeObject.customInteraction.action = objInteractionActionEl.value;
        if (objModalContentEl) activeObject.customInteraction.modalContent = objModalContentEl.value;
        if (objNavigateToEl) activeObject.customInteraction.navigateTo = objNavigateToEl.value;
        if (objPanZoomLevelEl) activeObject.customInteraction.panZoomLevel = parseFloat(objPanZoomLevelEl.value) || 1.5;

        updateInteractionConfigVisibility(activeObject.customInteraction.action);
        if (interactionSettingsButtonEl) interactionSettingsButtonEl.classList.toggle('active', !!(activeObject.customInteraction.trigger && activeObject.customInteraction.action));
        console.log("Interaction data updated for object:", activeObject.customInteraction);
        canvas.renderAll(); // Ensure change is reflected if visual properties depend on it (though unlikely here)
    }

    function updateInteractionConfigVisibility(action) {
        // These elements are INSIDE the interactionPopover
        const modalConfig = interactionPopoverEl ? interactionPopoverEl.querySelector('#modalContentConfig') : null;
        const navigateConfig = interactionPopoverEl ? interactionPopoverEl.querySelector('#navigateToConfig') : null;
        const panZoomConfig = interactionPopoverEl ? interactionPopoverEl.querySelector('#panZoomConfigEl') : null;

        const showModal = action === 'showModal';
        const showNavigate = action === 'navigateToSlide' || action === 'navigateToURL';
        const showPanZoomConfig = action === 'panZoomToTarget';

        if (modalConfig) modalConfig.style.display = showModal ? 'block' : 'none';
        if (navigateConfig) navigateConfig.style.display = showNavigate ? 'block' : 'none';
        if (panZoomConfig) panZoomConfig.style.display = showPanZoomConfig ? 'block' : 'none';
    }

    function updateAnimationStrengthUnit(animationType) {
        // This element is INSIDE the animationPopover
        const strengthUnitEl = animationPopoverEl ? animationPopoverEl.querySelector('#objAnimationStrengthUnit') : null;
        if (!strengthUnitEl) return;

        let unitText = "(pixels/degrees/scale)"; // Default/generic
        switch(animationType) {
            case 'wiggle': unitText = "(degrees)"; break;
            case 'float': unitText = "(pixels)"; break;
            case 'growShrink': unitText = "(scale factor e.g., 1.2)"; break;
        }
        strengthUnitEl.textContent = unitText;
    }

    function handleAnimationChange() {
        const canvas = adminApp.state.fabricCanvasInstance;
        if (!canvas) return;
        const activeObject = canvas.getActiveObject();
        if (!activeObject) return;

        if (!activeObject.customAnimation) {
            activeObject.customAnimation = { trigger: "", type: "", speed: "normal", strength: 5, loop: false };
        }

        if (objAnimationTriggerEl) activeObject.customAnimation.trigger = objAnimationTriggerEl.value;
        if (objAnimationTypeEl) activeObject.customAnimation.type = objAnimationTypeEl.value;
        
        const showAnimParams = !!(activeObject.customAnimation.trigger && activeObject.customAnimation.type);
        // This config element is INSIDE the animationPopover
        const animParamsConfig = animationPopoverEl ? animationPopoverEl.querySelector('#animationParamsConfig') : null;
        if (animParamsConfig) animParamsConfig.style.display = showAnimParams ? 'block' : 'none';

        if (showAnimParams) {
            if (objAnimationSpeedEl) activeObject.customAnimation.speed = objAnimationSpeedEl.value;
            // Map speed to duration for data model (client might use speed directly)
            switch(activeObject.customAnimation.speed) {
                case 'slow': activeObject.customAnimation.duration = 1500; break;
                case 'fast': activeObject.customAnimation.duration = 500; break;
                default: activeObject.customAnimation.duration = 1000; // Normal
            }
            
            if (objAnimationStrengthEl) activeObject.customAnimation.strength = parseFloat(objAnimationStrengthEl.value) || 5;
            updateAnimationStrengthUnit(activeObject.customAnimation.type);
            if (objAnimationLoopEl) activeObject.customAnimation.loop = objAnimationLoopEl.value === "true";
            
            // Remove legacy properties from the object model for cleanliness
            delete activeObject.customAnimation.loopCount;
            delete activeObject.customAnimation.loopDelay; // Or set to a default if used by client animation logic

        } else { // If no trigger or type, reset customAnimation properties
            activeObject.customAnimation.trigger = "";
            activeObject.customAnimation.type = "";
            activeObject.customAnimation.speed = "normal";
            activeObject.customAnimation.duration = 1000;
            activeObject.customAnimation.strength = 5;
            activeObject.customAnimation.loop = false;
            delete activeObject.customAnimation.loopCount;
            delete activeObject.customAnimation.loopDelay;
            updateAnimationStrengthUnit(""); 
        }
        if (animationSettingsButtonEl) animationSettingsButtonEl.classList.toggle('active', showAnimParams);
        console.log("Animation data updated for object:", activeObject.customAnimation);
        canvas.renderAll();
    }

    function updateFabricObjectFromToolbar(propertyName, value, inputType, isFloat = false) {
      const canvas = adminApp.state.fabricCanvasInstance;
      if (!canvas) return;
      const activeObject = canvas.getActiveObject();
      if (!activeObject) return;

      let parsedValue = value;
      if (inputType === 'number') {
          parsedValue = isFloat ? parseFloat(value) : parseInt(value, 10);
          if (isNaN(parsedValue)) {
              // Allow empty strokeWidth or charSpacing to be 0.
              if ((propertyName === 'strokeWidth' || propertyName === 'charSpacing') && value === '') parsedValue = 0;
              else if (value === '') return; // For other number fields, if empty, do nothing.
              else return; // If truly NaN and not an allowed empty case, do nothing.
          }
      } else if (inputType === 'range') { // Opacity, shadow.blur
          parsedValue = parseFloat(value);
          if (isNaN(parsedValue)) return;
      } else if (inputType === 'checkbox') { // For shadow.affectStroke, shadow.nonScaling
          parsedValue = !!value; // This is usually already a boolean from e.target.checked
      }
      // For string properties (fill, stroke, text, fontFamily, fontWeight, fontStyle, textAlign), parsedValue is already correct.

      if (propertyName === 'width') { 
          const newWidth = parseFloat(value);
          if (!isNaN(newWidth) && newWidth >= 0) {
            activeObject.scaleX = newWidth > 0 ? (newWidth / activeObject.width) : (activeObject.width > 0 ? 0.0001 / activeObject.width : 0.0001);
          }
      } else if (propertyName === 'height') { 
          const newHeight = parseFloat(value);
           if (!isNaN(newHeight) && newHeight >= 0) {
            activeObject.scaleY = newHeight > 0 ? (newHeight / activeObject.height) : (activeObject.height > 0 ? 0.0001 / activeObject.height : 0.0001);
           }
      } else if (propertyName.startsWith('shadow.')) {
        const shadowPropKey = propertyName.split('.')[1]; // color, blur, offsetX, etc.
        let shadowOptions = activeObject.shadow instanceof fabric.Shadow ? activeObject.shadow.toObject() : {};
        
        // Update the specific property that triggered this call
        shadowOptions[shadowPropKey] = parsedValue;

        // Always re-read all shadow properties from the popover inputs to ensure consistency
        // This is important because one change might affect how another is interpreted (e.g. blur needs a color)
        if (shadowPopoverEl) { // Ensure popover exists (it should if this is called)
            const popoverShadowColorEl = shadowPopoverEl.querySelector('#objShadowColor');
            const popoverShadowBlurEl = shadowPopoverEl.querySelector('#objShadowBlur');
            const popoverShadowOffsetXEl = shadowPopoverEl.querySelector('#objShadowOffsetX');
            const popoverShadowOffsetYEl = shadowPopoverEl.querySelector('#objShadowOffsetY');
            const popoverShadowAffectStrokeEl = shadowPopoverEl.querySelector('#objShadowAffectStroke');
            const popoverShadowNonScalingEl = shadowPopoverEl.querySelector('#objShadowNonScaling');

            if (popoverShadowColorEl) shadowOptions.color = popoverShadowColorEl.value || '#000000';
            if (popoverShadowBlurEl) shadowOptions.blur = parseFloat(popoverShadowBlurEl.value) || 0;
            if (popoverShadowOffsetXEl) shadowOptions.offsetX = parseInt(popoverShadowOffsetXEl.value, 10) || 0;
            if (popoverShadowOffsetYEl) shadowOptions.offsetY = parseInt(popoverShadowOffsetYEl.value, 10) || 0;
            if (popoverShadowAffectStrokeEl) shadowOptions.affectStroke = popoverShadowAffectStrokeEl.checked;
            if (popoverShadowNonScalingEl) shadowOptions.nonScaling = popoverShadowNonScalingEl.checked;
        }
        
        // Only set shadow if it has meaningful values (blur > 0 or an offset, or a non-default color)
        // A black shadow with 0 blur and 0 offset is effectively no shadow.
        if (shadowOptions.blur > 0 || shadowOptions.offsetX !== 0 || shadowOptions.offsetY !== 0 || 
            (shadowOptions.color && shadowOptions.color !== '#000000' && shadowOptions.color.toLowerCase() !== 'rgb(0,0,0)' && shadowOptions.color.toLowerCase() !== 'rgba(0,0,0,0)')) {
            activeObject.set('shadow', new fabric.Shadow(shadowOptions));
        } else {
            activeObject.set('shadow', null); // Remove shadow if all parameters are default/zero
        }
        if (shadowSettingsButtonEl) shadowSettingsButtonEl.classList.toggle('active', !!activeObject.shadow);

      } else {
        // Exclude customInteraction and customAnimation as they are handled by their specific functions
        if (!propertyName.startsWith('customInteraction.') && !propertyName.startsWith('customAnimation.')) {
             activeObject.set(propertyName, parsedValue);
             // Sync hidden selects for text properties (these are in fontFamilyPopover)
             if (propertyName === 'fontWeight' && objFontWeightEl) objFontWeightEl.value = parsedValue;
             if (propertyName === 'fontStyle' && objFontStyleEl) objFontStyleEl.value = parsedValue;
             if (propertyName === 'textAlign' && objTextAlignEl) objTextAlignEl.value = parsedValue;
        }
      }

      // For text objects, certain property changes require re-calculating dimensions.
      if ((activeObject.type === 'textbox' || activeObject.type === 'i-text') &&
          ['text', 'fontSize', 'fontWeight', 'fontStyle', 'fontFamily', 'lineHeight', 'charSpacing', 'textAlign'].includes(propertyName)) {
          activeObject.initDimensions(); // Re-calculate bounding box
      }
      activeObject.setCoords(); // Update object's coordinates
      canvas.renderAll();
      // Do NOT call populateToolbar here to avoid potential infinite loops.
      // The primary event handlers (e.g., button clicks) should call populateToolbar if a visual update of the toolbar itself is needed.
    }

    // --- Utilities ---
    var Utilities = { getUuid: function() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); } };

    function extractYouTubeVideoId(url) {
        if (!url) return null;
        let videoId = null;
        try {
            const urlObj = new URL(url);
            if (urlObj.hostname === 'www.youtube.com' || urlObj.hostname === 'youtube.com') {
                videoId = urlObj.searchParams.get('v');
            } else if (urlObj.hostname === 'youtu.be') {
                videoId = urlObj.pathname.substring(1);
            }
        } catch (e) {
            console.error("Error parsing YouTube URL:", e);
            // Fallback for simpler regex if URL parsing fails (e.g. invalid URL)
            const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
            const match = url.match(regex);
            if (match) videoId = match[1];
        }
        return videoId;
    }

    function debounce(func, delay) {
        let timeout;
        return function(...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), delay);
        };
    }

    function handleWindowResize() {
        if (adminApp.state.currentView === 'edit' && adminApp.state.fabricCanvasInstance) {
            console.log("Window resized, attempting to refit canvas.");
            const currentSlide = (adminApp.state.currentSlideIndex !== -1 && adminApp.state.projectData && adminApp.state.projectData.slides) ? 
                                 adminApp.state.projectData.slides[adminApp.state.currentSlideIndex] : 
                                 null;
            adminApp.resizeCanvasToFit(currentSlide);
        }
    }

    adminApp.attachVideoQuestionEventListeners = function() {
        if (videoTimelineSliderEl) {
            videoTimelineSliderEl.addEventListener('input', function() {
                if (adminApp.state.adminYouTubePlayer && typeof adminApp.state.adminYouTubePlayer.seekTo === 'function') {
                    adminApp.state.adminYouTubePlayer.seekTo(this.value, true);
                }
            });
        }

        if (addQuestionBtnEl) {
            addQuestionBtnEl.addEventListener('click', function() {
                if (adminApp.state.adminYouTubePlayer && typeof adminApp.state.adminYouTubePlayer.pauseVideo === 'function') {
                    adminApp.state.adminYouTubePlayer.pauseVideo();
                }
                const currentTime = adminApp.state.adminYouTubePlayer ? adminApp.state.adminYouTubePlayer.getCurrentTime() : 0;
                if (questionTimestampDisplayEl) {
                    questionTimestampDisplayEl.textContent = formatTime(currentTime);
                    // Store raw timestamp for saving, e.g., on a data attribute of the modal or a global variable
                    if(questionModalEl) questionModalEl.dataset.rawTimestamp = currentTime;
                }

                // Clear form fields
                if(questionTextEl) questionTextEl.value = '';
                optionInputsEl.forEach(input => { if(input) input.value = ''; });
                correctAnswerRadiosEl.forEach(radio => { if(radio) radio.checked = false; });
                if(editingQuestionIndexEl) editingQuestionIndexEl.value = '-1';

                if (questionModalEl) questionModalEl.style.display = 'block';
            });
        }

        if (saveQuestionBtnEl) {
            saveQuestionBtnEl.addEventListener('click', function() {
                const currentSlide = getCurrentSlide();
                if (!currentSlide || !currentSlide.slideMedia || currentSlide.slideMedia.type !== 'youtube') {
                    displayMessage("Not a YouTube slide or slide data missing.", false);
                    return;
                }

                const questionText = questionTextEl ? questionTextEl.value.trim() : '';
                if (!questionText) {
                    displayMessage("Question text cannot be empty.", false);
                    return;
                }

                const options = optionInputsEl.map(input => input ? input.value.trim() : '').filter(opt => opt !== '');
                if (options.length < 2) { // Require at least 2 options
                    displayMessage("Please provide at least two options.", false);
                    return;
                }

                let correctOptionIndex = -1;
                for (let i = 0; i < correctAnswerRadiosEl.length; i++) {
                    if (correctAnswerRadiosEl[i] && correctAnswerRadiosEl[i].checked) {
                        correctOptionIndex = i;
                        break;
                    }
                }
                if (correctOptionIndex === -1 || correctOptionIndex >= options.length) { // Ensure correct option is selected and within bounds of provided options
                    displayMessage("Please select a correct answer from the provided options.", false);
                    return;
                }
                
                const timestamp = questionModalEl && questionModalEl.dataset.rawTimestamp ? parseFloat(questionModalEl.dataset.rawTimestamp) : 0;

                const questionData = {
                    timestamp: timestamp,
                    questionText: questionText,
                    options: options,
                    correctOptionIndex: correctOptionIndex
                };

                const editIndex = editingQuestionIndexEl ? parseInt(editingQuestionIndexEl.value, 10) : -1;

                if (!Array.isArray(currentSlide.slideMedia.videoQuestions)) {
                    currentSlide.slideMedia.videoQuestions = [];
                }

                if (editIndex === -1) { // New question
                    currentSlide.slideMedia.videoQuestions.push(questionData);
                } else { // Editing existing question
                    currentSlide.slideMedia.videoQuestions[editIndex] = questionData;
                }
                
                // Sort questions by timestamp
                currentSlide.slideMedia.videoQuestions.sort((a, b) => a.timestamp - b.timestamp);

                console.log("videoQuestions array after save:", currentSlide.slideMedia.videoQuestions); // Added console.log

                displayMessage("Question saved!", true);
                if (questionModalEl) questionModalEl.style.display = 'none';
                renderVideoQuestionsList(); // Re-render the list after saving
            });
        }

        if (cancelQuestionBtnEl) {
            cancelQuestionBtnEl.addEventListener('click', function() {
                if (questionModalEl) questionModalEl.style.display = 'none';
            });
        }
    };

    function updateVideoToolsVisibility(show) {
        if (videoTimelineControlsEl) {
            videoTimelineControlsEl.style.display = show ? 'block' : 'none';
        } else {
            console.warn("updateVideoToolsVisibility: videoTimelineControlsEl not found.");
        }
        if (videoQuestionsListContainerEl) { // Also control the questions list visibility
            videoQuestionsListContainerEl.style.display = show ? 'block' : 'none';
        } else {
            console.warn("updateVideoToolsVisibility: videoQuestionsListContainerEl not found.");
        }
        if (videoQuestionsListContainerEl) { // Also control the questions list visibility
            videoQuestionsListContainerEl.style.display = show ? 'block' : 'none';
        } else {
            console.warn("updateVideoToolsVisibility: videoQuestionsListContainerEl not found.");
        }
        // The addQuestionBtnEl is inside videoTimelineControlsEl, so it's shown/hidden with its parent.
    }

    function renderVideoQuestionsList() {
        if (!videoQuestionsListEl) {
            console.warn("renderVideoQuestionsList: videoQuestionsListEl not found.");
            return;
        }
        videoQuestionsListEl.innerHTML = ''; // Clear existing items

        const currentSlide = getCurrentSlide();
        if (!currentSlide || !currentSlide.slideMedia || currentSlide.slideMedia.type !== 'youtube' || !currentSlide.slideMedia.videoQuestions || currentSlide.slideMedia.videoQuestions.length === 0) {
            const li = document.createElement('li');
            li.textContent = "No questions added yet.";
            li.style.fontStyle = "italic";
            videoQuestionsListEl.appendChild(li);
            return;
        }

        const questions = currentSlide.slideMedia.videoQuestions;

        console.log("Rendering questions list:", questions); // Added console.log

        questions.forEach((question, index) => {
            const li = document.createElement('li');
            li.style.marginBottom = "8px";
            li.style.padding = "5px";
            li.style.border = "1px solid #eee"; // Light border for each item
            li.style.borderRadius = "3px";
            li.style.display = "flex"; // Use flexbox for alignment
            li.style.justifyContent = "space-between"; // Space out text and buttons
            li.style.alignItems = "center"; // Align items vertically

            const questionTextSpan = document.createElement('span'); 
            questionTextSpan.textContent = `[${formatTime(question.timestamp)}] ${question.questionText.substring(0, 40)}${question.questionText.length > 40 ? '...' : ''}`;
            questionTextSpan.style.flexGrow = "1"; // Allow text to take available space
            
            const actionsDiv = document.createElement('div');
            actionsDiv.style.whiteSpace = "nowrap"; // Prevent buttons from wrapping

            const editBtn = document.createElement('button');
            editBtn.textContent = 'Edit';
            editBtn.style.marginLeft = '5px'; 
            editBtn.style.padding = '3px 8px';
            editBtn.style.fontSize = '0.8em';
            editBtn.className = 'edit-button'; 
            editBtn.onclick = function() {
                console.log("Editing question index:", index, questions[index]); // Added console.log

                if (adminApp.state.adminYouTubePlayer && typeof adminApp.state.adminYouTubePlayer.pauseVideo === 'function') {
                    adminApp.state.adminYouTubePlayer.pauseVideo();
                }
                
                if(questionTimestampDisplayEl) questionTimestampDisplayEl.textContent = formatTime(question.timestamp);
                if(questionModalEl) questionModalEl.dataset.rawTimestamp = question.timestamp;
                if(questionTextEl) questionTextEl.value = question.questionText;

                optionInputsEl.forEach((input, i) => {
                    if(input) input.value = question.options[i] || '';
                });
                // Ensure correct number of radio buttons are checked based on available options for the question
                correctAnswerRadiosEl.forEach((radio, i) => {
                    if(radio) radio.checked = (i === question.correctOptionIndex && i < question.options.length);
                });
                
                if(editingQuestionIndexEl) editingQuestionIndexEl.value = index;
                if(questionModalEl) questionModalEl.style.display = 'block';
            };

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'Delete';
            deleteBtn.className = 'danger-button'; 
            deleteBtn.style.marginLeft = '5px';
            deleteBtn.style.padding = '3px 8px'; 
            deleteBtn.style.fontSize = '0.8em';
            deleteBtn.onclick = function() {
                if (confirm(`Are you sure you want to delete the question: "${question.questionText.substring(0,30)}..."?`)) {
                    console.log("Deleting question index:", index); // Added console.log

                    currentSlide.slideMedia.videoQuestions.splice(index, 1);
                    renderVideoQuestionsList(); 
                    displayMessage("Question deleted.", true);
                }
            };
            
            actionsDiv.appendChild(editBtn);
            actionsDiv.appendChild(deleteBtn);
            
            li.appendChild(questionTextSpan);
            li.appendChild(actionsDiv);

            videoQuestionsListEl.appendChild(li);
        });
    }

    function formatTime(totalSeconds) {
        totalSeconds = Math.floor(totalSeconds);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    }
</script>