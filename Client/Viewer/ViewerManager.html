<script>
// Ensure ViewerManager is properly initialized
console.log("ViewerManager: Script starting to load...");

// Define ViewerManager immediately on window
window.viewerManager = {
  state: {
    isLoading: false,
    currentProjectData: null,
    currentSlideIndex: 0,
    currentMediaType: null, // 'youtube', 'audio', 'image', 'none'
    viewerFabricCanvas: null,
    askedQuestionIndices: [],
    activeOverlays: new Map(),
    currentImageTimelineEvents: [],
    currentImageSlideEventIndex: -1,
    defaultCanvasWidth: 960,
    defaultCanvasHeight: 540,
    isCanvasPannedOrZoomed: false
  },
  dom: {},

  init: function() {
    console.log("ViewerManager: init() called.");
    this.setupDOMReferences();
    this.attachEventListeners();
    this.setupMediaManagerCallbacks(); // New call
    this.loadViewerProjectsList();
  },

  setupDOMReferences: function() {
    console.log("ViewerManager: Setting up DOM references...");
    
    // Map element IDs to property names for easier debugging
    const elementMap = {
      'viewerProjectListContainer': 'viewerProjectListContainerEl',
      'messageAreaViewer': 'messageAreaElViewer',
      'loadingSpinner': 'loadingSpinnerElViewer',
      'viewerListViewContainer': 'viewerListViewContainerEl',
      'viewerProjectDisplayArea': 'viewerProjectDisplayAreaEl',
      'viewingProjectTitle': 'viewingProjectTitleEl',
      'viewerMediaContainer': 'viewerMediaContainerEl',
      'youtubePlayerContainer': 'youtubePlayerContainerEl',
      'viewerAudioPlayer': 'viewerAudioPlayerEl',
      'viewerCanvasContainer': 'viewerCanvasContainerEl',
      'viewerFabricCanvas': 'viewerFabricCanvasEl',
      'viewerPrevSlideButton': 'viewerPrevSlideButtonEl',
      'viewerNextSlideButton': 'viewerNextSlideButtonEl',
      'viewerSlideIndicator': 'viewerSlideIndicatorEl',
      'backToViewerListButton': 'backToViewerListButtonEl',
      'viewerModal': 'viewerModalEl',
      'viewerModalCloseButton': 'viewerModalCloseButtonEl',
      'viewerModalBody': 'viewerModalBodyEl',
      'modalPrevButton': 'modalPrevButtonEl',
      'modalNextButton': 'modalNextButtonEl',
      'viewerTimelineTrack': 'viewerTimelineTrackEl',
      'viewerTimelineProgress': 'viewerTimelineProgressEl',
      'viewerCurrentTime': 'viewerCurrentTimeEl',
      'viewerTotalDuration': 'viewerTotalDurationEl',
      'viewerPrevImageEventButton': 'viewerPrevImageEventButtonEl',
      'viewerImageEventIndicator': 'viewerImageEventIndicatorEl',
      'viewerNextImageEventButton': 'viewerNextImageEventButtonEl',
      'interactiveTimelineBar': 'interactiveTimelineBarEl',
      'overlayDisplayArea': 'overlayDisplayAreaEl',
      'imageEventNavigation': 'imageEventNavigationEl'
    };
    
    let missingElements = [];
    
    // Get all DOM references and track missing ones
    for (const [elementId, propertyName] of Object.entries(elementMap)) {
      const element = document.getElementById(elementId);
      this.dom[propertyName] = element;
      
      if (!element) {
        missingElements.push(elementId);
        console.warn(`ViewerManager: Element '${elementId}' not found in DOM`);
      } else {
        console.log(`ViewerManager: âœ“ Found element '${elementId}'`);
      }
    }
    
    if (missingElements.length > 0) {
      console.warn("ViewerManager: Missing DOM elements:", missingElements);
      console.warn("ViewerManager: Some functionality may not work properly");
    }
    
    console.log("ViewerManager: DOM references setup completed.");
  },

  attachEventListeners: function() {
    // ... (same as previous step)
    const dom = this.dom;
    if (dom.backToViewerListButtonEl) dom.backToViewerListButtonEl.addEventListener('click', this.showProjectListView.bind(this));
    if (dom.viewerPrevSlideButtonEl) dom.viewerPrevSlideButtonEl.addEventListener('click', this.navigateToPrevSlide.bind(this));
    if (dom.viewerNextSlideButtonEl) dom.viewerNextSlideButtonEl.addEventListener('click', this.navigateToNextSlide.bind(this));
    if (dom.viewerModalCloseButtonEl) dom.viewerModalCloseButtonEl.addEventListener('click', this.hideViewerModal.bind(this));
    if (dom.viewerModalEl) {
        dom.viewerModalEl.addEventListener('click', (event) => {
            if (event.target === dom.viewerModalEl) this.hideViewerModal();
        });
    }
    if (dom.modalPrevButtonEl) dom.modalPrevButtonEl.addEventListener('click', this.navigateModalPrevious.bind(this));
    if (dom.modalNextButtonEl) dom.modalNextButtonEl.addEventListener('click', this.navigateModalNext.bind(this));
    if (dom.viewerTimelineTrackEl) {
        dom.viewerTimelineTrackEl.addEventListener('click', (e) => {
            const mediaType = this.state.currentMediaType;
            let duration = 0;
            if (mediaType === 'youtube') duration = mediaManager.getDuration();
            else if (mediaType === 'audio') duration = mediaManager.getAudioDuration();

            if (duration > 0) {
                const rect = dom.viewerTimelineTrackEl.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const percentage = clickX / rect.width;
                const seekTime = percentage * duration;
                if (mediaType === 'youtube') {
                    mediaManager.seekTo(seekTime);
                    if (mediaManager.getPlayerState() !== YT.PlayerState.PLAYING) mediaManager.playVideo();
                } else if (mediaType === 'audio') {
                    mediaManager.seekAudioTo(seekTime);
                    if (!mediaManager.state.audioPlayer || mediaManager.state.audioPlayer.paused) mediaManager.playAudio();
                }
            }
        });
    }
    console.log("ViewerManager: Event listeners attached.");
  },

  setupMediaManagerCallbacks: function() {
    console.log("ViewerManager: Setting up MediaManager callbacks...");
    
    if (!window.mediaManager) {
      console.error("ViewerManager: MediaManager not available - cannot setup callbacks");
      return;
    }
    
    if (!mediaManager.state || !mediaManager.state.callbacks) {
      console.error("ViewerManager: MediaManager state or callbacks not initialized");
      return;
    }
    
    try {
      mediaManager.state.callbacks.onReady = this.handleMediaPlayerReady.bind(this);
      mediaManager.state.callbacks.onStateChange = this.handleMediaPlayerStateChange.bind(this);
      mediaManager.state.callbacks.onError = this.handleMediaPlayerError.bind(this);
      mediaManager.state.callbacks.onTimeUpdate = this.handleMediaTimeUpdate.bind(this);
      mediaManager.state.callbacks.onQuestionTrigger = this.handleMediaQuestionTrigger.bind(this);
      mediaManager.state.callbacks.onOverlayUpdateNeeded = this.handleMediaOverlayUpdate.bind(this);
      mediaManager.state.callbacks.onEnded = this.handleMediaEnded.bind(this);
      console.log("ViewerManager: MediaManager callbacks configured successfully.");
    } catch (error) {
      console.error("ViewerManager: Error setting up MediaManager callbacks:", error);
    }
  },

  loadViewerProjectsList: function() { /* ... (same as previous step) ... */
    console.log("ViewerManager: loadViewerProjectsList called");
    if (!google || !google.script || !google.script.run) {
      baseApp.displayMessage("Error: Client-server communication bridge unavailable.", false, 'messageAreaViewer');
      return;
    }
    if (!this.dom.viewerProjectListContainerEl) {
      console.warn("ViewerManager: viewerProjectListContainerEl not found. Cannot display projects.");
      return;
    }
    baseApp.showLoading(true, 'loadingSpinner');
    this.state.isLoading = true;
    google.script.run
      .withSuccessHandler(this.displayViewerProjects.bind(this))
      .withFailureHandler((error) => baseApp.onServerError(error, 'messageAreaViewer'))
      .getActiveProjectsList();
  },

displayViewerProjects: function(response) {
  baseApp.showLoading(false, 'loadingSpinner');
  this.state.isLoading = false;

  if (!response || !response.success) return;

  const projectsArray = response.data && response.data.projects ? response.data.projects : [];

  if (!this.dom.viewerProjectListContainerEl) {
    console.error("ViewerManager: displayViewerProjects - viewerProjectListContainerEl is not found!");
    return;
  }

  this.dom.viewerProjectListContainerEl.innerHTML = '';

  if (!projectsArray || projectsArray.length === 0) {
    this.dom.viewerProjectListContainerEl.innerHTML = '<p>No active training modules found at this time.</p>';
    return;
  }

  const ul = sharedUtils.createElement('ul', { className: 'project-list-viewer' });

  projectsArray.forEach(project => {
    if (!project || !project.projectId) {
      console.warn("ViewerManager: Skipping display of invalid project object:", project);
      return;
    }

    const projectCard = sharedUtils.createProjectCard(project, {
      onView: (projectId) => this.loadProjectForViewing(projectId)
    }, false);

    const listItem = sharedUtils.createElement('li');
    listItem.appendChild(projectCard.element);
    ul.appendChild(listItem);
  });

  this.dom.viewerProjectListContainerEl.appendChild(ul);
},

  showProjectListView: function() { /* ... (same as previous step, ensure mediaManager calls are correct) ... */
    console.log("ViewerManager: showProjectListView called");
    sharedUtils.showElement(this.dom.viewerListViewContainerEl);
    sharedUtils.hideElement(this.dom.viewerProjectDisplayAreaEl);

    if (this.state.currentMediaType === 'youtube' && mediaManager.isYouTubePlayerAvailable()) {
        mediaManager.stopAndDestroyPlayer();
    } else if (this.state.currentMediaType === 'audio' && mediaManager.isAudioPlayerAvailable()) {
        mediaManager.stopAndClearAudioPlayer();
    }
    this.state.currentMediaType = null;

    if (this.state.viewerFabricCanvas) {
        this.state.viewerFabricCanvas.dispose();
        this.state.viewerFabricCanvas = null;
    }
    this.state.currentProjectData = null;
    this.state.currentSlideIndex = 0;
    this.loadViewerProjectsList();
  },

  // --- Project Viewing and Slide Rendering ---
  loadProjectForViewing: function(projectId) {
    if (!projectId) {
      baseApp.displayMessage("Invalid project ID.", false, 'messageAreaViewer');
      return;
    }
    console.log(`ViewerManager: Loading project ID: ${projectId}`);
    baseApp.showLoading(true, 'loadingSpinner');
    this.state.isLoading = true;
    google.script.run
      .withSuccessHandler(this.onProjectViewDataReceived.bind(this))
      .withFailureHandler(error => baseApp.onServerError(error, 'messageAreaViewer'))
      .getProjectViewById(projectId);
  },

  onProjectViewDataReceived: function(response) {
    baseApp.showLoading(false, 'loadingSpinner');
    this.state.isLoading = false;
    if (!response || !response.success || !response.data || !response.data.projectDataJSON) {
      baseApp.onServerError(response || { error: "Failed to load project data." }, 'messageAreaViewer');
      this.state.currentProjectData = null;
      return;
    }
    try {
      const projectData = JSON.parse(response.data.projectDataJSON);
      if (!projectData.slides || projectData.slides.length === 0) {
        baseApp.displayMessage("This project has no slides.", true, 'messageAreaViewer'); // true for info, not error
        this.state.currentProjectData = null;
        this.showProjectListView(); // Go back to list if project is empty
        return;
      }
      this.state.currentProjectData = projectData;
      this.state.currentSlideIndex = 0;
      if (this.dom.viewingProjectTitleEl) this.dom.viewingProjectTitleEl.textContent = projectData.title || 'Untitled Project';

      if (!this.state.viewerFabricCanvas && this.dom.viewerFabricCanvasEl) {
        this.initializeViewerCanvas();
      }

      this.renderSlideForViewing(0);
      this.showProjectView();
    } catch (e) {
      console.error("Error parsing project data:", e);
      baseApp.onServerError({ message: "Error processing project data: " + e.message }, 'messageAreaViewer');
      this.state.currentProjectData = null;
    }
  },

  showProjectView: function() {
    console.log("ViewerManager: showProjectView called");
    sharedUtils.hideElement(this.dom.viewerListViewContainerEl);
    sharedUtils.showElement(this.dom.viewerProjectDisplayAreaEl);
  },

  getCurrentSlide: function() {
    if (this.state.currentProjectData && this.state.currentProjectData.slides &&
        this.state.currentProjectData.slides.length > this.state.currentSlideIndex) {
      return this.state.currentProjectData.slides[this.state.currentSlideIndex];
    }
    return null;
  },

  initializeViewerCanvas: function() {
    if (!this.dom.viewerFabricCanvasEl) {
      console.error("ViewerManager: viewerFabricCanvasEl not found. Cannot initialize Fabric.js canvas.");
      return;
    }
    if (this.state.viewerFabricCanvas) { // Dispose existing if any
        this.state.viewerFabricCanvas.dispose();
    }
    this.state.viewerFabricCanvas = new fabric.Canvas(this.dom.viewerFabricCanvasEl, {
        // Default options
        width: this.state.defaultCanvasWidth,
        height: this.state.defaultCanvasHeight,
        preserveObjectStacking: true,
        renderOnAddRemove: false // Manual renderAll for performance
    });
    
    // Add interaction event handlers for interactive objects
    this.state.viewerFabricCanvas.on('mouse:down', (e) => {
      if (e.target) {
        // Handle interactions
        if (e.target.customInteraction) {
          const interaction = e.target.customInteraction;
          if (interaction.trigger === 'click' || interaction.trigger === 'onClick') {
            this.handleObjectInteraction(e.target, interaction);
          } else if (interaction.trigger === 'clickAndHold') {
            this.startClickAndHold(e.target, interaction);
          }
        }
        
        // Handle onClick animations
        if (e.target.customAnimation && e.target.customAnimation.trigger === 'onClick') {
          this.startAnimation(e.target, e.target.customAnimation);
        }
      }
    });
    
    this.state.viewerFabricCanvas.on('mouse:up', (e) => {
      this.clearClickAndHold();
    });
    
    this.state.viewerFabricCanvas.on('mouse:over', (e) => {
      if (e.target) {
        // Handle hover interactions
        if (e.target.customInteraction && e.target.customInteraction.trigger === 'hover') {
          this.handleObjectInteraction(e.target, e.target.customInteraction);
        }
        // Handle hover animations
        if (e.target.customAnimation && e.target.customAnimation.trigger === 'Hover') {
          this.startAnimation(e.target, e.target.customAnimation);
        }
      }
    });
    
    console.log("ViewerManager: Fabric.js canvas initialized with interaction handlers.");
  },

  renderSlideForViewing: function(slideIndex) {
    console.log(`ViewerManager: renderSlideForViewing - slideIndex: ${slideIndex}`);
    if (!this.state.currentProjectData || !this.state.viewerFabricCanvas) {
        console.error("ViewerManager: Project data or Fabric canvas not available for rendering slide.");
        return;
    }
    const slides = this.state.currentProjectData.slides;
    if (slideIndex < 0 || slideIndex >= slides.length) {
        console.warn(`ViewerManager: Invalid slideIndex ${slideIndex}. Max is ${slides.length -1}`);
        return;
    }

    // Stop any currently playing media from previous slide
    if (this.state.currentMediaType === 'youtube' && mediaManager.isYouTubePlayerAvailable()) mediaManager.stopAndDestroyPlayer();
    else if (this.state.currentMediaType === 'audio' && mediaManager.isAudioPlayerAvailable()) mediaManager.stopAndClearAudioPlayer();

    // Clean up any active spotlight effects
    const spotlightOverlay = document.getElementById('spotlight-overlay');
    if (spotlightOverlay) spotlightOverlay.remove();
    
    // Reset pan/zoom if active
    if(this.state.isCanvasPannedOrZoomed) this.resetPanZoom();

    const slideData = slides[slideIndex];
    const canvas = this.state.viewerFabricCanvas;
    this.state.currentSlideIndex = slideIndex;
    this.state.currentMediaType = (slideData.slideMedia && slideData.slideMedia.type) ? slideData.slideMedia.type : 'none';
    this.state.askedQuestionIndices = []; // Reset for new slide
    this.state.currentImageTimelineEvents = (slideData.timelineEvents && Array.isArray(slideData.timelineEvents)) ? slideData.timelineEvents : [];
    this.state.currentImageSlideEventIndex = 0; // Reset for new slide

    sharedUtils.safeDOMUpdate(this.dom.interactiveTimelineBarEl, el => el.style.display = (this.state.currentMediaType === 'youtube' || this.state.currentMediaType === 'audio') ? 'block' : 'none');

    this.initializeVideoOverlays(); // Placeholder - clears/prepares overlay area

    // Clear any old canvas timestamp overlays if they exist
    if (canvas) {
        canvas.getObjects().forEach(obj => {
            if (obj.customType === 'videoTimestampOverlay' || obj.isTimestampOverlay) canvas.remove(obj);
        });
    }
    // Ensure slideMedia exists with a type
    if (!slideData.slideMedia) slideData.slideMedia = { type: 'none' };


    const slideWidth = slideData.canvasWidth || this.state.defaultCanvasWidth;
    const slideHeight = slideData.canvasHeight || this.state.defaultCanvasHeight;
    canvas.setWidth(slideWidth);
    canvas.setHeight(slideHeight);
    if (this.dom.viewerFabricCanvasEl) { this.dom.viewerFabricCanvasEl.width = slideWidth; this.dom.viewerFabricCanvasEl.height = slideHeight; }
    if (this.dom.viewerMediaContainerEl) { this.dom.viewerMediaContainerEl.style.width = slideWidth + 'px'; this.dom.viewerMediaContainerEl.style.height = slideHeight + 'px'; }

    canvas.clear(); // Clears objects and background
    canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas));
    canvas.backgroundColor = 'transparent'; // Default, slideData might override

    const media = slideData.slideMedia;
    sharedUtils.hideElement(this.dom.youtubePlayerContainerEl);
    sharedUtils.hideElement(this.dom.viewerAudioPlayerEl); // Hide actual audio controls, use custom
    sharedUtils.showElement(this.dom.viewerCanvasContainerEl); // Canvas is always visible (might be transparent)

    console.log(`ViewerManager: Rendering slide ${slideIndex + 1}, media type: ${this.state.currentMediaType}`);

    switch(this.state.currentMediaType) {
        case 'image':
            sharedUtils.safeDOMUpdate(this.dom.viewerMediaContainerEl, el => el.style.backgroundColor = slideData.backgroundColor || '#FFFFFF');
            sharedUtils.safeDOMUpdate(this.dom.viewerFabricCanvasEl, el => el.style.opacity = '1'); // Ensure canvas is visible
            sharedUtils.safeDOMUpdate(this.dom.viewerCanvasContainerEl, el => el.style.pointerEvents = 'auto'); // Allow canvas interaction
            if (media && media.driveFileId) {
                baseApp.showLoading(true, 'loadingSpinner');
                this.state.isLoading = true;
                google.script.run
                    .withSuccessHandler((imageResponse) => {
                        baseApp.showLoading(false, 'loadingSpinner');
                        this.state.isLoading = false;
                        if (this.state.currentSlideIndex !== slideIndex) return; // Slide changed
                        if (imageResponse && imageResponse.success && imageResponse.base64Data) {
                            fabric.Image.fromURL(imageResponse.base64Data, (img) => {
                                if (!this.state.viewerFabricCanvas) return;
                                this.state.viewerFabricCanvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                                    scaleX: canvas.width / img.width,
                                    scaleY: canvas.height / img.height
                                });
                            });
                        } else { baseApp.onServerError(imageResponse || {error:"Failed to load image"}, 'messageAreaViewer');}
                        if (slideData.fabricCanvasJSON) {
                          canvas.loadFromJSON(slideData.fabricCanvasJSON, () => {
                            this.restoreObjectInteractions(canvas, slideData.fabricCanvasJSON);
                            canvas.renderAll();
                            this.updateViewerCanvasInteractivity();
                          });
                        } else {
                          canvas.renderAll();
                          this.updateViewerCanvasInteractivity();
                        }
                    })
                    .withFailureHandler(error => {baseApp.onServerError(error, 'messageAreaViewer'); canvas.renderAll(); this.state.isLoading = false;})
                    .getImageAsBase64(media.driveFileId);
            } else {
                if (slideData.fabricCanvasJSON) {
                  canvas.loadFromJSON(slideData.fabricCanvasJSON, () => {
                    this.restoreObjectInteractions(canvas, slideData.fabricCanvasJSON);
                    canvas.renderAll();
                    this.updateViewerCanvasInteractivity();
                  });
                } else {
                  canvas.renderAll();
                  this.updateViewerCanvasInteractivity();
                }
            }
            break;
        case 'youtube':
            sharedUtils.safeDOMUpdate(this.dom.viewerMediaContainerEl, el => el.style.backgroundColor = 'transparent');
            canvas.backgroundColor = 'rgba(0,0,0,0)'; // Make Fabric canvas transparent for YT background
            const videoId = sharedUtils.extractYouTubeVideoId(media.url);
            if (videoId && this.dom.youtubePlayerContainerEl) {
                sharedUtils.safeDOMUpdate(this.dom.youtubePlayerContainerEl, el => {
                    el.innerHTML = '<div id="viewerYouTubePlayerDiv" style="width: 100%; height: 100%;"></div>'; // Target for YT player
                    el.style.display = 'block';
                });
                const playerVars = { /* ... common player vars from old Viewer_JS ... */
                    'autoplay': 0, 'controls': 0, 'rel': 0, 'showinfo': 0,
                    'modestbranding': 1, 'iv_load_policy': 3, 'fs': 0, 'disablekb': 1, 'playsinline': 1,
                    'cc_load_policy': 0
                };
                mediaManager.setupPlayer(videoId, 'viewerYouTubePlayerDiv', playerVars); // MediaManager handles API readiness
            } else {
                baseApp.displayMessage("Invalid YouTube URL for this slide.", false, 'messageAreaViewer');
            }
            if (slideData.fabricCanvasJSON) {
              canvas.loadFromJSON(slideData.fabricCanvasJSON, () => {
                this.restoreObjectInteractions(canvas, slideData.fabricCanvasJSON);
                canvas.renderAll();
                this.updateViewerCanvasInteractivity();
              });
            } else {
              canvas.renderAll();
              this.updateViewerCanvasInteractivity();
            }
            break;
        case 'audio':
            sharedUtils.safeDOMUpdate(this.dom.viewerMediaContainerEl, el => el.style.backgroundColor = slideData.backgroundColor || '#EEEEEE');
            // Audio element is this.dom.viewerAudioPlayerEl, but controls are via timeline
            sharedUtils.showElement(this.dom.interactiveTimelineBarEl);

            if (media && media.driveFileId) {
                baseApp.showLoading(true, 'loadingSpinner');
                this.state.isLoading = true;
                google.script.run
                    .withSuccessHandler((audioResponse) => {
                        baseApp.showLoading(false, 'loadingSpinner');
                        this.state.isLoading = false;
                        if (this.state.currentSlideIndex !== slideIndex) return; // Slide changed
                        if (audioResponse && audioResponse.success && audioResponse.base64Data) {
                             // viewerAudioPlayerEl is the <audio> tag ID
                            mediaManager.setupAudio(audioResponse.base64Data, 'viewerAudioPlayer', {});
                        } else {
                           baseApp.onServerError(audioResponse || {error: "Failed to load audio data."}, 'messageAreaViewer');
                        }
                        if (slideData.fabricCanvasJSON) {
              canvas.loadFromJSON(slideData.fabricCanvasJSON, () => {
                this.restoreObjectInteractions(canvas, slideData.fabricCanvasJSON);
                canvas.renderAll();
                this.updateViewerCanvasInteractivity();
              });
            } else {
              canvas.renderAll();
              this.updateViewerCanvasInteractivity();
            }
                    })
                    .withFailureHandler(error => {
                        baseApp.onServerError(error, 'messageAreaViewer');
                        this.state.isLoading = false;
                        if (slideData.fabricCanvasJSON) {
              canvas.loadFromJSON(slideData.fabricCanvasJSON, () => {
                this.restoreObjectInteractions(canvas, slideData.fabricCanvasJSON);
                canvas.renderAll();
                this.updateViewerCanvasInteractivity();
              });
            } else {
              canvas.renderAll();
              this.updateViewerCanvasInteractivity();
            }
                    })
                    .getAudioAsBase64(media.driveFileId);
            } else {
                baseApp.displayMessage("Audio source missing for this slide.", false, 'messageAreaViewer');
                if (slideData.fabricCanvasJSON) {
              canvas.loadFromJSON(slideData.fabricCanvasJSON, () => {
                this.restoreObjectInteractions(canvas, slideData.fabricCanvasJSON);
                canvas.renderAll();
                this.updateViewerCanvasInteractivity();
              });
            } else {
              canvas.renderAll();
              this.updateViewerCanvasInteractivity();
            }
            }
            break;
        default: // 'none' or unknown
            sharedUtils.safeDOMUpdate(this.dom.viewerMediaContainerEl, el => el.style.backgroundColor = slideData.backgroundColor || '#FFFFFF');
            if (slideData.fabricCanvasJSON) {
              canvas.loadFromJSON(slideData.fabricCanvasJSON, () => {
                this.restoreObjectInteractions(canvas, slideData.fabricCanvasJSON);
                canvas.renderAll();
                this.updateViewerCanvasInteractivity();
              });
            } else {
              canvas.renderAll();
              this.updateViewerCanvasInteractivity();
            }
            break;
    }
    this.updateViewerCanvasInteractivity(); // Placeholder
    this.updateSlideNavigationUI(); // Placeholder
  },

  // --- MediaManager Callbacks ---
  handleMediaPlayerReady: function(mediaTypeInfo) {
    console.log(`ViewerManager: Media Player Ready. Type: ${mediaTypeInfo.type}`);
    baseApp.showLoading(false, 'loadingSpinner'); // Hide general loading spinner if one was shown for media loading
    sharedUtils.showElement(this.dom.interactiveTimelineBarEl);
    this.renderTimelineMarkers(); // Now part of viewerManager

    const currentSlide = this.getCurrentSlide();
    if (!currentSlide || !currentSlide.slideMedia) return;

    // Auto-play or click-to-begin logic (simplified from Viewer_JS)
    let startBehavior = 'clickToBegin'; // Default
    if (mediaTypeInfo.type === 'youtube' && currentSlide.slideMedia.youtubeOptions) {
        startBehavior = currentSlide.slideMedia.youtubeOptions.startBehavior || startBehavior;
    } else if (mediaTypeInfo.type === 'audio' && currentSlide.slideMedia.audioOptions) {
        startBehavior = currentSlide.slideMedia.audioOptions.startBehavior || startBehavior;
    }
    // Assuming a clickToBeginButton exists or this logic is handled differently (e.g. play on timeline click)
    // const clickToBeginButton = document.getElementById('viewerClickToBeginButton');
    // if (clickToBeginButton) sharedUtils.hideElement(clickToBeginButton); // Hide by default

    if (startBehavior === 'autoPlay') {
        if (mediaTypeInfo.type === 'youtube') mediaManager.playVideo();
        else if (mediaTypeInfo.type === 'audio') mediaManager.playAudio();
    } // else if (startBehavior === 'clickToBegin' && clickToBeginButton) sharedUtils.showElement(clickToBeginButton);

    this.updateViewerCanvasInteractivity();
  },
  handleMediaPlayerStateChange: function(eventData) {
    console.log(`ViewerManager: Media Player State Change. Type: ${eventData.type}, Data: ${eventData.data}`);
    this.updateViewerCanvasInteractivity();
  },
  handleMediaPlayerError: function(errorData) {
    console.error(`ViewerManager: Media Player Error. Type: ${errorData.type}`, errorData);
    baseApp.displayMessage(`${errorData.type.toUpperCase()} Player Error: ${errorData.data || (errorData.error ? errorData.error.message : 'Unknown error')}`, false, 'messageAreaViewer');
    this.updateViewerCanvasInteractivity();
  },
  handleMediaTimeUpdate: function(currentTime, duration, mediaType) {
    if (this.dom.viewerCurrentTimeEl) this.dom.viewerCurrentTimeEl.textContent = sharedUtils.formatTime(currentTime);
    if (this.dom.viewerTotalDurationEl) this.dom.viewerTotalDurationEl.textContent = sharedUtils.formatTime(duration);
    if (this.dom.viewerTimelineProgressEl && duration > 0) {
        this.dom.viewerTimelineProgressEl.style.width = (currentTime / duration) * 100 + '%';
    }
    // Call question and overlay handlers if they exist
    if (typeof this.handleMediaQuestionTrigger === 'function') this.handleMediaQuestionTrigger(currentTime);
    if (typeof this.handleMediaOverlayUpdate === 'function') this.handleMediaOverlayUpdate(currentTime, mediaType);
  },
  handleMediaQuestionTrigger: function(currentTime) {
  const currentSlide = this.getCurrentSlide();
  if (!currentSlide || !currentSlide.slideMedia || currentSlide.slideMedia.type !== 'youtube' ||
      !currentSlide.slideMedia.videoQuestions || currentSlide.slideMedia.videoQuestions.length === 0) {
    return;
  }
  for (let i = 0; i < currentSlide.slideMedia.videoQuestions.length; i++) {
    const question = currentSlide.slideMedia.videoQuestions[i];
    if (!this.state.askedQuestionIndices.includes(i) &&
        currentTime >= question.timestamp && currentTime < question.timestamp + 1.5) { // 1.5s window
      if (mediaManager.isYouTubePlayerAvailable()) mediaManager.pauseVideo();
      this.state.askedQuestionIndices.push(i);
      this.displayQuestion(question);
      break;
    }
  }
},

displayQuestion: function(question) {
  console.log("ViewerManager: Displaying Question:", question);
  const questionHtml = `
      <h4>Question at ${sharedUtils.formatTime(question.timestamp)}</h4>
      <p>${question.questionText}</p>
      ${question.options ? question.options.map((opt, idx) => `<button class="question-option-btn" data-idx="${idx}">${opt.text}</button><br>`).join('') : ''}
      <button onclick="viewerManager.closeQuestionModal()" class="modal-close-btn">Close</button>
  `;
  this.showViewerModal(questionHtml);
  // Future: Add event listeners for dynamically created question option buttons.
},

closeQuestionModal: function() {
  this.hideViewerModal();
  if (this.state.currentMediaType === 'youtube' && mediaManager.isYouTubePlayerAvailable()) {
       mediaManager.playVideo();
  }
},

handleMediaOverlayUpdate: function(currentTime, mediaType) {
  // This is the callback from MediaManager.
  console.log(`ViewerManager: handleMediaOverlayUpdate called - time: ${currentTime}, mediaType: ${mediaType}`);
  this.updateVideoOverlays(currentTime); // Call to placeholder
},

handleMediaEnded: function(mediaTypeInfo) {
    console.log(`ViewerManager: ${mediaTypeInfo.type} media ended.`);
    if (mediaTypeInfo.type === 'youtube') {
        this.state.askedQuestionIndices = []; // Reset for replay
    }
    // Potentially auto-advance or show end message
  },

  // --- Placeholder/Utility functions to be fully implemented later ---
  renderTimelineMarkers: function() {
  if (!this.dom.viewerTimelineTrackEl || !this.state.currentProjectData) {
    console.warn("ViewerManager: Timeline track or project data not ready for markers.");
    if(this.dom.viewerTimelineTrackEl) this.dom.viewerTimelineTrackEl.innerHTML = ''; // Clear if no data
    return;
  }
  const currentSlide = this.getCurrentSlide();
  if (!currentSlide || !currentSlide.slideMedia) {
    this.dom.viewerTimelineTrackEl.innerHTML = ''; // Clear if no slide media
    return;
  }
  const questions = (currentSlide.slideMedia.type === 'youtube' && Array.isArray(currentSlide.slideMedia.videoQuestions))
                     ? currentSlide.slideMedia.videoQuestions : [];
  const overlays = (Array.isArray(currentSlide.slideMedia.videoOverlays))
                     ? currentSlide.slideMedia.videoOverlays : [];
  mediaManager.renderTimelineMarkers('viewerTimelineTrack', questions, overlays);
  console.log("ViewerManager: Timeline markers rendered via MediaManager.");
},

updateSlideNavigationUI: function() {
  if (!this.dom.viewerPrevSlideButtonEl || !this.dom.viewerNextSlideButtonEl || !this.dom.viewerSlideIndicatorEl) {
    console.warn("ViewerManager: Slide navigation UI elements not found.");
    return;
  }

  const currentSlideIndex = this.state.currentSlideIndex;
  const totalSlides = this.state.currentProjectData ? this.state.currentProjectData.slides.length : 0;

  this.dom.viewerPrevSlideButtonEl.disabled = (currentSlideIndex <= 0);
  this.dom.viewerNextSlideButtonEl.disabled = (currentSlideIndex >= totalSlides - 1);
  this.dom.viewerSlideIndicatorEl.textContent = `Slide ${totalSlides > 0 ? currentSlideIndex + 1 : 0} / ${totalSlides}`;

  // Image Event Navigation (basic placeholder logic, can be expanded)
  const currentSlide = this.getCurrentSlide();
  const hasImageEvents = currentSlide && currentSlide.slideMedia && currentSlide.slideMedia.type === 'image' && this.state.currentImageTimelineEvents && this.state.currentImageTimelineEvents.length > 0;

  sharedUtils.safeDOMUpdate(this.dom.imageEventNavigationEl, el => el.style.display = hasImageEvents ? 'block' : 'none');
  if (hasImageEvents) {
      // Placeholder for updating image event specific buttons and indicator
      // this.updateImageTimelineNavUI(); // This function would need to be moved/created
      sharedUtils.safeDOMUpdate(this.dom.viewerImageEventIndicatorEl, el => el.textContent = `Event ${this.state.currentImageSlideEventIndex + 1} / ${this.state.currentImageTimelineEvents.length}`);
      sharedUtils.safeDOMUpdate(this.dom.viewerPrevImageEventButtonEl, el => el.disabled = (this.state.currentImageSlideEventIndex <= 0));
      sharedUtils.safeDOMUpdate(this.dom.viewerNextImageEventButtonEl, el => el.disabled = (this.state.currentImageSlideEventIndex >= this.state.currentImageTimelineEvents.length - 1));
  }
  console.log("ViewerManager: Slide navigation UI updated.");
},

initializeVideoOverlays: function() {
  console.log('ViewerManager: initializeVideoOverlays called');
  if(this.dom.overlayDisplayAreaEl) this.dom.overlayDisplayAreaEl.innerHTML = '';
  this.state.activeOverlays.forEach(el => el.remove()); // Defensive removal
  this.state.activeOverlays.clear();
},

// Add this new placeholder function
updateVideoOverlays: function(currentTime) {
  const slide = this.getCurrentSlide();
  console.log(`ViewerManager: updateVideoOverlays - currentTime: ${currentTime}`);
  console.log('ViewerManager: Current slide:', slide);
  
  if (!slide || !slide.slideMedia || !Array.isArray(slide.slideMedia.videoOverlays)) {
    console.log('ViewerManager: No overlays found for this slide');
    // Clear any existing overlays if there are none for this slide
    this.state.activeOverlays.forEach(overlayInfo => overlayInfo.element.remove());
    this.state.activeOverlays.clear();
    return;
  }

  const videoOverlays = slide.slideMedia.videoOverlays;
  console.log(`ViewerManager: Found ${videoOverlays.length} overlays for this slide:`, videoOverlays);

  videoOverlays.forEach(overlayData => {
    const overlayId = overlayData.id;
    const isActive = currentTime >= overlayData.startTime && currentTime < (overlayData.startTime + overlayData.duration);
    const isDisplayed = this.state.activeOverlays.has(overlayId);

    if (isActive && !isDisplayed) {
      // Create and display the overlay
      const overlayElement = this.createOverlayElementDOM(overlayData);
      if (this.dom.overlayDisplayAreaEl && overlayElement) {
        this.dom.overlayDisplayAreaEl.appendChild(overlayElement);
        this.state.activeOverlays.set(overlayId, { element: overlayElement, data: overlayData });
        console.log(`ViewerManager: Displayed overlay ${overlayId} at ${currentTime}`);
      }
    } else if (!isActive && isDisplayed) {
      // Remove the overlay
      const overlayInfo = this.state.activeOverlays.get(overlayId);
      if (overlayInfo && overlayInfo.element) {
        overlayInfo.element.remove();
      }
      this.state.activeOverlays.delete(overlayId);
      console.log(`ViewerManager: Removed overlay ${overlayId} at ${currentTime}`);
    }
  });
},

createOverlayElementDOM: function(overlayData) {
  // Simplified version of createOverlayElement from original Viewer_JS
  // This will be expanded later if more complex templates are needed.
  const element = document.createElement('div');
  element.id = 'overlay-' + overlayData.id; // Ensure unique ID for DOM element
  element.className = 'timeline-overlay-content'; // General class for styling

  // Basic styling based on template name (can be expanded)
  element.style.border = '1px solid black';
  element.style.padding = '10px';
  element.style.margin = '5px';
  element.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
  element.style.position = 'relative'; // For positioning controls like dismiss button

  if (overlayData.template) {
    element.classList.add('overlay-' + overlayData.template); // e.g., overlay-lowerThird
  }

  let contentHtml = '';
  if (overlayData.content) {
    if (overlayData.content.title) {
      contentHtml += `<h4>${overlayData.content.title}</h4>`;
    }
    if (overlayData.content.text) {
      contentHtml += `<p>${overlayData.content.text}</p>`;
    }
    // Add more content types as needed (image, button etc.)
  }
  element.innerHTML = contentHtml;

  // Add a dismiss button (simplified)
  const dismissButton = document.createElement('button');
  dismissButton.textContent = 'X';
  dismissButton.className = 'overlay-dismiss-button';
  dismissButton.style.position = 'absolute';
  dismissButton.style.top = '5px';
  dismissButton.style.right = '5px';
  dismissButton.onclick = () => {
    element.remove();
    this.state.activeOverlays.delete(overlayData.id);
    console.log(`ViewerManager: Dismissed overlay ${overlayData.id} by user action.`);
    // Potentially resume media if paused by an overlay action
    if (this.state.currentMediaType === 'youtube' && mediaManager.isYouTubePlayerAvailable() && mediaManager.getPlayerState() === YT.PlayerState.PAUSED) {
        // Check if pause was due to this overlay type, if so, play. This needs more sophisticated state.
        // For now, just play if it was paused.
        // mediaManager.playVideo();
    }
  };
  element.appendChild(dismissButton);

  // Add action button if specified (simplified)
  if (overlayData.action && overlayData.action.type !== 'none') {
    const actionButton = document.createElement('button');
    actionButton.textContent = overlayData.action.label || 'Action';
    actionButton.className = 'overlay-action-button';
    actionButton.onclick = () => this.handleOverlayActionDOM(overlayData);
    element.appendChild(actionButton);
  }

  return element;
},

handleOverlayActionDOM: function(overlayData) {
  console.log("ViewerManager: handleOverlayActionDOM for:", overlayData);
  // Simplified action handler
  const action = overlayData.action;
  if (!action) return;

  switch (action.type) {
    case 'link':
      if (action.url) {
        window.open(action.url, '_blank');
      }
      break;
    case 'seek':
      if (this.state.currentMediaType === 'youtube' && mediaManager.isYouTubePlayerAvailable() && action.time !== undefined) {
        mediaManager.seekTo(action.time);
        mediaManager.playVideo(); // Often want to play after seek from action
      } else if (this.state.currentMediaType === 'audio' && mediaManager.isAudioPlayerAvailable() && action.time !== undefined) {
        mediaManager.seekAudioTo(action.time);
        mediaManager.playAudio();
      }
      break;
    case 'pause': // Example: an overlay that explicitly pauses media
      if (this.state.currentMediaType === 'youtube' && mediaManager.isYouTubePlayerAvailable()) {
        mediaManager.pauseVideo();
      } else if (this.state.currentMediaType === 'audio' && mediaManager.isAudioPlayerAvailable()) {
        mediaManager.pauseAudio();
      }
      break;
    // Add more actions like 'play', 'showModal', etc.
    default:
      console.warn("Unknown overlay action type:", action.type);
  }
  // Overlays with actions often should be dismissed or automatically hidden after action
  // For now, manual dismiss is the primary way. Consider adding auto-dismiss for certain actions.
},

updateViewerCanvasInteractivity: function() {
    const canvas = this.state.viewerFabricCanvas;
    if (!canvas || !this.dom.viewerCanvasContainerEl) return;

    // An object is interactive if it has interactions OR animations with triggers
    const hasInteractiveObjects = canvas.getObjects().some(obj => {
        const hasInteraction = obj.customInteraction && obj.customInteraction.trigger && obj.customInteraction.action;
        const hasAnimation = obj.customAnimation && obj.customAnimation.trigger && obj.customAnimation.type;
        return hasInteraction || hasAnimation;
    });

    // The canvas should receive pointer events if any object is interactive.
    this.dom.viewerCanvasContainerEl.style.pointerEvents = hasInteractiveObjects ? 'auto' : 'none';

    // Configure all objects for "view-only" mode.
    canvas.selection = false; // Disable group selection.
    canvas.forEachObject(obj => {
        obj.selectable = false;
        
        // Object gets events if it has interactions OR animations with triggers
        const hasInteraction = obj.customInteraction && obj.customInteraction.trigger;
        const hasAnimation = obj.customAnimation && obj.customAnimation.trigger && obj.customAnimation.type;
        obj.evented = !!(hasInteraction || hasAnimation);
        
        obj.hasControls = false;
        obj.hasBorders = false;
        obj.lockMovementX = true;
        obj.lockMovementY = true;
        obj.lockRotation = true;
        obj.lockScalingX = true;
        obj.lockScalingY = true;
        
        // Set the cursor to a pointer if it's interactive, otherwise default.
        obj.hoverCursor = obj.evented ? 'pointer' : 'default';
    });

    console.log(`Viewer canvas interactivity updated. Pointer events: ${this.dom.viewerCanvasContainerEl.style.pointerEvents}`);
},

handleObjectInteraction: function(obj, interaction) {
  console.log("ViewerManager: handleObjectInteraction called", { obj, interaction });
  
  if (!interaction || !interaction.trigger || !interaction.action) {
    console.log("ViewerManager: No valid interaction defined for object");
    return;
  }

  // All triggers are now supported: click, onClick, hover, clickAndHold
  console.log(`ViewerManager: Processing ${interaction.trigger} trigger for ${interaction.action} action`);

  console.log(`ViewerManager: Executing ${interaction.action} interaction`);

  switch (interaction.action) {
    case 'showModal':
      if (interaction.modalContent) {
        this.showViewerModal(`<div>${interaction.modalContent}</div>`);
      } else {
        this.showViewerModal('<div>Modal content not specified</div>');
      }
      break;
      
    case 'navigateToSlide':
      if (interaction.navigateTo) {
        // Find slide by ID or use index
        const slideIndex = this.findSlideIndexById(interaction.navigateTo);
        if (slideIndex !== -1) {
          this.renderSlideForViewing(slideIndex);
        } else {
          console.warn(`ViewerManager: Could not find slide with ID: ${interaction.navigateTo}`);
        }
      }
      break;
      
    case 'navigateToURL':
      if (interaction.navigateTo) {
        window.open(interaction.navigateTo, '_blank');
      }
      break;
      
    case 'spotlight':
      this.handleSpotlightEffect(obj, interaction);
      break;
      
    case 'reveal':
      this.handleRevealEffect(obj, interaction);
      break;
      
    case 'panZoomToTarget':
      this.handlePanZoomEffect(obj, interaction);
      break;
      
    default:
      console.warn(`ViewerManager: Unknown interaction action: ${interaction.action}`);
  }
},

findSlideIndexById: function(slideId) {
  if (!this.state.currentProjectData || !this.state.currentProjectData.slides) {
    return -1;
  }
  
  return this.state.currentProjectData.slides.findIndex(slide => slide.slideId === slideId);
},

restoreObjectInteractions: function(canvas, fabricCanvasJSON) {
  console.log("ViewerManager: Restoring object interactions...");
  
  if (!fabricCanvasJSON || !fabricCanvasJSON.objects) {
    console.log("ViewerManager: No objects to restore interactions for");
    return;
  }
  
  // Restore custom interaction and animation properties that Fabric.js might not serialize properly
  canvas.getObjects().forEach((obj, index) => {
    const originalObj = fabricCanvasJSON.objects[index];
    if (originalObj) {
      // Restore custom interaction properties
      if (originalObj.customInteraction) {
        obj.customInteraction = { ...originalObj.customInteraction };
        console.log(`ViewerManager: Restored interaction for object ${index}:`, obj.customInteraction);
      }
      
      // Restore custom animation properties and start animations
      if (originalObj.customAnimation) {
        obj.customAnimation = { ...originalObj.customAnimation };
        // Trigger onLoad animations after restore
        if (obj.customAnimation.trigger === 'onLoad' && obj.customAnimation.type) {
          this.startAnimation(obj, obj.customAnimation);
        }
      }
      
      // Set cursor style based on interaction
      if (obj.customInteraction && obj.customInteraction.trigger && obj.customInteraction.action) {
        obj.hoverCursor = 'pointer';
        obj.moveCursor = 'pointer';
      }
    }
  });
  
  console.log(`ViewerManager: Restored interactions for ${canvas.getObjects().length} objects`);
},

handleSpotlightEffect: function(obj, interaction) {
  console.log("ViewerManager: Applying spotlight effect to object", obj);
  
  const canvas = this.state.viewerFabricCanvas;
  if (!canvas) return;
  
  // Create a dark overlay with a transparent "hole" over the target object
  const canvasWidth = canvas.getWidth();
  const canvasHeight = canvas.getHeight();
  
  // Get object bounds
  const objBounds = obj.getBoundingRect();
  const padding = 20; // Extra space around the spotlighted object
  
  // Create spotlight overlay
  const spotlightOverlay = document.createElement('div');
  spotlightOverlay.id = 'spotlight-overlay';
  spotlightOverlay.style.cssText = `
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 10;
    pointer-events: none;
    transition: opacity 0.3s ease;
  `;
  
  // Create the spotlight hole using CSS clip-path
  const spotlightX = objBounds.left - padding;
  const spotlightY = objBounds.top - padding;
  const spotlightWidth = objBounds.width + (padding * 2);
  const spotlightHeight = objBounds.height + (padding * 2);
  
  spotlightOverlay.style.clipPath = `polygon(
    0% 0%, 
    0% 100%, 
    ${(spotlightX / canvasWidth) * 100}% 100%, 
    ${(spotlightX / canvasWidth) * 100}% ${(spotlightY / canvasHeight) * 100}%, 
    ${((spotlightX + spotlightWidth) / canvasWidth) * 100}% ${(spotlightY / canvasHeight) * 100}%, 
    ${((spotlightX + spotlightWidth) / canvasWidth) * 100}% ${((spotlightY + spotlightHeight) / canvasHeight) * 100}%, 
    ${(spotlightX / canvasWidth) * 100}% ${((spotlightY + spotlightHeight) / canvasHeight) * 100}%, 
    ${(spotlightX / canvasWidth) * 100}% 100%, 
    100% 100%, 
    100% 0%
  )`;
  
  // Add to canvas container
  this.dom.viewerCanvasContainerEl.appendChild(spotlightOverlay);
  
  // Auto-remove after 5 seconds or on click
  setTimeout(() => {
    if (spotlightOverlay.parentNode) {
      spotlightOverlay.style.opacity = '0';
      setTimeout(() => spotlightOverlay.remove(), 300);
    }
  }, 5000);
  
  // Click to dismiss
  spotlightOverlay.addEventListener('click', () => {
    spotlightOverlay.style.opacity = '0';
    setTimeout(() => spotlightOverlay.remove(), 300);
  });
  
  console.log("ViewerManager: Spotlight effect applied");
},

handleRevealEffect: function(obj, interaction) {
  console.log("ViewerManager: Applying reveal effect to object", obj);
  
  // Make the object initially invisible, then reveal it with animation
  const originalOpacity = obj.opacity || 1;
  obj.set('opacity', 0);
  this.state.viewerFabricCanvas.renderAll();
  
  // Animate the reveal
  obj.animate('opacity', originalOpacity, {
    duration: 800,
    easing: fabric.util.ease.easeOutCubic,
    onChange: () => this.state.viewerFabricCanvas.renderAll(),
    onComplete: () => {
      console.log("ViewerManager: Reveal effect completed");
    }
  });
},

handlePanZoomEffect: function(obj, interaction) {
  console.log("ViewerManager: Applying pan/zoom effect to object", obj);
  
  const canvas = this.state.viewerFabricCanvas;
  if (!canvas) return;
  
  // Get zoom level from interaction (default 1.5)
  const zoomLevel = interaction.panZoomLevel || 1.5;
  
  // Get object center
  const objBounds = obj.getBoundingRect();
  const centerX = objBounds.left + (objBounds.width / 2);
  const centerY = objBounds.top + (objBounds.height / 2);
  
  // Calculate target viewport transform to center the object
  const canvasWidth = canvas.getWidth();
  const canvasHeight = canvas.getHeight();
  
  const targetX = (canvasWidth / 2) - (centerX * zoomLevel);
  const targetY = (canvasHeight / 2) - (centerY * zoomLevel);
  
  // Store original transform
  if (!this.state.originalViewportTransform) {
    this.state.originalViewportTransform = [...canvas.viewportTransform];
    this.state.originalZoom = canvas.getZoom();
  }
  
  // Animate to target transform
  const startTransform = [...canvas.viewportTransform];
  const startZoom = canvas.getZoom();
  
  const animate = (progress) => {
    const currentZoom = startZoom + (zoomLevel - startZoom) * progress;
    const currentX = startTransform[4] + (targetX - startTransform[4]) * progress;
    const currentY = startTransform[5] + (targetY - startTransform[5]) * progress;
    
    canvas.setZoom(currentZoom);
    canvas.viewportTransform[4] = currentX;
    canvas.viewportTransform[5] = currentY;
    canvas.calcOffset();
    canvas.renderAll();
  };
  
  // Smooth animation
  let start = null;
  const duration = 1000; // 1 second
  
  const animationFrame = (timestamp) => {
    if (!start) start = timestamp;
    const progress = Math.min((timestamp - start) / duration, 1);
    const easeProgress = 1 - Math.pow(1 - progress, 3); // ease-out cubic
    
    animate(easeProgress);
    
    if (progress < 1) {
      requestAnimationFrame(animationFrame);
    } else {
      console.log("ViewerManager: Pan/zoom effect completed");
      // Set flag to track that canvas is zoomed
      this.state.isCanvasPannedOrZoomed = true;
    }
  };
  
  requestAnimationFrame(animationFrame);
},

resetPanZoom: function() {
  console.log("ViewerManager: Resetting pan/zoom to original state");
  
  const canvas = this.state.viewerFabricCanvas;
  if (!canvas || !this.state.originalViewportTransform) return;
  
  const targetTransform = [...this.state.originalViewportTransform];
  const targetZoom = this.state.originalZoom || 1;
  
  // Animate back to original transform
  const startTransform = [...canvas.viewportTransform];
  const startZoom = canvas.getZoom();
  
  const animate = (progress) => {
    const currentZoom = startZoom + (targetZoom - startZoom) * progress;
    const currentX = startTransform[4] + (targetTransform[4] - startTransform[4]) * progress;
    const currentY = startTransform[5] + (targetTransform[5] - startTransform[5]) * progress;
    
    canvas.setZoom(currentZoom);
    canvas.viewportTransform[4] = currentX;
    canvas.viewportTransform[5] = currentY;
    canvas.calcOffset();
    canvas.renderAll();
  };
  
  let start = null;
  const duration = 800;
  
  const animationFrame = (timestamp) => {
    if (!start) start = timestamp;
    const progress = Math.min((timestamp - start) / duration, 1);
    const easeProgress = 1 - Math.pow(1 - progress, 3);
    
    animate(easeProgress);
    
    if (progress < 1) {
      requestAnimationFrame(animationFrame);
    } else {
      this.state.isCanvasPannedOrZoomed = false;
      console.log("ViewerManager: Pan/zoom reset completed");
    }
  };
  
  requestAnimationFrame(animationFrame);
},

startClickAndHold: function(obj, interaction) {
  console.log("ViewerManager: Starting click and hold for object", obj);
  
  // Clear any existing click and hold
  this.clearClickAndHold();
  
  // Start timer for click and hold (default 800ms)
  this.state.clickAndHoldTimeout = setTimeout(() => {
    this.handleObjectInteraction(obj, interaction);
    this.state.clickAndHoldTimeout = null;
  }, 800);
},

clearClickAndHold: function() {
  if (this.state.clickAndHoldTimeout) {
    clearTimeout(this.state.clickAndHoldTimeout);
    this.state.clickAndHoldTimeout = null;
  }
},

startAnimation: function(obj, animation) {
  console.log("ViewerManager: Starting animation", animation.type, "on object", obj);
  
  if (!animation || !animation.type) {
    console.warn("ViewerManager: Invalid animation object");
    return;
  }
  
  const canvas = this.state.viewerFabricCanvas;
  if (!canvas) return;
  
  switch (animation.type.toLowerCase()) {
    case 'fadeIn':
      const originalOpacity = obj.opacity || 1;
      obj.set('opacity', 0);
      obj.animate('opacity', originalOpacity, {
        duration: animation.duration || 500,
        easing: fabric.util.ease.easeOutCubic,
        onChange: () => canvas.renderAll()
      });
      break;
      
    case 'fadeOut':
      obj.animate('opacity', 0, {
        duration: animation.duration || 500,
        easing: fabric.util.ease.easeOutCubic,
        onChange: () => canvas.renderAll()
      });
      break;
      
    case 'slideIn':
      const direction = animation.direction || 'left';
      const originalLeft = obj.left;
      const originalTop = obj.top;
      const canvasWidth = canvas.getWidth();
      const canvasHeight = canvas.getHeight();
      
      // Set starting position based on direction
      switch (direction) {
        case 'left':
          obj.set('left', -obj.width);
          break;
        case 'right':
          obj.set('left', canvasWidth);
          break;
        case 'top':
          obj.set('top', -obj.height);
          break;
        case 'bottom':
          obj.set('top', canvasHeight);
          break;
      }
      
      // Animate to original position
      obj.animate(direction === 'left' || direction === 'right' ? 'left' : 'top', 
                  direction === 'left' || direction === 'right' ? originalLeft : originalTop, {
        duration: animation.duration || 800,
        easing: fabric.util.ease.easeOutCubic,
        onChange: () => canvas.renderAll()
      });
      break;
      
    case 'bounce':
      const originalScale = obj.scaleX || 1;
      obj.animate('scaleX', originalScale * 1.2, {
        duration: 150,
        easing: fabric.util.ease.easeOutBounce,
        onChange: () => canvas.renderAll(),
        onComplete: () => {
          obj.animate('scaleX', originalScale, {
            duration: 150,
            easing: fabric.util.ease.easeOutBounce,
            onChange: () => canvas.renderAll()
          });
          obj.animate('scaleY', originalScale, {
            duration: 150,
            easing: fabric.util.ease.easeOutBounce,
            onChange: () => canvas.renderAll()
          });
        }
      });
      obj.animate('scaleY', originalScale * 1.2, {
        duration: 150,
        easing: fabric.util.ease.easeOutBounce,
        onChange: () => canvas.renderAll()
      });
      break;
      
    case 'pulse':
      const pulseScale = animation.scale || 1.1;
      const pulseDuration = animation.duration || 300;
      const pulseOriginalScaleX = obj.scaleX || 1;
      const pulseOriginalScaleY = obj.scaleY || 1;
      
      obj.animate('scaleX', pulseOriginalScaleX * pulseScale, {
        duration: pulseDuration / 2,
        easing: fabric.util.ease.easeOutCubic,
        onChange: () => canvas.renderAll(),
        onComplete: () => {
          obj.animate('scaleX', pulseOriginalScaleX, {
            duration: pulseDuration / 2,
            easing: fabric.util.ease.easeOutCubic,
            onChange: () => canvas.renderAll()
          });
        }
      });
      obj.animate('scaleY', pulseOriginalScaleY * pulseScale, {
        duration: pulseDuration / 2,
        easing: fabric.util.ease.easeOutCubic,
        onChange: () => canvas.renderAll(),
        onComplete: () => {
          obj.animate('scaleY', pulseOriginalScaleY, {
            duration: pulseDuration / 2,
            easing: fabric.util.ease.easeOutCubic,
            onChange: () => canvas.renderAll()
          });
        }
      });
      break;
      
    default:
      console.warn(`ViewerManager: Unknown animation type: ${animation.type}`);
  }
},

  navigateToPrevSlide: function() {
  if (this.state.currentSlideIndex > 0) {
    this.renderSlideForViewing(this.state.currentSlideIndex - 1);
  } else {
    console.log("ViewerManager: Already on the first slide.");
  }
},

navigateToNextSlide: function() {
  if (this.state.currentProjectData && this.state.currentProjectData.slides &&
      this.state.currentSlideIndex < this.state.currentProjectData.slides.length - 1) {
    this.renderSlideForViewing(this.state.currentSlideIndex + 1);
  } else {
    console.log("ViewerManager: Already on the last slide or no project data.");
  }
},

hideViewerModal: function() {
  if (this.dom.viewerModalEl) {
    this.dom.viewerModalEl.style.display = 'none';
    this.dom.viewerModalBodyEl.innerHTML = ''; // Clear content
    console.log("ViewerManager: Modal hidden.");
  }
  // If media was paused due to a modal (e.g. question), it should be resumed by the logic that opened the modal (like closeQuestionModal)
},

showViewerModal: function(htmlContent) { // Ensure this function exists and is robust
  if (this.dom.viewerModalBodyEl && this.dom.viewerModalEl) {
    this.dom.viewerModalBodyEl.innerHTML = htmlContent;
    this.dom.viewerModalEl.style.display = 'flex'; // Or 'block' depending on CSS for centering
    console.log("ViewerManager: Modal shown.");
  } else {
    console.error("ViewerManager: Modal body or overlay element not found.");
  }
},

// Placeholders for modal sequence navigation if needed later
navigateModalPrevious: function() {
  console.log('ViewerManager: navigateModalPrevious (Placeholder)');
  // Add logic if sequence modals are used
},

navigateModalNext: function() {
  console.log('ViewerManager: navigateModalNext (Placeholder)');
  // Add logic if sequence modals are used
}
};

console.log("ViewerManager: Module loaded successfully. Available methods:", Object.keys(window.viewerManager));
</script>
