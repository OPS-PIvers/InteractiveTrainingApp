<script>
    // Namespace for the viewer application
    window.viewerApp = {};

    // --- Global Variables ---
    let ytPlayer; // Global variable to hold the YouTube player instance
    let isYouTubeApiReady = false; // Flag to track API readiness
    const CLICK_AND_HOLD_DURATION = 750; // Milliseconds for click and hold
    // Animation speed presets - duration for a complete animation cycle
    const ANIMATION_SPEED_PRESETS = {
      slow: { duration: 1500 },     // 1.5 seconds per cycle
      normal: { duration: 1000 },   // 1 second per cycle
      fast: { duration: 500 }       // 0.5 seconds per cycle
    };

    // --- Application State ---
    viewerApp.state = {
      isLoading: false,
      currentProjectData: null,
      currentSlideIndex: 0, // Default to 0, will be updated
      viewerFabricCanvas: null,
      defaultCanvasWidth: 960,
      defaultCanvasHeight: 540,
      currentAudioElement: null, // Reference to the currently playing audio element
      // State for Modal Sequencing (Step 21)
      currentModalOverlay: null, // The Fabric object that triggered the current modal sequence
      modalSequence: [],         // Array of Fabric objects in the current sequence on the slide
      currentModalSequenceIndex: -1, // Index within modalSequence being displayed
      // --- State for Spotlight Overlay ---
      isSpotlightActive: false,
      currentSpotlightInfo: null, // Will hold { svg, clickCatcher, targetFabricObject, textBubble, notesPanel }
      // --- State for Pan/Zoom ---
      originalViewportTransform: null, // To store [zoom, 0, 0, zoom, panX, panY]
      isCanvasPannedOrZoomed: false,
      panZoomTargetObject: null, 
      activeAnimations: new Map(),
      currentVideoQuestions: [], // Stores questions for the current video
      playerQuestionCheckInterval: null, // Interval ID for checking video time
      askedQuestionIndices: [], // Indices of questions already asked for the current slide view
    };

    // --- DOM Element References ---
    let viewerProjectListContainerEl, messageAreaElViewer, loadingSpinnerElViewer;
    let viewerListViewContainerEl, viewerProjectDisplayAreaEl, viewingProjectTitleEl;
    let viewerMediaContainerEl, youtubePlayerContainerEl, // New media container refs
        viewerCanvasContainerEl, viewerFabricCanvasEl;
    let viewerPrevSlideButtonEl, viewerNextSlideButtonEl, viewerSlideIndicatorEl, backToViewerListButtonEl;
    let viewerModalEl, viewerModalCloseButtonEl, viewerModalBodyEl,
        modalPrevButtonEl, modalNextButtonEl; // Modal Nav Buttons (Step 21)
    let viewerAudioPlayerEl; // Ref for the audio element

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function() {
      console.log("Viewer_JS: DOMContentLoaded event fired!");

      viewerApp.setupDOMReferences();
      viewerApp.attachEventListeners();

      loadViewerProjectsList();

      console.log("Viewer_JS: Initialization complete.");
    });

    viewerApp.setupDOMReferences = function() {
      viewerProjectListContainerEl = document.getElementById('viewerProjectListContainer');
      messageAreaElViewer = document.getElementById('messageAreaViewer');
      loadingSpinnerElViewer = document.getElementById('loadingSpinner');

      viewerListViewContainerEl = document.getElementById('viewerListViewContainer');
      viewerProjectDisplayAreaEl = document.getElementById('viewerProjectDisplayArea');
      viewingProjectTitleEl = document.getElementById('viewingProjectTitle');

      viewerMediaContainerEl = document.getElementById('viewerMediaContainer');
      youtubePlayerContainerEl = document.getElementById('youtubePlayerContainer');
      viewerCanvasContainerEl = document.getElementById('viewerCanvasContainer'); // Container for the canvas
      viewerFabricCanvasEl = document.getElementById('viewerFabricCanvas'); // The actual canvas element

      viewerPrevSlideButtonEl = document.getElementById('viewerPrevSlideButton');
      viewerNextSlideButtonEl = document.getElementById('viewerNextSlideButton');
      viewerSlideIndicatorEl = document.getElementById('viewerSlideIndicator');
      backToViewerListButtonEl = document.getElementById('backToViewerListButton');

      viewerModalEl = document.getElementById('viewerModal');
      viewerModalCloseButtonEl = document.getElementById('viewerModalCloseButton');
      viewerModalBodyEl = document.getElementById('viewerModalBody');
      modalPrevButtonEl = document.getElementById('modalPrevButton'); // Step 21
      modalNextButtonEl = document.getElementById('modalNextButton'); // Step 21

      viewerAudioPlayerEl = document.getElementById('viewerAudioPlayer');

      if (!viewerProjectListContainerEl) console.error("CRITICAL: viewerProjectListContainerEl not found!");
      if (!viewerModalEl) console.error("CRITICAL: viewerModalEl not found!");
      if (!viewerAudioPlayerEl) console.error("CRITICAL: viewerAudioPlayerEl not found!");
      if (!modalPrevButtonEl || !modalNextButtonEl) console.error("CRITICAL: Modal navigation buttons not found!"); // Step 21 Check
      // NEW: Get reference to the main display area for click-off listener
      viewerProjectDisplayAreaEl = document.getElementById('viewerProjectDisplayArea');
      if (!viewerProjectDisplayAreaEl) console.error("CRITICAL: viewerProjectDisplayAreaEl not found!"); // Add check

      console.log("Viewer_JS: DOM references set up.");
    };

    viewerApp.attachEventListeners = function() {
        if (backToViewerListButtonEl) backToViewerListButtonEl.addEventListener('click', showProjectListView);
        if (viewerPrevSlideButtonEl) viewerPrevSlideButtonEl.addEventListener('click', navigateToPrevSlide);
        if (viewerNextSlideButtonEl) viewerNextSlideButtonEl.addEventListener('click', navigateToNextSlide);
        if (viewerModalCloseButtonEl) viewerModalCloseButtonEl.addEventListener('click', hideViewerModal);
        if (viewerModalEl) { // Close modal if background is clicked
            viewerModalEl.addEventListener('click', function(event) {
                if (event.target === viewerModalEl) {
                    hideViewerModal();
                }
            });
        }
        // Step 21: Attach listeners for modal navigation buttons
        if (modalPrevButtonEl) modalPrevButtonEl.addEventListener('click', navigateModalPrevious);
        if (modalNextButtonEl) modalNextButtonEl.addEventListener('click', navigateModalNext);

        // Listener to remove spotlight when clicking outside the spotlighted object
        // This listener on viewerProjectDisplayAreaEl is now less critical for spotlight (SVG catcher handles it),
        // but might be useful for other "click off" behaviors later.
        if (viewerProjectDisplayAreaEl) {
             viewerProjectDisplayAreaEl.addEventListener('click', function(event) {
                if (viewerApp.state.spotlightOverlayObject && event.target !== viewerApp.state.spotlightOverlayObject.target) {
                    // console.log("Viewer area click detected while spotlight active, removing effect.");
                    // removeSpotlightEffect(); // SVG spotlight uses its own catcher
                }
             }, false);
        }
    };

    // --- UI Utils & Server Error Handling ---
    function showLoadingViewer(show) {
      viewerApp.state.isLoading = show;
      if (loadingSpinnerElViewer) {
        loadingSpinnerElViewer.style.display = show ? 'flex' : 'none';
      } else if (show) {
          console.warn("showLoadingViewer(true) called but loadingSpinnerElViewer not yet available.");
      }
    }

    function displayMessageViewer(message, isSuccess) {
      if (messageAreaElViewer) {
        messageAreaElViewer.innerHTML = '';
        const p = document.createElement('p');
        p.textContent = message;
        messageAreaElViewer.appendChild(p);
        messageAreaElViewer.className = isSuccess ? 'success' : 'error';
        setTimeout(() => {
          if (messageAreaElViewer) {
            messageAreaElViewer.innerHTML = '';
            messageAreaElViewer.className = '';
          }
        }, 7000);
      } else {
        console.warn("displayMessageViewer called but messageAreaElViewer not available. Message:", message);
      }
    }

    function onServerErrorViewer(errorObject) {
      showLoadingViewer(false);
      console.error('Viewer Server Error Object:', errorObject);
      let errorMessage = "An unknown error occurred on the server.";
      if (typeof errorObject === 'string') {
          errorMessage = errorObject;
      } else if (errorObject && errorObject.message && typeof errorObject.message === 'string') {
          errorMessage = errorObject.message;
      } else if (errorObject && errorObject.name && errorObject.message) {
          errorMessage = `Error: ${errorObject.name} - ${errorObject.message}`;
      } else if (errorObject && errorObject.error && typeof errorObject.error === 'string') { // Handle {success:false, error:"..."}
          errorMessage = errorObject.error;
      }
      displayMessageViewer('Server Error: ' + errorMessage, false);
    }

    // --- Project List Loading/Display ---
    function loadViewerProjectsList() {
      console.log("loadViewerProjectsList called");
      if (!google || !google.script || !google.script.run) {
        console.error("google.script.run is not available for loadViewerProjectsList!");
        displayMessageViewer("Error: Client-server communication bridge unavailable.", false); return;
      }
      if (!viewerProjectListContainerEl) {
          console.warn("loadViewerProjectsList: viewerProjectListContainerEl not ready yet.");
          showLoadingViewer(false);
          return;
      }
      showLoadingViewer(true);
      google.script.run
        .withSuccessHandler(displayViewerProjects)
        .withFailureHandler(onServerErrorViewer)
        .getActiveProjectsList();
    }

    function displayViewerProjects(projectsArray) {
      showLoadingViewer(false);
      console.log("displayViewerProjects received:", projectsArray ? projectsArray.length : 0, "projects");
      if (!viewerProjectListContainerEl) {
          console.error("displayViewerProjects: viewerProjectListContainerEl is not found!");
          return;
      }
      viewerProjectListContainerEl.innerHTML = '';
      if (!projectsArray || projectsArray.length === 0) {
        viewerProjectListContainerEl.innerHTML = '<p>No active training modules found at this time.</p>';
        return;
      }

      const ul = document.createElement('ul');
      ul.className = 'project-list-viewer';

      projectsArray.forEach(project => {
        if (!project || !project.projectId) {
            console.warn("Skipping display of invalid project object:", project);
            return;
        }
        const listItem = document.createElement('li');
        listItem.className = 'project-card-viewer';

        const titleHeader = document.createElement('h3');
        titleHeader.textContent = project.projectTitle || 'Untitled Project';

        const viewButton = document.createElement('button');
        viewButton.textContent = 'View Project';
        viewButton.className = 'view-project-button';
        viewButton.setAttribute('data-project-id', project.projectId);
        viewButton.onclick = function() {
          console.log("View Project button clicked for project ID:", project.projectId);
          loadProjectForViewing(project.projectId);
        };

        listItem.appendChild(titleHeader);
        listItem.appendChild(viewButton);
        ul.appendChild(listItem);
      });
      viewerProjectListContainerEl.appendChild(ul);
    }

    // --- View Switching & Cleanup ---
    function showProjectListView() {
        if (viewerListViewContainerEl) viewerListViewContainerEl.style.display = 'block';
        if (viewerProjectDisplayAreaEl) viewerProjectDisplayAreaEl.style.display = 'none';

        // Cleanup media players
        stopAndDestroyYouTubePlayer();
        stopAndClearAudioPlayer();
        hideSpotlightSVG();
        if(viewerApp.state.isCanvasPannedOrZoomed) resetPanZoomWithAnimation(true); // Reset immediately if panned/zoomed

        if (viewerApp.state.viewerFabricCanvas) {
            viewerApp.state.viewerFabricCanvas.dispose();
            viewerApp.state.viewerFabricCanvas = null;
        }
        viewerApp.state.currentProjectData = null;
        viewerApp.state.currentSlideIndex = 0;
        loadViewerProjectsList();
    }

    function showProjectView() {
        if (viewerListViewContainerEl) viewerListViewContainerEl.style.display = 'none';
        if (viewerProjectDisplayAreaEl) viewerProjectDisplayAreaEl.style.display = 'block';
    }

    // --- Project Data Loading ---
    function loadProjectForViewing(projectId) {
        if (!projectId) {
            displayMessageViewer("Invalid project ID.", false);
            return;
        }
        showLoadingViewer(true);
        displayMessageViewer("Loading project...", true);
        google.script.run
            .withSuccessHandler(onProjectViewDataReceived)
            .withFailureHandler(onServerErrorViewer)
            .getProjectViewData(projectId);
    }

    function onProjectViewDataReceived(response) {
        showLoadingViewer(false);
        if (!response || !response.success || !response.data) {
            onServerErrorViewer(response || { error: "Failed to load project data or project is not active." });
             showProjectListView(); // Go back to list on error
            return;
        }
        try {
            viewerApp.state.currentProjectData = JSON.parse(response.data);
             if (viewerApp.state.currentProjectData && Array.isArray(viewerApp.state.currentProjectData.slides)) {
                 viewerApp.state.currentProjectData.slides.forEach(slide => {
                    if (!slide.slideMedia) {
                        slide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
                    }
                    // Ensure videoQuestions array exists for YouTube slides
                    if (slide.slideMedia && slide.slideMedia.type === 'youtube' && !Array.isArray(slide.slideMedia.videoQuestions)) {
                        slide.slideMedia.videoQuestions = [];
                    }
                 });
             } else {
                 throw new Error("Project data is missing slides array.");
             }

            if (viewerApp.state.currentProjectData.slides.length === 0) {
                displayMessageViewer("Project loaded, but it has no slides.", false);
                 showProjectListView(); 
                return;
            }

            console.log("Project for viewing loaded:", viewerApp.state.currentProjectData);
            console.log("Number of slides loaded:", viewerApp.state.currentProjectData.slides.length);

            viewerApp.state.currentSlideIndex = 0; 
            showProjectView();
            if (viewingProjectTitleEl) viewingProjectTitleEl.textContent = viewerApp.state.currentProjectData.title || "Untitled Project";
            initializeViewerCanvas(); 
            renderSlideForViewing(viewerApp.state.currentSlideIndex); 
            displayMessageViewer("Project loaded.", true);
        } catch (e) {
            console.error("Error parsing project data for viewing:", e);
            displayMessageViewer("Error loading project: Invalid data format.", false);
            viewerApp.state.currentProjectData = null;
             showProjectListView();
        }
    }

    // --- Canvas & Slide Rendering ---
    function initializeViewerCanvas() {
        if (viewerApp.state.viewerFabricCanvas) {
            viewerApp.state.viewerFabricCanvas.dispose();
            viewerApp.state.viewerFabricCanvas = null;
        }
        if (!viewerFabricCanvasEl) {
            console.error("Viewer Fabric canvas element not found!");
            return;
        }
        try {
            viewerApp.state.viewerFabricCanvas = new fabric.Canvas(viewerFabricCanvasEl, {
                width: viewerApp.state.defaultCanvasWidth,
                height: viewerApp.state.defaultCanvasHeight,
                selection: false,
                hoverCursor: 'default',
                backgroundColor: 'transparent' 
            });
            viewerApp.state.viewerFabricCanvas.selection = false;
            
            // Listener for resetting pan/zoom on background click
            viewerApp.state.viewerFabricCanvas.on('mouse:down', function(options) {
                if (viewerApp.state.isCanvasPannedOrZoomed && !options.target) { // No object clicked, means background
                    console.log("Canvas background clicked while panned/zoomed, initiating reset.");
                    resetPanZoomWithAnimation();
                } else if (viewerApp.state.isCanvasPannedOrZoomed && options.target && options.target === viewerApp.state.panZoomTargetObject) {
                    // If the same panned/zoomed object is clicked again, reset.
                    console.log("Panned/zoomed target object clicked again, initiating reset.");
                    resetPanZoomWithAnimation();
                }
                // If options.target is another interactive object, its own 'mousedown' (from renderSlideForViewing)
                // will call handleOverlayInteraction, which has its own logic to reset zoom if needed.
            });
            viewerApp.state.viewerFabricCanvas.renderAll(); 
            console.log("Viewer canvas initialized.");
        } catch(e) {
            console.error("Error initializing viewer Fabric canvas:", e);
            displayMessageViewer("Error initializing display canvas.", false);
        }
    }

    function renderSlideForViewing(slideIndex) {
        if (!viewerApp.state.currentProjectData || !viewerApp.state.viewerFabricCanvas) {
            console.error("Cannot render slide: Project data or canvas not ready."); return;
        }
        const slides = viewerApp.state.currentProjectData.slides;
        if (slideIndex < 0 || slideIndex >= slides.length) {
            console.error("Invalid slide index:", slideIndex); return;
        }

        stopAndDestroyYouTubePlayer();
        stopAndClearAudioPlayer();
        hideSpotlightSVG(); 
        if(viewerApp.state.isCanvasPannedOrZoomed) resetPanZoomWithAnimation(true); // Reset immediately if panned/zoomed


        viewerApp.state.currentSlideIndex = slideIndex; 
        const slideData = slides[slideIndex];
        const canvas = viewerApp.state.viewerFabricCanvas;

         if (!slideData.slideMedia) {
            slideData.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
         }

        const slideWidth = slideData.canvasWidth || viewerApp.state.defaultCanvasWidth;
        const slideHeight = slideData.canvasHeight || viewerApp.state.defaultCanvasHeight;
        const media = slideData.slideMedia;
        let mediaType = (media && media.type) ? media.type : 'none';

        canvas.setWidth(slideWidth);
        canvas.setHeight(slideHeight);
        if (viewerFabricCanvasEl) {
            viewerFabricCanvasEl.width = slideWidth;
            viewerFabricCanvasEl.height = slideHeight;
        }
        if (viewerMediaContainerEl) {
            viewerMediaContainerEl.style.width = slideWidth + 'px';
            viewerMediaContainerEl.style.height = slideHeight + 'px';
        }

        canvas.clear();
        canvas.setBackgroundImage(null, () => { canvas.renderAll(); });
        canvas.backgroundColor = 'transparent';

        if (youtubePlayerContainerEl) youtubePlayerContainerEl.style.display = (mediaType === 'youtube') ? 'block' : 'none';
        // For YouTube, canvas container should be visible to overlay.
        if (viewerCanvasContainerEl) {
            viewerCanvasContainerEl.style.display = 'flex'; // Always visible, overlays YT or shows image/audio bg
            if (mediaType === 'youtube') {
                viewerCanvasContainerEl.style.pointerEvents = 'none'; // Pass clicks to player by default
                // Populate video questions for the current slide if it's a YouTube video
                if (slideData.slideMedia && slideData.slideMedia.videoQuestions) {
                    viewerApp.state.currentVideoQuestions = [...slideData.slideMedia.videoQuestions].sort((a, b) => a.timestamp - b.timestamp);
                } else {
                    viewerApp.state.currentVideoQuestions = [];
                }
                viewerApp.state.askedQuestionIndices = []; // Reset for new slide/video
            } else {
                viewerCanvasContainerEl.style.pointerEvents = 'auto'; // Allow clicks on canvas for non-YT
                viewerApp.state.currentVideoQuestions = []; // Clear questions if not a YT video
                viewerApp.state.askedQuestionIndices = [];
            }
        }
        if (viewerAudioPlayerEl) viewerAudioPlayerEl.style.display = 'none'; 

        console.log(`Rendering slide ${slideIndex + 1}, media type: ${mediaType}`);

        switch(mediaType) {
            case 'image':
                if (media.url && media.url.startsWith('data:image')) {
                    fabric.Image.fromURL(media.url, function(img) {
                        if (!viewerApp.state.viewerFabricCanvas || viewerApp.state.currentSlideIndex !== slideIndex) return;
                        canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                            scaleX: canvas.width / img.width, scaleY: canvas.height / img.height
                        });
                    }, { crossOrigin: 'anonymous' });
                } else {
                     console.warn("Image media present but URL is missing or not base64:", media.url);
                     canvas.backgroundColor = '#e9e9e9';
                     canvas.renderAll();
                }
                break;

            case 'youtube':
                // Canvas container is already set to display:flex above.
                // Fabric canvas dimensions are already set by slideWidth/slideHeight.
                // Fabric canvas background is transparent by default from initializeViewerCanvas.
                if (media.url) {
                    const videoId = extractYouTubeVideoId(media.url);
                    if (videoId) {
                        if (isYouTubeApiReady) {
                             setupYouTubePlayer(videoId);
                        } else {
                             console.warn("YouTube API not ready yet when trying to render slide.");
                             // Fallback if API never loads - show canvas with dark bg
                             canvas.backgroundColor = '#333'; // Dark fallback
                             canvas.renderAll();
                        }
                    } else {
                        console.error("Could not extract YouTube Video ID from URL:", media.url);
                         canvas.backgroundColor = '#555'; // Error indication
                         canvas.renderAll();
                    }
                } else {
                     console.warn("YouTube media type set but URL is missing.");
                     canvas.backgroundColor = '#e9e9e9'; // Default fallback
                     canvas.renderAll();
                }
                // Overlays will be loaded below, after the switch statement.
                break;

            case 'audio':
                 if (media.driveFileId) {
                     console.log("Audio media needs fetch from Drive ID:", media.driveFileId);
                     showLoadingViewer(true);
                     google.script.run
                         .withSuccessHandler(function(audioResponse) {
                             showLoadingViewer(false);
                             if (viewerApp.state.currentSlideIndex !== slideIndex) return;
                             if (audioResponse && audioResponse.success && audioResponse.base64Data) {
                                 setupAudioPlayer(audioResponse.base64Data);
                                 if (viewerAudioPlayerEl) viewerAudioPlayerEl.style.display = 'block';
                                 canvas.backgroundColor = '#e0e0e0';
                                 canvas.renderAll();
                             } else {
                                 console.error("Failed to fetch audio base64 data:", audioResponse);
                                 onServerErrorViewer(audioResponse || {error: "Failed to load audio data."});
                                 canvas.backgroundColor = '#e9e9e9';
                                 canvas.renderAll();
                             }
                         })
                         .withFailureHandler(function(error) {
                             showLoadingViewer(false);
                             onServerErrorViewer(error);
                             canvas.backgroundColor = '#e9e9e9';
                             canvas.renderAll();
                         })
                         .getAudioAsBase64(media.driveFileId);
                 } else {
                     console.warn("Audio media type set but driveFileId is missing.");
                     canvas.backgroundColor = '#e9e9e9';
                     canvas.renderAll();
                 }
                 break;

            default: 
                 canvas.backgroundColor = '#e9e9e9';
                 canvas.renderAll();
                 break;
        }

        // Load Fabric.js overlays for ALL slide types, including YouTube
        // The canvas container visibility and pointer-events are managed above.
        if (slideData.fabricCanvasJSON) {
            canvas.loadFromJSON(slideData.fabricCanvasJSON, function() {
                if (viewerApp.state.currentSlideIndex !== slideIndex) return;

                canvas.forEachObject(function(obj) {
                    obj.selectable = false;
                    obj.evented = true; 
                    obj.hoverCursor = 'pointer';
                    obj._clickAndHoldTimer = null;

                    obj.off('mousedown');
                    obj.off('mouseup');
                    obj.off('mouseout');
                    obj.off('mousemove'); 
                    obj.off('mouseover');

                    // --- Attach Interaction & Animation Listeners ---
                    if (obj.customInteraction && obj.customInteraction.trigger) {
                        const trigger = obj.customInteraction.trigger;
                        const action = obj.customInteraction.action;

                        // Special handling for "Click and Hold" + "Spotlight" (SVG Mask version)
                        if (trigger === 'clickAndHold' && action === 'spotlight') {
                            obj.on('mousedown', function(options) {
                                if (this.customInteraction && this.customInteraction.trigger === 'clickAndHold' && this.customInteraction.action === 'spotlight') {
                                    showSpotlightSVG(this, this.customInteraction);
                                }
                            });
                            obj.on('mouseup', function() {
                                if (this.customInteraction && this.customInteraction.trigger === 'clickAndHold' && this.customInteraction.action === 'spotlight') {
                                    if (viewerApp.state.isSpotlightActive && viewerApp.state.currentSpotlightInfo && viewerApp.state.currentSpotlightInfo.targetFabricObject === this) {
                                        hideSpotlightSVG();
                                    }
                                }
                            });
                            obj.on('mouseout', function() { 
                                if (this.customInteraction && this.customInteraction.trigger === 'clickAndHold' && this.customInteraction.action === 'spotlight') {
                                    if (viewerApp.state.isSpotlightActive && viewerApp.state.currentSpotlightInfo && viewerApp.state.currentSpotlightInfo.targetFabricObject === this) {
                                        hideSpotlightSVG();
                                    }
                                }
                            });
                        }
                        // General click, hover, and other clickAndHold actions
                        else if (trigger === 'click') {
                            obj.on('mousedown', function(options) {
                                if (this.customInteraction && this.customInteraction.trigger === 'click') {
                                    if (this._clickAndHoldTimer) { 
                                        clearTimeout(this._clickAndHoldTimer); this._clickAndHoldTimer = null;
                                    }
                                    handleOverlayInteraction(this, 'click');
                                    // Animation on click (if also configured)
                                    if (this.customAnimation && this.customAnimation.trigger === 'onClick' && this.customAnimation.type) {
                                        executeAnimation(this, this.customAnimation);
                                    }
                                    if(options.e) options.e.stopPropagation();
                                }
                            });
                        } else if (trigger === 'hover') {
                            obj.on('mouseover', function() {
                                if (this.customInteraction && this.customInteraction.trigger === 'hover') {
                                    handleOverlayInteraction(this, 'hover');
                                }
                                // Animation on hover (if also configured)
                                if (this.customAnimation && this.customAnimation.trigger === 'hover' && this.customAnimation.type) {
                                    executeAnimation(this, this.customAnimation);
                                }
                            });
                            // Optionally, add mouseout to stop/reset hover animations if needed
                            obj.on('mouseout', function() {
                                if (this.customAnimation && this.customAnimation.trigger === 'hover' && this.customAnimation.type) {
                                    stopAnimation(this); // Implement stopAnimation if needed
                                }
                            });
                        } else if (trigger === 'clickAndHold') { 
                            obj.on('mousedown', function(options) {
                                if (this.customInteraction && this.customInteraction.trigger === 'clickAndHold') { 
                                    if (this._clickAndHoldTimer) clearTimeout(this._clickAndHoldTimer);
                                    this._clickAndHoldTimer = setTimeout(() => {
                                        handleOverlayInteraction(this, 'clickAndHold');
                                        // Animation on clickAndHold (if also configured)
                                        if (this.customAnimation && this.customAnimation.trigger === 'onClick' && this.customAnimation.type) { // Assuming 'onClick' trigger for animation on hold completion
                                            executeAnimation(this, this.customAnimation);
                                        }
                                        this._clickAndHoldTimer = null;
                                    }, CLICK_AND_HOLD_DURATION);
                                }
                            });
                            const cancelGenericHold = function() {
                                if (this._clickAndHoldTimer) {
                                    clearTimeout(this._clickAndHoldTimer); this._clickAndHoldTimer = null;
                                }
                            };
                            obj.on('mouseup', cancelGenericHold);
                            obj.on('mouseout', cancelGenericHold);
                        }
                    }

                    // Animation: On Load
                    if (obj.customAnimation && obj.customAnimation.trigger === 'onLoad' && obj.customAnimation.type) {
                        // Delay slightly to ensure object is fully rendered
                        setTimeout(() => executeAnimation(obj, obj.customAnimation), 100);
                    }
                }); // End of canvas.forEachObject
                canvas.renderAll();
            }); // End of canvas.loadFromJSON
        } else if (viewerCanvasContainerEl && viewerCanvasContainerEl.style.display !== 'none') {
             if(mediaType !== 'image' && mediaType !== 'audio') { 
                 canvas.renderAll();
             }
        }
        updateSlideNavigationUI(); 
    }

    // --- Interaction & Modal Handling ---
    function handleOverlayInteraction(fabricObject, eventType) {
        if (!fabricObject.customInteraction) return;
        const interaction = fabricObject.customInteraction;

        console.log(`Interaction Triggered: type=${eventType}, action=${interaction.action}, object=${fabricObject.type}, currentOpacity=${fabricObject.opacity}`);

        if (interaction.trigger !== eventType) {
            console.log(`Interaction Mismatch: Configured trigger '${interaction.trigger}' does not match event '${eventType}'. Ignoring for this handler instance.`);
            return;
        }
        if (viewerApp.state.isSpotlightActive && interaction.action !== 'spotlight') {
            hideSpotlightSVG();
        }
         if (viewerApp.state.isCanvasPannedOrZoomed && interaction.action !== 'panZoomToTarget') {
            // If canvas is zoomed and a new, non-panZoom interaction is triggered, reset zoom.
            // Or, if the interaction is on the panZoomTargetObject itself, don't reset yet (allow modals from a zoomed object).
            if(fabricObject !== viewerApp.state.panZoomTargetObject){
                console.log("Different object clicked while panned/zoomed. Resetting zoom first."); 
                resetPanZoomWithAnimation();
            }
        }


        console.log("Handling interaction:", interaction.action, "for object:", fabricObject);

        switch (interaction.action) {
            case 'showModal':
                if (fabricObject.customInteraction && fabricObject.customInteraction.modalContent) {
                    const canvas = viewerApp.state.viewerFabricCanvas;
                    if (!canvas) break;
                    const allObjects = canvas.getObjects();
                    viewerApp.state.modalSequence = allObjects.filter(obj =>
                        obj.customInteraction &&
                        obj.customInteraction.action === 'showModal' &&
                        typeof obj.sequenceOrder === 'number' &&
                        !isNaN(obj.sequenceOrder)
                    ).sort((a, b) => a.sequenceOrder - b.sequenceOrder);
                    viewerApp.state.currentModalSequenceIndex = viewerApp.state.modalSequence.findIndex(obj => obj === fabricObject);
                    if (viewerApp.state.currentModalSequenceIndex === -1) {
                        viewerApp.state.modalSequence = [fabricObject];
                        viewerApp.state.currentModalSequenceIndex = 0;
                    }
                    viewerApp.state.currentModalOverlay = fabricObject;
                    showViewerModal(interaction.modalContent);
                    updateModalNavigationButtons();
                } else {
                     console.warn("Show Modal: modalContent missing.");
                     if(modalPrevButtonEl) modalPrevButtonEl.style.display = 'none';
                     if(modalNextButtonEl) modalNextButtonEl.style.display = 'none';
                }
                break;
            case 'navigateToSlide':
                const targetSlideId = interaction.navigateTo;
                if (targetSlideId && viewerApp.state.currentProjectData && viewerApp.state.currentProjectData.slides) {
                    const targetSlideIndex = viewerApp.state.currentProjectData.slides.findIndex(s => s.slideId === targetSlideId);
                    if (targetSlideIndex !== -1) {
                        renderSlideForViewing(targetSlideIndex);
                    } else {
                        displayMessageViewer(`Navigation error: Slide '${targetSlideId}' not found.`, false);
                    }
                }
                break;
            case 'navigateToURL':
                if (interaction.navigateTo) {
                    let url = interaction.navigateTo;
                    if (!url.startsWith('http://') && !url.startsWith('https://')) url = 'https://' + url;
                    try {
                         const newWindow = window.open(url, '_blank');
                         if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
                              displayMessageViewer("Could not open link. Check popup settings.", false);
                         }
                    } catch (e) { displayMessageViewer("Error opening link.", false); }
                }
                break;
            case 'spotlight':
                 if (viewerApp.state.isSpotlightActive && viewerApp.state.currentSpotlightInfo && viewerApp.state.currentSpotlightInfo.targetFabricObject === fabricObject) {
                     hideSpotlightSVG();
                 } else {
                     showSpotlightSVG(fabricObject, interaction);
                 }
                 break;
            case 'panZoomToTarget':
                console.log("Pan/Zoom to Target action triggered for:", fabricObject);
                if (fabricObject && viewerApp.state.viewerFabricCanvas) {
                    const canvas = viewerApp.state.viewerFabricCanvas;

                    if (!viewerApp.state.isCanvasPannedOrZoomed) { 
                        viewerApp.state.originalViewportTransform = canvas.viewportTransform.slice(); // Store the array
                        console.log("Storing original viewport transform:", viewerApp.state.originalViewportTransform);
                    }

                    const targetZoom = fabricObject.customInteraction.panZoomLevel || 1.5;
                    viewerApp.state.panZoomTargetObject = fabricObject; 

                    animatePanZoom(fabricObject, targetZoom);
                }
                break;
            case 'reveal':
                 console.log("Reveal action triggered for:", fabricObject);
                 if (fabricObject && viewerApp.state.viewerFabricCanvas) {
                      fabricObject.animate('opacity', 1, {
                          duration: 500,
                          onChange: viewerApp.state.viewerFabricCanvas.renderAll.bind(viewerApp.state.viewerFabricCanvas),
                          onComplete: () => console.log("Reveal complete. Opacity:", fabricObject.opacity)
                      });
                 }
                 break;
            default:
                console.log("Unknown interaction action:", interaction.action);
        }
    }

    function executeAnimation(fabricObject, animConfig) {
        if (!fabricObject || !animConfig || !animConfig.type) return;
        console.log(`Executing animation: ${animConfig.type} for object`, fabricObject);

        // Stop any existing animation on this object first
        stopAnimation(fabricObject);

        // Store original properties for reset
        if (!fabricObject._originalState) {
            fabricObject._originalState = {
                angle: fabricObject.angle,
                top: fabricObject.top,
                left: fabricObject.left,
                scaleX: fabricObject.scaleX,
                scaleY: fabricObject.scaleY
            };
        }
        
        // Translate speed setting to duration
        let duration = 1000; // Default: normal
        if (animConfig.speed) {
            duration = ANIMATION_SPEED_PRESETS[animConfig.speed]?.duration || 1000;
        } else if (animConfig.duration) {
            // Backward compatibility for direct duration setting
            duration = animConfig.duration;
        }
        
        // Default strength values by animation type
        let strength = animConfig.strength || getDefaultStrength(animConfig.type);
        
        // Simple AbortController-like mechanism for stopping
        const controller = { aborted: false };
        viewerApp.state.activeAnimations.set(fabricObject, controller);

        switch (animConfig.type) {
            case 'wiggle':
                animateWiggle(fabricObject, duration, strength, controller, animConfig.loop);
                break;
            case 'float':
                animateFloat(fabricObject, duration, strength, controller, animConfig.loop);
                break;
            case 'growShrink':
                animateGrowShrink(fabricObject, duration, strength, controller, animConfig.loop);
                break;
            default:
                console.warn("Unknown animation type:", animConfig.type);
                viewerApp.state.activeAnimations.delete(fabricObject);
        }
    }

    // Helper to get default strength values by animation type
    function getDefaultStrength(animationType) {
        switch (animationType) {
            case 'wiggle': return 5;      // 5 degrees
            case 'float': return 10;      // 10 pixels
            case 'growShrink': return 1.2; // 20% scale
            default: return 5;
        }
    }

    function stopAnimation(fabricObject) {
        if (viewerApp.state.activeAnimations.has(fabricObject)) {
            const controller = viewerApp.state.activeAnimations.get(fabricObject);
            controller.aborted = true;
            viewerApp.state.activeAnimations.delete(fabricObject);
            console.log("Animation stopped for object", fabricObject);

            // Option: Reset to original state if defined
            if (fabricObject._originalState) {
                fabricObject.set(fabricObject._originalState);
                viewerApp.state.viewerFabricCanvas.renderAll();
            }
        }
    }

    function animateWiggle(fabricObject, duration, strength, controller, shouldLoop) {
        const canvas = viewerApp.state.viewerFabricCanvas;
        if (!canvas) return;
        const originalAngle = fabricObject._originalState ? fabricObject._originalState.angle : fabricObject.angle;
        strength = parseFloat(strength) || 5; // degrees
        
        // Step 1: Animate from center to left
        fabricObject.animate('angle', originalAngle - strength, {
            duration: duration / 3,
            onChange: canvas.renderAll.bind(canvas),
            abort: () => controller.aborted,
            onComplete: function() {
                if (controller.aborted) { 
                    fabricObject.set('angle', originalAngle); 
                    canvas.renderAll(); 
                    viewerApp.state.activeAnimations.delete(fabricObject);
                    return; 
                }
                
                // Step 2: Animate from left to right
                fabricObject.animate('angle', originalAngle + strength, {
                    duration: duration / 3 * 2,
                    onChange: canvas.renderAll.bind(canvas),
                    abort: () => controller.aborted,
                    onComplete: function() {
                        if (controller.aborted) { 
                            fabricObject.set('angle', originalAngle); 
                            canvas.renderAll(); 
                            viewerApp.state.activeAnimations.delete(fabricObject);
                            return; 
                        }
                        
                        // Step 3: Animate from right back to center
                        fabricObject.animate('angle', originalAngle, {
                            duration: duration / 3,
                            onChange: canvas.renderAll.bind(canvas),
                            abort: () => controller.aborted,
                            onComplete: function() {
                                if (controller.aborted) { 
                                    fabricObject.set('angle', originalAngle); 
                                    canvas.renderAll(); 
                                    viewerApp.state.activeAnimations.delete(fabricObject);
                                    return; 
                                }
                                
                                // One complete cycle finished
                                console.log(`Wiggle cycle complete, shouldLoop: ${shouldLoop}`);
                                
                                if (shouldLoop === true) {
                                    // Start a new cycle with a small delay
                                    setTimeout(() => {
                                        // Check abort again during the delay
                                        if (viewerApp.state.activeAnimations.has(fabricObject) && 
                                            viewerApp.state.activeAnimations.get(fabricObject).aborted) {
                                            fabricObject.set('angle', originalAngle);
                                            canvas.renderAll();
                                            viewerApp.state.activeAnimations.delete(fabricObject);
                                            return;
                                        }
                                        
                                        // Create new controller for the next cycle
                                        const newLoopController = { aborted: false };
                                        viewerApp.state.activeAnimations.set(fabricObject, newLoopController);
                                        animateWiggle(fabricObject, duration, strength, newLoopController, shouldLoop);
                                    }, 50); // Small delay between cycles
                                } else {
                                    // Animation completed, clean up
                                    viewerApp.state.activeAnimations.delete(fabricObject);
                                    console.log(`Animation wiggle finished.`);
                                }
                            }
                        });
                    }
                });
            }
        });
    }

    function animateFloat(fabricObject, duration, strength, controller, shouldLoop) {
        const canvas = viewerApp.state.viewerFabricCanvas;
        if (!canvas) return;
        const originalTop = fabricObject._originalState ? fabricObject._originalState.top : fabricObject.top;
        strength = parseFloat(strength) || 10; // pixels
        
        // Step 1: Animate from original position upward
        fabricObject.animate('top', originalTop - strength, {
            duration: duration / 3,
            onChange: canvas.renderAll.bind(canvas),
            abort: () => controller.aborted,
            onComplete: function() {
                if (controller.aborted) { 
                    fabricObject.set('top', originalTop); 
                    canvas.renderAll(); 
                    viewerApp.state.activeAnimations.delete(fabricObject);
                    return; 
                }
                
                // Step 2: Animate from up position to down position
                fabricObject.animate('top', originalTop + (strength/2), {
                    duration: duration / 3 * 2,
                    onChange: canvas.renderAll.bind(canvas),
                    abort: () => controller.aborted,
                    onComplete: function() {
                        if (controller.aborted) { 
                            fabricObject.set('top', originalTop); 
                            canvas.renderAll(); 
                            viewerApp.state.activeAnimations.delete(fabricObject);
                            return; 
                        }
                        
                        // Step 3: Animate from down position back to original
                        fabricObject.animate('top', originalTop, {
                            duration: duration / 3,
                            onChange: canvas.renderAll.bind(canvas),
                            abort: () => controller.aborted,
                            onComplete: function() {
                                if (controller.aborted) { 
                                    fabricObject.set('top', originalTop); 
                                    canvas.renderAll(); 
                                    viewerApp.state.activeAnimations.delete(fabricObject);
                                    return; 
                                }
                                
                                // One complete cycle finished
                                console.log(`Float cycle complete, shouldLoop: ${shouldLoop}`);
                                
                                if (shouldLoop === true) {
                                    // Start a new cycle with a small delay
                                    setTimeout(() => {
                                        // Check abort again during the delay
                                        if (viewerApp.state.activeAnimations.has(fabricObject) && 
                                            viewerApp.state.activeAnimations.get(fabricObject).aborted) {
                                            fabricObject.set('top', originalTop);
                                            canvas.renderAll();
                                            viewerApp.state.activeAnimations.delete(fabricObject);
                                            return;
                                        }
                                        
                                        // Create new controller for the next cycle
                                        const newLoopController = { aborted: false };
                                        viewerApp.state.activeAnimations.set(fabricObject, newLoopController);
                                        animateFloat(fabricObject, duration, strength, newLoopController, shouldLoop);
                                    }, 50); // Small delay between cycles
                                } else {
                                    // Animation completed, clean up
                                    viewerApp.state.activeAnimations.delete(fabricObject);
                                    console.log(`Animation float finished.`);
                                }
                            }
                        });
                    }
                });
            }
        });
    }

    function animateGrowShrink(fabricObject, duration, strength, controller, shouldLoop) {
        const canvas = viewerApp.state.viewerFabricCanvas;
        if (!canvas) return;
        const originalScaleX = fabricObject._originalState ? fabricObject._originalState.scaleX : fabricObject.scaleX;
        const originalScaleY = fabricObject._originalState ? fabricObject._originalState.scaleY : fabricObject.scaleY;
        strength = parseFloat(strength) || 1.2; // scale factor
        
        // Step 1: Animate from original size to grown size
        animateScale(strength);
        
        function animateScale(targetScale) {
            fabric.util.animate({
                startValue: 1,
                endValue: targetScale,
                duration: duration / 2,
                onChange: function(value) {
                    if (controller.aborted) return;
                    // Apply scale relative to original scale
                    fabricObject.set({
                        scaleX: originalScaleX * value,
                        scaleY: originalScaleY * value
                    });
                    canvas.renderAll();
                },
                abort: () => controller.aborted,
                onComplete: function() {
                    if (controller.aborted) {
                        fabricObject.set({
                            scaleX: originalScaleX,
                            scaleY: originalScaleY
                        });
                        canvas.renderAll();
                        viewerApp.state.activeAnimations.delete(fabricObject);
                        return;
                    }
                    
                    if (targetScale > 1) {
                        // Step 2: Animate from grown size back to original
                        animateScale(1);
                    } else {
                        // Complete cycle finished
                        console.log(`GrowShrink cycle complete, shouldLoop: ${shouldLoop}`);
                        
                        if (shouldLoop === true) {
                            // Start a new cycle with a small delay
                            setTimeout(() => {
                                // Check abort again during the delay
                                if (viewerApp.state.activeAnimations.has(fabricObject) && 
                                    viewerApp.state.activeAnimations.get(fabricObject).aborted) {
                                    fabricObject.set({
                                        scaleX: originalScaleX,
                                        scaleY: originalScaleY
                                    });
                                    canvas.renderAll();
                                    viewerApp.state.activeAnimations.delete(fabricObject);
                                    return;
                                }
                                
                                // Create new controller for the next cycle
                                const newLoopController = { aborted: false };
                                viewerApp.state.activeAnimations.set(fabricObject, newLoopController);
                                animateGrowShrink(fabricObject, duration, strength, newLoopController, shouldLoop);
                            }, 50); // Small delay between cycles
                        } else {
                            // Animation completed, clean up
                            viewerApp.state.activeAnimations.delete(fabricObject);
                            console.log(`Animation growShrink finished.`);
                        }
                    }
                },
                easing: fabric.util.ease.easeInOutQuad
            });
        }
    }

    function animatePanZoom(targetObject, targetZoom) {
        const canvas = viewerApp.state.viewerFabricCanvas;
        if (!canvas || !targetObject) return;

        const animationDuration = 500; // ms
        const objectCenter = targetObject.getCenterPoint();

        // Current viewport transform components
        const vpt = canvas.viewportTransform;
        const currentZoom = vpt[0];
        const currentPanX = vpt[4];
        const currentPanY = vpt[5];

        // Calculate desired final pan to center the object AT THE TARGET ZOOM
        const finalPanX = (canvas.width / 2) - (objectCenter.x * targetZoom);
        const finalPanY = (canvas.height / 2) - (objectCenter.y * targetZoom);

        console.log(`Animating Pan/Zoom. From: Z=${currentZoom.toFixed(2)}, X=${currentPanX.toFixed(2)}, Y=${currentPanY.toFixed(2)}`);
        console.log(`Targeting: Z=${targetZoom.toFixed(2)}, X=${finalPanX.toFixed(2)}, Y=${finalPanY.toFixed(2)} for obj center (${objectCenter.x.toFixed(2)}, ${objectCenter.y.toFixed(2)})`);

        // Animate a dummy object or just use the progress value directly
        fabric.util.animate({
            startValue: 0, // Animation progress from 0%
            endValue: 1,   // to 100%
            duration: animationDuration,
            onChange: function(progress) {
                const newZoom = currentZoom + (targetZoom - currentZoom) * progress;
                const newPanX = currentPanX + (finalPanX - currentPanX) * progress;
                const newPanY = currentPanY + (finalPanY - currentPanY) * progress;

                canvas.setViewportTransform([newZoom, 0, 0, newZoom, newPanX, newPanY]);
                // Fabric's animate utility might not automatically render canvas on each tick
                // when not animating a Fabric object property directly.
                canvas.requestRenderAll(); 
            },
            onComplete: function() {
                viewerApp.state.isCanvasPannedOrZoomed = true;
                // Ensure final state is precise
                canvas.setViewportTransform([targetZoom, 0, 0, targetZoom, finalPanX, finalPanY]);
                canvas.renderAll(); // Final render
                console.log("Pan/Zoom animation complete.");
            },
            easing: fabric.util.ease.easeInOutQuad // Smoother easing
        });
    }

    function resetPanZoomWithAnimation(immediate = false) {
        const canvas = viewerApp.state.viewerFabricCanvas;

        console.log("[ResetPanZoom] Called. Immediate:", immediate);
        // ... (keep the detailed logging from the previous version here for diagnostics)
        console.log("  - canvas valid:", !!canvas);
        console.log("  - isCanvasPannedOrZoomed:", viewerApp.state.isCanvasPannedOrZoomed);
        console.log("  - originalViewportTransform type:", typeof viewerApp.state.originalViewportTransform);
        console.log("  - originalViewportTransform isArray:", Array.isArray(viewerApp.state.originalViewportTransform));
        if(Array.isArray(viewerApp.state.originalViewportTransform)) {
            console.log("  - originalViewportTransform value:", JSON.stringify(viewerApp.state.originalViewportTransform));
        } else {
            console.log("  - originalViewportTransform value: Not an array or null");
        }

        if (!canvas) {
            console.error("[ResetPanZoom] Aborting: Canvas object is null.");
            viewerApp.state.isCanvasPannedOrZoomed = false;
            viewerApp.state.panZoomTargetObject = null;
            viewerApp.state.originalViewportTransform = null;
            return;
        }
        if (!viewerApp.state.isCanvasPannedOrZoomed) {
            console.log("[ResetPanZoom] Aborting: Canvas not currently panned or zoomed (isCanvasPannedOrZoomed is false).");
            if (Array.isArray(viewerApp.state.originalViewportTransform)) {
                 console.warn("[ResetPanZoom] Inconsistent state: isCanvasPannedOrZoomed is false, but originalViewportTransform exists. Attempting hard reset to original.");
                 canvas.setViewportTransform(viewerApp.state.originalViewportTransform.slice());
                 canvas.renderAll();
            }
            viewerApp.state.isCanvasPannedOrZoomed = false;
            viewerApp.state.panZoomTargetObject = null;
            viewerApp.state.originalViewportTransform = null;
            return;
        }
        if (!Array.isArray(viewerApp.state.originalViewportTransform) || viewerApp.state.originalViewportTransform.length !== 6) {
            console.error("[ResetPanZoom] Aborting: originalViewportTransform is not a valid 6-element array. Cannot reset. Value:", viewerApp.state.originalViewportTransform);
            viewerApp.state.isCanvasPannedOrZoomed = false;
            viewerApp.state.panZoomTargetObject = null;
            if (!Array.isArray(viewerApp.state.originalViewportTransform)) {
                 viewerApp.state.originalViewportTransform = null;
            }
            return;
        }
        
        console.log("[ResetPanZoom] Conditions met, proceeding with reset.");

        const animationDuration = immediate ? 0 : 500;
        const vpt = canvas.viewportTransform;
        const currentZoom = vpt[0];
        const currentPanX = vpt[4];
        const currentPanY = vpt[5];

        const finalOriginalVPT = viewerApp.state.originalViewportTransform.slice(); // Secure a copy
        const finalZoom = finalOriginalVPT[0];
        const finalPanX = finalOriginalVPT[4];
        const finalPanY = finalOriginalVPT[5];
        
        viewerApp.state.panZoomTargetObject = null; 

        if (immediate) {
            canvas.setViewportTransform(finalOriginalVPT);
            viewerApp.state.isCanvasPannedOrZoomed = false;
            viewerApp.state.originalViewportTransform = null; 
            canvas.renderAll();
            console.log("Pan/Zoom reset immediately.");
            return;
        }

        fabric.util.animate({
            startValue: 0, // Animation progress 0%
            endValue: 1,   // to 100%
            duration: animationDuration,
            onChange: function(progress) {
                const newZoom = currentZoom + (finalZoom - currentZoom) * progress;
                const newPanX = currentPanX + (finalPanX - currentPanX) * progress;
                const newPanY = currentPanY + (finalPanY - currentPanY) * progress;
                
                canvas.setViewportTransform([newZoom, 0, 0, newZoom, newPanX, newPanY]);
                canvas.requestRenderAll();
            },
            onComplete: function() {
                canvas.setViewportTransform(finalOriginalVPT); // Ensure final state
                viewerApp.state.isCanvasPannedOrZoomed = false;
                viewerApp.state.originalViewportTransform = null; 
                canvas.renderAll(); // Final render
                console.log("Pan/Zoom reset animation complete.");
            },
            easing: fabric.util.ease.easeInOutQuad
        });
    }

    function showViewerModal(htmlContent) {
        if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = htmlContent;
        if (viewerModalEl) viewerModalEl.style.display = 'flex';
    }

    function hideViewerModal() {
        if (viewerModalEl) viewerModalEl.style.display = 'none';
        if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = '';
        viewerApp.state.currentModalOverlay = null;
        viewerApp.state.modalSequence = [];
        viewerApp.state.currentModalSequenceIndex = -1;
        if(modalPrevButtonEl) modalPrevButtonEl.style.display = 'none';
        if(modalNextButtonEl) modalNextButtonEl.style.display = 'none';
    }

    function updateModalNavigationButtons() {
         if (!modalPrevButtonEl || !modalNextButtonEl) return;
         const sequence = viewerApp.state.modalSequence;
         const currentIndex = viewerApp.state.currentModalSequenceIndex;
         if (sequence.length <= 1) {
             modalPrevButtonEl.style.display = 'none';
             modalNextButtonEl.style.display = 'none';
             return;
         }
         if (currentIndex > 0) {
             modalPrevButtonEl.disabled = false;
             modalPrevButtonEl.style.display = 'inline-block';
         } else {
             modalPrevButtonEl.disabled = true;
              modalPrevButtonEl.style.display = 'inline-block';
         }
         if (currentIndex < sequence.length - 1) {
             modalNextButtonEl.disabled = false;
             modalNextButtonEl.style.display = 'inline-block';
         } else {
             modalNextButtonEl.disabled = true;
             modalNextButtonEl.style.display = 'inline-block';
         }
     }

     function navigateModalPrevious() {
          const sequence = viewerApp.state.modalSequence;
          let currentIndex = viewerApp.state.currentModalSequenceIndex;
          if (currentIndex > 0) {
              currentIndex--;
              const prevOverlay = sequence[currentIndex];
              if (prevOverlay && prevOverlay.customInteraction && prevOverlay.customInteraction.modalContent) {
                  viewerApp.state.currentModalSequenceIndex = currentIndex;
                  viewerApp.state.currentModalOverlay = prevOverlay;
                  if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = prevOverlay.customInteraction.modalContent;
                  updateModalNavigationButtons();
                  console.log("Navigated to previous modal, index:", currentIndex);
              } else {
                   console.error("Previous overlay or its content is invalid.");
              }
          }
     }

     function navigateModalNext() {
          const sequence = viewerApp.state.modalSequence;
          let currentIndex = viewerApp.state.currentModalSequenceIndex;
          if (currentIndex < sequence.length - 1) {
              currentIndex++;
              const nextOverlay = sequence[currentIndex];
               if (nextOverlay && nextOverlay.customInteraction && nextOverlay.customInteraction.modalContent) {
                   viewerApp.state.currentModalSequenceIndex = currentIndex;
                   viewerApp.state.currentModalOverlay = nextOverlay;
                   if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = nextOverlay.customInteraction.modalContent;
                   updateModalNavigationButtons();
                    console.log("Navigated to next modal, index:", currentIndex);
               } else {
                    console.error("Next overlay or its content is invalid.");
               }
          }
     }

     // --- Spotlight SVG Functions ---
    function showSpotlightSVG(targetFabricObject, interactionData) {
        hideSpotlightSVG(); 

        const canvas = viewerApp.state.viewerFabricCanvas;
        if (!canvas || !targetFabricObject) {
            console.error("Cannot show spotlight: canvas or targetFabricObject missing.");
            return;
        }

        console.log(`[WebApp] Spotlight SVG requested for Fabric object:`, targetFabricObject);
        const targetRect = targetFabricObject.getBoundingRect(true); 
        const canvasRect = viewerFabricCanvasEl.getBoundingClientRect(); 

        const viewportLeft = canvasRect.left + targetRect.left;
        const viewportTop = canvasRect.top + targetRect.top;
        const viewportWidth = targetRect.width;
        const viewportHeight = targetRect.height;

        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("id", "spotlightSVG");
        svg.style.position = "fixed";
        svg.style.top = "0";
        svg.style.left = "0";
        svg.style.width = "100vw"; 
        svg.style.height = "100vh";
        svg.style.zIndex = "9990"; 
        svg.style.pointerEvents = "none"; 

        const mask = document.createElementNS(svgNS, "mask");
        mask.setAttribute("id", "spotlightMask");

        const bgRect = document.createElementNS(svgNS, "rect");
        bgRect.setAttribute("x", "0");
        bgRect.setAttribute("y", "0");
        bgRect.setAttribute("width", "100%");
        bgRect.setAttribute("height", "100%");
        bgRect.setAttribute("fill", "white");
        mask.appendChild(bgRect);

        const cutoutRect = document.createElementNS(svgNS, "rect");
        cutoutRect.setAttribute("x", viewportLeft);
        cutoutRect.setAttribute("y", viewportTop);
        cutoutRect.setAttribute("width", viewportWidth);
        cutoutRect.setAttribute("height", viewportHeight);
        cutoutRect.setAttribute("fill", "black"); 
        mask.appendChild(cutoutRect);
        svg.appendChild(mask);

        const dimRect = document.createElementNS(svgNS, "rect");
        dimRect.setAttribute("x", "0");
        dimRect.setAttribute("y", "0");
        dimRect.setAttribute("width", "100%");
        dimRect.setAttribute("height", "100%");
        dimRect.setAttribute("fill", "rgba(0, 0, 0, 0.75)");
        dimRect.setAttribute("mask", "url(#spotlightMask)");
        svg.appendChild(dimRect);

        document.body.appendChild(svg);

        const clickCatcher = document.createElement('div');
        clickCatcher.id = 'spotlightClickCatcher';
        clickCatcher.style.position = 'fixed';
        clickCatcher.style.top = '0';
        clickCatcher.style.left = '0';
        clickCatcher.style.width = '100vw';
        clickCatcher.style.height = '100vh';
        clickCatcher.style.zIndex = '9989'; 
        clickCatcher.style.cursor = 'pointer'; 
        clickCatcher.addEventListener('click', function(event) {
            console.log("Spotlight click catcher clicked.");
            hideSpotlightSVG();
            event.stopPropagation(); 
        });
        document.body.appendChild(clickCatcher);

        viewerApp.state.isSpotlightActive = true;
        viewerApp.state.currentSpotlightInfo = {
            svg: svg,
            clickCatcher: clickCatcher,
            targetFabricObject: targetFabricObject,
        };
        displayMessageViewer("Spotlight active. Click anywhere to dismiss.", true);
        console.log("[WebApp] SVG Spotlight activated for Fabric object:", targetFabricObject);
    }

    function hideSpotlightSVG() {
        if (!viewerApp.state.isSpotlightActive || !viewerApp.state.currentSpotlightInfo) {
            return;
        }
        console.log('[WebApp] Hiding SVG Spotlight');

        if (viewerApp.state.currentSpotlightInfo.svg) {
            document.body.removeChild(viewerApp.state.currentSpotlightInfo.svg);
        }
        if (viewerApp.state.currentSpotlightInfo.clickCatcher) {
            document.body.removeChild(viewerApp.state.currentSpotlightInfo.clickCatcher);
        }
        viewerApp.state.isSpotlightActive = false;
        viewerApp.state.currentSpotlightInfo = null;
    }
    // --- Slide Navigation ---
    function updateSlideNavigationUI() {
        console.log("updateSlideNavigationUI called. Current Index:", viewerApp.state.currentSlideIndex, "Project Data:", viewerApp.state.currentProjectData);
        if (!viewerApp.state.currentProjectData || !Array.isArray(viewerApp.state.currentProjectData.slides)) {
             console.error("updateSlideNavigationUI: Invalid project data or slides array.");
             if (viewerSlideIndicatorEl) viewerSlideIndicatorEl.textContent = "Slide ? / ?";
             if (viewerPrevSlideButtonEl) viewerPrevSlideButtonEl.disabled = true;
             if (viewerNextSlideButtonEl) viewerNextSlideButtonEl.disabled = true;
             return;
        }
        const numSlides = viewerApp.state.currentProjectData.slides.length;
        const currentIndex = viewerApp.state.currentSlideIndex;
        if (viewerSlideIndicatorEl) viewerSlideIndicatorEl.textContent = `Slide ${currentIndex + 1} / ${numSlides}`;
        if (viewerPrevSlideButtonEl) viewerPrevSlideButtonEl.disabled = (currentIndex <= 0);
        if (viewerNextSlideButtonEl) viewerNextSlideButtonEl.disabled = (currentIndex >= numSlides - 1);
    }

    function navigateToPrevSlide() {
         if (viewerApp.state.currentSlideIndex > 0) {
            renderSlideForViewing(viewerApp.state.currentSlideIndex - 1);
        }
    }
    function navigateToNextSlide() {
         if (viewerApp.state.currentProjectData && viewerApp.state.currentSlideIndex < viewerApp.state.currentProjectData.slides.length - 1) {
            renderSlideForViewing(viewerApp.state.currentSlideIndex + 1);
        }
    }

    // --- YouTube Player API Functions ---
    function onYouTubeIframeAPIReady() {
        console.log("YouTube IFrame API Ready (called by external script).");
        isYouTubeApiReady = true;
    }

    function setupYouTubePlayer(videoId) {
        if (!youtubePlayerContainerEl) {
            console.error("YouTube player container element not found."); return;
        }
        youtubePlayerContainerEl.innerHTML = '<div id="youtube-player-div" style="width: 100%; height: 100%;"></div>';
        youtubePlayerContainerEl.style.display = 'block';
        console.log("Setting up YouTube player for video ID:", videoId);
        if (!isYouTubeApiReady || typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
            console.error("YT object or YT.Player is not available or API not ready.");
            displayMessageViewer("YouTube Player API not ready. Please wait or reload.", false);
            return;
        }
        try {
             if(ytPlayer && typeof ytPlayer.destroy === 'function') {
                 console.log("Destroying previous YT player instance.");
                 ytPlayer.destroy();
                 ytPlayer = null;
             }
             console.log("Creating new YT.Player instance.");
             ytPlayer = new YT.Player('youtube-player-div', {
                height: '100%',
                width: '100%',
                videoId: videoId,
                playerVars: {
                    'autoplay': 0, 'controls': 0, 'rel': 0, 'showinfo': 0,
                    'modestbranding': 1, 'iv_load_policy': 3, 'fs': 0,
                    'disablekb': 1, 'playsinline': 1
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': onPlayerError
                }
            });
             console.log("YT.Player instance potentially created.");
        } catch (e) {
            console.error("Error creating YouTube player instance:", e);
            displayMessageViewer(`Error initializing YouTube player: ${e.message}`, false);
             if (youtubePlayerContainerEl) youtubePlayerContainerEl.style.display = 'none';
        }
    }

    function onPlayerReady(event) {
        console.log("YouTube Player Ready for video:", event.target.getVideoData().video_id);
         if(youtubePlayerContainerEl && !youtubePlayerContainerEl.hasAttribute('click-listener-added')){
             console.log("Adding click-to-play listener to YT player container.");
             youtubePlayerContainerEl.addEventListener('click', function() {
                 console.log("Player container clicked.");
                 if (ytPlayer && typeof ytPlayer.playVideo === 'function' && typeof ytPlayer.pauseVideo === 'function' && typeof ytPlayer.getPlayerState === 'function') {
                     const state = ytPlayer.getPlayerState();
                     if (state !== YT.PlayerState.PLAYING) {
                         console.log("Calling playVideo().");
                         ytPlayer.playVideo();
                     } else {
                         console.log("Calling pauseVideo().");
                         ytPlayer.pauseVideo();
                     }
                 } else {
                     console.warn("Cannot play/pause: Player or methods not available.");
                 }
             });
             youtubePlayerContainerEl.setAttribute('click-listener-added', 'true');
         }
    }

    function onPlayerStateChange(event) {
        console.log("YouTube Player State Change:", event.data);
        if (event.data === YT.PlayerState.PLAYING) {
            if (viewerApp.state.playerQuestionCheckInterval) {
                clearInterval(viewerApp.state.playerQuestionCheckInterval);
            }
            viewerApp.state.playerQuestionCheckInterval = setInterval(checkVideoTimeForQuestions, 250);
        } else if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
            // Clear interval if paused or ended, but not if paused by a question (which clears its own interval)
            // This check might need refinement if questions can be dismissed without playing.
             if (viewerApp.state.playerQuestionCheckInterval) { // Check if an interval exists
                // A bit of a heuristic: if a question was just displayed, it would have cleared the interval.
                // So, if interval still exists here, it means user paused or video ended naturally.
                clearInterval(viewerApp.state.playerQuestionCheckInterval);
                viewerApp.state.playerQuestionCheckInterval = null;
            }
        }
    }

    function onPlayerError(event) {
        console.error("YouTube Player Error Code:", event.data);
        let errorMsg = `YouTube Player Error: Code ${event.data}. `;
        switch (event.data) {
            case 2: errorMsg += "Invalid video ID."; break;
            case 5: errorMsg += "HTML5 player error."; break;
            case 100: errorMsg += "Video not found or private."; break;
            case 101: case 150: errorMsg += "Playback forbidden by owner."; break;
            default: errorMsg += "Unknown error."; break;
        }
        displayMessageViewer(errorMsg, false);
    }

    function stopAndDestroyYouTubePlayer() {
        try {
            if (ytPlayer && typeof ytPlayer.stopVideo === 'function') ytPlayer.stopVideo();
            if (ytPlayer && typeof ytPlayer.destroy === 'function') ytPlayer.destroy();
            ytPlayer = null;
        } catch (e) { console.error("Error stopping/destroying YouTube player:", e); }
        finally {
             if (youtubePlayerContainerEl) {
                 youtubePlayerContainerEl.removeAttribute('click-listener-added');
                 youtubePlayerContainerEl.innerHTML = '';
                 youtubePlayerContainerEl.style.display = 'none';
             }
             // Cleanup for question checking
            if (viewerApp.state.playerQuestionCheckInterval) {
                clearInterval(viewerApp.state.playerQuestionCheckInterval);
                viewerApp.state.playerQuestionCheckInterval = null;
            }
            viewerApp.state.currentVideoQuestions = [];
            viewerApp.state.askedQuestionIndices = [];
        }
    }

    function extractYouTubeVideoId(url) {
        if (!url) return null;
        let videoId = null;
        try {
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            videoId = (match && match[2].length === 11) ? match[2] : null;
        } catch (e) { console.error("Error extracting YouTube Video ID:", e); videoId = null; }
        console.log(`Extracted Video ID: ${videoId} from URL: ${url}`);
        return videoId;
    }

    function setupAudioPlayer(audioDataURI) {
        if (!viewerAudioPlayerEl) { console.error("Audio player element not found."); return;}
        console.log("Setting up audio player.");
        try {
             viewerAudioPlayerEl.src = audioDataURI;
             viewerAudioPlayerEl.load();
             const playPromise = viewerAudioPlayerEl.play();
             if (playPromise !== undefined) {
                 playPromise.then(() => console.log("Audio playback started."))
                          .catch(error => console.error("Audio playback failed:", error));
             }
             viewerAudioPlayerEl.style.display = 'block';
             viewerApp.state.currentAudioElement = viewerAudioPlayerEl;
        } catch (e) {
             console.error("Error setting up audio player:", e);
             displayMessageViewer("Error loading audio.", false);
        }
    }

    function stopAndClearAudioPlayer() {
        const audioPlayer = viewerApp.state.currentAudioElement || viewerAudioPlayerEl;
        if (audioPlayer) {
             try {
                 if (!audioPlayer.paused) audioPlayer.pause();
                 audioPlayer.removeAttribute('src');
                 audioPlayer.load();
                 audioPlayer.style.display = 'none';
                 console.log("Audio Player Stopped and Cleared.");
             } catch (e) { console.error("Error stopping/clearing audio player:", e); }
        }
         viewerApp.state.currentAudioElement = null;
    }

    // --- UPDATED Spotlight Functions (Step 23 - Cutout Overlay) ---
    function applySpotlightEffect(targetObject) { // This is the older version, SVG one is preferred
        const canvas = viewerApp.state.viewerFabricCanvas;
        if (!canvas) {
            console.log("Spotlight not applied: Canvas not available.");
            return;
        }
        if (viewerApp.state.spotlightOverlayObject) {
            console.log("Spotlight already active, removing previous one first.");
            removeSpotlightEffect();
        }

        console.log("Applying spotlight (cutout) effect to:", targetObject);
        viewerApp.state.spotlightOverlayObject = {}; 
        viewerApp.state.spotlightOverlayObject.target = targetObject; 

        const overlayRect = new fabric.Rect({
            left: 0,
            top: 0,
            originX: 'left',
            originY: 'top',
            width: canvas.width,
            height: canvas.height,
            fill: 'rgba(0, 0, 0, 0.75)', 
            selectable: false,
            evented: true, 
            hoverCursor: 'default',
            customInteraction: { isSpotlightDimOverlay: true }
        });
        overlayRect.on('mousedown', function(options) {
             console.log("Spotlight dim overlay clicked, removing spotlight.");
             if (options.e) options.e.stopPropagation(); 
             removeSpotlightEffect();
        });

        canvas.add(overlayRect);
        canvas.bringToFront(targetObject); 
        viewerApp.state.spotlightOverlayObject.rect = overlayRect;
        canvas.renderAll();
        displayMessageViewer("Spotlight active. Click outside the object (on the dim area) to remove.", true);
    }

    function removeSpotlightEffect() { // Older version
        const canvas = viewerApp.state.viewerFabricCanvas;
        const overlayRect = viewerApp.state.spotlightOverlayObject ? viewerApp.state.spotlightOverlayObject.rect : null;

        if (!canvas || !overlayRect) {
            return; 
        }
        console.log("Removing spotlight (cutout) effect.");
        canvas.remove(overlayRect); 
        viewerApp.state.spotlightOverlayObject = null; 
        canvas.renderAll();
    }
    // --- End UPDATED Spotlight Functions ---

    function checkVideoTimeForQuestions() {
        if (!ytPlayer || typeof ytPlayer.getCurrentTime !== 'function' || !viewerApp.state.currentVideoQuestions) {
            return;
        }
        const currentTime = ytPlayer.getCurrentTime();
        
        for (let i = 0; i < viewerApp.state.currentVideoQuestions.length; i++) {
            const question = viewerApp.state.currentVideoQuestions[i];
            if (currentTime >= question.timestamp && !viewerApp.state.askedQuestionIndices.includes(i)) {
                if(ytPlayer && typeof ytPlayer.pauseVideo === 'function') ytPlayer.pauseVideo();
                
                viewerApp.state.askedQuestionIndices.push(i);
                
                if (viewerApp.state.playerQuestionCheckInterval) {
                    clearInterval(viewerApp.state.playerQuestionCheckInterval);
                    viewerApp.state.playerQuestionCheckInterval = null; 
                }
                displayQuestion(question);
                break; 
            }
        }
    }

    function displayQuestion(question) {
        const canvas = viewerApp.state.viewerFabricCanvas;
        if (!canvas) return;

        if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'auto';

        // Background overlay for the question dialog
        const dialogWidth = canvas.width * 0.8;
        const dialogHeight = canvas.height * 0.7; // Adjust as needed, can be dynamic later
        const dialogBackground = new fabric.Rect({
            left: canvas.width / 2,
            top: canvas.height / 2,
            originX: 'center', originY: 'center',
            width: dialogWidth,
            height: dialogHeight,
            fill: 'rgba(0, 0, 0, 0.8)', // Darker fill
            rx: 10, ry: 10, // Rounded corners
            selectable: false, evented: false,
            customType: 'videoQuestionOverlay'
        });
        canvas.add(dialogBackground);

        // Question text styling
        const questionText = new fabric.Textbox(question.questionText, {
            left: dialogBackground.left, // Relative to dialogBackground center
            top: dialogBackground.top - dialogBackground.height / 2 + 40, // Position near top of dialog
            originX: 'center', originY: 'top',
            width: dialogWidth * 0.9, // Wrap text within 90% of dialog width
            fontSize: 24, // Suitable font size
            fill: '#FFFFFF', // White text
            textAlign: 'center',
            selectable: false, evented: false,
            customType: 'videoQuestionOverlay'
        });
        canvas.add(questionText);

        // Answer option styling and positioning
        const optionHeight = 40;
        const optionMargin = 15; // Increased margin for better spacing
        const optionsContainerWidth = dialogWidth * 0.8;
        
        // Calculate starting Y position for options to be centered vertically below question text
        const totalOptionsContentHeight = question.options.length * (optionHeight + optionMargin) - optionMargin;
        let startY = questionText.top + questionText.height + 30; // Initial Y below question
        
        // Adjust startY if options would overflow dialogHeight (simple centering for now)
        const remainingDialogHeight = dialogBackground.height - (questionText.top - (dialogBackground.top - dialogBackground.height/2)) - questionText.height - 20; // 20 for bottom padding
        if (totalOptionsContentHeight < remainingDialogHeight) {
            startY = questionText.top + questionText.height + (remainingDialogHeight - totalOptionsContentHeight) / 2;
        }


        question.options.forEach((optionStr, index) => {
            const optionGroupY = startY + index * (optionHeight + optionMargin);
            
            const optionRect = new fabric.Rect({
                width: optionsContainerWidth,
                height: optionHeight,
                fill: 'rgba(50, 50, 50, 0.9)', // Darker individual option background
                stroke: '#CCCCCC',
                strokeWidth: 1,
                rx: 5, ry: 5, // Rounded corners for options
                originX: 'center', originY: 'top'
            });

            const optionText = new fabric.Textbox(optionStr, {
                fontSize: 18,
                fill: '#FFFFFF',
                width: optionRect.width - 20, // Padding within the rect
                textAlign: 'center',
                originX: 'center', originY: 'center',
                top: optionRect.height / 2 // Center text vertically in rect
            });
            
            const optionGroup = new fabric.Group([optionRect, optionText], {
                left: dialogBackground.left, // Center with dialogBackground
                top: optionGroupY,
                originX: 'center', originY: 'top', // Group origin for easier positioning
                selectable: false,
                evented: true,
                customType: 'videoQuestionOverlay',
                customAnswerIndex: index,
                hoverCursor: 'pointer'
            });
            canvas.add(optionGroup);

            optionGroup.on('mousedown', function() {
                const isCorrect = (this.customAnswerIndex === question.correctOptionIndex);
                // Update optionRect fill directly (it's the first object in the group)
                this.item(0).set('fill', isCorrect ? 'rgba(0, 150, 0, 0.9)' : 'rgba(150, 0, 0, 0.9)');
                
                // Add checkmark or cross
                const feedbackSymbol = new fabric.Text(isCorrect ? '' : '', {
                    fontSize: 20,
                    fill: isCorrect ? 'lightgreen' : 'pink',
                    left: this.item(0).width / 2 - 25, // Position to the right of text
                    top: this.item(0).height / 2,    // Center vertically with text
                    originX: 'right', 
                    originY: 'center',
                    selectable: false,
                    evented: false
                });
                // Add symbol to the group so it's positioned relative to the option
                this.addWithUpdate(feedbackSymbol);
                // Ensure the symbol is visible if text is long
                this.item(1).set('width', optionRect.width - 50); // Make space for symbol

                canvas.renderAll();

                // Disable further clicks on options
                canvas.getObjects('group').forEach(obj => {
                    if (obj.customType === 'videoQuestionOverlay' && obj.customAnswerIndex !== undefined) {
                        obj.evented = false;
                    }
                });

                setTimeout(() => {
                    // Remove all question elements
                    canvas.getObjects().forEach(obj => {
                        if (obj.customType === 'videoQuestionOverlay') {
                            canvas.remove(obj);
                        }
                    });
                    if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'none';
                    canvas.renderAll();
                    
                    if(ytPlayer && typeof ytPlayer.playVideo === 'function') ytPlayer.playVideo();
                    // Interval will be restarted by onPlayerStateChange if video plays
                }, 1500); // Show feedback for 1.5 seconds
            });
        });
        canvas.renderAll();
    }

  </script>