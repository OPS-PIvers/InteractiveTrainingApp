<script>
    // Namespace for the viewer application
    window.viewerApp = {};

    // --- Global Variables ---
    let ytPlayer; // Global variable to hold the YouTube player instance

    // --- Application State ---
    viewerApp.state = {
      isLoading: false,
      currentProjectData: null, 
      currentSlideIndex: 0,
      viewerFabricCanvas: null,
      defaultCanvasWidth: 960, 
      defaultCanvasHeight: 540,
      currentAudioElement: null // Reference to the currently playing audio element
    };
  
    // --- DOM Element References ---
    let viewerProjectListContainerEl, messageAreaElViewer, loadingSpinnerElViewer;
    let viewerListViewContainerEl, viewerProjectDisplayAreaEl, viewingProjectTitleEl;
    let viewerMediaContainerEl, youtubePlayerContainerEl, // New media container refs
        viewerCanvasContainerEl, viewerFabricCanvasEl;
    let viewerPrevSlideButtonEl, viewerNextSlideButtonEl, viewerSlideIndicatorEl, backToViewerListButtonEl;
    let viewerModalEl, viewerModalCloseButtonEl, viewerModalBodyEl;
    let viewerAudioPlayerEl; // Ref for the audio element
  
    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function() {
      console.log("Viewer_JS: DOMContentLoaded event fired!");
      
      viewerApp.setupDOMReferences();
      viewerApp.attachEventListeners(); 
      
      loadViewerProjectsList(); 
      
      console.log("Viewer_JS: Initialization complete.");
    });
  
    viewerApp.setupDOMReferences = function() {
      viewerProjectListContainerEl = document.getElementById('viewerProjectListContainer');
      messageAreaElViewer = document.getElementById('messageAreaViewer'); 
      loadingSpinnerElViewer = document.getElementById('loadingSpinner'); 

      viewerListViewContainerEl = document.getElementById('viewerListViewContainer');
      viewerProjectDisplayAreaEl = document.getElementById('viewerProjectDisplayArea');
      viewingProjectTitleEl = document.getElementById('viewingProjectTitle');
      
      viewerMediaContainerEl = document.getElementById('viewerMediaContainer'); // New
      youtubePlayerContainerEl = document.getElementById('youtubePlayerContainer'); // New
      viewerCanvasContainerEl = document.getElementById('viewerCanvasContainer');
      viewerFabricCanvasEl = document.getElementById('viewerFabricCanvas');
      
      viewerPrevSlideButtonEl = document.getElementById('viewerPrevSlideButton');
      viewerNextSlideButtonEl = document.getElementById('viewerNextSlideButton');
      viewerSlideIndicatorEl = document.getElementById('viewerSlideIndicator');
      backToViewerListButtonEl = document.getElementById('backToViewerListButton');

      viewerModalEl = document.getElementById('viewerModal');
      viewerModalCloseButtonEl = document.getElementById('viewerModalCloseButton');
      viewerModalBodyEl = document.getElementById('viewerModalBody');

      viewerAudioPlayerEl = document.getElementById('viewerAudioPlayer'); // New Audio Ref
  
      if (!viewerProjectListContainerEl) console.error("CRITICAL: viewerProjectListContainerEl not found!");
      if (!viewerModalEl) console.error("CRITICAL: viewerModalEl not found!");
      if (!viewerAudioPlayerEl) console.error("CRITICAL: viewerAudioPlayerEl not found!");
      console.log("Viewer_JS: DOM references set up.");
    };

    viewerApp.attachEventListeners = function() {
        if (backToViewerListButtonEl) backToViewerListButtonEl.addEventListener('click', showProjectListView);
        if (viewerPrevSlideButtonEl) viewerPrevSlideButtonEl.addEventListener('click', navigateToPrevSlide);
        if (viewerNextSlideButtonEl) viewerNextSlideButtonEl.addEventListener('click', navigateToNextSlide);
        if (viewerModalCloseButtonEl) viewerModalCloseButtonEl.addEventListener('click', hideViewerModal);
        if (viewerModalEl) { // Close modal if background is clicked
            viewerModalEl.addEventListener('click', function(event) {
                if (event.target === viewerModalEl) {
                    hideViewerModal();
                }
            });
        }
    };
  
    // --- UI Utils & Server Error Handling ---
    function showLoadingViewer(show) {
      viewerApp.state.isLoading = show;
      if (loadingSpinnerElViewer) {
        loadingSpinnerElViewer.style.display = show ? 'flex' : 'none';
      } else if (show) { 
          console.warn("showLoadingViewer(true) called but loadingSpinnerElViewer not yet available.");
      }
    }
  
    function displayMessageViewer(message, isSuccess) {
      if (messageAreaElViewer) {
        messageAreaElViewer.innerHTML = ''; 
        const p = document.createElement('p');
        p.textContent = message;
        messageAreaElViewer.appendChild(p);
        messageAreaElViewer.className = isSuccess ? 'success' : 'error'; 
        setTimeout(() => {
          if (messageAreaElViewer) {
            messageAreaElViewer.innerHTML = '';
            messageAreaElViewer.className = '';
          }
        }, 7000); 
      } else {
        console.warn("displayMessageViewer called but messageAreaElViewer not available. Message:", message);
      }
    }
    
    function onServerErrorViewer(errorObject) {
      showLoadingViewer(false);
      console.error('Viewer Server Error Object:', errorObject);
      let errorMessage = "An unknown error occurred on the server.";
      if (typeof errorObject === 'string') { 
          errorMessage = errorObject;
      } else if (errorObject && errorObject.message && typeof errorObject.message === 'string') { 
          errorMessage = errorObject.message;
      } else if (errorObject && errorObject.name && errorObject.message) { 
          errorMessage = `Error: ${errorObject.name} - ${errorObject.message}`;
      } else if (errorObject && errorObject.error && typeof errorObject.error === 'string') { // Handle {success:false, error:"..."}
          errorMessage = errorObject.error;
      }
      displayMessageViewer('Server Error: ' + errorMessage, false);
    }
  
    // --- Project List Loading/Display ---
    function loadViewerProjectsList() {
      console.log("loadViewerProjectsList called");
      if (!google || !google.script || !google.script.run) {
        console.error("google.script.run is not available for loadViewerProjectsList!");
        displayMessageViewer("Error: Client-server communication bridge unavailable.", false); return;
      }
      if (!viewerProjectListContainerEl) {
          console.warn("loadViewerProjectsList: viewerProjectListContainerEl not ready yet.");
          showLoadingViewer(false);
          return; 
      }
      showLoadingViewer(true);
      google.script.run
        .withSuccessHandler(displayViewerProjects)
        .withFailureHandler(onServerErrorViewer)
        .getActiveProjectsList(); 
    }
  
    function displayViewerProjects(projectsArray) {
      showLoadingViewer(false);
      console.log("displayViewerProjects received:", projectsArray ? projectsArray.length : 0, "projects");
      if (!viewerProjectListContainerEl) {
          console.error("displayViewerProjects: viewerProjectListContainerEl is not found!");
          return;
      }
      viewerProjectListContainerEl.innerHTML = ''; 
      if (!projectsArray || projectsArray.length === 0) {
        viewerProjectListContainerEl.innerHTML = '<p>No active training modules found at this time.</p>';
        return;
      }
  
      const ul = document.createElement('ul');
      ul.className = 'project-list-viewer'; 
  
      projectsArray.forEach(project => {
        if (!project || !project.projectId) { 
            console.warn("Skipping display of invalid project object:", project);
            return; 
        }
        const listItem = document.createElement('li');
        listItem.className = 'project-card-viewer'; 
        
        const titleHeader = document.createElement('h3');
        titleHeader.textContent = project.projectTitle || 'Untitled Project';
        
        const viewButton = document.createElement('button');
        viewButton.textContent = 'View Project';
        viewButton.className = 'view-project-button'; 
        viewButton.setAttribute('data-project-id', project.projectId); 
        viewButton.onclick = function() { 
          console.log("View Project button clicked for project ID:", project.projectId);
          loadProjectForViewing(project.projectId);
        };
  
        listItem.appendChild(titleHeader);
        listItem.appendChild(viewButton);
        ul.appendChild(listItem);
      });
      viewerProjectListContainerEl.appendChild(ul);
    }

    // --- View Switching & Cleanup ---
    function showProjectListView() {
        if (viewerListViewContainerEl) viewerListViewContainerEl.style.display = 'block';
        if (viewerProjectDisplayAreaEl) viewerProjectDisplayAreaEl.style.display = 'none';
        
        // Cleanup media players
        stopAndDestroyYouTubePlayer();
        stopAndClearAudioPlayer();

        if (viewerApp.state.viewerFabricCanvas) {
            viewerApp.state.viewerFabricCanvas.dispose();
            viewerApp.state.viewerFabricCanvas = null;
        }
        viewerApp.state.currentProjectData = null;
        viewerApp.state.currentSlideIndex = 0;
        loadViewerProjectsList(); 
    }

    function showProjectView() {
        if (viewerListViewContainerEl) viewerListViewContainerEl.style.display = 'none';
        if (viewerProjectDisplayAreaEl) viewerProjectDisplayAreaEl.style.display = 'block';
    }

    // --- Project Data Loading ---
    function loadProjectForViewing(projectId) {
        if (!projectId) {
            displayMessageViewer("Invalid project ID.", false);
            return;
        }
        showLoadingViewer(true);
        displayMessageViewer("Loading project...", true);
        google.script.run
            .withSuccessHandler(onProjectViewDataReceived)
            .withFailureHandler(onServerErrorViewer)
            .getProjectViewData(projectId);
    }

    function onProjectViewDataReceived(response) {
        showLoadingViewer(false);
        if (!response || !response.success || !response.data) {
            onServerErrorViewer(response || { error: "Failed to load project data or project is not active." });
             showProjectListView(); // Go back to list on error
            return;
        }
        try {
            viewerApp.state.currentProjectData = JSON.parse(response.data);
             // Ensure slides array exists and has slideMedia initialized
             if (viewerApp.state.currentProjectData && Array.isArray(viewerApp.state.currentProjectData.slides)) {
                 viewerApp.state.currentProjectData.slides.forEach(slide => {
                    if (!slide.slideMedia) {
                        slide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
                    }
                 });
             } else {
                 throw new Error("Project data is missing slides array.");
             }

            if (viewerApp.state.currentProjectData.slides.length === 0) {
                displayMessageViewer("Project loaded, but it has no slides.", false);
                 showProjectListView(); // Go back to list if project is empty
                return;
            }

            console.log("Project for viewing loaded:", viewerApp.state.currentProjectData);
            viewerApp.state.currentSlideIndex = 0;
            showProjectView();
            if (viewingProjectTitleEl) viewingProjectTitleEl.textContent = viewerApp.state.currentProjectData.title || "Untitled Project";
            initializeViewerCanvas(); // Initialize canvas once per project load
            renderSlideForViewing(viewerApp.state.currentSlideIndex); // Render the first slide
            displayMessageViewer("Project loaded.", true);
        } catch (e) {
            console.error("Error parsing project data for viewing:", e);
            displayMessageViewer("Error loading project: Invalid data format.", false);
            viewerApp.state.currentProjectData = null;
             showProjectListView(); // Go back to list on error
        }
    }

    // --- Canvas & Slide Rendering ---
    function initializeViewerCanvas() {
        if (viewerApp.state.viewerFabricCanvas) {
            viewerApp.state.viewerFabricCanvas.dispose();
            viewerApp.state.viewerFabricCanvas = null;
        }
        if (!viewerFabricCanvasEl) {
            console.error("Viewer Fabric canvas element not found!");
            return;
        }
        try {
            viewerApp.state.viewerFabricCanvas = new fabric.Canvas(viewerFabricCanvasEl, {
                width: viewerApp.state.defaultCanvasWidth,
                height: viewerApp.state.defaultCanvasHeight,
                selection: false, 
                hoverCursor: 'default',
                backgroundColor: 'transparent' // Default to transparent for layering
            });
             // Make canvas non-interactive for drawing selection, etc.
            viewerApp.state.viewerFabricCanvas.selection = false;
            viewerApp.state.viewerFabricCanvas.renderAll(); // Initial render
            console.log("Viewer canvas initialized.");
        } catch(e) {
            console.error("Error initializing viewer Fabric canvas:", e);
            displayMessageViewer("Error initializing display canvas.", false);
        }
    }

    function renderSlideForViewing(slideIndex) {
        if (!viewerApp.state.currentProjectData || !viewerApp.state.viewerFabricCanvas) {
            console.error("Cannot render slide: Project data or canvas not ready."); return;
        }
        const slides = viewerApp.state.currentProjectData.slides;
        if (slideIndex < 0 || slideIndex >= slides.length) {
            console.error("Invalid slide index:", slideIndex); return;
        }
        
        // --- Cleanup Previous Slide Media FIRST ---
        stopAndDestroyYouTubePlayer(); 
        stopAndClearAudioPlayer();

        viewerApp.state.currentSlideIndex = slideIndex;
        const slideData = slides[slideIndex];
        const canvas = viewerApp.state.viewerFabricCanvas;

        // Ensure slideMedia exists
         if (!slideData.slideMedia) {
            slideData.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
         }

        // Set canvas dimensions and container dimensions
        const slideWidth = slideData.canvasWidth || viewerApp.state.defaultCanvasWidth;
        const slideHeight = slideData.canvasHeight || viewerApp.state.defaultCanvasHeight;
        canvas.setWidth(slideWidth);
        canvas.setHeight(slideHeight);
        if (viewerFabricCanvasEl) { 
            viewerFabricCanvasEl.width = slideWidth;
            viewerFabricCanvasEl.height = slideHeight;
        }
        // Adjust media container size to match canvas/slide aspect ratio
        if (viewerMediaContainerEl) {
            viewerMediaContainerEl.style.width = slideWidth + 'px';
             viewerMediaContainerEl.style.height = slideHeight + 'px'; 
        }
        
        // Clear canvas objects and background image
        canvas.clear(); 
        canvas.setBackgroundImage(null, () => { canvas.renderAll(); }); // Ensure BG cleared before loading new one
        canvas.backgroundColor = 'transparent'; // Default transparent for layering

        // Load Media based on type
        const media = slideData.slideMedia;
        let mediaType = (media && media.type) ? media.type : 'none';
        console.log(`Rendering slide ${slideIndex + 1}, media type: ${mediaType}`);

        // Hide all media containers initially
        if (youtubePlayerContainerEl) youtubePlayerContainerEl.style.display = 'none';
        if (viewerAudioPlayerEl) viewerAudioPlayerEl.style.display = 'none'; 

        switch(mediaType) {
            case 'image':
                // Assuming URL is base64 for images loaded via admin interface
                if (media.url && media.url.startsWith('data:image')) {
                    fabric.Image.fromURL(media.url, function(img) {
                        if (!viewerApp.state.viewerFabricCanvas || viewerApp.state.currentSlideIndex !== slideIndex) return; 
                        canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                            scaleX: canvas.width / img.width, scaleY: canvas.height / img.height
                        });
                    }, { crossOrigin: 'anonymous' });
                } else {
                     console.warn("Image media present but URL is missing or not base64:", media.url);
                     canvas.backgroundColor = '#e9e9e9'; // Fallback BG
                     canvas.renderAll(); // Render fallback immediately
                }
                break;

            case 'youtube':
                if (media.url) {
                    const videoId = extractYouTubeVideoId(media.url);
                    if (videoId) {
                        if (youtubePlayerContainerEl) youtubePlayerContainerEl.style.display = 'block';
                        setupYouTubePlayer(videoId); // This function now handles creating the player
                         canvas.backgroundColor = 'transparent'; // Ensure canvas overlay is transparent
                         canvas.renderAll(); // Re-render canvas to ensure transparency
                    } else {
                        console.error("Could not extract YouTube Video ID from URL:", media.url);
                         canvas.backgroundColor = '#555'; // Error state background
                         canvas.renderAll(); // Render error background
                    }
                } else {
                     console.warn("YouTube media type set but URL is missing.");
                     canvas.backgroundColor = '#e9e9e9'; // Fallback BG
                     canvas.renderAll(); // Render fallback
                }
                break;

            case 'audio':
                 if (media.driveFileId) { // Use Drive File ID to fetch base64 data
                     console.log("Audio media needs fetch from Drive ID:", media.driveFileId);
                     showLoadingViewer(true); // Show spinner while fetching audio data
                     google.script.run
                         .withSuccessHandler(function(audioResponse) {
                             showLoadingViewer(false);
                             if (viewerApp.state.currentSlideIndex !== slideIndex) return; // Slide changed
                             if (audioResponse && audioResponse.success && audioResponse.base64Data) {
                                 setupAudioPlayer(audioResponse.base64Data); // Use base64 data URI
                                 if (viewerAudioPlayerEl) viewerAudioPlayerEl.style.display = 'block'; // Show controls
                                 canvas.backgroundColor = '#e0e0e0'; // Neutral background for audio slides
                                 canvas.renderAll(); // Render BG change
                             } else {
                                 console.error("Failed to fetch audio base64 data:", audioResponse);
                                 onServerErrorViewer(audioResponse || {error: "Failed to load audio data."});
                                 canvas.backgroundColor = '#e9e9e9'; // Fallback BG
                                 canvas.renderAll(); // Render fallback
                             }
                         })
                         .withFailureHandler(function(error) { // Separate failure handler for audio fetch
                             showLoadingViewer(false);
                             onServerErrorViewer(error);
                             canvas.backgroundColor = '#e9e9e9'; // Fallback BG
                             canvas.renderAll(); // Render fallback
                         })
                         .getAudioAsBase64(media.driveFileId);
                 } else {
                     console.warn("Audio media type set but driveFileId is missing.");
                     canvas.backgroundColor = '#e9e9e9'; // Fallback BG
                     canvas.renderAll(); // Render fallback BG immediately
                 }
                 break;

            default: // 'none' or unknown
                 canvas.backgroundColor = '#e9e9e9'; // Standard empty background
                 canvas.renderAll(); // Render background
                 break;
        }
        
        // Load Fabric objects (overlays) - AFTER background/media setup
        if (slideData.fabricCanvasJSON) {
            canvas.loadFromJSON(slideData.fabricCanvasJSON, function() {
                if (viewerApp.state.currentSlideIndex !== slideIndex) return; 
                
                canvas.forEachObject(function(obj) {
                    obj.selectable = false; 
                    obj.evented = true;    
                    obj.hoverCursor = 'pointer'; 

                    // Remove potentially duplicated listeners first
                    obj.off('mousedown');
                    obj.off('mouseover');

                    // Attach interaction listeners
                    if (obj.customInteraction && obj.customInteraction.trigger) {
                        if (obj.customInteraction.trigger === 'click') {
                            obj.on('mousedown', function(options) { 
                                if (this.customInteraction.trigger === 'click') {
                                    handleOverlayInteraction(this, 'click');
                                    if(options.e) options.e.stopPropagation(); 
                                }
                            });
                        } else if (obj.customInteraction.trigger === 'hover') {
                             obj.on('mouseover', function() {
                                if (this.customInteraction.trigger === 'hover') {
                                    handleOverlayInteraction(this, 'hover');
                                }
                            });
                        }
                    }
                });
                // Final render after objects loaded and listeners attached
                canvas.renderAll(); 
            });
        } else {
             // Canvas background/color already rendered in switch statement
             // canvas.renderAll(); // Might be redundant
        }
        updateSlideNavigationUI();
    }

    // --- Interaction & Modal Handling ---
    function handleOverlayInteraction(fabricObject, eventType) {
        if (!fabricObject.customInteraction) return;
        const interaction = fabricObject.customInteraction;

        if (interaction.trigger !== eventType) return; 

        console.log("Handling interaction:", interaction.action, "for object:", fabricObject);

        switch (interaction.action) {
            case 'showModal':
                if (interaction.modalContent) {
                    showViewerModal(interaction.modalContent);
                }
                break;
            case 'navigateToSlide':
                const targetSlideId = interaction.navigateTo;
                if (targetSlideId && viewerApp.state.currentProjectData && viewerApp.state.currentProjectData.slides) {
                    const targetSlideIndex = viewerApp.state.currentProjectData.slides.findIndex(s => s.slideId === targetSlideId);
                    if (targetSlideIndex !== -1) {
                        renderSlideForViewing(targetSlideIndex);
                    } else {
                        console.warn("NavigateToSlide: Target slide ID not found:", targetSlideId);
                        displayMessageViewer(`Navigation error: Slide '${targetSlideId}' not found.`, false);
                    }
                }
                break;
            case 'navigateToURL':
                if (interaction.navigateTo) {
                    let url = interaction.navigateTo;
                    if (!url.startsWith('http://') && !url.startsWith('https://')) {
                        url = 'https://' + url; // Default to https
                    }
                    try {
                         const newWindow = window.open(url, '_blank');
                         if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
                              displayMessageViewer("Could not open link. Please check browser popup settings.", false);
                         }
                    } catch (e) {
                         console.error("Error opening URL:", e);
                         displayMessageViewer("Error opening link.", false);
                    }
                }
                break;
            default:
                console.log("Unknown or no action defined for this interaction.");
        }
    }

    function showViewerModal(htmlContent) {
        if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = htmlContent;
        if (viewerModalEl) viewerModalEl.style.display = 'flex'; 
    }

    function hideViewerModal() {
        if (viewerModalEl) viewerModalEl.style.display = 'none';
        if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = ''; 
    }
    
    // --- Slide Navigation ---
    function updateSlideNavigationUI() {
        if (!viewerApp.state.currentProjectData || !viewerApp.state.currentProjectData.slides) return;
        const numSlides = viewerApp.state.currentProjectData.slides.length;
        const currentIndex = viewerApp.state.currentSlideIndex;

        if (viewerSlideIndicatorEl) viewerSlideIndicatorEl.textContent = `Slide ${currentIndex + 1} / ${numSlides}`;
        if (viewerPrevSlideButtonEl) viewerPrevSlideButtonEl.disabled = (currentIndex === 0);
        if (viewerNextSlideButtonEl) viewerNextSlideButtonEl.disabled = (currentIndex >= numSlides - 1);
    }

    function navigateToPrevSlide() {
         if (viewerApp.state.currentSlideIndex > 0) {
            renderSlideForViewing(viewerApp.state.currentSlideIndex - 1);
        }
    }
    function navigateToNextSlide() {
         if (viewerApp.state.currentProjectData && viewerApp.state.currentSlideIndex < viewerApp.state.currentProjectData.slides.length - 1) {
            renderSlideForViewing(viewerApp.state.currentSlideIndex + 1);
        }
    }


    // --- YouTube Player API Functions ---
    // This global function MUST exist for the API script to call
    function onYouTubeIframeAPIReady() {
        console.log("YouTube IFrame API Ready (called by external script).");
        // Player is created later by setupYouTubePlayer when needed
    }

    function setupYouTubePlayer(videoId) {
        if (!youtubePlayerContainerEl) {
            console.error("YouTube player container element not found."); return;
        }
        // Ensure container is empty and visible before creating player
        youtubePlayerContainerEl.innerHTML = '<div id="youtube-player-div"></div>'; // Target for YT Player constructor
        youtubePlayerContainerEl.style.display = 'block';
        
        console.log("Setting up YouTube player for video ID:", videoId);
        
        // Check if YT object and Player constructor are available
        if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
            console.error("YT object or YT.Player is not available. API might not be fully loaded yet.");
            displayMessageViewer("YouTube Player API not ready. Please wait and try again.", false);
            // Optionally, retry after a short delay
            // setTimeout(() => setupYouTubePlayer(videoId), 500); 
            return;
        }

        try {
             // Ensure previous player is destroyed if somehow it exists
             if(ytPlayer && typeof ytPlayer.destroy === 'function') {
                 console.log("Destroying previous YT player instance.");
                 ytPlayer.destroy();
                 ytPlayer = null;
             }
             console.log("Creating new YT.Player instance.");
             ytPlayer = new YT.Player('youtube-player-div', {
                height: '100%', 
                width: '100%', 
                videoId: videoId,
                playerVars: { // More restrictive player vars matching working example
                    'autoplay': 0,        // Keep autoplay off (Essential)
                    'controls': 0,        // **** Disable default controls ****
                    'rel': 0,             // Keep off
                    'showinfo': 0,        // Keep off
                    'modestbranding': 1,  // Keep on
                    'iv_load_policy': 3,  // Keep annotations off
                    'fs': 0,              // **** Keep fullscreen disabled ****
                    'disablekb': 1,       // **** Keep keyboard disabled ****
                    'playsinline': 1      // Keep playsinline
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': onPlayerError 
                }
            });
             console.log("YT.Player instance potentially created (check console for errors/readiness).");
        } catch (e) {
            console.error("Error creating YouTube player instance:", e);
            displayMessageViewer(`Error initializing YouTube player: ${e.message}`, false);
             if (youtubePlayerContainerEl) youtubePlayerContainerEl.style.display = 'none'; // Hide container on error
        }
    }

    function onPlayerReady(event) {
        // Autoplay is off, so just log readiness. User needs to click play.
        console.log("YouTube Player Ready for video:", event.target.getVideoData().video_id);
        // Since default controls are off, we might need custom play button or start video programmatically on first interaction
        // For now, user cannot play it easily. We need custom controls or different playerVars.
        // Let's try playing it here to see if the permissions issue is gone, even if controls are hidden
        // event.target.playVideo(); // Try playing it now that it's ready
        
         // Add an event listener to the container to play on click as substitute for controls
         if(youtubePlayerContainerEl && !youtubePlayerContainerEl.hasAttribute('click-listener-added')){
             youtubePlayerContainerEl.addEventListener('click', function() {
                 if (ytPlayer && typeof ytPlayer.playVideo === 'function' && ytPlayer.getPlayerState() !== YT.PlayerState.PLAYING) {
                     ytPlayer.playVideo();
                 }
             });
             youtubePlayerContainerEl.setAttribute('click-listener-added', 'true');
         }


    }

    function onPlayerStateChange(event) {
        console.log("YouTube Player State Change:", event.data, "(Playing:", YT.PlayerState.PLAYING, "Paused:", YT.PlayerState.PAUSED, "Ended:", YT.PlayerState.ENDED, ")");
    }

    function onPlayerError(event) {
        console.error("YouTube Player Error Code:", event.data);
        let errorMsg = `YouTube Player Error: Code ${event.data}. `;
        // Provide more context based on common error codes
        switch (event.data) {
            case 2: errorMsg += "Invalid video ID."; break;
            case 5: errorMsg += "HTML5 player error."; break;
            case 100: errorMsg += "Video not found or private."; break;
            case 101: 
            case 150: errorMsg += "Playback forbidden by owner."; break;
            default: errorMsg += "Unknown error."; break;
        }
        displayMessageViewer(errorMsg, false);
    }

    function stopAndDestroyYouTubePlayer() {
        try {
            // Check if ytPlayer exists and has the necessary methods before calling them
            if (ytPlayer && typeof ytPlayer.stopVideo === 'function') {
                ytPlayer.stopVideo();
                console.log("Called ytPlayer.stopVideo()");
            } else {
                 // console.log("ytPlayer.stopVideo not available or ytPlayer is null.");
            }
            if (ytPlayer && typeof ytPlayer.destroy === 'function') {
                ytPlayer.destroy();
                 console.log("YouTube Player Destroyed.");
            } else {
                 // console.log("ytPlayer.destroy not available or ytPlayer is null.");
            }
             ytPlayer = null; // Clear the global reference
        } catch (e) {
            console.error("Error stopping/destroying YouTube player:", e);
        } finally {
             // Always try to hide the container and remove click listener
             if (youtubePlayerContainerEl) {
                 youtubePlayerContainerEl.innerHTML = ''; 
                 youtubePlayerContainerEl.style.display = 'none';
                 youtubePlayerContainerEl.removeAttribute('click-listener-added'); // Clean up listener flag
                 // Consider explicitly removing the listener if needed, although removing innerHTML might suffice
             }
        }
    }

    function extractYouTubeVideoId(url) {
        if (!url) return null;
        let videoId = null;
        try {
            // Handle various YouTube URL formats
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            videoId = (match && match[2].length === 11) ? match[2] : null;
        } catch (e) {
            console.error("Error extracting YouTube Video ID with Regex:", e);
            videoId = null;
        }
        console.log(`Extracted Video ID: ${videoId} from URL: ${url}`);
        return videoId;
    }

     // --- Audio Player Functions ---
    function setupAudioPlayer(audioDataURI) { // Now expects base64 data URI
        if (!viewerAudioPlayerEl) { console.error("Audio player element not found."); return;}
        console.log("Setting up audio player with base64 data URI.");
        try {
             viewerAudioPlayerEl.src = audioDataURI;
             viewerAudioPlayerEl.load(); 
             const playPromise = viewerAudioPlayerEl.play();
             if (playPromise !== undefined) {
                 playPromise.then(() => {
                     console.log("Audio playback started.");
                 }).catch(error => { 
                     console.error("Audio playback failed (likely autoplay blocked):", error);
                     // Don't show confusing message if source loaded fine but autoplay blocked
                     // displayMessageViewer("Audio couldn't autoplay. Use controls.", false); 
                  }); 
             }
             // Always show controls for audio
             viewerAudioPlayerEl.style.display = 'block'; 
             viewerApp.state.currentAudioElement = viewerAudioPlayerEl; // Store ref
        } catch (e) {
             console.error("Error setting up audio player:", e);
             displayMessageViewer("Error loading audio.", false);
        }
    }

    function stopAndClearAudioPlayer() {
        const audioPlayer = viewerApp.state.currentAudioElement || viewerAudioPlayerEl; // Get ref
        if (audioPlayer) {
             try {
                 if (!audioPlayer.paused) {
                     audioPlayer.pause();
                 }
                 audioPlayer.removeAttribute('src'); 
                 audioPlayer.load(); 
                 audioPlayer.style.display = 'none'; 
                 console.log("Audio Player Stopped and Cleared.");
             } catch (e) {
                  console.error("Error stopping/clearing audio player:", e);
             }
        }
         viewerApp.state.currentAudioElement = null; // Clear ref
    }

  </script>