<script>
    // Namespace for the viewer application
    window.viewerApp = {};

    // --- Global Variables ---
    // let ytPlayer; // Global variable to hold the YouTube player instance - MOVED to viewerApp.state.ytPlayer
    let isYouTubeApiReady = false; // Flag to track API readiness
    const CLICK_AND_HOLD_DURATION = 750; // Milliseconds for click and hold
    // Animation speed presets - duration for a complete animation cycle
    const ANIMATION_SPEED_PRESETS = {
      slow: { duration: 1500 },     // 1.5 seconds per cycle
      normal: { duration: 1000 },   // 1 second per cycle
      fast: { duration: 500 }       // 0.5 seconds per cycle
    };

    // --- Application State ---
    viewerApp.state = {
      isLoading: false,
      currentProjectData: null,
      currentSlideIndex: 0, // Default to 0, will be updated
      currentMediaType: null, // Added to store current media type
      viewerFabricCanvas: null,
      defaultCanvasWidth: 960,
      defaultCanvasHeight: 540,
      currentAudioElement: null, // Reference to the currently playing audio element
      // State for Modal Sequencing (Step 21)
      currentModalOverlay: null, // The Fabric object that triggered the current modal sequence
      modalSequence: [],         // Array of Fabric objects in the current sequence on the slide
      currentModalSequenceIndex: -1, // Index within modalSequence being displayed
      // --- State for Spotlight Overlay ---
      isSpotlightActive: false,
      currentSpotlightInfo: null, // Will hold { svg, clickCatcher, targetFabricObject, textBubble, notesPanel }
      // --- State for Pan/Zoom ---
      originalViewportTransform: null, // To store [zoom, 0, 0, zoom, panX, panY]
      isCanvasPannedOrZoomed: false,
      panZoomTargetObject: null, 
      activeAnimations: new Map(),
      currentVideoQuestions: [], // Stores questions for the current video
      playerQuestionCheckInterval: null, // Interval ID for checking video time
      askedQuestionIndices: [], // Indices of questions already asked for the current slide view
      currentTimestampOverlays: [], // Stores full overlay definitions for the current slide
      activeTimestampOverlayIds: new Set(), // Stores IDs of currently displayed timestamp overlays
      currentVideoDuration: 0, // Phase 1: Store current video duration for timeline
      ytPlayer: null, // Holds the YouTube player instance
      deferredYouTubeVideoId: null // Stores videoId if player setup is deferred
    };

    // Add callback for when YouTube API is ready
    viewerApp.onYouTubeApiReady = function() {
      isYouTubeApiReady = true;
      console.log("YouTube API is now ready for use");
      if (viewerApp.state.deferredYouTubeVideoId) {
          console.log("Deferred YouTube video found, setting up player for:", viewerApp.state.deferredYouTubeVideoId);
          setupYouTubePlayer(viewerApp.state.deferredYouTubeVideoId);
          viewerApp.state.deferredYouTubeVideoId = null; // Clear after setup
      }
    };

    // --- DOM Element References ---
    let viewerProjectListContainerEl, messageAreaElViewer, loadingSpinnerElViewer;
    let viewerListViewContainerEl, viewerProjectDisplayAreaEl, viewingProjectTitleEl;
    let viewerMediaContainerEl, youtubePlayerContainerEl, // New media container refs
        viewerCanvasContainerEl, viewerFabricCanvasEl;
    let viewerPrevSlideButtonEl, viewerNextSlideButtonEl, viewerSlideIndicatorEl, backToViewerListButtonEl;
    let viewerModalEl, viewerModalCloseButtonEl, viewerModalBodyEl,
        modalPrevButtonEl, modalNextButtonEl; // Modal Nav Buttons (Step 21)
    let viewerAudioPlayerEl; // Ref for the audio element

    // Phase 1: Timeline Elements
    let viewerVideoTimelineContainerEl, viewerTimelineTrackEl, viewerTimelineProgressEl,
        viewerCurrentTimeEl, viewerTotalDurationEl;

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function() {
      console.log("Viewer_JS: DOMContentLoaded event fired!");

      viewerApp.setupDOMReferences();
      viewerApp.attachEventListeners();

      loadViewerProjectsList();

      console.log("Viewer_JS: Initialization complete.");
    });

    viewerApp.setupDOMReferences = function() {
      viewerProjectListContainerEl = document.getElementById('viewerProjectListContainer');
      messageAreaElViewer = document.getElementById('messageAreaViewer');
      loadingSpinnerElViewer = document.getElementById('loadingSpinner');

      viewerListViewContainerEl = document.getElementById('viewerListViewContainer');
      viewerProjectDisplayAreaEl = document.getElementById('viewerProjectDisplayArea');
      viewingProjectTitleEl = document.getElementById('viewingProjectTitle');

      viewerMediaContainerEl = document.getElementById('viewerMediaContainer');
      youtubePlayerContainerEl = document.getElementById('youtubePlayerContainer');
      viewerCanvasContainerEl = document.getElementById('viewerCanvasContainer'); // Container for the canvas
      viewerFabricCanvasEl = document.getElementById('viewerFabricCanvas'); // The actual canvas element

      viewerPrevSlideButtonEl = document.getElementById('viewerPrevSlideButton');
      viewerNextSlideButtonEl = document.getElementById('viewerNextSlideButton');
      viewerSlideIndicatorEl = document.getElementById('viewerSlideIndicator');
      backToViewerListButtonEl = document.getElementById('backToViewerListButton');

      viewerModalEl = document.getElementById('viewerModal');
      viewerModalCloseButtonEl = document.getElementById('viewerModalCloseButton');
      viewerModalBodyEl = document.getElementById('viewerModalBody');
      modalPrevButtonEl = document.getElementById('modalPrevButton'); // Step 21
      modalNextButtonEl = document.getElementById('modalNextButton'); // Step 21

      viewerAudioPlayerEl = document.getElementById('viewerAudioPlayer');

      // Phase 1: Timeline Elements
      viewerVideoTimelineContainerEl = document.getElementById('viewerVideoTimelineContainer');
      viewerTimelineTrackEl = document.getElementById('viewerTimelineTrack');
      viewerTimelineProgressEl = document.getElementById('viewerTimelineProgress');
      viewerCurrentTimeEl = document.getElementById('viewerCurrentTime');
      viewerTotalDurationEl = document.getElementById('viewerTotalDuration');


      if (!viewerProjectListContainerEl) console.error("CRITICAL: viewerProjectListContainerEl not found!");
      if (!viewerModalEl) console.error("CRITICAL: viewerModalEl not found!");
      if (!viewerAudioPlayerEl) console.error("CRITICAL: viewerAudioPlayerEl not found!");
      if (!modalPrevButtonEl || !modalNextButtonEl) console.error("CRITICAL: Modal navigation buttons not found!"); // Step 21 Check
      // NEW: Get reference to the main display area for click-off listener
      viewerProjectDisplayAreaEl = document.getElementById('viewerProjectDisplayArea');
      if (!viewerProjectDisplayAreaEl) console.error("CRITICAL: viewerProjectDisplayAreaEl not found!"); // Add check
      if (!viewerVideoTimelineContainerEl) console.warn("Timeline container not found (viewerVideoTimelineContainerEl)");


      console.log("Viewer_JS: DOM references set up.");
    };

    viewerApp.attachEventListeners = function() {
        if (backToViewerListButtonEl) backToViewerListButtonEl.addEventListener('click', showProjectListView);
        if (viewerPrevSlideButtonEl) viewerPrevSlideButtonEl.addEventListener('click', navigateToPrevSlide);
        if (viewerNextSlideButtonEl) viewerNextSlideButtonEl.addEventListener('click', navigateToNextSlide);
        if (viewerModalCloseButtonEl) viewerModalCloseButtonEl.addEventListener('click', hideViewerModal);
        if (viewerModalEl) { // Close modal if background is clicked
            viewerModalEl.addEventListener('click', function(event) {
                if (event.target === viewerModalEl) {
                    hideViewerModal();
                }
            });
        }
        // Step 21: Attach listeners for modal navigation buttons
        if (modalPrevButtonEl) modalPrevButtonEl.addEventListener('click', navigateModalPrevious);
        if (modalNextButtonEl) modalNextButtonEl.addEventListener('click', navigateModalNext);

        // Listener to remove spotlight when clicking outside the spotlighted object
        // This listener on viewerProjectDisplayAreaEl is now less critical for spotlight (SVG catcher handles it),
        // but might be useful for other "click off" behaviors later.
        if (viewerProjectDisplayAreaEl) {
             viewerProjectDisplayAreaEl.addEventListener('click', function(event) {
                if (viewerApp.state.spotlightOverlayObject && event.target !== viewerApp.state.spotlightOverlayObject.target) {
                    // console.log("Viewer area click detected while spotlight active, removing effect.");
                    // removeSpotlightEffect(); // SVG spotlight uses its own catcher
                }
             }, false);
        }

        // Phase 1: Timeline track click listener for seeking
        if (viewerTimelineTrackEl) {
            viewerTimelineTrackEl.addEventListener('click', function(e) {
                if (viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.seekTo === 'function' && viewerApp.state.currentVideoDuration > 0) {
                    const rect = viewerTimelineTrackEl.getBoundingClientRect();
                    const clickX = e.clientX - rect.left; // Click position relative to the track
                    const percentage = clickX / rect.width;
                    const seekTime = percentage * viewerApp.state.currentVideoDuration;
                    viewerApp.state.ytPlayer.seekTo(seekTime, true); // true allows seek ahead
                    console.log(`Timeline clicked: Seek to ${seekTime.toFixed(2)}s`);
                }
            });
        }
    };

    // --- UI Utils & Server Error Handling ---
    function showLoadingViewer(show) {
      viewerApp.state.isLoading = show;
      if (loadingSpinnerElViewer) {
        loadingSpinnerElViewer.style.display = show ? 'flex' : 'none';
      } else if (show) {
          console.warn("showLoadingViewer(true) called but loadingSpinnerElViewer not yet available.");
      }
    }

    function displayMessageViewer(message, isSuccess) {
      if (messageAreaElViewer) {
        messageAreaElViewer.innerHTML = '';
        const p = document.createElement('p');
        p.textContent = message;
        messageAreaElViewer.appendChild(p);
        messageAreaElViewer.className = isSuccess ? 'success' : 'error';
        setTimeout(() => {
          if (messageAreaElViewer) {
            messageAreaElViewer.innerHTML = '';
            messageAreaElViewer.className = '';
          }
        }, 7000);
      } else {
        console.warn("displayMessageViewer called but messageAreaElViewer not available. Message:", message);
      }
    }

    function onServerErrorViewer(errorObject) {
      showLoadingViewer(false);
      console.error('Viewer Server Error Object:', errorObject);
      let errorMessage = "An unknown error occurred on the server.";
      if (typeof errorObject === 'string') {
          errorMessage = errorObject;
      } else if (errorObject && errorObject.message && typeof errorObject.message === 'string') {
          errorMessage = errorObject.message;
      } else if (errorObject && errorObject.name && errorObject.message) {
          errorMessage = `Error: ${errorObject.name} - ${errorObject.message}`;
      } else if (errorObject && errorObject.error && typeof errorObject.error === 'string') { // Handle {success:false, error:"..."}
          errorMessage = errorObject.error;
      }
      displayMessageViewer('Server Error: ' + errorMessage, false);
    }

    // Phase 1: Helper function to format time (similar to Admin_JS)
    // Place it for example near other helper functions or before Project List Loading
    function formatTime(totalSeconds) {
        totalSeconds = Math.floor(totalSeconds);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    }


    // --- Project List Loading/Display ---
    function loadViewerProjectsList() {
      console.log("loadViewerProjectsList called");
      if (!google || !google.script || !google.script.run) {
        console.error("google.script.run is not available for loadViewerProjectsList!");
        displayMessageViewer("Error: Client-server communication bridge unavailable.", false); return;
      }
      if (!viewerProjectListContainerEl) {
          console.warn("loadViewerProjectsList: viewerProjectListContainerEl not ready yet.");
          showLoadingViewer(false);
          return;
      }
      showLoadingViewer(true);
      google.script.run
        .withSuccessHandler(displayViewerProjects)
        .withFailureHandler(onServerErrorViewer)
        .getActiveProjectsList();
    }

    function displayViewerProjects(projectsArray) {
      showLoadingViewer(false);
      console.log("displayViewerProjects received:", projectsArray ? projectsArray.length : 0, "projects");
      if (!viewerProjectListContainerEl) {
          console.error("displayViewerProjects: viewerProjectListContainerEl is not found!");
          return;
      }
      viewerProjectListContainerEl.innerHTML = '';
      if (!projectsArray || projectsArray.length === 0) {
        viewerProjectListContainerEl.innerHTML = '<p>No active training modules found at this time.</p>';
        return;
      }

      const ul = document.createElement('ul');
      ul.className = 'project-list-viewer';

      projectsArray.forEach(project => {
        if (!project || !project.projectId) {
            console.warn("Skipping display of invalid project object:", project);
            return;
        }
        const listItem = document.createElement('li');
        listItem.className = 'project-card-viewer';

        const titleHeader = document.createElement('h3');
        titleHeader.textContent = project.projectTitle || 'Untitled Project';

        const viewButton = document.createElement('button');
        viewButton.textContent = 'View Project';
        viewButton.className = 'view-project-button';
        viewButton.setAttribute('data-project-id', project.projectId);
        viewButton.onclick = function() {
          console.log("View Project button clicked for project ID:", project.projectId);
          loadProjectForViewing(project.projectId);
        };

        listItem.appendChild(titleHeader);
        listItem.appendChild(viewButton);
        ul.appendChild(listItem);
      });
      viewerProjectListContainerEl.appendChild(ul);
    }

    // --- View Switching & Cleanup ---
    function showProjectListView() {
        if (viewerListViewContainerEl) viewerListViewContainerEl.style.display = 'block';
        if (viewerProjectDisplayAreaEl) viewerProjectDisplayAreaEl.style.display = 'none';

        // Cleanup media players
        stopAndDestroyYouTubePlayer();
        stopAndClearAudioPlayer();
        hideSpotlightSVG();
        if(viewerApp.state.isCanvasPannedOrZoomed) resetPanZoomWithAnimation(true); // Reset immediately if panned/zoomed

        if (viewerApp.state.viewerFabricCanvas) {
            viewerApp.state.viewerFabricCanvas.dispose();
            viewerApp.state.viewerFabricCanvas = null;
        }
        viewerApp.state.currentProjectData = null;
        viewerApp.state.currentSlideIndex = 0;
        loadViewerProjectsList();
    }

    function showProjectView() {
        if (viewerListViewContainerEl) viewerListViewContainerEl.style.display = 'none';
        if (viewerProjectDisplayAreaEl) viewerProjectDisplayAreaEl.style.display = 'block';
    }

    // --- Project Data Loading ---
    function loadProjectForViewing(projectId) {
        if (!projectId) {
            displayMessageViewer("Invalid project ID.", false);
            return;
        }
        showLoadingViewer(true);
        displayMessageViewer("Loading project...", true);
        google.script.run
            .withSuccessHandler(onProjectViewDataReceived)
            .withFailureHandler(onServerErrorViewer)
            .getProjectViewData(projectId);
    }

    function onProjectViewDataReceived(response) {
        showLoadingViewer(false);
        if (!response || !response.success || !response.data) {
            onServerErrorViewer(response || { error: "Failed to load project data or project is not active." });
             showProjectListView(); // Go back to list on error
            return;
        }
        try {
            viewerApp.state.currentProjectData = JSON.parse(response.data);
             if (viewerApp.state.currentProjectData && Array.isArray(viewerApp.state.currentProjectData.slides)) {
                 viewerApp.state.currentProjectData.slides.forEach(slide => {
                    if (!slide.slideMedia) {
                        slide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
                    }
                    // Ensure videoQuestions array exists for YouTube slides
                    if (slide.slideMedia && slide.slideMedia.type === 'youtube' && !Array.isArray(slide.slideMedia.videoQuestions)) {
                        slide.slideMedia.videoQuestions = [];
                    }
                    // Phase 1: Ensure youtubeOptions exists for YouTube slides
                    if (slide.slideMedia && slide.slideMedia.type === 'youtube' && typeof slide.slideMedia.youtubeOptions === 'undefined') {
                        slide.slideMedia.youtubeOptions = { showClickToBeginButton: false }; // Default
                    }
                 });
             } else {
                 throw new Error("Project data is missing slides array.");
             }

            if (viewerApp.state.currentProjectData.slides.length === 0) {
                displayMessageViewer("Project loaded, but it has no slides.", false);
                 showProjectListView(); 
                return;
            }

            console.log("Project for viewing loaded:", viewerApp.state.currentProjectData);
            console.log("Number of slides loaded:", viewerApp.state.currentProjectData.slides.length);

            viewerApp.state.currentSlideIndex = 0; 
            showProjectView();
            if (viewingProjectTitleEl) viewingProjectTitleEl.textContent = viewerApp.state.currentProjectData.title || "Untitled Project";
            initializeViewerCanvas(); 
            renderSlideForViewing(viewerApp.state.currentSlideIndex); 
            displayMessageViewer("Project loaded.", true);
        } catch (e) {
            console.error("Error parsing project data for viewing:", e);
            displayMessageViewer("Error loading project: Invalid data format.", false);
            viewerApp.state.currentProjectData = null;
             showProjectListView();
        }
    }

    // --- Canvas & Slide Rendering ---
    function initializeViewerCanvas() {
        if (viewerApp.state.viewerFabricCanvas) {
            viewerApp.state.viewerFabricCanvas.dispose();
            viewerApp.state.viewerFabricCanvas = null;
        }
        if (!viewerFabricCanvasEl) {
            console.error("Viewer Fabric canvas element not found!");
            return;
        }
        try {
            viewerApp.state.viewerFabricCanvas = new fabric.Canvas(viewerFabricCanvasEl, {
                width: viewerApp.state.defaultCanvasWidth,
                height: viewerApp.state.defaultCanvasHeight,
                selection: false,
                hoverCursor: 'default',
                backgroundColor: 'transparent' 
            });
            viewerApp.state.viewerFabricCanvas.selection = false;
            
            // Listener for resetting pan/zoom on background click
            viewerApp.state.viewerFabricCanvas.on('mouse:down', function(options) {
                if (viewerApp.state.isCanvasPannedOrZoomed && !options.target) { // No object clicked, means background
                    console.log("Canvas background clicked while panned/zoomed, initiating reset.");
                    resetPanZoomWithAnimation();
                } else if (viewerApp.state.isCanvasPannedOrZoomed && options.target && options.target === viewerApp.state.panZoomTargetObject) {
                    // If the same panned/zoomed object is clicked again, reset.
                    console.log("Panned/zoomed target object clicked again, initiating reset.");
                    resetPanZoomWithAnimation();
                }
                // If options.target is another interactive object, its own 'mousedown' (from renderSlideForViewing)
                // will call handleOverlayInteraction, which has its own logic to reset zoom if needed.
            });
            viewerApp.state.viewerFabricCanvas.renderAll(); 
            console.log("Viewer canvas initialized.");
        } catch(e) {
            console.error("Error initializing viewer Fabric canvas:", e);
            displayMessageViewer("Error initializing display canvas.", false);
        }
    }

    function renderSlideForViewing(slideIndex) {
        if (!viewerApp.state.currentProjectData || !viewerApp.state.viewerFabricCanvas) {
            console.error("Cannot render slide: Project data or canvas not ready."); return;
        }
        const slides = viewerApp.state.currentProjectData.slides;
        if (slideIndex < 0 || slideIndex >= slides.length) {
            console.error("Invalid slide index:", slideIndex); return;
        }

        stopAndDestroyYouTubePlayer(); // This will also clear timestamp overlay states & video duration
        stopAndClearAudioPlayer();
        hideSpotlightSVG(); 
        if(viewerApp.state.isCanvasPannedOrZoomed) resetPanZoomWithAnimation(true); // Reset immediately if panned/zoomed

        const slideData = slides[slideIndex]; // Moved up to access slideData earlier

        viewerApp.state.currentSlideIndex = slideIndex; 
        
        // Initialize timestamp overlay states for the new slide
        // Clear any existing timestamp overlays from canvas (part of stopAndDestroyYouTubePlayer now, but good to be sure)
        if (viewerApp.state.viewerFabricCanvas) {
            viewerApp.state.viewerFabricCanvas.getObjects().forEach(obj => {
                if (obj.isTimestampOverlay) { // Assuming we add this flag when creating them
                    viewerApp.state.viewerFabricCanvas.remove(obj);
                }
            });
        }
        viewerApp.state.currentTimestampOverlays = (slideData && slideData.timestampOverlays && Array.isArray(slideData.timestampOverlays)) ? [...slideData.timestampOverlays] : [];
        viewerApp.state.activeTimestampOverlayIds = new Set(); // Initialize as a new Set

        // const slideData = slides[slideIndex]; // Original position
        const canvas = viewerApp.state.viewerFabricCanvas;

         if (!slideData.slideMedia) {
            slideData.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null, youtubeOptions: { showClickToBeginButton: false } };
         } else if (slideData.slideMedia.type === 'youtube' && typeof slideData.slideMedia.youtubeOptions === 'undefined') {
            slideData.slideMedia.youtubeOptions = { showClickToBeginButton: false }; // Ensure it exists for YouTube
         }


        const slideWidth = slideData.canvasWidth || viewerApp.state.defaultCanvasWidth;
        const slideHeight = slideData.canvasHeight || viewerApp.state.defaultCanvasHeight;
        const media = slideData.slideMedia;
        let mediaType = (media && media.type) ? media.type : 'none';
        viewerApp.state.currentMediaType = mediaType; // Store current media type

        canvas.setWidth(slideWidth);
        canvas.setHeight(slideHeight);
        if (viewerFabricCanvasEl) {
            viewerFabricCanvasEl.width = slideWidth;
            viewerFabricCanvasEl.height = slideHeight;
        }
        if (viewerMediaContainerEl) {
            viewerMediaContainerEl.style.width = slideWidth + 'px';
            viewerMediaContainerEl.style.height = slideHeight + 'px';
        }

        canvas.clear();
        canvas.setBackgroundImage(null, () => { canvas.renderAll(); });
        canvas.backgroundColor = 'transparent';

        if (youtubePlayerContainerEl) youtubePlayerContainerEl.style.display = (mediaType === 'youtube') ? 'block' : 'none';
        if (viewerVideoTimelineContainerEl) viewerVideoTimelineContainerEl.style.display = 'none'; // Hide by default

        if (viewerCanvasContainerEl) {
            viewerCanvasContainerEl.style.display = 'flex'; 
            if (mediaType === 'youtube') {
                // Initial state before "Click to Begin" or overlays are evaluated
                viewerCanvasContainerEl.style.pointerEvents = 'none'; 
                viewerFabricCanvasEl.style.opacity = '0'; 

                if (slideData.slideMedia && slideData.slideMedia.videoQuestions) {
                    viewerApp.state.currentVideoQuestions = [...slideData.slideMedia.videoQuestions].sort((a, b) => a.timestamp - b.timestamp);
                } else {
                    viewerApp.state.currentVideoQuestions = [];
                }
                viewerApp.state.askedQuestionIndices = []; 
            } else {
                viewerCanvasContainerEl.style.pointerEvents = 'auto'; 
                viewerFabricCanvasEl.style.opacity = '1'; 
                viewerApp.state.currentVideoQuestions = []; 
                viewerApp.state.askedQuestionIndices = [];
            }
        }
        if (viewerAudioPlayerEl) viewerAudioPlayerEl.style.display = 'none'; 

        console.log(`Rendering slide ${slideIndex + 1}, media type: ${mediaType}`);

        switch(mediaType) {
            case 'image':
                if (media.driveFileId) {
                    showLoadingViewer(true);
                    google.script.run
                        .withSuccessHandler(function(response) {
                            showLoadingViewer(false);
                            if (viewerApp.state.currentSlideIndex !== slideIndex) return;
                            if (response && response.success && response.base64Data) {
                                fabric.Image.fromURL(response.base64Data, function(img) {
                                    if (!viewerApp.state.viewerFabricCanvas || viewerApp.state.currentSlideIndex !== slideIndex) return;
                                    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                                        scaleX: canvas.width / img.width, 
                                        scaleY: canvas.height / img.height
                                    });
                                }, { crossOrigin: 'anonymous' });
                            } else {
                                console.error("Failed to fetch image for viewer:", response);
                                canvas.renderAll();
                            }
                        })
                        .withFailureHandler(function(error) {
                            showLoadingViewer(false);
                            onServerErrorViewer(error);
                            canvas.renderAll();
                        })
                        .getImageAsBase64(media.driveFileId);
                } else {
                    console.warn("Image media present but no driveFileId:", media);
                    canvas.renderAll();
                }
                if (viewerMediaContainerEl) viewerMediaContainerEl.style.backgroundColor = '#333';
                if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '1';
                if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'auto';
                break;

            case 'youtube':
                if (viewerMediaContainerEl) viewerMediaContainerEl.style.backgroundColor = 'transparent';
                if (media.url) {
                    const videoId = extractYouTubeVideoId(media.url);
                    if (videoId) {
                        if (isYouTubeApiReady) {
                             setupYouTubePlayer(videoId); 
                             
                             const youtubeOptions = media.youtubeOptions || { showClickToBeginButton: false };

                             // Clear existing "click to begin" buttons before adding a new one or setting defaults
                             canvas.getObjects().forEach(obj => {
                                 if (obj.customType === 'clickToBeginButton') {
                                     canvas.remove(obj);
                                 }
                             });

                             if (youtubeOptions.showClickToBeginButton) {
                                 if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'auto';
                                 if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '1';

                                 const beginButtonText = new fabric.Textbox('Click here to begin', {
                                     left: canvas.width / 2, 
                                     top: canvas.height / 2, 
                                     originX: 'center', 
                                     originY: 'center',
                                     fontSize: (canvas.width > 600 ? 30 : 24), 
                                     fill: 'white', 
                                     backgroundColor: 'rgba(0,0,0,0.8)',
                                     padding: 20, 
                                     rx: 10, ry: 10,
                                     selectable: false, 
                                     evented: true, 
                                     hoverCursor: 'pointer',
                                     customType: 'clickToBeginButton' 
                                 });

                                 beginButtonText.on('mousedown', function() {
                                     if (viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.playVideo === 'function') {
                                         viewerApp.state.ytPlayer.playVideo();
                                     } else {
                                         console.warn("ClickToBegin: viewerApp.state.ytPlayer not ready or playVideo not available.");
                                     }
                                     canvas.remove(this); 
                                     updateViewerCanvasInteractivity(); 
                                     // renderAll will be called by updateViewerCanvasInteractivity
                                 });
                                 canvas.add(beginButtonText);
                                 canvas.bringToFront(beginButtonText);
                                 canvas.renderAll(); // Render after adding button. updateViewerCanvasInteractivity will also render.
                             } else {
                                 // If button not shown, call updateViewerCanvasInteractivity to set defaults
                                 // (which for YT without other interactive elements is opacity 0, pointerEvents none)
                                 updateViewerCanvasInteractivity(); // This will also call renderAll
                             }
                             // Timeline and question marker setup will happen in onPlayerReady
                        } else {
                             console.warn("YouTube API not ready yet. Player setup deferred for videoId:", videoId);
                             viewerApp.state.deferredYouTubeVideoId = videoId; // Store video ID for deferred setup
                             if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '0';
                             if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'none';
                             displayMessageViewer("YouTube player is loading...", true);
                             // Fallback if API load fails is handled by the API loader itself
                        }
                    } else {
                        console.error("Could not extract YouTube Video ID from URL:", media.url);
                        displayMessageViewer("Invalid YouTube URL format.", false);
                        if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '0';
                        if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'none';
                    }
                } else {
                     console.warn("YouTube media type set but URL is missing.");
                     displayMessageViewer("YouTube URL is missing for this slide.", false);
                     if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '0';
                     if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'none';
                }
                break;

            case 'audio':
                 if (viewerMediaContainerEl) viewerMediaContainerEl.style.backgroundColor = '#333';
                 if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '1';
                 if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'auto';
                 if (media.driveFileId) {
                     showLoadingViewer(true);
                     google.script.run
                         .withSuccessHandler(function(audioResponse) {
                             showLoadingViewer(false);
                             if (viewerApp.state.currentSlideIndex !== slideIndex) return;
                             if (audioResponse && audioResponse.success && audioResponse.base64Data) {
                                 setupAudioPlayer(audioResponse.base64Data);
                                 if (viewerAudioPlayerEl) viewerAudioPlayerEl.style.display = 'block';
                                 canvas.renderAll();
                             } else {
                                 onServerErrorViewer(audioResponse || {error: "Failed to load audio data."});
                                 canvas.renderAll();
                             }
                         })
                         .withFailureHandler(function(error) {
                             showLoadingViewer(false);
                             onServerErrorViewer(error);
                             canvas.renderAll();
                         })
                         .getAudioAsBase64(media.driveFileId);
                 } else {
                     console.warn("Audio media type set but driveFileId is missing.");
                     canvas.renderAll();
                 }
                 break;

            default: 
                 if (viewerMediaContainerEl) viewerMediaContainerEl.style.backgroundColor = '#333';
                 if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '1';
                 if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'auto';
                 canvas.renderAll();
                 break;
        }

        if (slideData.fabricCanvasJSON) {
            canvas.loadFromJSON(slideData.fabricCanvasJSON, function() {
                if (viewerApp.state.currentSlideIndex !== slideIndex) return;

                canvas.forEachObject(function(obj) {
                    obj.selectable = false;
                    obj.evented = true; 
                    obj.hoverCursor = 'pointer';
                    obj._clickAndHoldTimer = null;

                    obj.off('mousedown'); obj.off('mouseup'); obj.off('mouseout');
                    obj.off('mousemove'); obj.off('mouseover');

                    if (obj.customInteraction && obj.customInteraction.trigger) {
                        const trigger = obj.customInteraction.trigger;
                        const action = obj.customInteraction.action;

                        if (trigger === 'clickAndHold' && action === 'spotlight') {
                            obj.on('mousedown', function(options) { if (this.customInteraction && this.customInteraction.trigger === 'clickAndHold' && this.customInteraction.action === 'spotlight') { showSpotlightSVG(this, this.customInteraction); }});
                            obj.on('mouseup', function() { if (this.customInteraction && this.customInteraction.trigger === 'clickAndHold' && this.customInteraction.action === 'spotlight') { if (viewerApp.state.isSpotlightActive && viewerApp.state.currentSpotlightInfo && viewerApp.state.currentSpotlightInfo.targetFabricObject === this) { hideSpotlightSVG(); } }});
                            obj.on('mouseout', function() {  if (this.customInteraction && this.customInteraction.trigger === 'clickAndHold' && this.customInteraction.action === 'spotlight') { if (viewerApp.state.isSpotlightActive && viewerApp.state.currentSpotlightInfo && viewerApp.state.currentSpotlightInfo.targetFabricObject === this) { hideSpotlightSVG(); } }});
                        }
                        else if (trigger === 'click') {
                            obj.on('mousedown', function(options) { if (this.customInteraction && this.customInteraction.trigger === 'click') { if (this._clickAndHoldTimer) { clearTimeout(this._clickAndHoldTimer); this._clickAndHoldTimer = null;} handleOverlayInteraction(this, 'click'); if (this.customAnimation && this.customAnimation.trigger === 'onClick' && this.customAnimation.type) { executeAnimation(this, this.customAnimation); } if(options.e) options.e.stopPropagation();}});
                        } else if (trigger === 'hover') {
                            obj.on('mouseover', function() { if (this.customInteraction && this.customInteraction.trigger === 'hover') { handleOverlayInteraction(this, 'hover'); } if (this.customAnimation && this.customAnimation.trigger === 'hover' && this.customAnimation.type) { executeAnimation(this, this.customAnimation); }});
                            obj.on('mouseout', function() { if (this.customAnimation && this.customAnimation.trigger === 'hover' && this.customAnimation.type) { stopAnimation(this); }});
                        } else if (trigger === 'clickAndHold') { 
                            obj.on('mousedown', function(options) { if (this.customInteraction && this.customInteraction.trigger === 'clickAndHold') {  if (this._clickAndHoldTimer) clearTimeout(this._clickAndHoldTimer); this._clickAndHoldTimer = setTimeout(() => { handleOverlayInteraction(this, 'clickAndHold'); if (this.customAnimation && this.customAnimation.trigger === 'onClick' && this.customAnimation.type) { executeAnimation(this, this.customAnimation); } this._clickAndHoldTimer = null; }, CLICK_AND_HOLD_DURATION);}});
                            const cancelGenericHold = function() { if (this._clickAndHoldTimer) { clearTimeout(this._clickAndHoldTimer); this._clickAndHoldTimer = null; }};
                            obj.on('mouseup', cancelGenericHold); obj.on('mouseout', cancelGenericHold);
                        }
                    }
                    if (obj.customAnimation && obj.customAnimation.trigger === 'onLoad' && obj.customAnimation.type) {
                        setTimeout(() => executeAnimation(obj, obj.customAnimation), 100);
                    }
                }); 
                canvas.renderAll();
            }); 
        } else if (viewerCanvasContainerEl && viewerCanvasContainerEl.style.display !== 'none') {
             if(mediaType !== 'image' && mediaType !== 'audio') { 
                 canvas.renderAll();
             }
        }
        updateSlideNavigationUI(); 
    }

    // --- Interaction & Modal Handling ---
    function handleOverlayInteraction(fabricObject, eventType) {
        if (!fabricObject.customInteraction) return;
        const interaction = fabricObject.customInteraction;

        console.log(`Interaction Triggered: type=${eventType}, action=${interaction.action}, object=${fabricObject.type}, currentOpacity=${fabricObject.opacity}`);

        if (interaction.trigger !== eventType) {
            console.log(`Interaction Mismatch: Configured trigger '${interaction.trigger}' does not match event '${eventType}'. Ignoring for this handler instance.`);
            return;
        }
        if (viewerApp.state.isSpotlightActive && interaction.action !== 'spotlight') {
            hideSpotlightSVG();
        }
         if (viewerApp.state.isCanvasPannedOrZoomed && interaction.action !== 'panZoomToTarget') {
            if(fabricObject !== viewerApp.state.panZoomTargetObject){
                console.log("Different object clicked while panned/zoomed. Resetting zoom first."); 
                resetPanZoomWithAnimation();
            }
        }

        console.log("Handling interaction:", interaction.action, "for object:", fabricObject);

        switch (interaction.action) {
            case 'showModal':
                if (fabricObject.customInteraction && fabricObject.customInteraction.modalContent) {
                    const canvas = viewerApp.state.viewerFabricCanvas;
                    if (!canvas) break;
                    const allObjects = canvas.getObjects();
                    viewerApp.state.modalSequence = allObjects.filter(obj =>
                        obj.customInteraction &&
                        obj.customInteraction.action === 'showModal' &&
                        typeof obj.sequenceOrder === 'number' &&
                        !isNaN(obj.sequenceOrder)
                    ).sort((a, b) => a.sequenceOrder - b.sequenceOrder);
                    viewerApp.state.currentModalSequenceIndex = viewerApp.state.modalSequence.findIndex(obj => obj === fabricObject);
                    if (viewerApp.state.currentModalSequenceIndex === -1) {
                        viewerApp.state.modalSequence = [fabricObject];
                        viewerApp.state.currentModalSequenceIndex = 0;
                    }
                    viewerApp.state.currentModalOverlay = fabricObject;
                    showViewerModal(interaction.modalContent);
                    updateModalNavigationButtons();
                } else {
                     console.warn("Show Modal: modalContent missing.");
                     if(modalPrevButtonEl) modalPrevButtonEl.style.display = 'none';
                     if(modalNextButtonEl) modalNextButtonEl.style.display = 'none';
                }
                break;
            case 'navigateToSlide':
                const targetSlideId = interaction.navigateTo;
                if (targetSlideId && viewerApp.state.currentProjectData && viewerApp.state.currentProjectData.slides) {
                    const targetSlideIndex = viewerApp.state.currentProjectData.slides.findIndex(s => s.slideId === targetSlideId);
                    if (targetSlideIndex !== -1) {
                        renderSlideForViewing(targetSlideIndex);
                    } else {
                        displayMessageViewer(`Navigation error: Slide '${targetSlideId}' not found.`, false);
                    }
                }
                break;
            case 'navigateToURL':
                if (interaction.navigateTo) {
                    let url = interaction.navigateTo;
                    if (!url.startsWith('http://') && !url.startsWith('https://')) url = 'https://' + url;
                    try {
                         const newWindow = window.open(url, '_blank');
                         if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
                              displayMessageViewer("Could not open link. Check popup settings.", false);
                         }
                    } catch (e) { displayMessageViewer("Error opening link.", false); }
                }
                break;
            case 'spotlight':
                 if (viewerApp.state.isSpotlightActive && viewerApp.state.currentSpotlightInfo && viewerApp.state.currentSpotlightInfo.targetFabricObject === fabricObject) {
                     hideSpotlightSVG();
                 } else {
                     showSpotlightSVG(fabricObject, interaction);
                 }
                 break;
            case 'panZoomToTarget':
                console.log("Pan/Zoom to Target action triggered for:", fabricObject);
                if (fabricObject && viewerApp.state.viewerFabricCanvas) {
                    const canvas = viewerApp.state.viewerFabricCanvas;

                    if (!viewerApp.state.isCanvasPannedOrZoomed) { 
                        viewerApp.state.originalViewportTransform = canvas.viewportTransform.slice(); 
                        console.log("Storing original viewport transform:", viewerApp.state.originalViewportTransform);
                    }

                    const targetZoom = fabricObject.customInteraction.panZoomLevel || 1.5;
                    viewerApp.state.panZoomTargetObject = fabricObject; 

                    animatePanZoom(fabricObject, targetZoom);
                }
                break;
            case 'reveal':
                 console.log("Reveal action triggered for:", fabricObject);
                 if (fabricObject && viewerApp.state.viewerFabricCanvas) {
                      fabricObject.animate('opacity', 1, {
                          duration: 500,
                          onChange: viewerApp.state.viewerFabricCanvas.renderAll.bind(viewerApp.state.viewerFabricCanvas),
                          onComplete: () => console.log("Reveal complete. Opacity:", fabricObject.opacity)
                      });
                 }
                 break;
            default:
                console.log("Unknown interaction action:", interaction.action);
        }
    }

    function executeAnimation(fabricObject, animConfig) {
        if (!fabricObject || !animConfig || !animConfig.type) return;
        console.log(`Executing animation: ${animConfig.type} for object`, fabricObject);

        stopAnimation(fabricObject);

        if (!fabricObject._originalState) {
            fabricObject._originalState = {
                angle: fabricObject.angle,
                top: fabricObject.top,
                left: fabricObject.left,
                scaleX: fabricObject.scaleX,
                scaleY: fabricObject.scaleY
            };
        }
        
        let duration = 1000; 
        if (animConfig.speed) {
            duration = ANIMATION_SPEED_PRESETS[animConfig.speed]?.duration || 1000;
        } else if (animConfig.duration) {
            duration = animConfig.duration;
        }
        
        let strength = animConfig.strength || getDefaultStrength(animConfig.type);
        
        const controller = { aborted: false };
        viewerApp.state.activeAnimations.set(fabricObject, controller);

        switch (animConfig.type) {
            case 'wiggle': animateWiggle(fabricObject, duration, strength, controller, animConfig.loop); break;
            case 'float': animateFloat(fabricObject, duration, strength, controller, animConfig.loop); break;
            case 'growShrink': animateGrowShrink(fabricObject, duration, strength, controller, animConfig.loop); break;
            default:
                console.warn("Unknown animation type:", animConfig.type);
                viewerApp.state.activeAnimations.delete(fabricObject);
        }
    }

    function getDefaultStrength(animationType) {
        switch (animationType) {
            case 'wiggle': return 5; case 'float': return 10; case 'growShrink': return 1.2;
            default: return 5;
        }
    }

    function stopAnimation(fabricObject) {
        if (viewerApp.state.activeAnimations.has(fabricObject)) {
            const controller = viewerApp.state.activeAnimations.get(fabricObject);
            controller.aborted = true;
            viewerApp.state.activeAnimations.delete(fabricObject);
            console.log("Animation stopped for object", fabricObject);
            if (fabricObject._originalState) {
                fabricObject.set(fabricObject._originalState);
                viewerApp.state.viewerFabricCanvas.renderAll();
            }
        }
    }

    function animateWiggle(fabricObject, duration, strength, controller, shouldLoop) {
        const canvas = viewerApp.state.viewerFabricCanvas; if (!canvas) return;
        const originalAngle = fabricObject._originalState ? fabricObject._originalState.angle : fabricObject.angle;
        strength = parseFloat(strength) || 5; 
        fabricObject.animate('angle', originalAngle - strength, {
            duration: duration / 3, onChange: canvas.renderAll.bind(canvas), abort: () => controller.aborted,
            onComplete: function() {
                if (controller.aborted) { fabricObject.set('angle', originalAngle); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return; }
                fabricObject.animate('angle', originalAngle + strength, {
                    duration: duration / 3 * 2, onChange: canvas.renderAll.bind(canvas), abort: () => controller.aborted,
                    onComplete: function() {
                        if (controller.aborted) { fabricObject.set('angle', originalAngle); canvas.renderAll();  viewerApp.state.activeAnimations.delete(fabricObject); return; }
                        fabricObject.animate('angle', originalAngle, {
                            duration: duration / 3, onChange: canvas.renderAll.bind(canvas), abort: () => controller.aborted,
                            onComplete: function() {
                                if (controller.aborted) { fabricObject.set('angle', originalAngle); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return; }
                                console.log(`Wiggle cycle complete, shouldLoop: ${shouldLoop}`);
                                if (shouldLoop === true) { setTimeout(() => { if (viewerApp.state.activeAnimations.has(fabricObject) && viewerApp.state.activeAnimations.get(fabricObject).aborted) { fabricObject.set('angle', originalAngle); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return;} const newLoopController = { aborted: false }; viewerApp.state.activeAnimations.set(fabricObject, newLoopController); animateWiggle(fabricObject, duration, strength, newLoopController, shouldLoop); }, 50);
                                } else { viewerApp.state.activeAnimations.delete(fabricObject); console.log(`Animation wiggle finished.`); }
                            }
                        });
                    }
                });
            }
        });
    }
    function animateFloat(fabricObject, duration, strength, controller, shouldLoop) {
        const canvas = viewerApp.state.viewerFabricCanvas; if (!canvas) return;
        const originalTop = fabricObject._originalState ? fabricObject._originalState.top : fabricObject.top;
        strength = parseFloat(strength) || 10; 
        fabricObject.animate('top', originalTop - strength, {
            duration: duration / 3, onChange: canvas.renderAll.bind(canvas), abort: () => controller.aborted,
            onComplete: function() {
                if (controller.aborted) { fabricObject.set('top', originalTop); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return; }
                fabricObject.animate('top', originalTop + (strength/2), { // Go slightly below original
                    duration: duration / 3 * 2, onChange: canvas.renderAll.bind(canvas), abort: () => controller.aborted,
                    onComplete: function() {
                        if (controller.aborted) { fabricObject.set('top', originalTop); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return; }
                        fabricObject.animate('top', originalTop, {
                            duration: duration / 3, onChange: canvas.renderAll.bind(canvas), abort: () => controller.aborted,
                            onComplete: function() {
                                if (controller.aborted) { fabricObject.set('top', originalTop); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return; }
                                console.log(`Float cycle complete, shouldLoop: ${shouldLoop}`);
                                if (shouldLoop === true) { setTimeout(() => { if (viewerApp.state.activeAnimations.has(fabricObject) && viewerApp.state.activeAnimations.get(fabricObject).aborted) { fabricObject.set('top', originalTop); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return;} const newLoopController = { aborted: false }; viewerApp.state.activeAnimations.set(fabricObject, newLoopController); animateFloat(fabricObject, duration, strength, newLoopController, shouldLoop); }, 50);
                                } else { viewerApp.state.activeAnimations.delete(fabricObject); console.log(`Animation float finished.`); }
                            }
                        });
                    }
                });
            }
        });
    }

    function animateGrowShrink(fabricObject, duration, strength, controller, shouldLoop) {
        const canvas = viewerApp.state.viewerFabricCanvas; if (!canvas) return;
        const originalScaleX = fabricObject._originalState ? fabricObject._originalState.scaleX : fabricObject.scaleX;
        const originalScaleY = fabricObject._originalState ? fabricObject._originalState.scaleY : fabricObject.scaleY;
        strength = parseFloat(strength) || 1.2; 
        
        animateScale(strength); // Start by growing
        
        function animateScale(targetScaleFactor) { // targetScaleFactor is relative to original, e.g. 1.2 for 120%
            fabric.util.animate({
                startValue: fabricObject.scaleX / originalScaleX, // Current relative scale
                endValue: targetScaleFactor,
                duration: duration / 2, // Half duration for grow, half for shrink
                onChange: function(value) {
                    if (controller.aborted) return;
                    fabricObject.set({ scaleX: originalScaleX * value, scaleY: originalScaleY * value });
                    canvas.renderAll();
                },
                abort: () => controller.aborted,
                onComplete: function() {
                    if (controller.aborted) { fabricObject.set({scaleX: originalScaleX, scaleY: originalScaleY}); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return; }
                    
                    if (targetScaleFactor > 1) { // If we just grew, now shrink back to original
                        animateScale(1);
                    } else { // We just shrunk back to original, cycle complete
                        console.log(`GrowShrink cycle complete, shouldLoop: ${shouldLoop}`);
                        if (shouldLoop === true) { setTimeout(() => { if (viewerApp.state.activeAnimations.has(fabricObject) && viewerApp.state.activeAnimations.get(fabricObject).aborted) { fabricObject.set({scaleX: originalScaleX, scaleY: originalScaleY}); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return; } const newLoopController = { aborted: false }; viewerApp.state.activeAnimations.set(fabricObject, newLoopController); animateGrowShrink(fabricObject, duration, strength, newLoopController, shouldLoop); }, 50);
                        } else { viewerApp.state.activeAnimations.delete(fabricObject); console.log(`Animation growShrink finished.`); }
                    }
                },
                easing: fabric.util.ease.easeInOutQuad
            });
        }
    }

    function animatePanZoom(targetObject, targetZoom) {
        const canvas = viewerApp.state.viewerFabricCanvas;
        if (!canvas || !targetObject) return;

        const animationDuration = 500; 
        const objectCenter = targetObject.getCenterPoint();
        const vpt = canvas.viewportTransform;
        const currentZoom = vpt[0];
        const currentPanX = vpt[4];
        const currentPanY = vpt[5];
        const finalPanX = (canvas.width / 2) - (objectCenter.x * targetZoom);
        const finalPanY = (canvas.height / 2) - (objectCenter.y * targetZoom);

        console.log(`Animating Pan/Zoom. From: Z=${currentZoom.toFixed(2)}, X=${currentPanX.toFixed(2)}, Y=${currentPanY.toFixed(2)}`);
        console.log(`Targeting: Z=${targetZoom.toFixed(2)}, X=${finalPanX.toFixed(2)}, Y=${finalPanY.toFixed(2)} for obj center (${objectCenter.x.toFixed(2)}, ${objectCenter.y.toFixed(2)})`);

        fabric.util.animate({
            startValue: 0, endValue: 1, duration: animationDuration,
            onChange: function(progress) {
                const newZoom = currentZoom + (targetZoom - currentZoom) * progress;
                const newPanX = currentPanX + (finalPanX - currentPanX) * progress;
                const newPanY = currentPanY + (finalPanY - currentPanY) * progress;
                canvas.setViewportTransform([newZoom, 0, 0, newZoom, newPanX, newPanY]);
                canvas.requestRenderAll(); 
            },
            onComplete: function() {
                viewerApp.state.isCanvasPannedOrZoomed = true;
                canvas.setViewportTransform([targetZoom, 0, 0, targetZoom, finalPanX, finalPanY]);
                canvas.renderAll(); 
                console.log("Pan/Zoom animation complete.");
            },
            easing: fabric.util.ease.easeInOutQuad 
        });
    }

    function resetPanZoomWithAnimation(immediate = false) {
        const canvas = viewerApp.state.viewerFabricCanvas;
        console.log("[ResetPanZoom] Called. Immediate:", immediate, "isPanned:", viewerApp.state.isCanvasPannedOrZoomed, "OriginalVPT:", viewerApp.state.originalViewportTransform);

        if (!canvas || !viewerApp.state.isCanvasPannedOrZoomed || !Array.isArray(viewerApp.state.originalViewportTransform) || viewerApp.state.originalViewportTransform.length !== 6) {
            console.warn("[ResetPanZoom] Aborting: Conditions not met or invalid original transform.");
            if(canvas && Array.isArray(viewerApp.state.originalViewportTransform) && viewerApp.state.originalViewportTransform.length === 6 && !viewerApp.state.isCanvasPannedOrZoomed){
                 // If somehow isCanvasPannedOrZoomed is false but we have a transform, try to reset.
                 console.log("[ResetPanZoom] Attempting reset despite isCanvasPannedOrZoomed being false, as original transform exists.");
            } else if (!canvas) {
                viewerApp.state.isCanvasPannedOrZoomed = false; viewerApp.state.panZoomTargetObject = null; viewerApp.state.originalViewportTransform = null; return;
            } else { // Not panned or invalid original transform
                viewerApp.state.isCanvasPannedOrZoomed = false; viewerApp.state.panZoomTargetObject = null; viewerApp.state.originalViewportTransform = null; return;
            }
        }
        
        console.log("[ResetPanZoom] Conditions met, proceeding with reset.");
        const animationDuration = immediate ? 0 : 500;
        const vpt = canvas.viewportTransform;
        const currentZoom = vpt[0]; const currentPanX = vpt[4]; const currentPanY = vpt[5];
        const finalOriginalVPT = viewerApp.state.originalViewportTransform.slice();
        const finalZoom = finalOriginalVPT[0]; const finalPanX = finalOriginalVPT[4]; const finalPanY = finalOriginalVPT[5];
        
        viewerApp.state.panZoomTargetObject = null; 

        if (immediate) {
            canvas.setViewportTransform(finalOriginalVPT);
            viewerApp.state.isCanvasPannedOrZoomed = false; viewerApp.state.originalViewportTransform = null; 
            canvas.renderAll(); console.log("Pan/Zoom reset immediately.");
            return;
        }

        fabric.util.animate({
            startValue: 0, endValue: 1, duration: animationDuration,
            onChange: function(progress) {
                const newZoom = currentZoom + (finalZoom - currentZoom) * progress;
                const newPanX = currentPanX + (finalPanX - currentPanX) * progress;
                const newPanY = currentPanY + (finalPanY - currentPanY) * progress;
                canvas.setViewportTransform([newZoom, 0, 0, newZoom, newPanX, newPanY]);
                canvas.requestRenderAll();
            },
            onComplete: function() {
                canvas.setViewportTransform(finalOriginalVPT); 
                viewerApp.state.isCanvasPannedOrZoomed = false; viewerApp.state.originalViewportTransform = null; 
                canvas.renderAll(); console.log("Pan/Zoom reset animation complete.");
            },
            easing: fabric.util.ease.easeInOutQuad
        });
    }

    function showViewerModal(htmlContent) {
        if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = htmlContent;
        if (viewerModalEl) viewerModalEl.style.display = 'flex';
    }

    function hideViewerModal() {
        if (viewerModalEl) viewerModalEl.style.display = 'none';
        if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = '';
        viewerApp.state.currentModalOverlay = null;
        viewerApp.state.modalSequence = [];
        viewerApp.state.currentModalSequenceIndex = -1;
        if(modalPrevButtonEl) modalPrevButtonEl.style.display = 'none';
        if(modalNextButtonEl) modalNextButtonEl.style.display = 'none';
    }

    function updateModalNavigationButtons() {
         if (!modalPrevButtonEl || !modalNextButtonEl) return;
         const sequence = viewerApp.state.modalSequence;
         const currentIndex = viewerApp.state.currentModalSequenceIndex;
         if (sequence.length <= 1) {
             modalPrevButtonEl.style.display = 'none'; modalNextButtonEl.style.display = 'none'; return;
         }
         modalPrevButtonEl.disabled = !(currentIndex > 0); modalPrevButtonEl.style.display = 'inline-block';
         modalNextButtonEl.disabled = !(currentIndex < sequence.length - 1); modalNextButtonEl.style.display = 'inline-block';
     }

     function navigateModalPrevious() {
          const sequence = viewerApp.state.modalSequence; let currentIndex = viewerApp.state.currentModalSequenceIndex;
          if (currentIndex > 0) { currentIndex--; const prevOverlay = sequence[currentIndex];
              if (prevOverlay && prevOverlay.customInteraction && prevOverlay.customInteraction.modalContent) {
                  viewerApp.state.currentModalSequenceIndex = currentIndex; viewerApp.state.currentModalOverlay = prevOverlay;
                  if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = prevOverlay.customInteraction.modalContent;
                  updateModalNavigationButtons(); console.log("Navigated to previous modal, index:", currentIndex);
              } else { console.error("Previous overlay or its content is invalid."); }
          }
     }
     function navigateModalNext() {
          const sequence = viewerApp.state.modalSequence; let currentIndex = viewerApp.state.currentModalSequenceIndex;
          if (currentIndex < sequence.length - 1) { currentIndex++; const nextOverlay = sequence[currentIndex];
               if (nextOverlay && nextOverlay.customInteraction && nextOverlay.customInteraction.modalContent) {
                   viewerApp.state.currentModalSequenceIndex = currentIndex; viewerApp.state.currentModalOverlay = nextOverlay;
                   if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = nextOverlay.customInteraction.modalContent;
                   updateModalNavigationButtons(); console.log("Navigated to next modal, index:", currentIndex);
               } else { console.error("Next overlay or its content is invalid."); }
          }
     }

    function showSpotlightSVG(targetFabricObject, interactionData) {
        hideSpotlightSVG(); 
        const canvas = viewerApp.state.viewerFabricCanvas;
        if (!canvas || !targetFabricObject) { console.error("Cannot show spotlight: canvas or targetFabricObject missing."); return; }
        console.log(`[WebApp] Spotlight SVG requested for Fabric object:`, targetFabricObject);
        const targetRect = targetFabricObject.getBoundingRect(true); 
        const canvasRect = viewerFabricCanvasEl.getBoundingClientRect(); 
        const viewportLeft = canvasRect.left + window.scrollX + targetRect.left; // Account for canvas position and scroll
        const viewportTop = canvasRect.top + window.scrollY + targetRect.top;   // Account for canvas position and scroll
        const viewportWidth = targetRect.width; const viewportHeight = targetRect.height;
        const svgNS = "http://www.w3.org/2000/svg"; const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("id", "spotlightSVG");
        svg.style.position = "fixed"; svg.style.top = "0"; svg.style.left = "0";
        svg.style.width = "100vw";  svg.style.height = "100vh";
        svg.style.zIndex = "9990";  svg.style.pointerEvents = "none"; 
        const mask = document.createElementNS(svgNS, "mask"); mask.setAttribute("id", "spotlightMask");
        const bgRect = document.createElementNS(svgNS, "rect");
        bgRect.setAttribute("x", "0"); bgRect.setAttribute("y", "0"); bgRect.setAttribute("width", "100%"); bgRect.setAttribute("height", "100%"); bgRect.setAttribute("fill", "white");
        mask.appendChild(bgRect);
        const cutoutRect = document.createElementNS(svgNS, "rect");
        cutoutRect.setAttribute("x", viewportLeft); cutoutRect.setAttribute("y", viewportTop);
        cutoutRect.setAttribute("width", viewportWidth); cutoutRect.setAttribute("height", viewportHeight);
        cutoutRect.setAttribute("fill", "black"); 
        mask.appendChild(cutoutRect); svg.appendChild(mask);
        const dimRect = document.createElementNS(svgNS, "rect");
        dimRect.setAttribute("x", "0"); dimRect.setAttribute("y", "0"); dimRect.setAttribute("width", "100%"); dimRect.setAttribute("height", "100%");
        dimRect.setAttribute("fill", "rgba(0, 0, 0, 0.75)"); dimRect.setAttribute("mask", "url(#spotlightMask)");
        svg.appendChild(dimRect); document.body.appendChild(svg);
        const clickCatcher = document.createElement('div'); clickCatcher.id = 'spotlightClickCatcher';
        clickCatcher.style.position = 'fixed'; clickCatcher.style.top = '0'; clickCatcher.style.left = '0';
        clickCatcher.style.width = '100vw'; clickCatcher.style.height = '100vh';
        clickCatcher.style.zIndex = '9989';  clickCatcher.style.cursor = 'pointer'; 
        clickCatcher.addEventListener('click', function(event) { console.log("Spotlight click catcher clicked."); hideSpotlightSVG(); event.stopPropagation(); });
        document.body.appendChild(clickCatcher);
        viewerApp.state.isSpotlightActive = true;
        viewerApp.state.currentSpotlightInfo = { svg: svg, clickCatcher: clickCatcher, targetFabricObject: targetFabricObject,};
        displayMessageViewer("Spotlight active. Click anywhere to dismiss.", true);
        console.log("[WebApp] SVG Spotlight activated for Fabric object:", targetFabricObject);
    }
    function hideSpotlightSVG() {
        if (!viewerApp.state.isSpotlightActive || !viewerApp.state.currentSpotlightInfo) return;
        console.log('[WebApp] Hiding SVG Spotlight');
        if (viewerApp.state.currentSpotlightInfo.svg) document.body.removeChild(viewerApp.state.currentSpotlightInfo.svg);
        if (viewerApp.state.currentSpotlightInfo.clickCatcher) document.body.removeChild(viewerApp.state.currentSpotlightInfo.clickCatcher);
        viewerApp.state.isSpotlightActive = false; viewerApp.state.currentSpotlightInfo = null;
    }

    function updateSlideNavigationUI() {
        console.log("updateSlideNavigationUI called. Current Index:", viewerApp.state.currentSlideIndex, "Project Data:", viewerApp.state.currentProjectData);
        if (!viewerApp.state.currentProjectData || !Array.isArray(viewerApp.state.currentProjectData.slides)) {
             console.error("updateSlideNavigationUI: Invalid project data or slides array.");
             if (viewerSlideIndicatorEl) viewerSlideIndicatorEl.textContent = "Slide ? / ?";
             if (viewerPrevSlideButtonEl) viewerPrevSlideButtonEl.disabled = true;
             if (viewerNextSlideButtonEl) viewerNextSlideButtonEl.disabled = true;
             return;
        }
        const numSlides = viewerApp.state.currentProjectData.slides.length;
        const currentIndex = viewerApp.state.currentSlideIndex;
        if (viewerSlideIndicatorEl) viewerSlideIndicatorEl.textContent = `Slide ${currentIndex + 1} / ${numSlides}`;
        if (viewerPrevSlideButtonEl) viewerPrevSlideButtonEl.disabled = (currentIndex <= 0);
        if (viewerNextSlideButtonEl) viewerNextSlideButtonEl.disabled = (currentIndex >= numSlides - 1);
    }
    function navigateToPrevSlide() { if (viewerApp.state.currentSlideIndex > 0) renderSlideForViewing(viewerApp.state.currentSlideIndex - 1); }
    function navigateToNextSlide() { if (viewerApp.state.currentProjectData && viewerApp.state.currentSlideIndex < viewerApp.state.currentProjectData.slides.length - 1) renderSlideForViewing(viewerApp.state.currentSlideIndex + 1); }

    window.onYouTubeIframeAPIReady = function() { console.log("YouTube IFrame API Ready (called by external script)."); isYouTubeApiReady = true;};

    function setupYouTubePlayer(videoId) {
        if (!youtubePlayerContainerEl) { console.error("YouTube player container element not found."); displayMessageViewer("YouTube player setup error: container missing.", false); return; }
        youtubePlayerContainerEl.innerHTML = '<div id="youtube-player-div" style="width: 100%; height: 100%;"></div>';
        youtubePlayerContainerEl.style.display = 'block';
        console.log("Setting up YouTube player for video ID:", videoId);
        
        if (!isYouTubeApiReady || typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
            console.error("YT object or YT.Player is not available or API not ready.");
            displayMessageViewer("YouTube Player API not available. Please check your internet connection and refresh.", false); return;
        }
        try {
             if(viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.destroy === 'function') {
                 console.log("Destroying previous YT player instance.");
                 viewerApp.state.ytPlayer.destroy();
                 viewerApp.state.ytPlayer = null;
             }
             console.log("Creating new YT.Player instance.");
             viewerApp.state.ytPlayer = new YT.Player('youtube-player-div', {
                height: '100%', width: '100%', videoId: videoId,
                // Ensure all required playerVars are present, especially disablekb: 1
                playerVars: {
                    'autoplay': 0,
                    'controls': 0,
                    'rel': 0,
                    'showinfo': 0,
                    'modestbranding': 1,
                    'iv_load_policy': 3,
                    'fs': 0,
                    'disablekb': 1, // Ensures keyboard controls are disabled
                    'playsinline': 1
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': onPlayerError
                }
            });
             console.log("YT.Player instance created successfully.");
        } catch (e) {
            console.error("Error creating YouTube player instance:", e);
            displayMessageViewer(`Error initializing YouTube player: ${e.message}`, false);
             if (youtubePlayerContainerEl) youtubePlayerContainerEl.style.display = 'none';
        }
    }

    function onPlayerReady(event) {
        console.log("YouTube Player Ready for video:", event.target.getVideoData().video_id);
        const videoDuration = event.target.getDuration();
        viewerApp.state.currentVideoDuration = videoDuration; // Store duration
        if (viewerTotalDurationEl) viewerTotalDurationEl.textContent = formatTime(videoDuration);
        if (viewerCurrentTimeEl) viewerCurrentTimeEl.textContent = formatTime(0); // Reset current time display
        if (viewerTimelineProgressEl) viewerTimelineProgressEl.style.width = '0%'; // Reset progress bar
        if (viewerVideoTimelineContainerEl) viewerVideoTimelineContainerEl.style.display = 'block'; // Show timeline

        // renderQuestionMarkers(); // Call this after duration is known - REPLACED by renderTimelineMarkers
        renderTimelineMarkers(); // New function to render all timeline markers

         if(youtubePlayerContainerEl && !youtubePlayerContainerEl.hasAttribute('click-listener-added')){
             console.log("Adding click-to-play listener to YT player container.");
             youtubePlayerContainerEl.addEventListener('click', function() {
                 console.log("Player container clicked.");
                 if (viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.playVideo === 'function' && typeof viewerApp.state.ytPlayer.pauseVideo === 'function' && typeof viewerApp.state.ytPlayer.getPlayerState === 'function') {
                     const state = viewerApp.state.ytPlayer.getPlayerState();
                     if (state !== YT.PlayerState.PLAYING) { console.log("Calling playVideo()."); viewerApp.state.ytPlayer.playVideo(); } 
                     else { console.log("Calling pauseVideo()."); viewerApp.state.ytPlayer.pauseVideo(); }
                 } else { console.warn("Cannot play/pause: Player or methods not available."); }
             });
             youtubePlayerContainerEl.setAttribute('click-listener-added', 'true');
         }
    }

    // New function for Phase 1 to render question markers on the timeline - REPLACED by renderTimelineMarkers
    // function renderQuestionMarkers() { ... } // Removed

    function renderTimelineMarkers() {
        if (!viewerTimelineTrackEl || !viewerApp.state.currentVideoDuration || viewerApp.state.currentVideoDuration <= 0) {
            console.warn("renderTimelineMarkers: Timeline track or video duration not available.");
            return;
        }

        // Clear any existing markers
        const existingMarkers = viewerTimelineTrackEl.querySelectorAll('.timeline-marker');
        existingMarkers.forEach(marker => marker.remove());

        // Render Question Markers
        if (viewerApp.state.currentVideoQuestions && viewerApp.state.currentVideoQuestions.length > 0) {
            viewerApp.state.currentVideoQuestions.forEach(question => {
                const marker = document.createElement('div');
                marker.className = 'timeline-marker question-marker'; // Generic and specific class
                marker.style.position = 'absolute';
                marker.style.width = '3px';
                marker.style.height = '100%';
                marker.style.backgroundColor = 'orange'; // Question color
                marker.style.top = '0px';
                marker.style.zIndex = '2'; // Ensure visible above progress bar

                const percentagePosition = (question.timestamp / viewerApp.state.currentVideoDuration) * 100;
                marker.style.left = percentagePosition + '%';
                marker.title = `Question at ${formatTime(question.timestamp)}: ${question.questionText.substring(0, 30)}...`;
                viewerTimelineTrackEl.appendChild(marker);
            });
        }

        // Render Timestamp Overlay Markers
        if (viewerApp.state.currentTimestampOverlays && viewerApp.state.currentTimestampOverlays.length > 0) {
            viewerApp.state.currentTimestampOverlays.forEach(overlayDef => {
                if (overlayDef && typeof overlayDef.timestampShow !== 'undefined' && overlayDef.fabricObjectJSON) {
                    const marker = document.createElement('div');
                    marker.className = 'timeline-marker overlay-marker'; // Generic and specific class
                    marker.style.position = 'absolute';
                    marker.style.width = '3px'; 
                    marker.style.height = '100%';
                    marker.style.backgroundColor = '#4CAF50'; // Green for overlays
                    marker.style.top = '0px';
                    marker.style.zIndex = '2';

                    const percentagePosition = (overlayDef.timestampShow / viewerApp.state.currentVideoDuration) * 100;
                    marker.style.left = percentagePosition + '%';
                    // Attempt to get a meaningful name for the overlay from its JSON
                    let overlayName = 'Overlay';
                    if (overlayDef.fabricObjectJSON.type) {
                        overlayName = overlayDef.fabricObjectJSON.type.charAt(0).toUpperCase() + overlayDef.fabricObjectJSON.type.slice(1);
                    } else if (overlayDef.fabricObjectJSON.text) {
                         overlayName = `Text: "${overlayDef.fabricObjectJSON.text.substring(0,15)}..."`;
                    }
                    marker.title = `${overlayName} at ${formatTime(overlayDef.timestampShow)}`;
                    viewerTimelineTrackEl.appendChild(marker);
                }
            });
        }
    }


    function onPlayerStateChange(event) {
        console.log("YouTube Player State Change:", event.data);
        if (viewerApp.state.playerQuestionCheckInterval) { // Always clear previous interval
            clearInterval(viewerApp.state.playerQuestionCheckInterval);
            viewerApp.state.playerQuestionCheckInterval = null;
        }

        if (event.data === YT.PlayerState.PLAYING) {
            viewerApp.state.playerQuestionCheckInterval = setInterval(function() {
                if (viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.getCurrentTime === 'function') { // Ensure player exists
                    const currentTime = viewerApp.state.ytPlayer.getCurrentTime();
                    if (viewerCurrentTimeEl) viewerCurrentTimeEl.textContent = formatTime(currentTime);
                    if (viewerTimelineProgressEl && viewerApp.state.currentVideoDuration > 0) {
                        viewerTimelineProgressEl.style.width = (currentTime / viewerApp.state.currentVideoDuration) * 100 + '%';
                    }
                    checkVideoTimeForQuestions();
                    checkVideoTimeForTimestampOverlays(); 
                } else { // Player was destroyed or became unavailable
                    if (viewerApp.state.playerQuestionCheckInterval) {
                        clearInterval(viewerApp.state.playerQuestionCheckInterval);
                        viewerApp.state.playerQuestionCheckInterval = null;
                    }
                }

    function updateViewerCanvasInteractivity() {
        console.log("Placeholder: updateViewerCanvasInteractivity() called.");
        // Full logic will be added in a later step.
        // For now, ensure canvas is non-interactive if no other elements demand attention.
        // This is a simplified placeholder.
        const canvas = viewerApp.state.viewerFabricCanvas;
        if (canvas && !canvas.getObjects().some(obj => obj.evented && obj.customType !== 'clickToBeginButton')) { // Basic check
             if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '0';
             if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'none';
        }
    }
            }, 250);
        } else if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
            // Interval is cleared above, so no need to clear again here.
            checkVideoTimeForTimestampOverlays(); // Call once on pause/end for overlays
        }
    }

    // Ensure updateViewerCanvasInteractivity is a global helper function
    function updateViewerCanvasInteractivity() {
        const canvas = viewerApp.state.viewerFabricCanvas;
        if (!canvas || !viewerCanvasContainerEl || !viewerFabricCanvasEl) return;

        const isQuestionActive = canvas.getObjects().some(obj => obj.customType === 'videoQuestionOverlay');
        const isClickToBeginActive = canvas.getObjects().some(obj => obj.customType === 'clickToBeginButton');

        let isInteractiveTSOverlayVisible = false;
        let isAnyTSOverlayVisible = viewerApp.state.activeTimestampOverlayIds.size > 0;

        if (isAnyTSOverlayVisible) {
            for (const overlayDef of viewerApp.state.currentTimestampOverlays) {
                if (viewerApp.state.activeTimestampOverlayIds.has(overlayDef.overlayId) && overlayDef.isInteractive) {
                    isInteractiveTSOverlayVisible = true;
                    break;
                }
            }
        }

        if (isQuestionActive || isClickToBeginActive || isInteractiveTSOverlayVisible) {
            viewerCanvasContainerEl.style.pointerEvents = 'auto';
            viewerFabricCanvasEl.style.opacity = '1';
        } else if (isAnyTSOverlayVisible) { // Non-interactive overlay(s) are visible
            viewerCanvasContainerEl.style.pointerEvents = 'none'; // Pass clicks to player
            viewerFabricCanvasEl.style.opacity = '1'; // But canvas is visible
        } else { // No questions, no click-to-begin, no timestamp overlays active
            if (viewerApp.state.currentMediaType === 'youtube') {
                viewerCanvasContainerEl.style.pointerEvents = 'none';
                viewerFabricCanvasEl.style.opacity = '0';
            } else { // For non-YouTube media, default to interactive canvas
                viewerCanvasContainerEl.style.pointerEvents = 'auto';
                viewerFabricCanvasEl.style.opacity = '1';
            }
        }
        // canvas.requestRenderAll(); // Not strictly needed here as callers should render
    }

    function onPlayerError(event) {
        console.error("YouTube Player Error Code:", event.data);
        let errorMsg = `YouTube Player Error: Code ${event.data}. `;
        switch (event.data) {
            case 2: errorMsg += "Invalid video ID."; break; case 5: errorMsg += "HTML5 player error."; break;
            case 100: errorMsg += "Video not found or private."; break; case 101: case 150: errorMsg += "Playback forbidden by owner."; break;
            default: errorMsg += "Unknown error."; break;
        }
        displayMessageViewer(errorMsg, false);
    }

    function stopAndDestroyYouTubePlayer() {
        try {
            if (viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.stopVideo === 'function') {
                viewerApp.state.ytPlayer.stopVideo();
            }
            if (viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.destroy === 'function') {
                viewerApp.state.ytPlayer.destroy();
            }
        } catch (e) {
            console.error("Error stopping/destroying YouTube player:", e);
        } finally {
            viewerApp.state.ytPlayer = null; // Ensure it's nulled out
            if (youtubePlayerContainerEl) {
                 youtubePlayerContainerEl.removeAttribute('click-listener-added');
                 youtubePlayerContainerEl.innerHTML = ''; youtubePlayerContainerEl.style.display = 'none';
             }
            if (viewerApp.state.playerQuestionCheckInterval) { clearInterval(viewerApp.state.playerQuestionCheckInterval); viewerApp.state.playerQuestionCheckInterval = null;}
            viewerApp.state.currentVideoQuestions = []; viewerApp.state.askedQuestionIndices = [];
            
            // Cleanup Fabric objects: Timestamp overlays and ClickToBeginButton
            if (viewerApp.state.viewerFabricCanvas) {
                const canvas = viewerApp.state.viewerFabricCanvas;
                const objectsToRemove = [];
                canvas.getObjects().forEach(obj => {
                    // Check for timestamp overlays by overlayId
                    if (obj.overlayId && viewerApp.state.activeTimestampOverlayIds.has(obj.overlayId)) {
                        objectsToRemove.push(obj);
                    }
                    // Check for ClickToBeginButton by customType
                    if (obj.customType === 'clickToBeginButton') {
                        objectsToRemove.push(obj);
                    }
                });
                objectsToRemove.forEach(obj => canvas.remove(obj));
                if (objectsToRemove.length > 0) {
                    canvas.requestRenderAll(); // Render after removing objects
                }
            }
            viewerApp.state.currentTimestampOverlays = []; // Clear state for timestamp overlays
            viewerApp.state.activeTimestampOverlayIds.clear();
            
            // Phase 1: Timeline cleanup
            viewerApp.state.currentVideoDuration = 0;
            if (viewerVideoTimelineContainerEl) viewerVideoTimelineContainerEl.style.display = 'none';
            if (viewerTimelineProgressEl) viewerTimelineProgressEl.style.width = '0%';
            if (viewerCurrentTimeEl) viewerCurrentTimeEl.textContent = formatTime(0);
            if (viewerTotalDurationEl) viewerTotalDurationEl.textContent = formatTime(0);
            if (viewerTimelineTrackEl) { // Clear all timeline markers
                const existingMarkers = viewerTimelineTrackEl.querySelectorAll('.timeline-marker');
                existingMarkers.forEach(marker => marker.remove());
            }

            if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '0'; 
            if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'none';
        }
    }

    function extractYouTubeVideoId(url) {
        if (!url) return null; let videoId = null;
        try { const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/; const match = url.match(regExp); videoId = (match && match[2].length === 11) ? match[2] : null;} 
        catch (e) { console.error("Error extracting YouTube Video ID:", e); videoId = null; }
        console.log(`Extracted Video ID: ${videoId} from URL: ${url}`); return videoId;
    }

    function setupAudioPlayer(audioDataURI) {
        if (!viewerAudioPlayerEl) { console.error("Audio player element not found."); return;}
        console.log("Setting up audio player.");
        try {
             viewerAudioPlayerEl.src = audioDataURI; viewerAudioPlayerEl.load();
             const playPromise = viewerAudioPlayerEl.play();
             if (playPromise !== undefined) { playPromise.then(() => console.log("Audio playback started.")).catch(error => console.error("Audio playback failed:", error));}
             viewerAudioPlayerEl.style.display = 'block'; viewerApp.state.currentAudioElement = viewerAudioPlayerEl;
        } catch (e) { console.error("Error setting up audio player:", e); displayMessageViewer("Error loading audio.", false); }
    }
    function stopAndClearAudioPlayer() {
        const audioPlayer = viewerApp.state.currentAudioElement || viewerAudioPlayerEl;
        if (audioPlayer) { try { if (!audioPlayer.paused) audioPlayer.pause(); audioPlayer.removeAttribute('src'); audioPlayer.load(); audioPlayer.style.display = 'none'; console.log("Audio Player Stopped and Cleared."); } catch (e) { console.error("Error stopping/clearing audio player:", e); }}
         viewerApp.state.currentAudioElement = null;
    }
    function applySpotlightEffect(targetObject) { /* SVG version preferred, this might be removed */ }
    function removeSpotlightEffect() { /* SVG version preferred, this might be removed */ }

    function checkVideoTimeForQuestions() {
        if (!viewerApp.state.ytPlayer || typeof viewerApp.state.ytPlayer.getCurrentTime !== 'function' || !viewerApp.state.currentVideoQuestions) return;
        const currentTime = viewerApp.state.ytPlayer.getCurrentTime();
        for (let i = 0; i < viewerApp.state.currentVideoQuestions.length; i++) {
            const question = viewerApp.state.currentVideoQuestions[i];
            if (currentTime >= question.timestamp && !viewerApp.state.askedQuestionIndices.includes(i)) {
                if(viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.pauseVideo === 'function') viewerApp.state.ytPlayer.pauseVideo();
                viewerApp.state.askedQuestionIndices.push(i);
                // Interval is cleared in onPlayerStateChange when paused/ended. No need to clear here
                // if the pause for the question itself triggers the state change that clears it.
                displayQuestion(question, viewerApp.state.currentMediaType); 
                break; 
            }
        }
    }

    function displayQuestion(question, mediaType) { 
        const canvas = viewerApp.state.viewerFabricCanvas; if (!canvas) return;

        // Ensure canvas is interactive for the question
        if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'auto';
        if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '1';

        const dialogWidth = Math.min(canvas.width * 0.9, 600); // Max width for dialog
        const dialogHeightRatio = canvas.height > 500 ? 0.75 : 0.85; // Adjust height ratio for smaller canvases
        let dialogHeight = canvas.height * dialogHeightRatio; 

        const dialogBackground = new fabric.Rect({
            left: canvas.width / 2, top: canvas.height / 2, originX: 'center', originY: 'center',
            width: dialogWidth, height: dialogHeight, fill: 'rgba(20, 20, 20, 0.92)', 
            rx: 15, ry: 15, stroke: 'rgba(200, 200, 200, 0.5)', strokeWidth: 1,
            shadow: 'rgba(0,0,0,0.6) 8px 8px 20px',
            selectable: false, evented: false, customType: 'videoQuestionOverlay'
        });

        const questionFontSize = Math.max(16, Math.min(28, dialogWidth / 25)); // Responsive font size
        const questionText = new fabric.Textbox(question.questionText, {
            left: dialogBackground.left, top: dialogBackground.top - dialogBackground.height / 2 + (questionFontSize * 1.5), 
            originX: 'center', originY: 'top', width: dialogWidth * 0.85, 
            fontSize: questionFontSize, fill: '#EFEFEF', textAlign: 'center', padding: 10,
            selectable: false, evented: false, customType: 'videoQuestionOverlay'
        });
        
        const optionFontSize = Math.max(14, Math.min(22, dialogWidth / 30));
        const optionHeight = optionFontSize * 2.2; // Proportional height
        const optionMargin = optionFontSize * 0.8;
        const optionsContainerWidth = dialogWidth * 0.8;
        const totalOptionsContentHeight = question.options.length * (optionHeight + optionMargin) - optionMargin;
        
        // Recalculate dialogHeight if content (question + options) is too large
        const minContentHeight = questionText.height + totalOptionsContentHeight + (questionFontSize * 2) + (optionMargin * 2); // Approx.
        if (minContentHeight > dialogHeight) {
            dialogHeight = minContentHeight + 40; // Add some padding
            dialogBackground.set('height', dialogHeight);
        }
        // Re-adjust questionText top if dialogHeight changed
        questionText.set('top', dialogBackground.top - dialogBackground.height / 2 + (questionFontSize * 1.5));


        let startY = questionText.top + questionText.height + optionMargin * 1.5; 
        const remainingDialogHeightForOptions = dialogBackground.height - (questionText.top - (dialogBackground.top - dialogBackground.height/2)) - questionText.height - (optionMargin * 1.5);
        if (totalOptionsContentHeight < remainingDialogHeightForOptions) { // Center options in remaining space
            startY = questionText.top + questionText.height + (remainingDialogHeightForOptions - totalOptionsContentHeight) / 2;
        }
        
        canvas.add(dialogBackground); // Add background first
        canvas.add(questionText);   // Then question text

        question.options.forEach((optionStr, index) => {
            const optionGroupY = startY + index * (optionHeight + optionMargin);
            const optionRect = new fabric.Rect({
                width: optionsContainerWidth, height: optionHeight, fill: 'rgba(60, 60, 60, 0.95)', 
                stroke: '#888', strokeWidth: 1, rx: 8, ry: 8, originX: 'center', originY: 'top'
            });
            const optionTextContent = new fabric.Textbox(optionStr, {
                fontSize: optionFontSize, fill: '#DADADA', width: optionRect.width - 20, 
                textAlign: 'center', originX: 'center', originY: 'center', top: optionRect.height / 2 
            });
            const optionGroup = new fabric.Group([optionRect, optionTextContent], {
                left: dialogBackground.left, top: optionGroupY, originX: 'center', originY: 'top', 
                selectable: false, evented: true, customType: 'videoQuestionOverlay', 
                customAnswerIndex: index, hoverCursor: 'pointer'
            });
            canvas.add(optionGroup);

            optionGroup.on('mousedown', function() {
                const isCorrect = (this.customAnswerIndex === question.correctOptionIndex);
                this.item(0).set('fill', isCorrect ? 'rgba(40, 180, 99, 0.95)' : 'rgba(231, 76, 60, 0.95)');
                
                const feedbackSymbolText = isCorrect ? '✓' : '✗';
                const feedbackSymbolColor = isCorrect ? '#D5F5E3' : '#FADBD8';
                const existingSymbol = this.getObjects().find(obj => obj.isFeedbackSymbol);
                if (existingSymbol) this.remove(existingSymbol); // Remove if one exists

                const feedbackSymbol = new fabric.Text(feedbackSymbolText, {
                    fontSize: optionFontSize * 1.2, fill: feedbackSymbolColor,
                    left: this.item(0).width / 2 - (optionFontSize * 0.5), // Position to the right
                    top: this.item(0).height / 2, originX: 'right', originY: 'center',
                    selectable: false, evented: false, isFeedbackSymbol: true
                });
                this.addWithUpdate(feedbackSymbol);
                this.item(1).set('width', optionRect.width - (optionFontSize * 2)); // Adjust text width for symbol

                canvas.renderAll();
                canvas.getObjects('group').forEach(obj => { if (obj.customType === 'videoQuestionOverlay' && obj.customAnswerIndex !== undefined) obj.evented = false;});

                setTimeout(() => {
                    canvas.getObjects().forEach(obj => { if (obj.customType === 'videoQuestionOverlay') canvas.remove(obj);});
                    
                    // Determine canvas state after question
                    if (viewerApp.state.activeTimestampOverlayIds.size > 0) {
                         if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '1';
                         // Pointer events depend on whether active overlays are interactive (handled by checkVideoTimeForTimestampOverlays or a new updateCanvasInteractivity)
                         // For now, assume if overlays are present, canvas might need interaction.
                         if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'auto'; 
                    } else {
                         if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '0';
                         if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'none';
                    }
                    canvas.renderAll();
                    if(viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.playVideo === 'function') viewerApp.state.ytPlayer.playVideo();
                }, 1500); 
            });
        });
        canvas.renderAll();
    }

    function checkVideoTimeForTimestampOverlays() {
        if (!viewerApp.state.ytPlayer || typeof viewerApp.state.ytPlayer.getCurrentTime !== 'function' || 
            !viewerApp.state.viewerFabricCanvas || !viewerApp.state.currentTimestampOverlays) {
            return;
        }

        const currentTime = viewerApp.state.ytPlayer.getCurrentTime();
        const canvas = viewerApp.state.viewerFabricCanvas;

        viewerApp.state.currentTimestampOverlays.forEach(overlayDef => {
            if (!overlayDef || typeof overlayDef.timestampShow === 'undefined' || !overlayDef.overlayId || !overlayDef.fabricObjectJSON) {
                // console.warn("Skipping invalid overlay definition:", overlayDef);
                return; 
            }

            const shouldBeVisible = (currentTime >= overlayDef.timestampShow) && 
                                  (overlayDef.timestampHide === null || currentTime < overlayDef.timestampHide);
            const isActive = viewerApp.state.activeTimestampOverlayIds.has(overlayDef.overlayId);

            if (shouldBeVisible && !isActive) {
                fabric.util.enlivenObjects([overlayDef.fabricObjectJSON], function(enlivenedObjects) {
                    if (enlivenedObjects && enlivenedObjects.length > 0) {
                        const fabricObject = enlivenedObjects[0];
                        fabricObject.set({
                            selectable: false,
                            evented: false, // Default to non-evented
                            overlayId: overlayDef.overlayId, // Store overlayId for later reference
                            isTimestampOverlay: true // Mark it as a timestamp overlay for easier cleanup
                        });

                        // Apply custom properties that might have been stripped during JSON serialization/deserialization
                        // For example, if customInteraction was stored in fabricObjectJSON.customInteraction
                        if (overlayDef.fabricObjectJSON.customInteraction) {
                            fabricObject.customInteraction = {...overlayDef.fabricObjectJSON.customInteraction};
                        }
                        if (overlayDef.fabricObjectJSON.customAnimation) {
                            fabricObject.customAnimation = {...overlayDef.fabricObjectJSON.customAnimation};
                        }


                        if (overlayDef.isInteractive) {
                            fabricObject.set({
                                evented: true,
                                hoverCursor: 'pointer'
                            });
                            // Assuming 'click' is the primary trigger for interactive timestamp overlays.
                            // This might need to be more generic if overlays can have different triggers (e.g., hover)
                            // and if those triggers are defined within overlayDef.fabricObjectJSON.customInteraction.trigger
                            fabricObject.off('mousedown'); // Clear previous if any (e.g., from default fabric behavior)
                            fabricObject.on('mousedown', function() {
                                // If the overlay has its own customInteraction, use that.
                                if (this.customInteraction && this.customInteraction.trigger && this.customInteraction.action) {
                                    handleOverlayInteraction(this, this.customInteraction.trigger);
                                } else {
                                    // Fallback or default interaction if not specified in the object itself
                                    console.warn("Interactive timestamp overlay clicked, but no specific customInteraction defined on object. OverlayDef:", overlayDef);
                                }
                            });
                        }
                        
                        // Check if object with this ID already exists (e.g. due to rapid state changes)
                        let alreadyExists = false;
                        canvas.getObjects().forEach(obj => {
                            if (obj.overlayId === overlayDef.overlayId) {
                                alreadyExists = true;
                            }
                        });
                        if(!alreadyExists) {
                            canvas.add(fabricObject);
                            viewerApp.state.activeTimestampOverlayIds.add(overlayDef.overlayId);
                            // console.log("Added timestamp overlay:", overlayDef.overlayId, "at", currentTime);
                            canvas.requestRenderAll();
                            updateViewerCanvasInteractivity();
                        }
                    }
                }, ''); // Pass empty namespace, not strictly necessary for simple objects

            } else if (!shouldBeVisible && isActive) {
                let foundObject = null;
                canvas.getObjects().forEach(obj => {
                    if (obj.overlayId === overlayDef.overlayId) {
                        foundObject = obj;
                    }
                });

                if (foundObject) {
                    canvas.remove(foundObject);
                    viewerApp.state.activeTimestampOverlayIds.delete(overlayDef.overlayId);
                    // console.log("Removed timestamp overlay:", overlayDef.overlayId, "at", currentTime);
                    canvas.requestRenderAll();
                    updateViewerCanvasInteractivity();
                }
            }
        });
    }

    // updateCanvasInteractivity was renamed to updateViewerCanvasInteractivity, the placeholder below can be removed.
    // function updateCanvasInteractivity() { ... } // This is now updateViewerCanvasInteractivity

  </script>