<script>
    // Namespace for the viewer application
    window.viewerApp = {};

    // --- Global Variables ---
    let ytPlayer; // Global variable to hold the YouTube player instance
    let isYouTubeApiReady = false; // Flag to track API readiness
    const CLICK_AND_HOLD_DURATION = 750; // Milliseconds for click and hold

    // --- Application State ---
    viewerApp.state = {
      isLoading: false,
      currentProjectData: null,
      currentSlideIndex: 0, // Default to 0, will be updated
      viewerFabricCanvas: null,
      defaultCanvasWidth: 960,
      defaultCanvasHeight: 540,
      currentAudioElement: null, // Reference to the currently playing audio element
      // State for Modal Sequencing (Step 21)
      currentModalOverlay: null, // The Fabric object that triggered the current modal sequence
      modalSequence: [],         // Array of Fabric objects in the current sequence on the slide
      currentModalSequenceIndex: -1, // Index within modalSequence being displayed
      // --- State for Spotlight Overlay ---
      // spotlightOverlayObject: null // Holds the reference to the dimming overlay rect
      isSpotlightActive: false,
      currentSpotlightInfo: null // Will hold { svg, clickCatcher, targetFabricObject, textBubble, notesPanel }
    };

    // --- DOM Element References ---
    let viewerProjectListContainerEl, messageAreaElViewer, loadingSpinnerElViewer;
    let viewerListViewContainerEl, viewerProjectDisplayAreaEl, viewingProjectTitleEl;
    let viewerMediaContainerEl, youtubePlayerContainerEl, // New media container refs
        viewerCanvasContainerEl, viewerFabricCanvasEl;
    let viewerPrevSlideButtonEl, viewerNextSlideButtonEl, viewerSlideIndicatorEl, backToViewerListButtonEl;
    let viewerModalEl, viewerModalCloseButtonEl, viewerModalBodyEl,
        modalPrevButtonEl, modalNextButtonEl; // Modal Nav Buttons (Step 21)
    let viewerAudioPlayerEl; // Ref for the audio element

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function() {
      console.log("Viewer_JS: DOMContentLoaded event fired!");

      viewerApp.setupDOMReferences();
      viewerApp.attachEventListeners();

      loadViewerProjectsList();

      console.log("Viewer_JS: Initialization complete.");
    });

    viewerApp.setupDOMReferences = function() {
      viewerProjectListContainerEl = document.getElementById('viewerProjectListContainer');
      messageAreaElViewer = document.getElementById('messageAreaViewer');
      loadingSpinnerElViewer = document.getElementById('loadingSpinner');

      viewerListViewContainerEl = document.getElementById('viewerListViewContainer');
      viewerProjectDisplayAreaEl = document.getElementById('viewerProjectDisplayArea');
      viewingProjectTitleEl = document.getElementById('viewingProjectTitle');

      viewerMediaContainerEl = document.getElementById('viewerMediaContainer');
      youtubePlayerContainerEl = document.getElementById('youtubePlayerContainer');
      viewerCanvasContainerEl = document.getElementById('viewerCanvasContainer'); // Container for the canvas
      viewerFabricCanvasEl = document.getElementById('viewerFabricCanvas'); // The actual canvas element

      viewerPrevSlideButtonEl = document.getElementById('viewerPrevSlideButton');
      viewerNextSlideButtonEl = document.getElementById('viewerNextSlideButton');
      viewerSlideIndicatorEl = document.getElementById('viewerSlideIndicator');
      backToViewerListButtonEl = document.getElementById('backToViewerListButton');

      viewerModalEl = document.getElementById('viewerModal');
      viewerModalCloseButtonEl = document.getElementById('viewerModalCloseButton');
      viewerModalBodyEl = document.getElementById('viewerModalBody');
      modalPrevButtonEl = document.getElementById('modalPrevButton'); // Step 21
      modalNextButtonEl = document.getElementById('modalNextButton'); // Step 21

      viewerAudioPlayerEl = document.getElementById('viewerAudioPlayer');

      if (!viewerProjectListContainerEl) console.error("CRITICAL: viewerProjectListContainerEl not found!");
      if (!viewerModalEl) console.error("CRITICAL: viewerModalEl not found!");
      if (!viewerAudioPlayerEl) console.error("CRITICAL: viewerAudioPlayerEl not found!");
      if (!modalPrevButtonEl || !modalNextButtonEl) console.error("CRITICAL: Modal navigation buttons not found!"); // Step 21 Check
      // NEW: Get reference to the main display area for click-off listener
      viewerProjectDisplayAreaEl = document.getElementById('viewerProjectDisplayArea');
      if (!viewerProjectDisplayAreaEl) console.error("CRITICAL: viewerProjectDisplayAreaEl not found!"); // Add check

      console.log("Viewer_JS: DOM references set up.");
    };

    viewerApp.attachEventListeners = function() {
        if (backToViewerListButtonEl) backToViewerListButtonEl.addEventListener('click', showProjectListView);
        if (viewerPrevSlideButtonEl) viewerPrevSlideButtonEl.addEventListener('click', navigateToPrevSlide);
        if (viewerNextSlideButtonEl) viewerNextSlideButtonEl.addEventListener('click', navigateToNextSlide);
        if (viewerModalCloseButtonEl) viewerModalCloseButtonEl.addEventListener('click', hideViewerModal);
        if (viewerModalEl) { // Close modal if background is clicked
            viewerModalEl.addEventListener('click', function(event) {
                if (event.target === viewerModalEl) {
                    hideViewerModal();
                }
            });
        }
        // Step 21: Attach listeners for modal navigation buttons
        if (modalPrevButtonEl) modalPrevButtonEl.addEventListener('click', navigateModalPrevious);
        if (modalNextButtonEl) modalNextButtonEl.addEventListener('click', navigateModalNext);

        // Listener to remove spotlight when clicking outside the spotlighted object
        if (viewerProjectDisplayAreaEl) {
             viewerProjectDisplayAreaEl.addEventListener('click', function(event) {
                // If the spotlight overlay exists, remove it.
                // We rely on the fabric event on the target object stopping propagation
                // so this only fires on clicks *not* handled by the target object itself.
                // A more robust way would be to check if event.target is the canvas background.
                if (viewerApp.state.spotlightOverlayObject && event.target !== viewerApp.state.spotlightOverlayObject.target) {
                    console.log("Viewer area click detected while spotlight active, removing effect.");
                    removeSpotlightEffect();
                }
             }, false); // Use bubble phase
        }
    };

    // --- UI Utils & Server Error Handling ---
    function showLoadingViewer(show) {
      viewerApp.state.isLoading = show;
      if (loadingSpinnerElViewer) {
        loadingSpinnerElViewer.style.display = show ? 'flex' : 'none';
      } else if (show) {
          console.warn("showLoadingViewer(true) called but loadingSpinnerElViewer not yet available.");
      }
    }

    function displayMessageViewer(message, isSuccess) {
      if (messageAreaElViewer) {
        messageAreaElViewer.innerHTML = '';
        const p = document.createElement('p');
        p.textContent = message;
        messageAreaElViewer.appendChild(p);
        messageAreaElViewer.className = isSuccess ? 'success' : 'error';
        setTimeout(() => {
          if (messageAreaElViewer) {
            messageAreaElViewer.innerHTML = '';
            messageAreaElViewer.className = '';
          }
        }, 7000);
      } else {
        console.warn("displayMessageViewer called but messageAreaElViewer not available. Message:", message);
      }
    }

    function onServerErrorViewer(errorObject) {
      showLoadingViewer(false);
      console.error('Viewer Server Error Object:', errorObject);
      let errorMessage = "An unknown error occurred on the server.";
      if (typeof errorObject === 'string') {
          errorMessage = errorObject;
      } else if (errorObject && errorObject.message && typeof errorObject.message === 'string') {
          errorMessage = errorObject.message;
      } else if (errorObject && errorObject.name && errorObject.message) {
          errorMessage = `Error: ${errorObject.name} - ${errorObject.message}`;
      } else if (errorObject && errorObject.error && typeof errorObject.error === 'string') { // Handle {success:false, error:"..."}
          errorMessage = errorObject.error;
      }
      displayMessageViewer('Server Error: ' + errorMessage, false);
    }

    // --- Project List Loading/Display ---
    function loadViewerProjectsList() {
      console.log("loadViewerProjectsList called");
      if (!google || !google.script || !google.script.run) {
        console.error("google.script.run is not available for loadViewerProjectsList!");
        displayMessageViewer("Error: Client-server communication bridge unavailable.", false); return;
      }
      if (!viewerProjectListContainerEl) {
          console.warn("loadViewerProjectsList: viewerProjectListContainerEl not ready yet.");
          showLoadingViewer(false);
          return;
      }
      showLoadingViewer(true);
      google.script.run
        .withSuccessHandler(displayViewerProjects)
        .withFailureHandler(onServerErrorViewer)
        .getActiveProjectsList();
    }

    function displayViewerProjects(projectsArray) {
      showLoadingViewer(false);
      console.log("displayViewerProjects received:", projectsArray ? projectsArray.length : 0, "projects");
      if (!viewerProjectListContainerEl) {
          console.error("displayViewerProjects: viewerProjectListContainerEl is not found!");
          return;
      }
      viewerProjectListContainerEl.innerHTML = '';
      if (!projectsArray || projectsArray.length === 0) {
        viewerProjectListContainerEl.innerHTML = '<p>No active training modules found at this time.</p>';
        return;
      }

      const ul = document.createElement('ul');
      ul.className = 'project-list-viewer';

      projectsArray.forEach(project => {
        if (!project || !project.projectId) {
            console.warn("Skipping display of invalid project object:", project);
            return;
        }
        const listItem = document.createElement('li');
        listItem.className = 'project-card-viewer';

        const titleHeader = document.createElement('h3');
        titleHeader.textContent = project.projectTitle || 'Untitled Project';

        const viewButton = document.createElement('button');
        viewButton.textContent = 'View Project';
        viewButton.className = 'view-project-button';
        viewButton.setAttribute('data-project-id', project.projectId);
        viewButton.onclick = function() {
          console.log("View Project button clicked for project ID:", project.projectId);
          loadProjectForViewing(project.projectId);
        };

        listItem.appendChild(titleHeader);
        listItem.appendChild(viewButton);
        ul.appendChild(listItem);
      });
      viewerProjectListContainerEl.appendChild(ul);
    }

    // --- View Switching & Cleanup ---
    function showProjectListView() {
        if (viewerListViewContainerEl) viewerListViewContainerEl.style.display = 'block';
        if (viewerProjectDisplayAreaEl) viewerProjectDisplayAreaEl.style.display = 'none';

        // Cleanup media players
        stopAndDestroyYouTubePlayer();
        stopAndClearAudioPlayer();
        // Remove spotlight if active
        hideSpotlightSVG();

        if (viewerApp.state.viewerFabricCanvas) {
            viewerApp.state.viewerFabricCanvas.dispose();
            viewerApp.state.viewerFabricCanvas = null;
        }
        viewerApp.state.currentProjectData = null;
        viewerApp.state.currentSlideIndex = 0;
        loadViewerProjectsList();
    }

    function showProjectView() {
        if (viewerListViewContainerEl) viewerListViewContainerEl.style.display = 'none';
        if (viewerProjectDisplayAreaEl) viewerProjectDisplayAreaEl.style.display = 'block';
    }

    // --- Project Data Loading ---
    function loadProjectForViewing(projectId) {
        if (!projectId) {
            displayMessageViewer("Invalid project ID.", false);
            return;
        }
        showLoadingViewer(true);
        displayMessageViewer("Loading project...", true);
        google.script.run
            .withSuccessHandler(onProjectViewDataReceived)
            .withFailureHandler(onServerErrorViewer)
            .getProjectViewData(projectId);
    }

    function onProjectViewDataReceived(response) {
        showLoadingViewer(false);
        if (!response || !response.success || !response.data) {
            onServerErrorViewer(response || { error: "Failed to load project data or project is not active." });
             showProjectListView(); // Go back to list on error
            return;
        }
        try {
            viewerApp.state.currentProjectData = JSON.parse(response.data);
             // Ensure slides array exists and has slideMedia initialized
             if (viewerApp.state.currentProjectData && Array.isArray(viewerApp.state.currentProjectData.slides)) {
                 viewerApp.state.currentProjectData.slides.forEach(slide => {
                    if (!slide.slideMedia) {
                        slide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
                    }
                 });
             } else {
                 throw new Error("Project data is missing slides array.");
             }

            if (viewerApp.state.currentProjectData.slides.length === 0) {
                displayMessageViewer("Project loaded, but it has no slides.", false);
                 showProjectListView(); // Go back to list if project is empty
                return;
            }

            console.log("Project for viewing loaded:", viewerApp.state.currentProjectData);
            console.log("Number of slides loaded:", viewerApp.state.currentProjectData.slides.length);

            viewerApp.state.currentSlideIndex = 0; // Reset to first slide
            showProjectView();
            if (viewingProjectTitleEl) viewingProjectTitleEl.textContent = viewerApp.state.currentProjectData.title || "Untitled Project";
            initializeViewerCanvas(); // Initialize canvas once per project load
            renderSlideForViewing(viewerApp.state.currentSlideIndex); // Render the first slide
            displayMessageViewer("Project loaded.", true);
        } catch (e) {
            console.error("Error parsing project data for viewing:", e);
            displayMessageViewer("Error loading project: Invalid data format.", false);
            viewerApp.state.currentProjectData = null;
             showProjectListView(); // Go back to list on error
        }
    }

    // --- Canvas & Slide Rendering ---
    function initializeViewerCanvas() {
        if (viewerApp.state.viewerFabricCanvas) {
            viewerApp.state.viewerFabricCanvas.dispose();
            viewerApp.state.viewerFabricCanvas = null;
        }
        if (!viewerFabricCanvasEl) {
            console.error("Viewer Fabric canvas element not found!");
            return;
        }
        try {
            viewerApp.state.viewerFabricCanvas = new fabric.Canvas(viewerFabricCanvasEl, {
                width: viewerApp.state.defaultCanvasWidth,
                height: viewerApp.state.defaultCanvasHeight,
                selection: false,
                hoverCursor: 'default',
                backgroundColor: 'transparent' // Default to transparent for layering
            });
             // Make canvas non-interactive for drawing selection, etc.
            viewerApp.state.viewerFabricCanvas.selection = false;
            viewerApp.state.viewerFabricCanvas.renderAll(); // Initial render
            console.log("Viewer canvas initialized.");
        } catch(e) {
            console.error("Error initializing viewer Fabric canvas:", e);
            displayMessageViewer("Error initializing display canvas.", false);
        }
    }

    function renderSlideForViewing(slideIndex) {
        if (!viewerApp.state.currentProjectData || !viewerApp.state.viewerFabricCanvas) {
            console.error("Cannot render slide: Project data or canvas not ready."); return;
        }
        const slides = viewerApp.state.currentProjectData.slides;
        if (slideIndex < 0 || slideIndex >= slides.length) {
            console.error("Invalid slide index:", slideIndex); return;
        }

        // --- Cleanup Previous Slide Media FIRST ---
        stopAndDestroyYouTubePlayer();
        stopAndClearAudioPlayer();
        // Also remove any lingering spotlight effect from previous slide
        hideSpotlightSVG(); // Ensure spotlight is cleared when changing slides


        viewerApp.state.currentSlideIndex = slideIndex; // Update state *before* using it
        const slideData = slides[slideIndex];
        const canvas = viewerApp.state.viewerFabricCanvas;

        // Ensure slideMedia exists
         if (!slideData.slideMedia) {
            slideData.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
         }

        // Set canvas dimensions and container dimensions
        const slideWidth = slideData.canvasWidth || viewerApp.state.defaultCanvasWidth;
        const slideHeight = slideData.canvasHeight || viewerApp.state.defaultCanvasHeight;
        const media = slideData.slideMedia;
        let mediaType = (media && media.type) ? media.type : 'none';

        // Set canvas element size regardless of media type now
        canvas.setWidth(slideWidth);
        canvas.setHeight(slideHeight);
        if (viewerFabricCanvasEl) {
            viewerFabricCanvasEl.width = slideWidth;
            viewerFabricCanvasEl.height = slideHeight;
        }
        // Adjust media container size
        if (viewerMediaContainerEl) {
            viewerMediaContainerEl.style.width = slideWidth + 'px';
            viewerMediaContainerEl.style.height = slideHeight + 'px';
        }

        // Clear canvas objects and background image
        canvas.clear();
        canvas.setBackgroundImage(null, () => { canvas.renderAll(); });
        canvas.backgroundColor = 'transparent';

        // Hide/show containers based on media type
        if (youtubePlayerContainerEl) youtubePlayerContainerEl.style.display = (mediaType === 'youtube') ? 'block' : 'none';
        if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.display = (mediaType === 'youtube') ? 'none' : 'flex'; // Show unless YT
        if (viewerAudioPlayerEl) viewerAudioPlayerEl.style.display = 'none'; // Hide audio initially

        console.log(`Rendering slide ${slideIndex + 1}, media type: ${mediaType}`);

        switch(mediaType) {
            case 'image':
                if (media.url && media.url.startsWith('data:image')) {
                    fabric.Image.fromURL(media.url, function(img) {
                        if (!viewerApp.state.viewerFabricCanvas || viewerApp.state.currentSlideIndex !== slideIndex) return;
                        canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                            scaleX: canvas.width / img.width, scaleY: canvas.height / img.height
                        });
                    }, { crossOrigin: 'anonymous' });
                } else {
                     console.warn("Image media present but URL is missing or not base64:", media.url);
                     canvas.backgroundColor = '#e9e9e9';
                     canvas.renderAll();
                }
                break;

            case 'youtube':
                if (media.url) {
                    const videoId = extractYouTubeVideoId(media.url);
                    if (videoId) {
                        // Canvas container is already hidden
                        if (isYouTubeApiReady) {
                             setupYouTubePlayer(videoId);
                        } else {
                             console.warn("YouTube API not ready yet when trying to render slide.");
                        }
                         // No canvas background setting needed
                    } else {
                        console.error("Could not extract YouTube Video ID from URL:", media.url);
                         // Show canvas container with error BG if YT fails
                         if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.display = 'flex';
                         canvas.backgroundColor = '#555';
                         canvas.renderAll();
                    }
                } else {
                     console.warn("YouTube media type set but URL is missing.");
                      if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.display = 'flex'; // Show canvas
                     canvas.backgroundColor = '#e9e9e9';
                     canvas.renderAll();
                }
                break;

            case 'audio':
                 // Canvas container is already visible
                 if (media.driveFileId) {
                     console.log("Audio media needs fetch from Drive ID:", media.driveFileId);
                     showLoadingViewer(true);
                     google.script.run
                         .withSuccessHandler(function(audioResponse) {
                             showLoadingViewer(false);
                             if (viewerApp.state.currentSlideIndex !== slideIndex) return;
                             if (audioResponse && audioResponse.success && audioResponse.base64Data) {
                                 setupAudioPlayer(audioResponse.base64Data);
                                 if (viewerAudioPlayerEl) viewerAudioPlayerEl.style.display = 'block';
                                 canvas.backgroundColor = '#e0e0e0';
                                 canvas.renderAll();
                             } else {
                                 console.error("Failed to fetch audio base64 data:", audioResponse);
                                 onServerErrorViewer(audioResponse || {error: "Failed to load audio data."});
                                 canvas.backgroundColor = '#e9e9e9';
                                 canvas.renderAll();
                             }
                         })
                         .withFailureHandler(function(error) {
                             showLoadingViewer(false);
                             onServerErrorViewer(error);
                             canvas.backgroundColor = '#e9e9e9';
                             canvas.renderAll();
                         })
                         .getAudioAsBase64(media.driveFileId);
                 } else {
                     console.warn("Audio media type set but driveFileId is missing.");
                     canvas.backgroundColor = '#e9e9e9';
                     canvas.renderAll();
                 }
                 break;

            default: // 'none' or unknown
                 // Canvas container is already visible
                 canvas.backgroundColor = '#e9e9e9';
                 canvas.renderAll();
                 break;
        }

        // Load Fabric objects (overlays) ONLY if canvas container is visible
        if (viewerCanvasContainerEl && viewerCanvasContainerEl.style.display !== 'none' && slideData.fabricCanvasJSON) {
            canvas.loadFromJSON(slideData.fabricCanvasJSON, function() {
                if (viewerApp.state.currentSlideIndex !== slideIndex) return;

                canvas.forEachObject(function(obj) {
                    obj.selectable = false;
                    obj.evented = true; // Canvas container is visible, so events should work
                    obj.hoverCursor = 'pointer';
                    obj._clickAndHoldTimer = null;

                    obj.off('mousedown');
                    obj.off('mouseup');
                    obj.off('mouseout');
                    obj.off('mousemove'); // Usually not needed to cancel hold unless specific logic
                    obj.off('mouseover');

                    // Attach interaction listeners
                    if (obj.customInteraction && obj.customInteraction.trigger) {
                        const trigger = obj.customInteraction.trigger;
                        const action = obj.customInteraction.action;

                        // Special handling for "Click and Hold" + "Spotlight" (SVG Mask version)
                        if (trigger === 'clickAndHold' && action === 'spotlight') {
                            obj.on('mousedown', function(options) {
                                if (this.customInteraction && this.customInteraction.trigger === 'clickAndHold' && this.customInteraction.action === 'spotlight') {
                                    console.log("Hold-Spotlight: mousedown, showing spotlight for", this.type);
                                    showSpotlightSVG(this, this.customInteraction);
                                    // We don't stop propagation here as the target itself might be clicked again to dismiss a non-hold spotlight
                                    // However, for hold, the mouseup/mouseout on THIS object should dismiss.
                                }
                            });
                            obj.on('mouseup', function() {
                                if (this.customInteraction && this.customInteraction.trigger === 'clickAndHold' && this.customInteraction.action === 'spotlight') {
                                     // Only hide if the *current* spotlight target is this object
                                    if (viewerApp.state.isSpotlightActive && viewerApp.state.currentSpotlightInfo && viewerApp.state.currentSpotlightInfo.targetFabricObject === this) {
                                        console.log("Hold-Spotlight: mouseup, hiding spotlight for", this.type);
                                        hideSpotlightSVG();
                                    }
                                }
                            });
                            obj.on('mouseout', function() { // If mouse leaves while still holding
                                if (this.customInteraction && this.customInteraction.trigger === 'clickAndHold' && this.customInteraction.action === 'spotlight') {
                                     // Only hide if the *current* spotlight target is this object
                                    if (viewerApp.state.isSpotlightActive && viewerApp.state.currentSpotlightInfo && viewerApp.state.currentSpotlightInfo.targetFabricObject === this) {
                                        console.log("Hold-Spotlight: mouseout, hiding spotlight for", this.type);
                                        hideSpotlightSVG();
                                    }
                                }
                            });
                        }
                        // General click, hover, and other clickAndHold actions
                        else if (trigger === 'click') {
                            obj.on('mousedown', function(options) {
                                if (this.customInteraction && this.customInteraction.trigger === 'click') {
                                    if (this._clickAndHoldTimer) { // Clear any pending hold timer from other configs
                                        clearTimeout(this._clickAndHoldTimer); this._clickAndHoldTimer = null;
                                    }
                                    handleOverlayInteraction(this, 'click');
                                    if(options.e) options.e.stopPropagation();
                                }
                            });
                        } else if (trigger === 'hover') {
                             obj.on('mouseover', function() {
                                if (this.customInteraction && this.customInteraction.trigger === 'hover') {
                                    handleOverlayInteraction(this, 'hover');
                                }
                            });
                            // Note: you might need a mouseout for hover "undo" actions later
                        } else if (trigger === 'clickAndHold') { // For actions OTHER than spotlight
                            obj.on('mousedown', function(options) {
                                if (this.customInteraction && this.customInteraction.trigger === 'clickAndHold') { // Check trigger again
                                    if (this._clickAndHoldTimer) clearTimeout(this._clickAndHoldTimer);
                                    this._clickAndHoldTimer = setTimeout(() => {
                                        handleOverlayInteraction(this, 'clickAndHold');
                                        this._clickAndHoldTimer = null;
                                    }, CLICK_AND_HOLD_DURATION);
                                }
                            });
                            const cancelGenericHold = function() {
                                if (this._clickAndHoldTimer) {
                                    clearTimeout(this._clickAndHoldTimer); this._clickAndHoldTimer = null;
                                }
                            };
                            obj.on('mouseup', cancelGenericHold);
                            obj.on('mouseout', cancelGenericHold);
                        }
                    }
                });
                canvas.renderAll();
            });
        } else if (viewerCanvasContainerEl && viewerCanvasContainerEl.style.display !== 'none') {
             // Render canvas background if no JSON but canvas is visible
             if(mediaType !== 'image' && mediaType !== 'audio') { // Avoid redundant render
                 canvas.renderAll();
             }
        }
        updateSlideNavigationUI(); // Update nav AFTER potential async operations
    }

    // --- Interaction & Modal Handling ---
    function handleOverlayInteraction(fabricObject, eventType) {
        if (!fabricObject.customInteraction) return;
        const interaction = fabricObject.customInteraction;

        console.log(`Interaction Triggered: type=${eventType}, action=${interaction.action}, object=${fabricObject.type}, currentOpacity=${fabricObject.opacity}`);

        if (interaction.trigger !== eventType) {
            // This log helps debug if a 'click' mousedown is processed by a 'clickAndHold' configured object
            // before the hold timer completes or is cancelled.
            console.log(`Interaction Mismatch: Configured trigger '${interaction.trigger}' does not match event '${eventType}'. Ignoring for this handler instance.`);
            return;
        }
        // If a spotlight is active and the new action ISN'T spotlight, remove spotlight first.
        if (viewerApp.state.isSpotlightActive && interaction.action !== 'spotlight') {
            hideSpotlightSVG();
        }

        console.log("Handling interaction:", interaction.action, "for object:", fabricObject);

        switch (interaction.action) {
            case 'showModal':
                // hideSpotlightSVG(); // Already handled above
                if (fabricObject.customInteraction && fabricObject.customInteraction.modalContent) {
                    const canvas = viewerApp.state.viewerFabricCanvas;
                    if (!canvas) break;
                    const allObjects = canvas.getObjects();
                    viewerApp.state.modalSequence = allObjects.filter(obj =>
                        obj.customInteraction &&
                        obj.customInteraction.action === 'showModal' &&
                        typeof obj.sequenceOrder === 'number' &&
                        !isNaN(obj.sequenceOrder)
                    ).sort((a, b) => a.sequenceOrder - b.sequenceOrder);
                    viewerApp.state.currentModalSequenceIndex = viewerApp.state.modalSequence.findIndex(obj => obj === fabricObject);
                    if (viewerApp.state.currentModalSequenceIndex === -1) {
                        viewerApp.state.modalSequence = [fabricObject];
                        viewerApp.state.currentModalSequenceIndex = 0;
                    }
                    viewerApp.state.currentModalOverlay = fabricObject;
                    showViewerModal(interaction.modalContent);
                    updateModalNavigationButtons();
                } else {
                     console.warn("Show Modal: modalContent missing.");
                     if(modalPrevButtonEl) modalPrevButtonEl.style.display = 'none';
                     if(modalNextButtonEl) modalNextButtonEl.style.display = 'none';
                }
                break;
            case 'navigateToSlide':
                // hideSpotlightSVG(); // Already handled above
                const targetSlideId = interaction.navigateTo;
                if (targetSlideId && viewerApp.state.currentProjectData && viewerApp.state.currentProjectData.slides) {
                    const targetSlideIndex = viewerApp.state.currentProjectData.slides.findIndex(s => s.slideId === targetSlideId);
                    if (targetSlideIndex !== -1) {
                        renderSlideForViewing(targetSlideIndex);
                    } else {
                        displayMessageViewer(`Navigation error: Slide '${targetSlideId}' not found.`, false);
                    }
                }
                break;
            case 'navigateToURL':
                // hideSpotlightSVG(); // Already handled above
                if (interaction.navigateTo) {
                    let url = interaction.navigateTo;
                    if (!url.startsWith('http://') && !url.startsWith('https://')) url = 'https://' + url;
                    try {
                         const newWindow = window.open(url, '_blank');
                         if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
                              displayMessageViewer("Could not open link. Check popup settings.", false);
                         }
                    } catch (e) { displayMessageViewer("Error opening link.", false); }
                }
                break;
            case 'spotlight':
                 if (viewerApp.state.isSpotlightActive && viewerApp.state.currentSpotlightInfo && viewerApp.state.currentSpotlightInfo.targetFabricObject === fabricObject) {
                     // Clicking the *same* spotlighted object again toggles it off
                     hideSpotlightSVG();
                 } else {
                     // If different object or no spotlight, apply (hideSpotlightSVG is called within showSpotlightSVG if needed)
                     showSpotlightSVG(fabricObject, interaction);
                 }
                 break;
            case 'panZoomToTarget':
                // hideSpotlightSVG(); // Already handled if spotlight was active
                console.log("Pan/Zoom to Target action triggered for:", fabricObject);
                if (fabricObject && viewerApp.state.viewerFabricCanvas) {
                    const canvas = viewerApp.state.viewerFabricCanvas;
                    const centerPoint = fabricObject.getCenterPoint();
                    const desiredZoomLevel = 1.5; // Or make this configurable later

                    // canvas.viewportCenterObject(fabricObject); // This centers without zoom
                    // canvas.setZoom(desiredZoomLevel);

                    canvas.zoomToPoint(new fabric.Point(centerPoint.x, centerPoint.y), desiredZoomLevel);
                    // Note: zoomToPoint pans the canvas so that the given point is the new center of the viewport
                    // and then applies the zoom. If you want the object to appear larger at its *current*
                    // screen position, you might need viewportTransform calculations.
                    // For a simple "zoom in on this object", zoomToPoint is often good.
                    canvas.renderAll();
                    console.log(`Pan/Zoomed to point (${centerPoint.x}, ${centerPoint.y}) with zoom ${desiredZoomLevel}`);
                }
                break;
            case 'reveal':
                 console.log("Reveal action triggered for:", fabricObject);
                 if (fabricObject && viewerApp.state.viewerFabricCanvas) {
                      fabricObject.animate('opacity', 1, {
                          duration: 500,
                          onChange: viewerApp.state.viewerFabricCanvas.renderAll.bind(viewerApp.state.viewerFabricCanvas),
                          onComplete: () => console.log("Reveal complete. Opacity:", fabricObject.opacity)
                      });
                 }
                 break;
            default:
                console.log("Unknown interaction action:", interaction.action);
        }
    }

    function showViewerModal(htmlContent) {
        if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = htmlContent;
        if (viewerModalEl) viewerModalEl.style.display = 'flex';
    }

    function hideViewerModal() {
        if (viewerModalEl) viewerModalEl.style.display = 'none';
        if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = '';
        viewerApp.state.currentModalOverlay = null;
        viewerApp.state.modalSequence = [];
        viewerApp.state.currentModalSequenceIndex = -1;
        if(modalPrevButtonEl) modalPrevButtonEl.style.display = 'none';
        if(modalNextButtonEl) modalNextButtonEl.style.display = 'none';
    }

    function updateModalNavigationButtons() {
         if (!modalPrevButtonEl || !modalNextButtonEl) return;
         const sequence = viewerApp.state.modalSequence;
         const currentIndex = viewerApp.state.currentModalSequenceIndex;
         if (sequence.length <= 1) {
             modalPrevButtonEl.style.display = 'none';
             modalNextButtonEl.style.display = 'none';
             return;
         }
         if (currentIndex > 0) {
             modalPrevButtonEl.disabled = false;
             modalPrevButtonEl.style.display = 'inline-block';
         } else {
             modalPrevButtonEl.disabled = true;
              modalPrevButtonEl.style.display = 'inline-block';
         }
         if (currentIndex < sequence.length - 1) {
             modalNextButtonEl.disabled = false;
             modalNextButtonEl.style.display = 'inline-block';
         } else {
             modalNextButtonEl.disabled = true;
             modalNextButtonEl.style.display = 'inline-block';
         }
     }

     function navigateModalPrevious() {
          const sequence = viewerApp.state.modalSequence;
          let currentIndex = viewerApp.state.currentModalSequenceIndex;
          if (currentIndex > 0) {
              currentIndex--;
              const prevOverlay = sequence[currentIndex];
              if (prevOverlay && prevOverlay.customInteraction && prevOverlay.customInteraction.modalContent) {
                  viewerApp.state.currentModalSequenceIndex = currentIndex;
                  viewerApp.state.currentModalOverlay = prevOverlay;
                  if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = prevOverlay.customInteraction.modalContent;
                  updateModalNavigationButtons();
                  console.log("Navigated to previous modal, index:", currentIndex);
              } else {
                   console.error("Previous overlay or its content is invalid.");
              }
          }
     }

     function navigateModalNext() {
          const sequence = viewerApp.state.modalSequence;
          let currentIndex = viewerApp.state.currentModalSequenceIndex;
          if (currentIndex < sequence.length - 1) {
              currentIndex++;
              const nextOverlay = sequence[currentIndex];
               if (nextOverlay && nextOverlay.customInteraction && nextOverlay.customInteraction.modalContent) {
                   viewerApp.state.currentModalSequenceIndex = currentIndex;
                   viewerApp.state.currentModalOverlay = nextOverlay;
                   if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = nextOverlay.customInteraction.modalContent;
                   updateModalNavigationButtons();
                    console.log("Navigated to next modal, index:", currentIndex);
               } else {
                    console.error("Next overlay or its content is invalid.");
               }
          }
     }

     // --- Spotlight SVG Functions ---
    function showSpotlightSVG(targetFabricObject, interactionData) {
        hideSpotlightSVG(); // Remove any existing spotlight

        const canvas = viewerApp.state.viewerFabricCanvas;
        if (!canvas || !targetFabricObject) {
            console.error("Cannot show spotlight: canvas or targetFabricObject missing.");
            return;
        }

        console.log(`[WebApp] Spotlight SVG requested for Fabric object:`, targetFabricObject);

        // Get target's position and dimensions relative to the canvas
        // Fabric's getBoundingRect() gives coordinates relative to canvas top-left
        // We need to ensure these are correctly translated if the canvas itself has an offset
        // For simplicity now, assume canvas container (viewerMediaContainerEl) is the reference.

        const targetRect = targetFabricObject.getBoundingRect(true); // true for absolute coords within canvas
        const canvasRect = viewerFabricCanvasEl.getBoundingClientRect(); // Screen coords of canvas element

        // Calculate position for the SVG cutout relative to the viewport
        const viewportLeft = canvasRect.left + targetRect.left;
        const viewportTop = canvasRect.top + targetRect.top;
        const viewportWidth = targetRect.width;
        const viewportHeight = targetRect.height;

        console.log(`  Target BBox (canvas relative): L${targetRect.left}, T${targetRect.top}, W${targetRect.width}, H${targetRect.height}`);
        console.log(`  Canvas BBox (screen relative): L${canvasRect.left}, T${canvasRect.top}`);
        console.log(`  Cutout Coords (viewport): L${viewportLeft}, T${viewportTop}, W${viewportWidth}, H${viewportHeight}`);


        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("id", "spotlightSVG");
        // Style the SVG to cover the entire viewport
        svg.style.position = "fixed";
        svg.style.top = "0";
        svg.style.left = "0";
        svg.style.width = "100vw"; // Use viewport units
        svg.style.height = "100vh";
        svg.style.zIndex = "9990"; // High z-index
        svg.style.pointerEvents = "none"; // SVG itself doesn't catch clicks initially

        const mask = document.createElementNS(svgNS, "mask");
        mask.setAttribute("id", "spotlightMask");

        const bgRect = document.createElementNS(svgNS, "rect");
        bgRect.setAttribute("x", "0");
        bgRect.setAttribute("y", "0");
        bgRect.setAttribute("width", "100%");
        bgRect.setAttribute("height", "100%");
        bgRect.setAttribute("fill", "white");
        mask.appendChild(bgRect);

        const cutoutRect = document.createElementNS(svgNS, "rect");
        cutoutRect.setAttribute("x", viewportLeft);
        cutoutRect.setAttribute("y", viewportTop);
        cutoutRect.setAttribute("width", viewportWidth);
        cutoutRect.setAttribute("height", viewportHeight);
        cutoutRect.setAttribute("fill", "black"); // Black makes this part of the mask transparent
        // Optional: Add rounded corners to the cutout if desired
        // cutoutRect.setAttribute("rx", "5");
        // cutoutRect.setAttribute("ry", "5");
        mask.appendChild(cutoutRect);
        svg.appendChild(mask);

        const dimRect = document.createElementNS(svgNS, "rect");
        dimRect.setAttribute("x", "0");
        dimRect.setAttribute("y", "0");
        dimRect.setAttribute("width", "100%");
        dimRect.setAttribute("height", "100%");
        dimRect.setAttribute("fill", "rgba(0, 0, 0, 0.75)");
        dimRect.setAttribute("mask", "url(#spotlightMask)");
        svg.appendChild(dimRect);

        document.body.appendChild(svg);

        // Click Catcher (full screen, below SVG mask visually, but catches clicks)
        const clickCatcher = document.createElement('div');
        clickCatcher.id = 'spotlightClickCatcher';
        clickCatcher.style.position = 'fixed';
        clickCatcher.style.top = '0';
        clickCatcher.style.left = '0';
        clickCatcher.style.width = '100vw';
        clickCatcher.style.height = '100vh';
        clickCatcher.style.zIndex = '9989'; // Just below SVG
        clickCatcher.style.cursor = 'pointer'; // Indicate it's clickable
        clickCatcher.addEventListener('click', function(event) {
            console.log("Spotlight click catcher clicked.");
            hideSpotlightSVG();
            event.stopPropagation(); // Prevent further bubbling
        });
        document.body.appendChild(clickCatcher);

        // Store info
        viewerApp.state.isSpotlightActive = true;
        viewerApp.state.currentSpotlightInfo = {
            svg: svg,
            clickCatcher: clickCatcher,
            targetFabricObject: targetFabricObject,
            // textBubble: null, // For later text/notes
            // notesPanel: null
        };

        // Make the target Fabric object temporarily non-evented IF we don't want it to
        // trigger its own spotlight removal on a second click.
        // For now, allow clicking target again to remove.
        // targetFabricObject.set('evented', false); // Optional

        // Optional: Add a visual highlight to the Fabric object itself (e.g., temp stroke)
        // targetFabricObject.set('stroke', 'rgba(255, 255, 0, 0.7)');
        // targetFabricObject.set('strokeWidth', 3);
        // canvas.renderAll();

        displayMessageViewer("Spotlight active. Click anywhere to dismiss.", true);
        console.log("[WebApp] SVG Spotlight activated for Fabric object:", targetFabricObject);
    }

    function hideSpotlightSVG() {
        if (!viewerApp.state.isSpotlightActive || !viewerApp.state.currentSpotlightInfo) {
            return;
        }
        console.log('[WebApp] Hiding SVG Spotlight');

        if (viewerApp.state.currentSpotlightInfo.svg) {
            document.body.removeChild(viewerApp.state.currentSpotlightInfo.svg);
        }
        if (viewerApp.state.currentSpotlightInfo.clickCatcher) {
            document.body.removeChild(viewerApp.state.currentSpotlightInfo.clickCatcher);
        }

        // Restore target Fabric object's eventing if changed
        // if (viewerApp.state.currentSpotlightInfo.targetFabricObject) {
        //     viewerApp.state.currentSpotlightInfo.targetFabricObject.set('evented', true);
            // Remove temporary highlight
        //     viewerApp.state.currentSpotlightInfo.targetFabricObject.set('stroke', viewerApp.state.currentSpotlightInfo.originalStroke || null);
        //     viewerApp.state.currentSpotlightInfo.targetFabricObject.set('strokeWidth', viewerApp.state.currentSpotlightInfo.originalStrokeWidth || 0);
        //     if(viewerApp.state.viewerFabricCanvas) viewerApp.state.viewerFabricCanvas.renderAll();
        // }


        viewerApp.state.isSpotlightActive = false;
        viewerApp.state.currentSpotlightInfo = null;
        // displayMessageViewer("", true); // Clear message
    }
    // --- Slide Navigation ---
    function updateSlideNavigationUI() {
        console.log("updateSlideNavigationUI called. Current Index:", viewerApp.state.currentSlideIndex, "Project Data:", viewerApp.state.currentProjectData);
        if (!viewerApp.state.currentProjectData || !Array.isArray(viewerApp.state.currentProjectData.slides)) {
             console.error("updateSlideNavigationUI: Invalid project data or slides array.");
             if (viewerSlideIndicatorEl) viewerSlideIndicatorEl.textContent = "Slide ? / ?";
             if (viewerPrevSlideButtonEl) viewerPrevSlideButtonEl.disabled = true;
             if (viewerNextSlideButtonEl) viewerNextSlideButtonEl.disabled = true;
             return;
        }
        const numSlides = viewerApp.state.currentProjectData.slides.length;
        const currentIndex = viewerApp.state.currentSlideIndex;
        if (viewerSlideIndicatorEl) viewerSlideIndicatorEl.textContent = `Slide ${currentIndex + 1} / ${numSlides}`;
        if (viewerPrevSlideButtonEl) viewerPrevSlideButtonEl.disabled = (currentIndex <= 0);
        if (viewerNextSlideButtonEl) viewerNextSlideButtonEl.disabled = (currentIndex >= numSlides - 1);
    }

    function navigateToPrevSlide() {
         if (viewerApp.state.currentSlideIndex > 0) {
            renderSlideForViewing(viewerApp.state.currentSlideIndex - 1);
        }
    }
    function navigateToNextSlide() {
         if (viewerApp.state.currentProjectData && viewerApp.state.currentSlideIndex < viewerApp.state.currentProjectData.slides.length - 1) {
            renderSlideForViewing(viewerApp.state.currentSlideIndex + 1);
        }
    }

    // --- YouTube Player API Functions ---
    function onYouTubeIframeAPIReady() {
        console.log("YouTube IFrame API Ready (called by external script).");
        isYouTubeApiReady = true;
    }

    function setupYouTubePlayer(videoId) {
        if (!youtubePlayerContainerEl) {
            console.error("YouTube player container element not found."); return;
        }
        youtubePlayerContainerEl.innerHTML = '<div id="youtube-player-div" style="width: 100%; height: 100%;"></div>';
        youtubePlayerContainerEl.style.display = 'block';
        console.log("Setting up YouTube player for video ID:", videoId);
        if (!isYouTubeApiReady || typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
            console.error("YT object or YT.Player is not available or API not ready.");
            displayMessageViewer("YouTube Player API not ready. Please wait or reload.", false);
            return;
        }
        try {
             if(ytPlayer && typeof ytPlayer.destroy === 'function') {
                 console.log("Destroying previous YT player instance.");
                 ytPlayer.destroy();
                 ytPlayer = null;
             }
             console.log("Creating new YT.Player instance.");
             ytPlayer = new YT.Player('youtube-player-div', {
                height: '100%',
                width: '100%',
                videoId: videoId,
                playerVars: {
                    'autoplay': 0, 'controls': 0, 'rel': 0, 'showinfo': 0,
                    'modestbranding': 1, 'iv_load_policy': 3, 'fs': 0,
                    'disablekb': 1, 'playsinline': 1
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': onPlayerError
                }
            });
             console.log("YT.Player instance potentially created.");
        } catch (e) {
            console.error("Error creating YouTube player instance:", e);
            displayMessageViewer(`Error initializing YouTube player: ${e.message}`, false);
             if (youtubePlayerContainerEl) youtubePlayerContainerEl.style.display = 'none';
        }
    }

    function onPlayerReady(event) {
        console.log("YouTube Player Ready for video:", event.target.getVideoData().video_id);
         if(youtubePlayerContainerEl && !youtubePlayerContainerEl.hasAttribute('click-listener-added')){
             console.log("Adding click-to-play listener to YT player container.");
             youtubePlayerContainerEl.addEventListener('click', function() {
                 console.log("Player container clicked.");
                 if (ytPlayer && typeof ytPlayer.playVideo === 'function' && typeof ytPlayer.pauseVideo === 'function' && typeof ytPlayer.getPlayerState === 'function') {
                     const state = ytPlayer.getPlayerState();
                     if (state !== YT.PlayerState.PLAYING) {
                         console.log("Calling playVideo().");
                         ytPlayer.playVideo();
                     } else {
                         console.log("Calling pauseVideo().");
                         ytPlayer.pauseVideo();
                     }
                 } else {
                     console.warn("Cannot play/pause: Player or methods not available.");
                 }
             });
             youtubePlayerContainerEl.setAttribute('click-listener-added', 'true');
         }
    }

    function onPlayerStateChange(event) {
        console.log("YouTube Player State Change:", event.data);
    }

    function onPlayerError(event) {
        console.error("YouTube Player Error Code:", event.data);
        let errorMsg = `YouTube Player Error: Code ${event.data}. `;
        switch (event.data) {
            case 2: errorMsg += "Invalid video ID."; break;
            case 5: errorMsg += "HTML5 player error."; break;
            case 100: errorMsg += "Video not found or private."; break;
            case 101: case 150: errorMsg += "Playback forbidden by owner."; break;
            default: errorMsg += "Unknown error."; break;
        }
        displayMessageViewer(errorMsg, false);
    }

    function stopAndDestroyYouTubePlayer() {
        try {
            if (ytPlayer && typeof ytPlayer.stopVideo === 'function') ytPlayer.stopVideo();
            if (ytPlayer && typeof ytPlayer.destroy === 'function') ytPlayer.destroy();
            ytPlayer = null;
        } catch (e) { console.error("Error stopping/destroying YouTube player:", e); }
        finally {
             if (youtubePlayerContainerEl) {
                 youtubePlayerContainerEl.removeAttribute('click-listener-added');
                 youtubePlayerContainerEl.innerHTML = '';
                 youtubePlayerContainerEl.style.display = 'none';
             }
        }
    }

    function extractYouTubeVideoId(url) {
        if (!url) return null;
        let videoId = null;
        try {
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            videoId = (match && match[2].length === 11) ? match[2] : null;
        } catch (e) { console.error("Error extracting YouTube Video ID:", e); videoId = null; }
        console.log(`Extracted Video ID: ${videoId} from URL: ${url}`);
        return videoId;
    }

    function setupAudioPlayer(audioDataURI) {
        if (!viewerAudioPlayerEl) { console.error("Audio player element not found."); return;}
        console.log("Setting up audio player.");
        try {
             viewerAudioPlayerEl.src = audioDataURI;
             viewerAudioPlayerEl.load();
             const playPromise = viewerAudioPlayerEl.play();
             if (playPromise !== undefined) {
                 playPromise.then(() => console.log("Audio playback started."))
                          .catch(error => console.error("Audio playback failed:", error));
             }
             viewerAudioPlayerEl.style.display = 'block';
             viewerApp.state.currentAudioElement = viewerAudioPlayerEl;
        } catch (e) {
             console.error("Error setting up audio player:", e);
             displayMessageViewer("Error loading audio.", false);
        }
    }

    function stopAndClearAudioPlayer() {
        const audioPlayer = viewerApp.state.currentAudioElement || viewerAudioPlayerEl;
        if (audioPlayer) {
             try {
                 if (!audioPlayer.paused) audioPlayer.pause();
                 audioPlayer.removeAttribute('src');
                 audioPlayer.load();
                 audioPlayer.style.display = 'none';
                 console.log("Audio Player Stopped and Cleared.");
             } catch (e) { console.error("Error stopping/clearing audio player:", e); }
        }
         viewerApp.state.currentAudioElement = null;
    }

    // --- UPDATED Spotlight Functions (Step 23 - Cutout Overlay) ---
    function applySpotlightEffect(targetObject) {
        const canvas = viewerApp.state.viewerFabricCanvas;
        if (!canvas) {
            console.log("Spotlight not applied: Canvas not available.");
            return;
        }
        // If a spotlight is already active, remove it first.
        // This handles cases where another object is clicked for spotlight or the same object is clicked again.
        if (viewerApp.state.spotlightOverlayObject) {
            console.log("Spotlight already active, removing previous one first.");
            removeSpotlightEffect();
        }

        console.log("Applying spotlight (cutout) effect to:", targetObject);
        viewerApp.state.spotlightOverlayObject = {}; // Initialize as an object to indicate it's active
        viewerApp.state.spotlightOverlayObject.target = targetObject; // Store the actual target

        // Create the dimming overlay
        const overlayRect = new fabric.Rect({
            left: 0,
            top: 0,
            originX: 'left',
            originY: 'top',
            width: canvas.width,
            height: canvas.height,
            fill: 'rgba(0, 0, 0, 0.75)', // Adjust color and alpha as needed
            selectable: false,
            evented: true, // Make overlay evented to catch clicks for removal
            hoverCursor: 'default',
            // Add a custom property to identify it as our spotlight overlay
            customInteraction: { isSpotlightDimOverlay: true }
        });
        // Add a mousedown listener to the overlay itself to remove the spotlight
        overlayRect.on('mousedown', function(options) {
             console.log("Spotlight dim overlay clicked, removing spotlight.");
             if (options.e) options.e.stopPropagation(); // Stop event from bubbling further
             removeSpotlightEffect();
        });


        // Add overlay and bring target object to front
        canvas.add(overlayRect);
        canvas.bringToFront(targetObject); // Bring the clicked object above the overlay

        // Store reference to the overlay rectangle
        viewerApp.state.spotlightOverlayObject.rect = overlayRect;

        canvas.renderAll();
        displayMessageViewer("Spotlight active. Click outside the object (on the dim area) to remove.", true);
    }

    function removeSpotlightEffect() {
        const canvas = viewerApp.state.viewerFabricCanvas;
        // Check the rect property specifically
        const overlayRect = viewerApp.state.spotlightOverlayObject ? viewerApp.state.spotlightOverlayObject.rect : null;

        if (!canvas || !overlayRect) {
            // console.log(`Spotlight not removed: canvas=${!!canvas}, overlayRectExists=${!!overlayRect}`);
            return; // Nothing to remove
        }

        console.log("Removing spotlight (cutout) effect.");

        canvas.remove(overlayRect); // Remove the overlay rectangle
        viewerApp.state.spotlightOverlayObject = null; // Clear the state reference

        canvas.renderAll();
        // Optionally clear the message
        // displayMessageViewer("", true);
    }
    // --- End UPDATED Spotlight Functions ---

  </script>