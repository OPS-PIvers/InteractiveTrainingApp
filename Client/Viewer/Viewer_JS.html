<script>
    // Namespace for the viewer application
    window.viewerApp = {};

    // --- Global Variables ---
    // let ytPlayer; // Global variable to hold the YouTube player instance - MOVED to viewerApp.state.ytPlayer
    let isYouTubeApiReady = false; // Flag to track API readiness
    const CLICK_AND_HOLD_DURATION = 750; // Milliseconds for click and hold
    // Animation speed presets - duration for a complete animation cycle
    const ANIMATION_SPEED_PRESETS = {
      slow: { duration: 1500 },     // 1.5 seconds per cycle
      normal: { duration: 1000 },   // 1 second per cycle
      fast: { duration: 500 }       // 0.5 seconds per cycle
    };

    // --- Application State ---
    viewerApp.state = {
      isLoading: false,
      currentProjectData: null,
      currentSlideIndex: 0, // Default to 0, will be updated
      currentMediaType: null, // Added to store current media type
      viewerFabricCanvas: null,
      defaultCanvasWidth: 960,
      defaultCanvasHeight: 540,
      currentAudioElement: null, // Reference to the currently playing audio element
      // State for Modal Sequencing (Step 21)
      currentModalOverlay: null, // The Fabric object that triggered the current modal sequence
      modalSequence: [],         // Array of Fabric objects in the current sequence on the slide
      currentModalSequenceIndex: -1, // Index within modalSequence being displayed
      // --- State for Spotlight Overlay ---
      isSpotlightActive: false,
      currentSpotlightInfo: null, // Will hold { svg, clickCatcher, targetFabricObject, textBubble, notesPanel }
      // --- State for Pan/Zoom ---
      originalViewportTransform: null, // To store [zoom, 0, 0, zoom, panX, panY]
      isCanvasPannedOrZoomed: false,
      panZoomTargetObject: null, 
      activeAnimations: new Map(),
      currentVideoQuestions: [], // Stores questions for the current video
      playerQuestionCheckInterval: null, // Interval ID for checking video time
      askedQuestionIndices: [], // Indices of questions already asked for the current slide view
      // currentVideoOverlays: [], // Removed as per issue #123
      // activeVideoOverlayIds: new Set(), // Removed as per issue #123
      videoOverlays: [], // Stores full overlay definitions for the current slide (formerly currentVideoOverlays)
      activeOverlays: new Map(), // Stores active DOM overlay elements, mapping ID to DOM element (formerly activeVideoOverlayIds)
      currentVideoDuration: 0, // Phase 1: Store current video duration for timeline
      ytPlayer: null, // Holds the YouTube player instance
      deferredYouTubeVideoId: null // Stores videoId if player setup is deferred
    };

    // Add callback for when YouTube API is ready
    viewerApp.onYouTubeApiReady = function() {
      isYouTubeApiReady = true;
      console.log("YouTube API is now ready for use");
      
      if (viewerApp.state.deferredYouTubeVideoId) {
        const maxRetries = 3;
        let retryCount = 0;
        
        const attemptSetup = () => {
          if (isYouTubePlayerAvailable()) {
            setupYouTubePlayer(viewerApp.state.deferredYouTubeVideoId);
            viewerApp.state.deferredYouTubeVideoId = null;
          } else if (retryCount < maxRetries) {
            retryCount++;
            console.log(`YouTube setup retry ${retryCount}/${maxRetries}`);
            setTimeout(attemptSetup, 500 * retryCount); // Exponential backoff
          } else {
            console.error("YouTube player setup failed after retries");
            displayMessageViewer("YouTube player failed to load. Please refresh.", false);
            viewerApp.state.deferredYouTubeVideoId = null;
          }
        };
        
        setTimeout(attemptSetup, 100);
      }
    };

function isYouTubePlayerAvailable() {
    return isYouTubeApiReady && 
           typeof YT !== 'undefined' && 
           typeof YT.Player !== 'undefined';
}

function safeGetCurrentTime(player) {
    if (!player || typeof player.getCurrentTime !== 'function') {
        return 0;
    }
    try {
        return player.getCurrentTime();
    } catch (e) {
        console.warn("Could not get current time from YouTube player:", e);
        return 0;
    }
}

function validateYouTubeContainer(containerEl, containerName) {
    if (!containerEl) {
        console.error(`${containerName} element not found`);
        return false;
    }
    return true;
}

    // --- DOM Element References ---
    let viewerProjectListContainerEl, messageAreaElViewer, loadingSpinnerElViewer;
    let viewerListViewContainerEl, viewerProjectDisplayAreaEl, viewingProjectTitleEl;
    let viewerMediaContainerEl, youtubePlayerContainerEl, // New media container refs
        viewerCanvasContainerEl, viewerFabricCanvasEl;
    let viewerPrevSlideButtonEl, viewerNextSlideButtonEl, viewerSlideIndicatorEl, backToViewerListButtonEl;
    let viewerModalEl, viewerModalCloseButtonEl, viewerModalBodyEl,
        modalPrevButtonEl, modalNextButtonEl; // Modal Nav Buttons (Step 21)
    let viewerAudioPlayerEl; // Ref for the audio element

    // Phase 1: Timeline Elements
    let viewerVideoTimelineContainerEl, viewerTimelineTrackEl, viewerTimelineProgressEl,
        viewerCurrentTimeEl, viewerTotalDurationEl;

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function() {
      console.log("Viewer_JS: DOMContentLoaded event fired!");

      viewerApp.setupDOMReferences();
      viewerApp.attachEventListeners();

      loadViewerProjectsList();

      console.log("Viewer_JS: Initialization complete.");
    });

    viewerApp.setupDOMReferences = function() {
      viewerProjectListContainerEl = document.getElementById('viewerProjectListContainer');
      messageAreaElViewer = document.getElementById('messageAreaViewer');
      loadingSpinnerElViewer = document.getElementById('loadingSpinner');

      viewerListViewContainerEl = document.getElementById('viewerListViewContainer');
      viewerProjectDisplayAreaEl = document.getElementById('viewerProjectDisplayArea');
      viewingProjectTitleEl = document.getElementById('viewingProjectTitle');

      viewerMediaContainerEl = document.getElementById('viewerMediaContainer');
      youtubePlayerContainerEl = document.getElementById('youtubePlayerContainer');
      viewerCanvasContainerEl = document.getElementById('viewerCanvasContainer'); // Container for the canvas
      viewerFabricCanvasEl = document.getElementById('viewerFabricCanvas'); // The actual canvas element

      viewerPrevSlideButtonEl = document.getElementById('viewerPrevSlideButton');
      viewerNextSlideButtonEl = document.getElementById('viewerNextSlideButton');
      viewerSlideIndicatorEl = document.getElementById('viewerSlideIndicator');
      backToViewerListButtonEl = document.getElementById('backToViewerListButton');

      viewerModalEl = document.getElementById('viewerModal');
      viewerModalCloseButtonEl = document.getElementById('viewerModalCloseButton');
      viewerModalBodyEl = document.getElementById('viewerModalBody');
      modalPrevButtonEl = document.getElementById('modalPrevButton'); // Step 21
      modalNextButtonEl = document.getElementById('modalNextButton'); // Step 21

      viewerAudioPlayerEl = document.getElementById('viewerAudioPlayer');

      // Phase 1: Timeline Elements
      viewerVideoTimelineContainerEl = document.getElementById('viewerVideoTimelineContainer');
      viewerTimelineTrackEl = document.getElementById('viewerTimelineTrack');
      viewerTimelineProgressEl = document.getElementById('viewerTimelineProgress');
      viewerCurrentTimeEl = document.getElementById('viewerCurrentTime');
      viewerTotalDurationEl = document.getElementById('viewerTotalDuration');


      if (!viewerProjectListContainerEl) console.error("CRITICAL: viewerProjectListContainerEl not found!");
      if (!viewerModalEl) console.error("CRITICAL: viewerModalEl not found!");
      if (!viewerAudioPlayerEl) console.error("CRITICAL: viewerAudioPlayerEl not found!");
      if (!modalPrevButtonEl || !modalNextButtonEl) console.error("CRITICAL: Modal navigation buttons not found!"); // Step 21 Check
      // NEW: Get reference to the main display area for click-off listener
      viewerProjectDisplayAreaEl = document.getElementById('viewerProjectDisplayArea');
      if (!viewerProjectDisplayAreaEl) console.error("CRITICAL: viewerProjectDisplayAreaEl not found!"); // Add check
      if (!viewerVideoTimelineContainerEl) console.warn("Timeline container not found (viewerVideoTimelineContainerEl)");


      console.log("Viewer_JS: DOM references set up.");
    };

    viewerApp.attachEventListeners = function() {
        if (backToViewerListButtonEl) backToViewerListButtonEl.addEventListener('click', showProjectListView);
        if (viewerPrevSlideButtonEl) viewerPrevSlideButtonEl.addEventListener('click', navigateToPrevSlide);
        if (viewerNextSlideButtonEl) viewerNextSlideButtonEl.addEventListener('click', navigateToNextSlide);
        if (viewerModalCloseButtonEl) viewerModalCloseButtonEl.addEventListener('click', hideViewerModal);
        if (viewerModalEl) { // Close modal if background is clicked
            viewerModalEl.addEventListener('click', function(event) {
                if (event.target === viewerModalEl) {
                    hideViewerModal();
                }
            });
        }
        // Step 21: Attach listeners for modal navigation buttons
        if (modalPrevButtonEl) modalPrevButtonEl.addEventListener('click', navigateModalPrevious);
        if (modalNextButtonEl) modalNextButtonEl.addEventListener('click', navigateModalNext);

        // Listener to remove spotlight when clicking outside the spotlighted object
        // This listener on viewerProjectDisplayAreaEl is now less critical for spotlight (SVG catcher handles it),
        // but might be useful for other "click off" behaviors later.
        if (viewerProjectDisplayAreaEl) {
             viewerProjectDisplayAreaEl.addEventListener('click', function(event) {
                if (viewerApp.state.spotlightOverlayObject && event.target !== viewerApp.state.spotlightOverlayObject.target) {
                    // console.log("Viewer area click detected while spotlight active, removing effect.");
                    // removeSpotlightEffect(); // SVG spotlight uses its own catcher
                }
             }, false);
        }

        // Phase 1: Timeline track click listener for seeking
        if (viewerTimelineTrackEl) {
            viewerTimelineTrackEl.addEventListener('click', function(e) {
                if (viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.seekTo === 'function' && viewerApp.state.currentVideoDuration > 0) {
                    const rect = viewerTimelineTrackEl.getBoundingClientRect();
                    const clickX = e.clientX - rect.left; // Click position relative to the track
                    const percentage = clickX / rect.width;
                    const seekTime = percentage * viewerApp.state.currentVideoDuration;
                    viewerApp.state.ytPlayer.seekTo(seekTime, true); // true allows seek ahead
                    console.log(`Timeline clicked: Seek to ${seekTime.toFixed(2)}s`);
                }
            });
        }

        // Keyboard navigation listeners
        document.addEventListener('keydown', function(event) {
            // Ensure the main project display area is visible
            if (viewerProjectDisplayAreaEl && viewerProjectDisplayAreaEl.style.display === 'block') {
                // Check if a modal is active
                if (viewerModalEl && viewerModalEl.style.display === 'flex') {
                    // Modal is active, handle modal navigation or close
                    if (event.key === 'Escape') {
                        hideViewerModal();
                    } else if (event.key === 'ArrowLeft' && modalPrevButtonEl && !modalPrevButtonEl.disabled) {
                        navigateModalPrevious();
                    } else if (event.key === 'ArrowRight' && modalNextButtonEl && !modalNextButtonEl.disabled) {
                        navigateModalNext();
                    }
                } else {
                    // Modal is not active, handle slide navigation
                    if (event.key === 'ArrowLeft' && viewerPrevSlideButtonEl && !viewerPrevSlideButtonEl.disabled) {
                        navigateToPrevSlide();
                    } else if (event.key === 'ArrowRight' && viewerNextSlideButtonEl && !viewerNextSlideButtonEl.disabled) {
                        navigateToNextSlide();
                    } else if (event.key === 'Home') {
                        // Optional: Navigate to the first slide if not already there
                        if (viewerApp.state.currentSlideIndex > 0) {
                            renderSlideForViewing(0);
                        }
                    } else if (event.key === 'End') {
                        // Optional: Navigate to the last slide if not already there
                        if (viewerApp.state.currentProjectData && viewerApp.state.currentSlideIndex < viewerApp.state.currentProjectData.slides.length - 1) {
                            renderSlideForViewing(viewerApp.state.currentProjectData.slides.length - 1);
                        }
                    }
                }
            } else if (viewerListViewContainerEl && viewerListViewContainerEl.style.display === 'block') {
                 // Project list view is active
                 if (event.key === 'Escape') {
                     // Potentially, if there was a common way to "go back" or "deselect search" in list view.
                     // For now, no specific action for Escape in list view unless defined later.
                 }
            }
        });
    };

    // --- UI Utils & Server Error Handling ---
    function showLoadingViewer(show) {
      viewerApp.state.isLoading = show;
      if (loadingSpinnerElViewer) {
        loadingSpinnerElViewer.style.display = show ? 'flex' : 'none';
      } else if (show) {
          console.warn("showLoadingViewer(true) called but loadingSpinnerElViewer not yet available.");
      }
    }

    function displayMessageViewer(message, isSuccess) {
      if (messageAreaElViewer) {
        messageAreaElViewer.innerHTML = '';
        const p = document.createElement('p');
        p.textContent = message;
        messageAreaElViewer.appendChild(p);
        messageAreaElViewer.className = isSuccess ? 'success' : 'error';
        setTimeout(() => {
          if (messageAreaElViewer) {
            messageAreaElViewer.innerHTML = '';
            messageAreaElViewer.className = '';
          }
        }, 7000);
      } else {
        console.warn("displayMessageViewer called but messageAreaElViewer not available. Message:", message);
      }
    }

    function onServerErrorViewer(errorObject) {
      showLoadingViewer(false);
      console.error('Viewer Server Error Object:', errorObject);
      let errorMessage = "An unknown error occurred on the server.";
      if (typeof errorObject === 'string') {
          errorMessage = errorObject;
      } else if (errorObject && errorObject.message && typeof errorObject.message === 'string') {
          errorMessage = errorObject.message;
      } else if (errorObject && errorObject.name && errorObject.message) {
          errorMessage = `Error: ${errorObject.name} - ${errorObject.message}`;
      } else if (errorObject && errorObject.error && typeof errorObject.error === 'string') { // Handle {success:false, error:"..."}
          errorMessage = errorObject.error;
      }
      displayMessageViewer('Server Error: ' + errorMessage, false);
    }

    // Phase 1: Helper function to format time (similar to Admin_JS)
    // Place it for example near other helper functions or before Project List Loading
    function formatTime(totalSeconds) {
        totalSeconds = Math.floor(totalSeconds);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    }

    // --- Performance Optimization Utilities ---
    function debounce(func, wait, immediate) {
        let timeout;
        return function() {
            const context = this, args = arguments;
            const later = function() {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };
            const callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(context, args);
        };
    }

    // Optimized rendering, especially useful with a debouncer
    let _optimizedRenderRAFId = null;
    function optimizedRenderAll(canvasInstance) {
        if (!canvasInstance) return;
        if (_optimizedRenderRAFId) {
            fabric.util.cancelAnimFrame(_optimizedRenderRAFId);
        }
        _optimizedRenderRAFId = fabric.util.requestAnimFrame(() => {
            canvasInstance.renderAll();
            _optimizedRenderRAFId = null; // Reset after execution
        }, canvasInstance.getElement());
    }
    
    // A more generic smooth animation function (if fabric.util.animate isn't sufficient or for non-fabric props)
    function smoothAnimate(drawCallback, duration = 300, easingFunction = easeInOutQuad) {
        let startTime = null;
        function animationStep(timestamp) {
            if (!startTime) startTime = timestamp;
            const progress = Math.min((timestamp - startTime) / duration, 1);
            const easedProgress = easingFunction(progress);
            
            drawCallback(easedProgress); // Pass the eased progress to the drawing callback

            if (progress < 1) {
                requestAnimationFrame(animationStep);
            }
        }
        requestAnimationFrame(animationStep);
    }

    // Standard easing function (if not already using one from a library or Fabric's own)
    function easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }

    // --- Project List Loading/Display ---
    function loadViewerProjectsList() {
      console.log("loadViewerProjectsList called");
      if (!google || !google.script || !google.script.run) {
        console.error("google.script.run is not available for loadViewerProjectsList!");
        displayMessageViewer("Error: Client-server communication bridge unavailable.", false); return;
      }
      if (!viewerProjectListContainerEl) {
          console.warn("loadViewerProjectsList: viewerProjectListContainerEl not ready yet.");
          showLoadingViewer(false);
          return;
      }
      showLoadingViewer(true);
      google.script.run
        .withSuccessHandler(displayViewerProjects)
        .withFailureHandler(onServerErrorViewer)
        .getActiveProjectsList();
    }

    function displayViewerProjects(projectsArray) {
      showLoadingViewer(false);
      console.log("displayViewerProjects received:", projectsArray ? projectsArray.length : 0, "projects");
      if (!viewerProjectListContainerEl) {
          console.error("displayViewerProjects: viewerProjectListContainerEl is not found!");
          return;
      }
      viewerProjectListContainerEl.innerHTML = '';
      if (!projectsArray || projectsArray.length === 0) {
        viewerProjectListContainerEl.innerHTML = '<p>No active training modules found at this time.</p>';
        return;
      }

      const ul = document.createElement('ul');
      ul.className = 'project-list-viewer';

      projectsArray.forEach(project => {
        if (!project || !project.projectId) {
            console.warn("Skipping display of invalid project object:", project);
            return;
        }
        const listItem = document.createElement('li');
        listItem.className = 'project-card-viewer';

        const titleHeader = document.createElement('h3');
        titleHeader.textContent = project.projectTitle || 'Untitled Project';

        const viewButton = document.createElement('button');
        viewButton.textContent = 'View Project';
        viewButton.className = 'view-project-button';
        viewButton.setAttribute('data-project-id', project.projectId);
        viewButton.onclick = function() {
          console.log("View Project button clicked for project ID:", project.projectId);
          loadProjectForViewing(project.projectId);
        };

        listItem.appendChild(titleHeader);
        listItem.appendChild(viewButton);
        ul.appendChild(listItem);
      });
      viewerProjectListContainerEl.appendChild(ul);
    }

    // --- View Switching & Cleanup ---
    function showProjectListView() {
        if (viewerListViewContainerEl) viewerListViewContainerEl.style.display = 'block';
        if (viewerProjectDisplayAreaEl) viewerProjectDisplayAreaEl.style.display = 'none';

        // Cleanup media players
        stopAndDestroyYouTubePlayer();
        stopAndClearAudioPlayer();
        hideSpotlightSVG();
        if(viewerApp.state.isCanvasPannedOrZoomed) resetPanZoomWithAnimation(true); // Reset immediately if panned/zoomed

        if (viewerApp.state.viewerFabricCanvas) {
            viewerApp.state.viewerFabricCanvas.dispose();
            viewerApp.state.viewerFabricCanvas = null;
        }
        viewerApp.state.currentProjectData = null;
        viewerApp.state.currentSlideIndex = 0;
        loadViewerProjectsList();
    }

    function showProjectView() {
        if (viewerListViewContainerEl) viewerListViewContainerEl.style.display = 'none';
        if (viewerProjectDisplayAreaEl) viewerProjectDisplayAreaEl.style.display = 'block';
    }

    // --- Project Data Loading ---
    function loadProjectForViewing(projectId) {
        if (!projectId) {
            displayMessageViewer("Invalid project ID.", false);
            return;
        }
        showLoadingViewer(true);
        displayMessageViewer("Loading project...", true);
        google.script.run
            .withSuccessHandler(onProjectViewDataReceived)
            .withFailureHandler(onServerErrorViewer)
            .getProjectViewData(projectId);
    }

    function onProjectViewDataReceived(response) {
        showLoadingViewer(false);
        if (!response || !response.success || !response.data) {
            onServerErrorViewer(response || { error: "Failed to load project data or project is not active." });
             showProjectListView(); // Go back to list on error
            return;
        }
        try {
            viewerApp.state.currentProjectData = JSON.parse(response.data);
             if (viewerApp.state.currentProjectData && Array.isArray(viewerApp.state.currentProjectData.slides)) {
                 viewerApp.state.currentProjectData.slides.forEach(slide => {
                    if (!slide.slideMedia) {
                        slide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
                    }
                    // Ensure videoQuestions array exists for YouTube slides
                    if (slide.slideMedia && slide.slideMedia.type === 'youtube' && !Array.isArray(slide.slideMedia.videoQuestions)) {
                        slide.slideMedia.videoQuestions = [];
                    }
                    // Phase 1: Ensure youtubeOptions exists for YouTube slides
                    if (slide.slideMedia && slide.slideMedia.type === 'youtube' && typeof slide.slideMedia.youtubeOptions === 'undefined') {
                        slide.slideMedia.youtubeOptions = { showClickToBeginButton: false }; // Default
                    }
                 });
             } else {
                 throw new Error("Project data is missing slides array.");
             }

            if (viewerApp.state.currentProjectData.slides.length === 0) {
                displayMessageViewer("Project loaded, but it has no slides.", false);
                 showProjectListView(); 
                return;
            }

            console.log("Project for viewing loaded:", viewerApp.state.currentProjectData);
            console.log("Number of slides loaded:", viewerApp.state.currentProjectData.slides.length);

            viewerApp.state.currentSlideIndex = 0; 
            showProjectView();
            if (viewingProjectTitleEl) viewingProjectTitleEl.textContent = viewerApp.state.currentProjectData.title || "Untitled Project";
            initializeViewerCanvas(); 
            renderSlideForViewing(viewerApp.state.currentSlideIndex); 
            displayMessageViewer("Project loaded.", true);
        } catch (e) {
            console.error("Error parsing project data for viewing:", e);
            displayMessageViewer("Error loading project: Invalid data format.", false);
            viewerApp.state.currentProjectData = null;
             showProjectListView();
        }
    }

    // --- Helper to get current slide data ---
    function getCurrentSlide() {
        if (viewerApp.state.currentProjectData && 
            Array.isArray(viewerApp.state.currentProjectData.slides) &&
            viewerApp.state.currentSlideIndex >= 0 &&
            viewerApp.state.currentSlideIndex < viewerApp.state.currentProjectData.slides.length) {
            return viewerApp.state.currentProjectData.slides[viewerApp.state.currentSlideIndex];
        }
        return null;
    }
    
    // --- New Video Overlay Helper Functions ---

    // Create overlay DOM element
    function createOverlayElement(overlay) {
        const div = document.createElement('div');
        div.className = `video-overlay overlay-${overlay.template}`;
        div.id = `overlay-${overlay.id}`;
        div.style.cssText = `
            position: absolute;
            left: ${overlay.position.x}%;
            top: ${overlay.position.y}%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            pointer-events: ${overlay.interaction.action !== 'none' || overlay.interaction.dismissible ? 'auto' : 'none'};
        `;
        
        // Apply template-specific styles
        applyTemplateStyles(div, overlay);
        
        // Add content
        if (overlay.content.text) {
            const textEl = document.createElement('div');
            textEl.className = 'overlay-text';
            textEl.textContent = overlay.content.text;
            div.appendChild(textEl);
        }
        
        // Add dismiss button if dismissible
        if (overlay.interaction.dismissible) {
            const dismissBtn = document.createElement('button');
            dismissBtn.className = 'overlay-dismiss';
            dismissBtn.innerHTML = '×'; // HTML entity for multiplication sign
            dismissBtn.onclick = (e) => {
                e.stopPropagation();
                dismissOverlay(overlay.id);
            };
            div.appendChild(dismissBtn);
        }
        
        // Add click handler for actions
        if (overlay.interaction.action !== 'none') {
            div.style.cursor = 'pointer';
            div.onclick = () => handleOverlayAction(overlay);
        }
        
        return div;
    }

    // Apply template-specific styles
    function applyTemplateStyles(element, overlay) {
        const templates = {
            lowerThird: {
                width: '300px',
                padding: '10px 20px',
                background: 'rgba(0, 0, 0, 0.8)',
                color: 'white',
                borderRadius: '4px',
                fontSize: '16px',
                fontWeight: 'bold',
                textAlign: 'center'
            },
            cornerCallout: {
                maxWidth: '200px',
                padding: '8px 12px',
                background: 'rgba(255, 255, 255, 0.95)',
                color: '#333',
                borderRadius: '8px',
                fontSize: '14px',
                boxShadow: '0 2px 8px rgba(0,0,0,0.2)'
            },
            centerCard: {
                width: '400px',
                padding: '20px',
                background: 'rgba(255, 255, 255, 0.98)',
                color: '#333',
                borderRadius: '12px',
                fontSize: '18px',
                textAlign: 'center',
                boxShadow: '0 4px 16px rgba(0,0,0,0.3)'
            },
            hotspot: {
                width: '40px',
                height: '40px',
                borderRadius: '50%',
                background: 'rgba(255, 255, 255, 0.9)',
                border: '3px solid #ff5722',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                animation: 'pulse 2s infinite'
            },
            quizBubble: {
                width: '350px',
                padding: '15px',
                background: 'rgba(103, 58, 183, 0.95)',
                color: 'white',
                borderRadius: '12px',
                fontSize: '16px'
            }
        };
        
        const style = templates[overlay.template] || templates.lowerThird; // Default to lowerThird
        Object.assign(element.style, style);
        
        // Apply custom colors if provided
        if (overlay.content.backgroundColor) {
            element.style.backgroundColor = overlay.content.backgroundColor;
        }
        if (overlay.content.textColor) {
            element.style.color = overlay.content.textColor;
        }
    }

    // Handle overlay interactions
    function handleOverlayAction(overlay) {
        switch (overlay.interaction.action) {
            case 'dismiss':
                dismissOverlay(overlay.id);
                break;
                
            case 'navigateToSlide':
                if (overlay.interaction.actionTarget) {
                    const targetIndex = viewerApp.state.currentProjectData.slides.findIndex(
                        s => s.slideId === overlay.interaction.actionTarget
                    );
                    if (targetIndex !== -1) {
                        renderSlideForViewing(targetIndex); // Assumes renderSlideForViewing is globally available
                    }
                }
                break;
                
            case 'showModal':
                if (overlay.interaction.actionTarget) {
                    showViewerModal(overlay.interaction.actionTarget); // Assumes showViewerModal is globally available
                }
                break;
        }
    }

    // Dismiss overlay manually
    function dismissOverlay(overlayId) {
        const element = viewerApp.state.activeOverlays.get(overlayId);
        if (element) {
            element.style.opacity = '0';
            setTimeout(() => {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
                viewerApp.state.activeOverlays.delete(overlayId);
                
                // Resume video if needed
                if (element.dataset.pausedVideo === 'true' && 
                    viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.getPlayerState === 'function' &&
                    viewerApp.state.ytPlayer.getPlayerState() === YT.PlayerState.PAUSED) {
                    viewerApp.state.ytPlayer.playVideo();
                }
            }, 300); // Match transition duration
        }
    }

    // Initialize video overlays for current slide
    function initializeVideoOverlays() {
        const currentSlide = getCurrentSlide(); // Assumes getCurrentSlide is globally available
        if (!currentSlide || !currentSlide.slideMedia || currentSlide.slideMedia.type !== 'youtube') {
            viewerApp.state.videoOverlays = []; // Clear if not a YouTube slide or no media
            viewerApp.state.activeOverlays.clear();
            // Clear the DOM container as well
            const container = document.getElementById('videoOverlayContainer');
            if (container) container.innerHTML = '';
            return;
        }
        
        viewerApp.state.videoOverlays = currentSlide.slideMedia.videoOverlays || [];
        // Clear any existing DOM overlays and the activeOverlays map before initializing new ones
        const container = document.getElementById('videoOverlayContainer');
        if (container) container.innerHTML = '';
        viewerApp.state.activeOverlays.clear(); 
    }

    // Check and update overlay visibility
    function updateVideoOverlays() {
        if (!isYouTubePlayerAvailable() || !viewerApp.state.ytPlayer || typeof viewerApp.state.ytPlayer.getCurrentTime !== 'function' || !viewerApp.state.videoOverlays) return;
        
        const currentTime = safeGetCurrentTime(viewerApp.state.ytPlayer);
        const container = document.getElementById('videoOverlayContainer');
        if (!container) return; // Make sure container exists
        
        viewerApp.state.videoOverlays.forEach(overlay => {
            const isActive = viewerApp.state.activeOverlays.has(overlay.id);
            const shouldShow = currentTime >= overlay.startTime && 
                              currentTime < (overlay.startTime + overlay.duration);
            
            if (shouldShow && !isActive) {
                // Show overlay
                const element = createOverlayElement(overlay);
                container.appendChild(element);
                viewerApp.state.activeOverlays.set(overlay.id, element);
                
                // Handle pause if needed
                if (overlay.interaction.pauseVideo && viewerApp.state.ytPlayer.getPlayerState() === YT.PlayerState.PLAYING) {
                    viewerApp.state.ytPlayer.pauseVideo();
                    element.dataset.pausedVideo = 'true';
                }
                
                // Fade in animation
                requestAnimationFrame(() => {
                    // Check if element still exists and is in map, in case of rapid changes
                    if (viewerApp.state.activeOverlays.get(overlay.id) === element) {
                         element.style.opacity = '1';
                    }
                });
                
            } else if (!shouldShow && isActive) {
                // Hide overlay
                const element = viewerApp.state.activeOverlays.get(overlay.id);
                // Check if element exists before trying to access its style
                if (element) {
                    element.style.opacity = '0';
                
                    setTimeout(() => {
                        // Check again if element still exists and is the one we expect to remove
                        if (viewerApp.state.activeOverlays.get(overlay.id) === element && element.parentNode) {
                             element.parentNode.removeChild(element);
                        }
                        // Delete from map only if it was the element we intended to remove
                        if (viewerApp.state.activeOverlays.get(overlay.id) === element) {
                            viewerApp.state.activeOverlays.delete(overlay.id);
                        }
                        
                        // Resume video if this overlay paused it
                        if (element.dataset.pausedVideo === 'true' && 
                            viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.getPlayerState === 'function' &&
                            viewerApp.state.ytPlayer.getPlayerState() === YT.PlayerState.PAUSED) {
                            // Check if other overlays that pause video are still active
                            let otherPausingOverlayActive = false;
                            for (const [id, el] of viewerApp.state.activeOverlays) {
                                const ov = viewerApp.state.videoOverlays.find(o => o.id === id);
                                if (ov && ov.interaction.pauseVideo && el.dataset.pausedVideo === 'true') {
                                    otherPausingOverlayActive = true;
                                    break;
                                }
                            }
                            if (!otherPausingOverlayActive) {
                                viewerApp.state.ytPlayer.playVideo();
                            }
                        }
                    }, 300); // Match transition duration
                } else {
                     // If element is not found but ID is in activeOverlays, remove it from map
                     viewerApp.state.activeOverlays.delete(overlay.id);
                }
            }
        });
    }

    // --- Canvas & Slide Rendering ---
    function initializeViewerCanvas() {
        if (viewerApp.state.viewerFabricCanvas) {
            viewerApp.state.viewerFabricCanvas.dispose();
            viewerApp.state.viewerFabricCanvas = null;
        }
        if (!viewerFabricCanvasEl) {
            console.error("Viewer Fabric canvas element not found!");
            return;
        }
        try {
            viewerApp.state.viewerFabricCanvas = new fabric.Canvas(viewerFabricCanvasEl, {
                width: viewerApp.state.defaultCanvasWidth,
                height: viewerApp.state.defaultCanvasHeight,
                selection: false,
                hoverCursor: 'default',
                backgroundColor: 'transparent' 
            });
            viewerApp.state.viewerFabricCanvas.selection = false;
            
            // Listener for resetting pan/zoom on background click
            viewerApp.state.viewerFabricCanvas.on('mouse:down', function(options) {
                if (viewerApp.state.isCanvasPannedOrZoomed && !options.target) { // No object clicked, means background
                    console.log("Canvas background clicked while panned/zoomed, initiating reset.");
                    resetPanZoomWithAnimation();
                } else if (viewerApp.state.isCanvasPannedOrZoomed && options.target && options.target === viewerApp.state.panZoomTargetObject) {
                    // If the same panned/zoomed object is clicked again, reset.
                    console.log("Panned/zoomed target object clicked again, initiating reset.");
                    resetPanZoomWithAnimation();
                }
                // If options.target is another interactive object, its own 'mousedown' (from renderSlideForViewing)
                // will call handleOverlayInteraction, which has its own logic to reset zoom if needed.
            });
            viewerApp.state.viewerFabricCanvas.renderAll(); 
            console.log("Viewer canvas initialized.");
        } catch(e) {
            console.error("Error initializing viewer Fabric canvas:", e);
            displayMessageViewer("Error initializing display canvas.", false);
        }
    }

    function renderSlideForViewing(slideIndex) {
        if (!viewerApp.state.currentProjectData || !viewerApp.state.viewerFabricCanvas) {
            console.error("Cannot render slide: Project data or canvas not ready."); return;
        }
        const slides = viewerApp.state.currentProjectData.slides;
        if (slideIndex < 0 || slideIndex >= slides.length) {
            console.error("Invalid slide index:", slideIndex); return;
        }

        stopAndDestroyYouTubePlayer(); // This will also clear timestamp overlay states & video duration
        stopAndClearAudioPlayer();
        hideSpotlightSVG(); 
        if(viewerApp.state.isCanvasPannedOrZoomed) resetPanZoomWithAnimation(true); // Reset immediately if panned/zoomed

        const slideData = slides[slideIndex]; // Moved up to access slideData earlier

        viewerApp.state.currentSlideIndex = slideIndex; 
        initializeVideoOverlays(); // This function now correctly uses viewerApp.state.videoOverlays and viewerApp.state.activeOverlays
        
        // Initialize timestamp overlay states for the new slide
        // Clear any existing Fabric-based timestamp overlays from canvas (part of stopAndDestroyYouTubePlayer now, but good to be sure)
        if (viewerApp.state.viewerFabricCanvas) {
            viewerApp.state.viewerFabricCanvas.getObjects().forEach(obj => {
                // Check for the old customType or a specific flag if one was used for Fabric overlays
                if (obj.customType === 'videoTimestampOverlay' || obj.isTimestampOverlay) { 
                    viewerApp.state.viewerFabricCanvas.remove(obj);
                }
            });
        }
        // The lines for currentVideoOverlays and activeVideoOverlayIds are removed as they are no longer part of the state.
        // initializeVideoOverlays() handles setting up the new videoOverlays and activeOverlays state.

        // const slideData = slides[slideIndex]; 
        const canvas = viewerApp.state.viewerFabricCanvas;

         if (!slideData.slideMedia) {
            slideData.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null, youtubeOptions: { showClickToBeginButton: false } };
         } else if (slideData.slideMedia.type === 'youtube' && typeof slideData.slideMedia.youtubeOptions === 'undefined') {
            slideData.slideMedia.youtubeOptions = { showClickToBeginButton: false }; // Ensure it exists for YouTube
         }


        const slideWidth = slideData.canvasWidth || viewerApp.state.defaultCanvasWidth;
        const slideHeight = slideData.canvasHeight || viewerApp.state.defaultCanvasHeight;
        const media = slideData.slideMedia;
        let mediaType = (media && media.type) ? media.type : 'none';
        viewerApp.state.currentMediaType = mediaType; // Store current media type

        canvas.setWidth(slideWidth);
        canvas.setHeight(slideHeight);
        if (viewerFabricCanvasEl) {
            viewerFabricCanvasEl.width = slideWidth;
            viewerFabricCanvasEl.height = slideHeight;
        }
        if (viewerMediaContainerEl) {
            viewerMediaContainerEl.style.width = slideWidth + 'px';
            viewerMediaContainerEl.style.height = slideHeight + 'px';
        }

        canvas.clear();
        canvas.setBackgroundImage(null, () => { canvas.renderAll(); });
        canvas.backgroundColor = 'transparent';

        if (youtubePlayerContainerEl) youtubePlayerContainerEl.style.display = (mediaType === 'youtube') ? 'block' : 'none';
        if (viewerVideoTimelineContainerEl) viewerVideoTimelineContainerEl.style.display = 'none'; // Hide by default

        if (viewerCanvasContainerEl) {
            viewerCanvasContainerEl.style.display = 'flex'; 
            if (mediaType === 'youtube') {
                // Initial state before "Click to Begin" or overlays are evaluated
                viewerCanvasContainerEl.style.pointerEvents = 'none'; 
                viewerFabricCanvasEl.style.opacity = '0'; 

                if (slideData.slideMedia && slideData.slideMedia.videoQuestions) {
                    viewerApp.state.currentVideoQuestions = [...slideData.slideMedia.videoQuestions].sort((a, b) => a.timestamp - b.timestamp);
                } else {
                    viewerApp.state.currentVideoQuestions = [];
                }
                viewerApp.state.askedQuestionIndices = []; 
            } else {
                viewerCanvasContainerEl.style.pointerEvents = 'auto'; 
                viewerFabricCanvasEl.style.opacity = '1'; 
                viewerApp.state.currentVideoQuestions = []; 
                viewerApp.state.askedQuestionIndices = [];
            }
        }
        if (viewerAudioPlayerEl) viewerAudioPlayerEl.style.display = 'none'; 

        console.log(`Rendering slide ${slideIndex + 1}, media type: ${mediaType}`);

        switch(mediaType) {
            case 'image':
                if (media.driveFileId) {
                    showLoadingViewer(true);
                    google.script.run
                        .withSuccessHandler(function(response) {
                            showLoadingViewer(false);
                            if (viewerApp.state.currentSlideIndex !== slideIndex) return;
                            if (response && response.success && response.base64Data) {
                                fabric.Image.fromURL(response.base64Data, function(img) {
                                    if (!viewerApp.state.viewerFabricCanvas || viewerApp.state.currentSlideIndex !== slideIndex) return;
                                    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                                        scaleX: canvas.width / img.width, 
                                        scaleY: canvas.height / img.height
                                    });
                                }, { crossOrigin: 'anonymous' });
                            } else {
                                console.error("Failed to fetch image for viewer:", response);
                                canvas.renderAll();
                            }
                        })
                        .withFailureHandler(function(error) {
                            showLoadingViewer(false);
                            onServerErrorViewer(error);
                            canvas.renderAll();
                        })
                        .getImageAsBase64(media.driveFileId);
                } else {
                    console.warn("Image media present but no driveFileId:", media);
                    canvas.renderAll();
                }
                if (viewerMediaContainerEl) viewerMediaContainerEl.style.backgroundColor = '#333';
                if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '1';
                if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'auto';
                break;

            case 'youtube':
                if (viewerMediaContainerEl) viewerMediaContainerEl.style.backgroundColor = 'transparent';
                if (media.url) {
                    const videoId = extractYouTubeVideoId(media.url);
                    if (videoId) {
                        if (isYouTubeApiReady) {
                             setupYouTubePlayer(videoId); 
                             initializeVideoOverlays(); // Ensure overlays are initialized for YouTube
                             
                             const youtubeOptions = media.youtubeOptions || { showClickToBeginButton: false };

                             // Clear existing "click to begin" buttons before adding a new one or setting defaults
                             canvas.getObjects().forEach(obj => {
                                 if (obj.customType === 'clickToBeginButton') {
                                     canvas.remove(obj);
                                 }
                             });

                             if (youtubeOptions.showClickToBeginButton) {
                                 if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'auto';
                                 if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '1';

                                 const beginButtonText = new fabric.Textbox('Click here to begin', {
                                     left: canvas.width / 2, 
                                     top: canvas.height / 2, 
                                     originX: 'center', 
                                     originY: 'center',
                                     fontSize: (canvas.width > 600 ? 30 : 24), 
                                     fill: 'white', 
                                     backgroundColor: 'rgba(0,0,0,0.8)',
                                     padding: 20, 
                                     rx: 10, ry: 10,
                                     selectable: false, 
                                     evented: true, 
                                     hoverCursor: 'pointer',
                                     customType: 'clickToBeginButton' 
                                 });

                                 beginButtonText.on('mousedown', function() {
                                     if (viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.playVideo === 'function') {
                                         viewerApp.state.ytPlayer.playVideo();
                                     } else {
                                         console.warn("ClickToBegin: viewerApp.state.ytPlayer not ready or playVideo not available.");
                                     }
                                     canvas.remove(this); 
                                     updateViewerCanvasInteractivity(); 
                                     // renderAll will be called by updateViewerCanvasInteractivity
                                 });
                                 canvas.add(beginButtonText);
                                 canvas.bringToFront(beginButtonText);
                                 canvas.renderAll(); // Render after adding button. updateViewerCanvasInteractivity will also render.
                             } else {
                                 // If button not shown, call updateViewerCanvasInteractivity to set defaults
                                 // (which for YT without other interactive elements is opacity 0, pointerEvents none)
                                 updateViewerCanvasInteractivity(); // This will also call renderAll
                             }
                             // Timeline and question marker setup will happen in onPlayerReady
                        } else {
                             console.warn("YouTube API not ready yet. Player setup deferred for videoId:", videoId);
                             viewerApp.state.deferredYouTubeVideoId = videoId; // Store video ID for deferred setup
                             if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '0';
                             if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'none';
                             displayMessageViewer("YouTube player is loading...", true);
                             // Fallback if API load fails is handled by the API loader itself
                        }
                    } else {
                        console.error("Could not extract YouTube Video ID from URL:", media.url);
                        displayMessageViewer("Invalid YouTube URL format.", false);
                        if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '0';
                        if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'none';
                    }
                } else {
                     console.warn("YouTube media type set but URL is missing.");
                     displayMessageViewer("YouTube URL is missing for this slide.", false);
                     if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '0';
                     if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'none';
                }
                break;

            case 'audio':
                 if (viewerMediaContainerEl) viewerMediaContainerEl.style.backgroundColor = '#333';
                 if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '1';
                 if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'auto';
                 if (media.driveFileId) {
                     showLoadingViewer(true);
                     google.script.run
                         .withSuccessHandler(function(audioResponse) {
                             showLoadingViewer(false);
                             if (viewerApp.state.currentSlideIndex !== slideIndex) return;
                             if (audioResponse && audioResponse.success && audioResponse.base64Data) {
                                 setupAudioPlayer(audioResponse.base64Data);
                                 if (viewerAudioPlayerEl) viewerAudioPlayerEl.style.display = 'block';
                                 canvas.renderAll();
                             } else {
                                 onServerErrorViewer(audioResponse || {error: "Failed to load audio data."});
                                 canvas.renderAll();
                             }
                         })
                         .withFailureHandler(function(error) {
                             showLoadingViewer(false);
                             onServerErrorViewer(error);
                             canvas.renderAll();
                         })
                         .getAudioAsBase64(media.driveFileId);
                 } else {
                     console.warn("Audio media type set but driveFileId is missing.");
                     canvas.renderAll();
                 }
                 break;

            default: 
                 if (viewerMediaContainerEl) viewerMediaContainerEl.style.backgroundColor = '#333';
                 if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '1';
                 if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'auto';
                 canvas.renderAll();
                 break;
        }

        if (slideData.fabricCanvasJSON) {
            canvas.loadFromJSON(slideData.fabricCanvasJSON, function() {
                if (viewerApp.state.currentSlideIndex !== slideIndex) return;

                canvas.forEachObject(function(obj) {
                    obj.selectable = false;
                    obj.evented = true; 
                    obj.hoverCursor = 'pointer';
                    obj._clickAndHoldTimer = null;

                    obj.off('mousedown'); obj.off('mouseup'); obj.off('mouseout');
                    obj.off('mousemove'); obj.off('mouseover');

                    if (obj.customInteraction && obj.customInteraction.trigger) {
                        const trigger = obj.customInteraction.trigger;
                        const action = obj.customInteraction.action;

                        if (trigger === 'clickAndHold' && action === 'spotlight') {
                            obj.on('mousedown', function(options) { if (this.customInteraction && this.customInteraction.trigger === 'clickAndHold' && this.customInteraction.action === 'spotlight') { showSpotlightSVG(this, this.customInteraction); }});
                            obj.on('mouseup', function() { if (this.customInteraction && this.customInteraction.trigger === 'clickAndHold' && this.customInteraction.action === 'spotlight') { if (viewerApp.state.isSpotlightActive && viewerApp.state.currentSpotlightInfo && viewerApp.state.currentSpotlightInfo.targetFabricObject === this) { hideSpotlightSVG(); } }});
                            obj.on('mouseout', function() {  if (this.customInteraction && this.customInteraction.trigger === 'clickAndHold' && this.customInteraction.action === 'spotlight') { if (viewerApp.state.isSpotlightActive && viewerApp.state.currentSpotlightInfo && viewerApp.state.currentSpotlightInfo.targetFabricObject === this) { hideSpotlightSVG(); } }});
                        }
                        else if (trigger === 'click') {
                            obj.on('mousedown', function(options) { if (this.customInteraction && this.customInteraction.trigger === 'click') { if (this._clickAndHoldTimer) { clearTimeout(this._clickAndHoldTimer); this._clickAndHoldTimer = null;} handleOverlayInteraction(this, 'click'); if (this.customAnimation && this.customAnimation.trigger === 'onClick' && this.customAnimation.type) { executeAnimation(this, this.customAnimation); } if(options.e) options.e.stopPropagation();}});
                        } else if (trigger === 'hover') {
                            obj.on('mouseover', function() { if (this.customInteraction && this.customInteraction.trigger === 'hover') { handleOverlayInteraction(this, 'hover'); } if (this.customAnimation && this.customAnimation.trigger === 'hover' && this.customAnimation.type) { executeAnimation(this, this.customAnimation); }});
                            obj.on('mouseout', function() { if (this.customAnimation && this.customAnimation.trigger === 'hover' && this.customAnimation.type) { stopAnimation(this); }});
                        } else if (trigger === 'clickAndHold') { 
                            obj.on('mousedown', function(options) { if (this.customInteraction && this.customInteraction.trigger === 'clickAndHold') {  if (this._clickAndHoldTimer) clearTimeout(this._clickAndHoldTimer); this._clickAndHoldTimer = setTimeout(() => { handleOverlayInteraction(this, 'clickAndHold'); if (this.customAnimation && this.customAnimation.trigger === 'onClick' && this.customAnimation.type) { executeAnimation(this, this.customAnimation); } this._clickAndHoldTimer = null; }, CLICK_AND_HOLD_DURATION);}});
                            const cancelGenericHold = function() { if (this._clickAndHoldTimer) { clearTimeout(this._clickAndHoldTimer); this._clickAndHoldTimer = null; }};
                            obj.on('mouseup', cancelGenericHold); obj.on('mouseout', cancelGenericHold);
                        }
                    }
                    if (obj.customAnimation && obj.customAnimation.trigger === 'onLoad' && obj.customAnimation.type) {
                        setTimeout(() => executeAnimation(obj, obj.customAnimation), 100);
                    }
                }); 
                canvas.renderAll();
            }); 
        } else if (viewerCanvasContainerEl && viewerCanvasContainerEl.style.display !== 'none') {
             if(mediaType !== 'image' && mediaType !== 'audio') { 
                 canvas.renderAll();
             }
        }
        updateSlideNavigationUI(); 
    }

    // --- Interaction & Modal Handling ---
    function handleOverlayInteraction(fabricObject, eventType) {
        if (!fabricObject.customInteraction) return;
        const interaction = fabricObject.customInteraction;

        console.log(`Interaction Triggered: type=${eventType}, action=${interaction.action}, object=${fabricObject.type}, currentOpacity=${fabricObject.opacity}`);

        if (interaction.trigger !== eventType) {
            console.log(`Interaction Mismatch: Configured trigger '${interaction.trigger}' does not match event '${eventType}'. Ignoring for this handler instance.`);
            return;
        }
        if (viewerApp.state.isSpotlightActive && interaction.action !== 'spotlight') {
            hideSpotlightSVG();
        }
         if (viewerApp.state.isCanvasPannedOrZoomed && interaction.action !== 'panZoomToTarget') {
            if(fabricObject !== viewerApp.state.panZoomTargetObject){
                console.log("Different object clicked while panned/zoomed. Resetting zoom first."); 
                resetPanZoomWithAnimation();
            }
        }

        console.log("Handling interaction:", interaction.action, "for object:", fabricObject);

        switch (interaction.action) {
            case 'showModal':
                if (fabricObject.customInteraction && fabricObject.customInteraction.modalContent) {
                    const canvas = viewerApp.state.viewerFabricCanvas;
                    if (!canvas) break;
                    const allObjects = canvas.getObjects();
                    viewerApp.state.modalSequence = allObjects.filter(obj =>
                        obj.customInteraction &&
                        obj.customInteraction.action === 'showModal' &&
                        typeof obj.sequenceOrder === 'number' &&
                        !isNaN(obj.sequenceOrder)
                    ).sort((a, b) => a.sequenceOrder - b.sequenceOrder);
                    viewerApp.state.currentModalSequenceIndex = viewerApp.state.modalSequence.findIndex(obj => obj === fabricObject);
                    if (viewerApp.state.currentModalSequenceIndex === -1) {
                        viewerApp.state.modalSequence = [fabricObject];
                        viewerApp.state.currentModalSequenceIndex = 0;
                    }
                    viewerApp.state.currentModalOverlay = fabricObject;
                    showViewerModal(interaction.modalContent);
                    updateModalNavigationButtons();
                } else {
                     console.warn("Show Modal: modalContent missing.");
                     if(modalPrevButtonEl) modalPrevButtonEl.style.display = 'none';
                     if(modalNextButtonEl) modalNextButtonEl.style.display = 'none';
                }
                break;
            case 'navigateToSlide':
                const targetSlideId = interaction.navigateTo;
                if (targetSlideId && viewerApp.state.currentProjectData && viewerApp.state.currentProjectData.slides) {
                    const targetSlideIndex = viewerApp.state.currentProjectData.slides.findIndex(s => s.slideId === targetSlideId);
                    if (targetSlideIndex !== -1) {
                        renderSlideForViewing(targetSlideIndex);
                    } else {
                        displayMessageViewer(`Navigation error: Slide '${targetSlideId}' not found.`, false);
                    }
                }
                break;
            case 'navigateToURL':
                if (interaction.navigateTo) {
                    let url = interaction.navigateTo;
                    if (!url.startsWith('http://') && !url.startsWith('https://')) url = 'https://' + url;
                    try {
                         const newWindow = window.open(url, '_blank');
                         if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
                              displayMessageViewer("Could not open link. Check popup settings.", false);
                         }
                    } catch (e) { displayMessageViewer("Error opening link.", false); }
                }
                break;
            case 'spotlight':
                 if (viewerApp.state.isSpotlightActive && viewerApp.state.currentSpotlightInfo && viewerApp.state.currentSpotlightInfo.targetFabricObject === fabricObject) {
                     hideSpotlightSVG();
                 } else {
                     showSpotlightSVG(fabricObject, interaction);
                 }
                 break;
            case 'panZoomToTarget':
                console.log("Pan/Zoom to Target action triggered for:", fabricObject);
                if (fabricObject && viewerApp.state.viewerFabricCanvas) {
                    const canvas = viewerApp.state.viewerFabricCanvas;

                    if (!viewerApp.state.isCanvasPannedOrZoomed) { 
                        viewerApp.state.originalViewportTransform = canvas.viewportTransform.slice(); 
                        console.log("Storing original viewport transform:", viewerApp.state.originalViewportTransform);
                    }

                    const targetZoom = fabricObject.customInteraction.panZoomLevel || 1.5;
                    viewerApp.state.panZoomTargetObject = fabricObject; 

                    animatePanZoom(fabricObject, targetZoom);
                }
                break;
            case 'reveal':
                 console.log("Reveal action triggered for:", fabricObject);
                 if (fabricObject && viewerApp.state.viewerFabricCanvas) {
                      fabricObject.animate('opacity', 1, {
                          duration: 500,
                          onChange: viewerApp.state.viewerFabricCanvas.renderAll.bind(viewerApp.state.viewerFabricCanvas),
                          onComplete: () => console.log("Reveal complete. Opacity:", fabricObject.opacity)
                      });
                 }
                 break;
            default:
                console.log("Unknown interaction action:", interaction.action);
        }
    }

    function executeAnimation(fabricObject, animConfig) {
        if (!fabricObject || !animConfig || !animConfig.type) return;
        console.log(`Executing animation: ${animConfig.type} for object`, fabricObject);

        stopAnimation(fabricObject);

        if (!fabricObject._originalState) {
            fabricObject._originalState = {
                angle: fabricObject.angle,
                top: fabricObject.top,
                left: fabricObject.left,
                scaleX: fabricObject.scaleX,
                scaleY: fabricObject.scaleY
            };
        }
        
        let duration = 1000; 
        if (animConfig.speed) {
            duration = ANIMATION_SPEED_PRESETS[animConfig.speed]?.duration || 1000;
        } else if (animConfig.duration) {
            duration = animConfig.duration;
        }
        
        let strength = animConfig.strength || getDefaultStrength(animConfig.type);
        
        const controller = { aborted: false };
        viewerApp.state.activeAnimations.set(fabricObject, controller);

        switch (animConfig.type) {
            case 'wiggle': animateWiggle(fabricObject, duration, strength, controller, animConfig.loop); break;
            case 'float': animateFloat(fabricObject, duration, strength, controller, animConfig.loop); break;
            case 'growShrink': animateGrowShrink(fabricObject, duration, strength, controller, animConfig.loop); break;
            default:
                console.warn("Unknown animation type:", animConfig.type);
                viewerApp.state.activeAnimations.delete(fabricObject);
        }
    }

    function getDefaultStrength(animationType) {
        switch (animationType) {
            case 'wiggle': return 5; case 'float': return 10; case 'growShrink': return 1.2;
            default: return 5;
        }
    }

    function stopAnimation(fabricObject) {
        if (viewerApp.state.activeAnimations.has(fabricObject)) {
            const controller = viewerApp.state.activeAnimations.get(fabricObject);
            controller.aborted = true;
            viewerApp.state.activeAnimations.delete(fabricObject);
            console.log("Animation stopped for object", fabricObject);
            if (fabricObject._originalState) {
                fabricObject.set(fabricObject._originalState);
                viewerApp.state.viewerFabricCanvas.renderAll();
            }
        }
    }

    function animateWiggle(fabricObject, duration, strength, controller, shouldLoop) {
        const canvas = viewerApp.state.viewerFabricCanvas; if (!canvas) return;
        const originalAngle = fabricObject._originalState ? fabricObject._originalState.angle : fabricObject.angle;
        strength = parseFloat(strength) || 5; 
        fabricObject.animate('angle', originalAngle - strength, {
            duration: duration / 3, onChange: canvas.renderAll.bind(canvas), abort: () => controller.aborted,
            onComplete: function() {
                if (controller.aborted) { fabricObject.set('angle', originalAngle); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return; }
                fabricObject.animate('angle', originalAngle + strength, {
                    duration: duration / 3 * 2, onChange: canvas.renderAll.bind(canvas), abort: () => controller.aborted,
                    onComplete: function() {
                        if (controller.aborted) { fabricObject.set('angle', originalAngle); canvas.renderAll();  viewerApp.state.activeAnimations.delete(fabricObject); return; }
                        fabricObject.animate('angle', originalAngle, {
                            duration: duration / 3, onChange: canvas.renderAll.bind(canvas), abort: () => controller.aborted,
                            onComplete: function() {
                                if (controller.aborted) { fabricObject.set('angle', originalAngle); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return; }
                                console.log(`Wiggle cycle complete, shouldLoop: ${shouldLoop}`);
                                if (shouldLoop === true) { setTimeout(() => { if (viewerApp.state.activeAnimations.has(fabricObject) && viewerApp.state.activeAnimations.get(fabricObject).aborted) { fabricObject.set('angle', originalAngle); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return;} const newLoopController = { aborted: false }; viewerApp.state.activeAnimations.set(fabricObject, newLoopController); animateWiggle(fabricObject, duration, strength, newLoopController, shouldLoop); }, 50);
                                } else { viewerApp.state.activeAnimations.delete(fabricObject); console.log(`Animation wiggle finished.`); }
                            }
                        });
                    }
                });
            }
        });
    }
    function animateFloat(fabricObject, duration, strength, controller, shouldLoop) {
        const canvas = viewerApp.state.viewerFabricCanvas; if (!canvas) return;
        const originalTop = fabricObject._originalState ? fabricObject._originalState.top : fabricObject.top;
        strength = parseFloat(strength) || 10; 
        fabricObject.animate('top', originalTop - strength, {
            duration: duration / 3, onChange: canvas.renderAll.bind(canvas), abort: () => controller.aborted,
            onComplete: function() {
                if (controller.aborted) { fabricObject.set('top', originalTop); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return; }
                fabricObject.animate('top', originalTop + (strength/2), { // Go slightly below original
                    duration: duration / 3 * 2, onChange: canvas.renderAll.bind(canvas), abort: () => controller.aborted,
                    onComplete: function() {
                        if (controller.aborted) { fabricObject.set('top', originalTop); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return; }
                        fabricObject.animate('top', originalTop, {
                            duration: duration / 3, onChange: canvas.renderAll.bind(canvas), abort: () => controller.aborted,
                            onComplete: function() {
                                if (controller.aborted) { fabricObject.set('top', originalTop); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return; }
                                console.log(`Float cycle complete, shouldLoop: ${shouldLoop}`);
                                if (shouldLoop === true) { setTimeout(() => { if (viewerApp.state.activeAnimations.has(fabricObject) && viewerApp.state.activeAnimations.get(fabricObject).aborted) { fabricObject.set('top', originalTop); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return;} const newLoopController = { aborted: false }; viewerApp.state.activeAnimations.set(fabricObject, newLoopController); animateFloat(fabricObject, duration, strength, newLoopController, shouldLoop); }, 50);
                                } else { viewerApp.state.activeAnimations.delete(fabricObject); console.log(`Animation float finished.`); }
                            }
                        });
                    }
                });
            }
        });
    }

    function animateGrowShrink(fabricObject, duration, strength, controller, shouldLoop) {
        const canvas = viewerApp.state.viewerFabricCanvas; if (!canvas) return;
        const originalScaleX = fabricObject._originalState ? fabricObject._originalState.scaleX : fabricObject.scaleX;
        const originalScaleY = fabricObject._originalState ? fabricObject._originalState.scaleY : fabricObject.scaleY;
        strength = parseFloat(strength) || 1.2; 
        
        animateScale(strength); // Start by growing
        
        function animateScale(targetScaleFactor) { // targetScaleFactor is relative to original, e.g. 1.2 for 120%
            fabric.util.animate({
                startValue: fabricObject.scaleX / originalScaleX, // Current relative scale
                endValue: targetScaleFactor,
                duration: duration / 2, // Half duration for grow, half for shrink
                onChange: function(value) {
                    if (controller.aborted) return;
                    fabricObject.set({ scaleX: originalScaleX * value, scaleY: originalScaleY * value });
                    canvas.renderAll();
                },
                abort: () => controller.aborted,
                onComplete: function() {
                    if (controller.aborted) { fabricObject.set({scaleX: originalScaleX, scaleY: originalScaleY}); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return; }
                    
                    if (targetScaleFactor > 1) { // If we just grew, now shrink back to original
                        animateScale(1);
                    } else { // We just shrunk back to original, cycle complete
                        console.log(`GrowShrink cycle complete, shouldLoop: ${shouldLoop}`);
                        if (shouldLoop === true) { setTimeout(() => { if (viewerApp.state.activeAnimations.has(fabricObject) && viewerApp.state.activeAnimations.get(fabricObject).aborted) { fabricObject.set({scaleX: originalScaleX, scaleY: originalScaleY}); canvas.renderAll(); viewerApp.state.activeAnimations.delete(fabricObject); return; } const newLoopController = { aborted: false }; viewerApp.state.activeAnimations.set(fabricObject, newLoopController); animateGrowShrink(fabricObject, duration, strength, newLoopController, shouldLoop); }, 50);
                        } else { viewerApp.state.activeAnimations.delete(fabricObject); console.log(`Animation growShrink finished.`); }
                    }
                },
                easing: fabric.util.ease.easeInOutQuad
            });
        }
    }

function animatePulse(fabricObject, duration, strength, controller, shouldLoop) {
    const canvas = viewerApp.state.viewerFabricCanvas;
    if (!canvas) return;

    const originalOpacity = fabricObject._originalState ? fabricObject._originalState.opacity : fabricObject.opacity;
    // Strength for pulse could be interpreted as the minimum opacity in the pulse
    // For example, if strength is 0.5, it pulses between originalOpacity and originalOpacity * 0.5
    const pulseToOpacity = originalOpacity * (1 - (strength || 0.5)); // Default to 50% reduction if strength not defined

    function doPulse(targetOpacity) {
        fabricObject.animate('opacity', targetOpacity, {
            duration: duration / 2, // Half duration for fade out, half for fade in
            onChange: canvas.renderAll.bind(canvas),
            abort: () => controller.aborted,
            onComplete: function() {
                if (controller.aborted) {
                    fabricObject.set('opacity', originalOpacity);
                    canvas.renderAll();
                    viewerApp.state.activeAnimations.delete(fabricObject);
                    return;
                }
                // If it just pulsed to targetOpacity (dimmed), now pulse back to original
                if (targetOpacity < originalOpacity) {
                    doPulse(originalOpacity);
                } else { // Cycle complete (faded in)
                    if (shouldLoop) {
                        setTimeout(() => {
                            // Check if still active before looping
                            if (viewerApp.state.activeAnimations.has(fabricObject) && !viewerApp.state.activeAnimations.get(fabricObject).aborted) {
                                animatePulse(fabricObject, duration, strength, controller, shouldLoop);
                            } else { // If aborted during timeout
                                fabricObject.set('opacity', originalOpacity);
                                canvas.renderAll();
                                viewerApp.state.activeAnimations.delete(fabricObject);
                            }
                        }, 50); // Brief pause before looping
                    } else {
                        viewerApp.state.activeAnimations.delete(fabricObject);
                        console.log(`Animation pulse finished.`);
                    }
                }
            },
            easing: fabric.util.ease.easeInOutSine // A smooth easing function
        });
    }
    // Start by pulsing to the dimmed opacity
    doPulse(pulseToOpacity);
}

    function animatePanZoom(targetObject, targetZoom) {
        const canvas = viewerApp.state.viewerFabricCanvas;
        if (!canvas || !targetObject) return;

        const animationDuration = 500; 
        const objectCenter = targetObject.getCenterPoint();
        const vpt = canvas.viewportTransform;
        const currentZoom = vpt[0];
        const currentPanX = vpt[4];
        const currentPanY = vpt[5];
        const finalPanX = (canvas.width / 2) - (objectCenter.x * targetZoom);
        const finalPanY = (canvas.height / 2) - (objectCenter.y * targetZoom);

        console.log(`Animating Pan/Zoom. From: Z=${currentZoom.toFixed(2)}, X=${currentPanX.toFixed(2)}, Y=${currentPanY.toFixed(2)}`);
        console.log(`Targeting: Z=${targetZoom.toFixed(2)}, X=${finalPanX.toFixed(2)}, Y=${finalPanY.toFixed(2)} for obj center (${objectCenter.x.toFixed(2)}, ${objectCenter.y.toFixed(2)})`);

        fabric.util.animate({
            startValue: 0, endValue: 1, duration: animationDuration,
            onChange: function(progress) {
                const newZoom = currentZoom + (targetZoom - currentZoom) * progress;
                const newPanX = currentPanX + (finalPanX - currentPanX) * progress;
                const newPanY = currentPanY + (finalPanY - currentPanY) * progress;
                canvas.setViewportTransform([newZoom, 0, 0, newZoom, newPanX, newPanY]);
                canvas.requestRenderAll(); 
            },
            onComplete: function() {
                viewerApp.state.isCanvasPannedOrZoomed = true;
                canvas.setViewportTransform([targetZoom, 0, 0, targetZoom, finalPanX, finalPanY]);
                canvas.renderAll(); 
                console.log("Pan/Zoom animation complete.");
            },
            easing: fabric.util.ease.easeInOutQuad 
        });
    }

    function resetPanZoomWithAnimation(immediate = false) {
        const canvas = viewerApp.state.viewerFabricCanvas;
        console.log("[ResetPanZoom] Called. Immediate:", immediate, "isPanned:", viewerApp.state.isCanvasPannedOrZoomed, "OriginalVPT:", viewerApp.state.originalViewportTransform);

        if (!canvas || !viewerApp.state.isCanvasPannedOrZoomed || !Array.isArray(viewerApp.state.originalViewportTransform) || viewerApp.state.originalViewportTransform.length !== 6) {
            console.warn("[ResetPanZoom] Aborting: Conditions not met or invalid original transform.");
            if(canvas && Array.isArray(viewerApp.state.originalViewportTransform) && viewerApp.state.originalViewportTransform.length === 6 && !viewerApp.state.isCanvasPannedOrZoomed){
                 // If somehow isCanvasPannedOrZoomed is false but we have a transform, try to reset.
                 console.log("[ResetPanZoom] Attempting reset despite isCanvasPannedOrZoomed being false, as original transform exists.");
            } else if (!canvas) {
                viewerApp.state.isCanvasPannedOrZoomed = false; viewerApp.state.panZoomTargetObject = null; viewerApp.state.originalViewportTransform = null; return;
            } else { // Not panned or invalid original transform
                viewerApp.state.isCanvasPannedOrZoomed = false; viewerApp.state.panZoomTargetObject = null; viewerApp.state.originalViewportTransform = null; return;
            }
        }
        
        console.log("[ResetPanZoom] Conditions met, proceeding with reset.");
        const animationDuration = immediate ? 0 : 500;
        const vpt = canvas.viewportTransform;
        const currentZoom = vpt[0]; const currentPanX = vpt[4]; const currentPanY = vpt[5];
        const finalOriginalVPT = viewerApp.state.originalViewportTransform.slice();
        const finalZoom = finalOriginalVPT[0]; const finalPanX = finalOriginalVPT[4]; const finalPanY = finalOriginalVPT[5];
        
        viewerApp.state.panZoomTargetObject = null; 

        if (immediate) {
            canvas.setViewportTransform(finalOriginalVPT);
            viewerApp.state.isCanvasPannedOrZoomed = false; viewerApp.state.originalViewportTransform = null; 
            canvas.renderAll(); console.log("Pan/Zoom reset immediately.");
            return;
        }

        fabric.util.animate({
            startValue: 0, endValue: 1, duration: animationDuration,
            onChange: function(progress) {
                const newZoom = currentZoom + (finalZoom - currentZoom) * progress;
                const newPanX = currentPanX + (finalPanX - currentPanX) * progress;
                const newPanY = currentPanY + (finalPanY - currentPanY) * progress;
                canvas.setViewportTransform([newZoom, 0, 0, newZoom, newPanX, newPanY]);
                canvas.requestRenderAll();
            },
            onComplete: function() {
                canvas.setViewportTransform(finalOriginalVPT); 
                viewerApp.state.isCanvasPannedOrZoomed = false; viewerApp.state.originalViewportTransform = null; 
                canvas.renderAll(); console.log("Pan/Zoom reset animation complete.");
            },
            easing: fabric.util.ease.easeInOutQuad
        });
    }

    function showViewerModal(htmlContent) {
        // Define a list of safe attributes. Others will be removed.
        // Added 'width', 'height' for images/iframes, 'frameborder', 'allowfullscreen', 'allow' for iframes.
        const SAFE_ATTRIBUTES = ['id', 'class', 'alt', 'title', 'src', 'href', 'target', 'rel', 
                                 'colspan', 'rowspan', 'scope', 'summary', 
                                 'aria-label', 'aria-labelledby', 'aria-describedby', 'role',
                                 'width', 'height', 'frameborder', 'allowfullscreen', 'allow'];

        function sanitizeNodeRecursive(node) {
            if (node.nodeType === Node.TEXT_NODE) {
                // For text nodes, just clone them.
                return node.cloneNode(true);
            }

            if (node.nodeType !== Node.ELEMENT_NODE) {
                // We are only interested in element nodes and text nodes.
                // Other types (like comments, processing instructions) will be ignored/removed.
                return null;
            }

            // Create a new element of the same type.
            const newElement = document.createElement(node.tagName);

            // Copy attributes if they are safe.
            for (const attr of Array.from(node.attributes)) {
                const attrName = attr.name.toLowerCase();

                // 1. Remove on* event handlers
                if (attrName.startsWith('on')) {
                    continue;
                }

                // 2. Remove style attributes
                if (attrName === 'style') {
                    continue;
                }

                // 3. Check against the allowlist
                if (SAFE_ATTRIBUTES.includes(attrName)) {
                    let value = attr.value;

                    // 3a. Sanitize href and src attributes for javascript:
                    if (attrName === 'href' || attrName === 'src') {
                        if (value.trim().toLowerCase().startsWith('javascript:')) {
                            continue; // Remove javascript: URLs
                        }
                    }
                    
                    // 3b. For <a> tags with target="_blank", add/ensure rel="noopener noreferrer"
                    if (newElement.tagName.toLowerCase() === 'a' && attrName === 'href') {
                        const targetAttr = node.getAttribute('target'); // Check original node's target
                        if (targetAttr && targetAttr.toLowerCase() === '_blank') {
                            let currentRel = newElement.getAttribute('rel') || '';
                            const relValues = new Set(currentRel.toLowerCase().split(' ').filter(Boolean));
                            
                            if (!relValues.has('noopener')) {
                                relValues.add('noopener');
                            }
                            if (!relValues.has('noreferrer')) {
                                relValues.add('noreferrer');
                            }
                            newElement.setAttribute('rel', Array.from(relValues).join(' '));
                        }
                    }
                    newElement.setAttribute(attr.name, value);
                }
            }

            // Recursively sanitize and append child nodes.
            for (const child of Array.from(node.childNodes)) {
                const sanitizedChild = sanitizeNodeRecursive(child);
                if (sanitizedChild) {
                    newElement.appendChild(sanitizedChild);
                }
            }
            return newElement;
        }

        if (viewerModalBodyEl) {
            viewerModalBodyEl.innerHTML = ''; // Clear previous content

            if (typeof DOMParser === 'function') {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    Array.from(doc.body.childNodes).forEach(originalNode => {
                        const sanitizedNode = sanitizeNodeRecursive(originalNode);
                        if (sanitizedNode) {
                            viewerModalBodyEl.appendChild(sanitizedNode);
                        }
                    });
                } catch (e) {
                    console.error("Error parsing or sanitizing modal content:", e);
                    viewerModalBodyEl.textContent = 'Error: Could not display content due to parsing error.';
                }
            } else {
                // Fail secure: If DOMParser is not available, do not proceed with potentially unsafe content.
                console.error("DOMParser not available. Cannot securely display modal content.");
                viewerModalBodyEl.textContent = 'Error: Content cannot be displayed securely.';
            }
        }

        if (viewerModalEl) {
            viewerModalEl.style.display = 'flex';
        }
    }

    function hideViewerModal() {
        if (viewerModalEl) viewerModalEl.style.display = 'none';
        if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = '';
        viewerApp.state.currentModalOverlay = null;
        viewerApp.state.modalSequence = [];
        viewerApp.state.currentModalSequenceIndex = -1;
        if(modalPrevButtonEl) modalPrevButtonEl.style.display = 'none';
        if(modalNextButtonEl) modalNextButtonEl.style.display = 'none';
    }

    function updateModalNavigationButtons() {
         if (!modalPrevButtonEl || !modalNextButtonEl) return;
         const sequence = viewerApp.state.modalSequence;
         const currentIndex = viewerApp.state.currentModalSequenceIndex;
         if (sequence.length <= 1) {
             modalPrevButtonEl.style.display = 'none'; modalNextButtonEl.style.display = 'none'; return;
         }
         modalPrevButtonEl.disabled = !(currentIndex > 0); modalPrevButtonEl.style.display = 'inline-block';
         modalNextButtonEl.disabled = !(currentIndex < sequence.length - 1); modalNextButtonEl.style.display = 'inline-block';
     }

     function navigateModalPrevious() {
          const sequence = viewerApp.state.modalSequence; let currentIndex = viewerApp.state.currentModalSequenceIndex;
          if (currentIndex > 0) { currentIndex--; const prevOverlay = sequence[currentIndex];
              if (prevOverlay && prevOverlay.customInteraction && prevOverlay.customInteraction.modalContent) {
                  viewerApp.state.currentModalSequenceIndex = currentIndex; viewerApp.state.currentModalOverlay = prevOverlay;
                  if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = prevOverlay.customInteraction.modalContent;
                  updateModalNavigationButtons(); console.log("Navigated to previous modal, index:", currentIndex);
              } else { console.error("Previous overlay or its content is invalid."); }
          }
     }
     function navigateModalNext() {
          const sequence = viewerApp.state.modalSequence; let currentIndex = viewerApp.state.currentModalSequenceIndex;
          if (currentIndex < sequence.length - 1) { currentIndex++; const nextOverlay = sequence[currentIndex];
               if (nextOverlay && nextOverlay.customInteraction && nextOverlay.customInteraction.modalContent) {
                   viewerApp.state.currentModalSequenceIndex = currentIndex; viewerApp.state.currentModalOverlay = nextOverlay;
                   if (viewerModalBodyEl) viewerModalBodyEl.innerHTML = nextOverlay.customInteraction.modalContent;
                   updateModalNavigationButtons(); console.log("Navigated to next modal, index:", currentIndex);
               } else { console.error("Next overlay or its content is invalid."); }
          }
     }

    function showSpotlightSVG(targetFabricObject, interactionData) {
        hideSpotlightSVG(); 
        const canvas = viewerApp.state.viewerFabricCanvas;
        if (!canvas || !targetFabricObject) { console.error("Cannot show spotlight: canvas or targetFabricObject missing."); return; }
        console.log(`[WebApp] Spotlight SVG requested for Fabric object:`, targetFabricObject);
        const targetRect = targetFabricObject.getBoundingRect(true); 
        const canvasRect = viewerFabricCanvasEl.getBoundingClientRect(); 
        const viewportLeft = canvasRect.left + window.scrollX + targetRect.left; // Account for canvas position and scroll
        const viewportTop = canvasRect.top + window.scrollY + targetRect.top;   // Account for canvas position and scroll
        const viewportWidth = targetRect.width; const viewportHeight = targetRect.height;
        const svgNS = "http://www.w3.org/2000/svg"; const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("id", "spotlightSVG");
        svg.style.position = "fixed"; svg.style.top = "0"; svg.style.left = "0";
        svg.style.width = "100vw";  svg.style.height = "100vh";
        svg.style.zIndex = "9990";  svg.style.pointerEvents = "none"; 
        const mask = document.createElementNS(svgNS, "mask"); mask.setAttribute("id", "spotlightMask");
        const bgRect = document.createElementNS(svgNS, "rect");
        bgRect.setAttribute("x", "0"); bgRect.setAttribute("y", "0"); bgRect.setAttribute("width", "100%"); bgRect.setAttribute("height", "100%"); bgRect.setAttribute("fill", "white");
        mask.appendChild(bgRect);
        const cutoutRect = document.createElementNS(svgNS, "rect");
        cutoutRect.setAttribute("x", viewportLeft); cutoutRect.setAttribute("y", viewportTop);
        cutoutRect.setAttribute("width", viewportWidth); cutoutRect.setAttribute("height", viewportHeight);
        cutoutRect.setAttribute("fill", "black"); 
        mask.appendChild(cutoutRect); svg.appendChild(mask);
        const dimRect = document.createElementNS(svgNS, "rect");
        dimRect.setAttribute("x", "0"); dimRect.setAttribute("y", "0"); dimRect.setAttribute("width", "100%"); dimRect.setAttribute("height", "100%");
        dimRect.setAttribute("fill", "rgba(0, 0, 0, 0.75)"); dimRect.setAttribute("mask", "url(#spotlightMask)");
        svg.appendChild(dimRect); document.body.appendChild(svg);
        const clickCatcher = document.createElement('div'); clickCatcher.id = 'spotlightClickCatcher';
        clickCatcher.style.position = 'fixed'; clickCatcher.style.top = '0'; clickCatcher.style.left = '0';
        clickCatcher.style.width = '100vw'; clickCatcher.style.height = '100vh';
        clickCatcher.style.zIndex = '9989';  clickCatcher.style.cursor = 'pointer'; 
        clickCatcher.addEventListener('click', function(event) { console.log("Spotlight click catcher clicked."); hideSpotlightSVG(); event.stopPropagation(); });
        document.body.appendChild(clickCatcher);
        viewerApp.state.isSpotlightActive = true;
        viewerApp.state.currentSpotlightInfo = { svg: svg, clickCatcher: clickCatcher, targetFabricObject: targetFabricObject,};
        displayMessageViewer("Spotlight active. Click anywhere to dismiss.", true);
        console.log("[WebApp] SVG Spotlight activated for Fabric object:", targetFabricObject);
    }
    function hideSpotlightSVG() {
        if (!viewerApp.state.isSpotlightActive || !viewerApp.state.currentSpotlightInfo) return;
        console.log('[WebApp] Hiding SVG Spotlight');
        if (viewerApp.state.currentSpotlightInfo.svg) document.body.removeChild(viewerApp.state.currentSpotlightInfo.svg);
        if (viewerApp.state.currentSpotlightInfo.clickCatcher) document.body.removeChild(viewerApp.state.currentSpotlightInfo.clickCatcher);
        viewerApp.state.isSpotlightActive = false; viewerApp.state.currentSpotlightInfo = null;
    }

    function updateSlideNavigationUI() {
        console.log("updateSlideNavigationUI called. Current Index:", viewerApp.state.currentSlideIndex, "Project Data:", viewerApp.state.currentProjectData);
        if (!viewerApp.state.currentProjectData || !Array.isArray(viewerApp.state.currentProjectData.slides)) {
             console.error("updateSlideNavigationUI: Invalid project data or slides array.");
             if (viewerSlideIndicatorEl) viewerSlideIndicatorEl.textContent = "Slide ? / ?";
             if (viewerPrevSlideButtonEl) viewerPrevSlideButtonEl.disabled = true;
             if (viewerNextSlideButtonEl) viewerNextSlideButtonEl.disabled = true;
             return;
        }
        const numSlides = viewerApp.state.currentProjectData.slides.length;
        const currentIndex = viewerApp.state.currentSlideIndex;
        if (viewerSlideIndicatorEl) viewerSlideIndicatorEl.textContent = `Slide ${currentIndex + 1} / ${numSlides}`;
        if (viewerPrevSlideButtonEl) viewerPrevSlideButtonEl.disabled = (currentIndex <= 0);
        if (viewerNextSlideButtonEl) viewerNextSlideButtonEl.disabled = (currentIndex >= numSlides - 1);
    }
    function navigateToPrevSlide() { if (viewerApp.state.currentSlideIndex > 0) renderSlideForViewing(viewerApp.state.currentSlideIndex - 1); }
    function navigateToNextSlide() { if (viewerApp.state.currentProjectData && viewerApp.state.currentSlideIndex < viewerApp.state.currentProjectData.slides.length - 1) renderSlideForViewing(viewerApp.state.currentSlideIndex + 1); }

    window.onYouTubeIframeAPIReady = function() { console.log("YouTube IFrame API Ready (called by external script)."); isYouTubeApiReady = true;};

    function setupYouTubePlayer(videoId) {
        if (!validateYouTubeContainer(youtubePlayerContainerEl, "YouTube player container")) {
            displayMessageViewer("YouTube player setup error: container missing.", false);
            return; 
        }
        youtubePlayerContainerEl.innerHTML = '<div id="youtube-player-div" style="width: 100%; height: 100%;"></div>';
        youtubePlayerContainerEl.style.display = 'block';
        console.log("Setting up YouTube player for video ID:", videoId);
        
        if (!isYouTubePlayerAvailable()) {
            console.error("YT object or YT.Player is not available or API not ready.");
            displayMessageViewer("YouTube Player API not available. Please check your internet connection and refresh.", false); return;
        }
        try {
             if(viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.destroy === 'function') {
                 console.log("Destroying previous YT player instance.");
                 viewerApp.state.ytPlayer.destroy();
                 viewerApp.state.ytPlayer = null;
             }
             console.log("Creating new YT.Player instance.");
             viewerApp.state.ytPlayer = new YT.Player('youtube-player-div', {
                height: '100%', width: '100%', videoId: videoId,
                // Ensure all required playerVars are present, especially disablekb: 1
                playerVars: {
                    'autoplay': 0,
                    'controls': 0,
                    'rel': 0,
                    'showinfo': 0,
                    'modestbranding': 1,
                    'iv_load_policy': 3,
                    'fs': 0,
                    'disablekb': 1, // Ensures keyboard controls are disabled
                    'playsinline': 1
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': onPlayerError
                }
            });
             console.log("YT.Player instance created successfully.");
        } catch (e) {
            console.error("Error creating YouTube player instance:", e);
            displayMessageViewer(`Error initializing YouTube player: ${e.message}`, false);
             if (youtubePlayerContainerEl) youtubePlayerContainerEl.style.display = 'none';
        }
    }

    function onPlayerReady(event) {
        try {
            const videoData = event.target.getVideoData();
            console.log("YouTube Player Ready for video:", videoData ? videoData.video_id : "unknown");
            
            const videoDuration = event.target.getDuration();
            if (isNaN(videoDuration) || videoDuration <= 0) {
                console.warn("Invalid video duration received:", videoDuration);
                displayMessageViewer("Video duration could not be determined", false);
                return;
            }
            
            viewerApp.state.currentVideoDuration = videoDuration;
            if (viewerTotalDurationEl) viewerTotalDurationEl.textContent = formatTime(videoDuration);
            if (viewerCurrentTimeEl) viewerCurrentTimeEl.textContent = formatTime(0);
            if (viewerTimelineProgressEl) viewerTimelineProgressEl.style.width = '0%';
            if (viewerVideoTimelineContainerEl) viewerVideoTimelineContainerEl.style.display = 'block';

            renderTimelineMarkers();

            // Add click listener with validation
            if(youtubePlayerContainerEl && !youtubePlayerContainerEl.hasAttribute('click-listener-added')){
                console.log("Adding click-to-play listener to YT player container.");
                youtubePlayerContainerEl.addEventListener('click', function() {
                    console.log("Player container clicked.");
                    if (viewerApp.state.ytPlayer && 
                        typeof viewerApp.state.ytPlayer.playVideo === 'function' && 
                        typeof viewerApp.state.ytPlayer.pauseVideo === 'function' && 
                        typeof viewerApp.state.ytPlayer.getPlayerState === 'function') {
                        try {
                            const state = viewerApp.state.ytPlayer.getPlayerState();
                            if (state !== YT.PlayerState.PLAYING) { 
                                console.log("Calling playVideo()."); 
                                viewerApp.state.ytPlayer.playVideo(); 
                            } else { 
                                console.log("Calling pauseVideo()."); 
                                viewerApp.state.ytPlayer.pauseVideo(); 
                            }
                        } catch (e) {
                            console.error("Error controlling YouTube player:", e);
                        }
                    } else { 
                        console.warn("Cannot play/pause: Player or methods not available."); 
                    }
                });
                youtubePlayerContainerEl.setAttribute('click-listener-added', 'true');
            }
        } catch (e) {
            console.error("Error in onPlayerReady:", e);
            displayMessageViewer("Error initializing YouTube player", false);
        }
    }

    // New function for Phase 1 to render question markers on the timeline - REPLACED by renderTimelineMarkers
    // function renderQuestionMarkers() { ... } // Removed

    // Helper function to get color based on template name
    function getTemplateColor(templateName) {
        switch (templateName) {
            case 'hotspot':
                return '#ff5722';
            case 'quizBubble':
                return '#673ab7';
            default:
                return '#4CAF50'; // Default color
        }
    }

    function renderTimelineMarkers() {
        if (!viewerApp.state.currentVideoDuration || viewerApp.state.currentVideoDuration <= 0) {
            console.warn("Invalid video duration for timeline markers");
            return;
        }
        if (!viewerTimelineTrackEl) {
            console.warn("renderTimelineMarkers: Timeline track not available.");
            return;
        }

        // Clear any existing markers
        const existingMarkers = viewerTimelineTrackEl.querySelectorAll('.timeline-marker');
        existingMarkers.forEach(marker => marker.remove());

        // Render Question Markers
        if (viewerApp.state.currentVideoQuestions && viewerApp.state.currentVideoQuestions.length > 0) {
            viewerApp.state.currentVideoQuestions.forEach(question => {
                const marker = document.createElement('div');
                marker.className = 'timeline-marker question-marker'; // Generic and specific class
                marker.style.position = 'absolute';
                marker.style.width = '3px';
                marker.style.height = '100%';
                marker.style.backgroundColor = 'orange'; // Question color
                marker.style.top = '0px';
                marker.style.zIndex = '2'; // Ensure visible above progress bar

                const percentagePosition = Math.max(0, Math.min(100, 
                    (question.timestamp / viewerApp.state.currentVideoDuration) * 100
                ));
                marker.style.left = percentagePosition + '%';
                marker.title = `Question at ${formatTime(question.timestamp)}: ${question.questionText.substring(0, 30)}...`;
                viewerTimelineTrackEl.appendChild(marker);
            });
        }

        // Render Timestamp Overlay Markers
        // Add overlay markers (This is the new/updated part)
        if (viewerApp.state.videoOverlays && viewerApp.state.videoOverlays.length > 0) { // This correctly uses the consolidated state variable
            viewerApp.state.videoOverlays.forEach(overlay => { // This correctly uses the consolidated state variable
                const startMarker = document.createElement('div');
                startMarker.className = 'timeline-marker overlay-marker';
                let markerColor = getTemplateColor(overlay.template);
                startMarker.style.backgroundColor = markerColor; 
                
                const startPercent = Math.max(0, Math.min(100,
                    (overlay.startTime / viewerApp.state.currentVideoDuration) * 100
                ));
                startMarker.style.left = startPercent + '%';
                startMarker.title = `${overlay.content.text || overlay.template} at ${formatTime(overlay.startTime)}`; // Assumes formatTime exists
                
                viewerTimelineTrackEl.appendChild(startMarker);
            });
        }
    }


    function onPlayerStateChange(event) {
        console.log("YouTube Player State Change:", event.data);
        if (viewerApp.state.playerQuestionCheckInterval) { // Always clear previous interval
            clearInterval(viewerApp.state.playerQuestionCheckInterval);
            viewerApp.state.playerQuestionCheckInterval = null;
        }

        if (event.data === YT.PlayerState.PLAYING) {
            viewerApp.state.playerQuestionCheckInterval = setInterval(function() {
                if (isYouTubePlayerAvailable() && viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.getCurrentTime === 'function') { // Ensure player exists
                    const currentTime = safeGetCurrentTime(viewerApp.state.ytPlayer);
                    if (viewerCurrentTimeEl) viewerCurrentTimeEl.textContent = formatTime(currentTime);
                    if (viewerTimelineProgressEl && viewerApp.state.currentVideoDuration > 0) {
                        viewerTimelineProgressEl.style.width = (currentTime / viewerApp.state.currentVideoDuration) * 100 + '%';
                    }
                    checkVideoTimeForQuestions();
                    updateVideoOverlays(); 
                } else { // Player was destroyed or became unavailable
                    if (viewerApp.state.playerQuestionCheckInterval) {
                        clearInterval(viewerApp.state.playerQuestionCheckInterval);
                        viewerApp.state.playerQuestionCheckInterval = null;
                    }
                }
            }, 100);
        } else if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
            // Interval is cleared above.
            updateVideoOverlays(); // Call to update overlay states based on final time
        }
    }

    // Definition of checkVideoTimeForTimestampOverlays is removed / replaced by checkVideoTimeForVideoOverlays
    
    function updateViewerCanvasInteractivity() {
        const canvas = viewerApp.state.viewerFabricCanvas;
        if (!canvas || !viewerCanvasContainerEl || !viewerFabricCanvasEl) return;

        const isQuestionActive = canvas.getObjects().some(obj => obj.customType === 'videoQuestionOverlay');
        const isClickToBeginActive = canvas.getObjects().some(obj => obj.customType === 'clickToBeginButton');
        
        // This part needs to check the new activeOverlays (Map) for DOM elements
        // to determine if any of *those* are interactive.
        // However, the primary interaction with DOM overlays (like click to dismiss or action)
        // is handled by the DOM elements themselves.
        // The canvas interactivity might be relevant if Fabric objects *on top of* the video
        // (but separate from the DOM overlays) need to be enabled/disabled based on DOM overlay state.
        // For now, let's assume that if any DOM overlay is active, the canvas might need to be interactive
        // for other elements or for consistency.
        // The old logic checked activeVideoOverlayIds (Set for Fabric overlays).
        // The new logic should check activeOverlays (Map for DOM overlays).
        let isInteractiveOverlayActive = false;
        if (viewerApp.state.activeOverlays && viewerApp.state.activeOverlays.size > 0 && Array.isArray(viewerApp.state.videoOverlays)) {
            for (const overlayId of viewerApp.state.activeOverlays.keys()) { // Iterate Map keys
                const overlayDef = viewerApp.state.videoOverlays.find(o => o.id === overlayId); // Find definition in the array
                // Check if the definition implies interactivity that would affect the *canvas* layer.
                // DOM overlays handle their own pointer events. This is more about whether the Fabric canvas layer
                // itself should be transparent to clicks or not when DOM overlays are present.
                if (overlayDef && overlayDef.interaction && (overlayDef.interaction.action !== 'none' || overlayDef.interaction.dismissible)) {
                    // If any active DOM overlay is interactive or dismissible, we might want the canvas to be aware.
                    // However, the new DOM overlay system places overlays in a separate container ('videoOverlayContainer')
                    // which is on top of the YouTube player, but potentially sibling to or layered with the Fabric canvas container.
                    // The logic here is to make the Fabric canvas itself interactive if needed.
                    // If DOM overlays are present, the canvas itself might not need to be interactive unless there are also Fabric elements.
                    // Let's simplify: if active DOM overlays exist, we assume the canvas layer might be needed for other things or should be consistent.
                    isInteractiveOverlayActive = true; 
                    break;
                }
            }
        }

        if (isQuestionActive || isClickToBeginActive || isInteractiveOverlayActive) {
            viewerFabricCanvasEl.style.opacity = '1';
            viewerCanvasContainerEl.style.pointerEvents = 'auto';
        } else if (viewerApp.state.currentMediaType === 'youtube') { // Only make YouTube non-interactive by default
            viewerFabricCanvasEl.style.opacity = '0';
            viewerCanvasContainerEl.style.pointerEvents = 'none';
        } else { // For other media types like image or audio, keep canvas interactive
            viewerFabricCanvasEl.style.opacity = '1';
            viewerCanvasContainerEl.style.pointerEvents = 'auto';
        }
        console.log(`updateViewerCanvasInteractivity: QuestionActive=${isQuestionActive}, ClickToBeginActive=${isClickToBeginActive}, InteractiveOverlayActive=${isInteractiveOverlayActive}. Canvas Opacity: ${viewerFabricCanvasEl.style.opacity}, PointerEvents: ${viewerCanvasContainerEl.style.pointerEvents}`);
    }

    function onPlayerError(event) {
        console.error("YouTube Player Error Code:", event.data);
        let errorMsg = `YouTube Player Error: Code ${event.data}. `;
        switch (event.data) {
            case 2: errorMsg += "Invalid video ID."; break; case 5: errorMsg += "HTML5 player error."; break;
            case 100: errorMsg += "Video not found or private."; break; case 101: case 150: errorMsg += "Playback forbidden by owner."; break;
            default: errorMsg += "Unknown error."; break;
        }
        displayMessageViewer(errorMsg, false);
    }

function stopAndDestroyYouTubePlayer() {
    try {
        console.log("Stopping and destroying YouTube player...");

        // Clear intervals
        if (viewerApp.state.playerQuestionCheckInterval) {
            clearInterval(viewerApp.state.playerQuestionCheckInterval);
            viewerApp.state.playerQuestionCheckInterval = null;
            console.log("Cleared viewerApp.state.playerQuestionCheckInterval.");
        }

        // Stop and destroy the player robustly
        if (viewerApp && viewerApp.state && viewerApp.state.ytPlayer) {
            try {
                if (typeof viewerApp.state.ytPlayer.stopVideo === 'function') {
                    viewerApp.state.ytPlayer.stopVideo();
                    console.log("Called stopVideo() on YouTube player.");
                } else {
                    console.warn("viewerApp.state.ytPlayer.stopVideo is not a function.");
                }

                if (typeof viewerApp.state.ytPlayer.destroy === 'function') {
                    viewerApp.state.ytPlayer.destroy();
                    console.log("Called destroy() on YouTube player.");
                } else {
                    console.warn("viewerApp.state.ytPlayer.destroy is not a function.");
                }
            } catch (playerError) {
                console.error("Error while stopping or destroying YouTube player:", playerError);
            } finally {
                viewerApp.state.ytPlayer = null;
                console.log("Nullified viewerApp.state.ytPlayer.");
            }
        } else {
            console.log("No YouTube player instance found to stop or destroy.");
        }

        // Clean up player container element
        const youtubePlayerContainerEl = document.getElementById("youtubePlayerContainer");
        if (youtubePlayerContainerEl) {
            youtubePlayerContainerEl.innerHTML = ''; // Clear the container
            youtubePlayerContainerEl.removeAttribute('click-listener-added'); // Remove listener if added
            youtubePlayerContainerEl.classList.remove('active'); // Assuming 'active' class controls visibility or state
            youtubePlayerContainerEl.style.display = 'none'; // Ensure it's hidden
            console.log("Cleaned up YouTube player container.");
        } else {
            console.warn("youtubePlayerContainer element not found.");
        }
        
        // Clear video-related state arrays (using viewerApp.state for consistency)
        if (viewerApp && viewerApp.state) {
            viewerApp.state.currentVideoQuestions = []; // From original function
            viewerApp.state.askedQuestionIndices = [];   // From original function
            
            // These were listed in the prompt but might be redundant if cleanupAllVideoOverlays handles them
            // For safety, ensure they are cleared if they exist directly on viewerApp.state
             if (Array.isArray(viewerApp.state.videoPlayerOverlayElements)) { // Example, adapt to actual names if different
                viewerApp.state.videoPlayerOverlayElements = [];
             }
             if (Array.isArray(viewerApp.state.videoPlayerOverlayElementIds)) {
                viewerApp.state.videoPlayerOverlayElementIds = [];
             }
             if (Array.isArray(viewerApp.state.videoPlayerActiveOverlayElements)) {
                viewerApp.state.videoPlayerActiveOverlayElements = [];
             }
            console.log("Cleared video-related state arrays.");
        }


        // Clean up overlays
        // Manual cleanup (previously in else, now primary as cleanupAllVideoOverlays was removed)
        console.log("Performing manual overlay cleanup."); // Updated console message
        if (viewerApp && viewerApp.state) {
            if (viewerApp.state.viewerFabricCanvas) {
                const canvas = viewerApp.state.viewerFabricCanvas;
                    const objectsToRemove = canvas.getObjects().filter(obj =>  
                        obj.customType === 'clickToBeginButton' || 
                        (obj.videoOverlayId && viewerApp.state.activeOverlays && viewerApp.state.activeOverlays.has(obj.videoOverlayId))
                    );
                    objectsToRemove.forEach(obj => canvas.remove(obj));
                    if (objectsToRemove.length > 0) canvas.requestRenderAll();
                    console.log("Manually removed Fabric overlay objects.");
                }

                if (viewerApp.state.activeOverlays && typeof viewerApp.state.activeOverlays.clear === 'function') {
                     viewerApp.state.activeOverlays.forEach((element, id) => {
                        if (element && element.parentNode) {
                            element.parentNode.removeChild(element);
                        }
                    });
                    viewerApp.state.activeOverlays.clear();
                    console.log("Cleared viewerApp.state.activeOverlays (Map).");
                }
                 if (Array.isArray(viewerApp.state.videoOverlays)) { // From original
                    viewerApp.state.videoOverlays = [];
                    console.log("Cleared viewerApp.state.videoOverlays (Array).");
                }
            }
            const overlayContainer = document.getElementById('videoOverlayContainer');
            if (overlayContainer) {
                overlayContainer.innerHTML = '';
                console.log("Cleared videoOverlayContainer HTML.");
            }
        // Reset timeline - Assuming resetTimeline is a global function
        if (typeof resetTimeline === 'function') {
            resetTimeline();
            console.log("Called resetTimeline().");
        } else {
            // Fallback/manual timeline cleanup if resetTimeline is not defined
            console.warn("resetTimeline is not a function. Performing manual timeline cleanup.");
            if (viewerApp && viewerApp.state) viewerApp.state.currentVideoDuration = 0;
            if (viewerVideoTimelineContainerEl) viewerVideoTimelineContainerEl.style.display = 'none';
            if (viewerTimelineProgressEl) viewerTimelineProgressEl.style.width = '0%';
            if (viewerCurrentTimeEl) viewerCurrentTimeEl.textContent = formatTime(0); // formatTime needs to be accessible
            if (viewerTotalDurationEl) viewerTotalDurationEl.textContent = formatTime(0); // formatTime needs to be accessible
            if (viewerTimelineTrackEl) {
                const existingMarkers = viewerTimelineTrackEl.querySelectorAll('.timeline-marker');
                existingMarkers.forEach(marker => marker.remove());
                console.log("Manually cleared timeline markers.");
            }
        }

        // Reset canvas visibility
        const viewerFabricCanvasEl = document.getElementById("viewerFabricCanvas");
        if (viewerFabricCanvasEl) {
            viewerFabricCanvasEl.style.visibility = 'hidden'; // As per prompt, though original used opacity
            viewerFabricCanvasEl.style.opacity = '0'; // Original behavior
            console.log("Set viewerFabricCanvas visibility to hidden and opacity to 0.");
        } else {
            console.warn("viewerFabricCanvas element not found.");
        }

        const viewerCanvasContainerEl = document.getElementById("viewerCanvasContainer");
        if (viewerCanvasContainerEl) {
            viewerCanvasContainerEl.style.display = 'none'; // Original behavior
            viewerCanvasContainerEl.style.pointerEvents = 'none'; // Original behavior
            console.log("Set viewerCanvasContainer display to none and pointerEvents to none.");
        } else {
            console.warn("viewerCanvasContainer element not found.");
        }

        console.log("YouTube player stopped and destroyed successfully.");
    } catch (error) {
        console.error("Error in stopAndDestroyYouTubePlayer:", error);
    }
}

    function extractYouTubeVideoId(url) {
        if (!url) return null; let videoId = null;
        try { const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/; const match = url.match(regExp); videoId = (match && match[2].length === 11) ? match[2] : null;} 
        catch (e) { console.error("Error extracting YouTube Video ID:", e); videoId = null; }
        console.log(`Extracted Video ID: ${videoId} from URL: ${url}`); return videoId;
    }

    function setupAudioPlayer(audioDataURI) {
        if (!viewerAudioPlayerEl) { console.error("Audio player element not found."); return;}
        console.log("Setting up audio player.");
        try {
             viewerAudioPlayerEl.src = audioDataURI; viewerAudioPlayerEl.load();
             const playPromise = viewerAudioPlayerEl.play();
             if (playPromise !== undefined) { playPromise.then(() => console.log("Audio playback started.")).catch(error => console.error("Audio playback failed:", error));}
             viewerAudioPlayerEl.style.display = 'block'; viewerApp.state.currentAudioElement = viewerAudioPlayerEl;
        } catch (e) { console.error("Error setting up audio player:", e); displayMessageViewer("Error loading audio.", false); }
    }

// ADD audio event handler storage:
let audioEventHandlers = {
  ended: null,
  error: null,
  loadedmetadata: null
};

    function stopAndClearAudioPlayer() {
        console.log("stopAndClearAudioPlayer: Starting audio player cleanup.");
        const audioPlayer = viewerApp.state.currentAudioElement || viewerAudioPlayerEl;

        if (audioPlayer) {
            try {
                console.log("stopAndClearAudioPlayer: Audio player found. Removing event listeners and resetting.");

                // Remove event listeners
                if (audioEventHandlers.ended) {
                    audioPlayer.removeEventListener('ended', audioEventHandlers.ended);
                    console.log("stopAndClearAudioPlayer: Removed 'ended' event listener.");
                }
                if (audioEventHandlers.error) {
                    audioPlayer.removeEventListener('error', audioEventHandlers.error);
                    console.log("stopAndClearAudioPlayer: Removed 'error' event listener.");
                }
                if (audioEventHandlers.loadedmetadata) {
                    audioPlayer.removeEventListener('loadedmetadata', audioEventHandlers.loadedmetadata);
                    console.log("stopAndClearAudioPlayer: Removed 'loadedmetadata' event listener.");
                }

                // Reset handlers object
                audioEventHandlers = {
                    ended: null,
                    error: null,
                    loadedmetadata: null
                };
                console.log("stopAndClearAudioPlayer: Event handlers reset.");

                if (!audioPlayer.paused) {
                    audioPlayer.pause();
                    console.log("stopAndClearAudioPlayer: Audio paused.");
                }
                
                audioPlayer.removeAttribute('src'); // Clear the source
                audioPlayer.load(); // Reset the audio element
                audioPlayer.style.display = 'none'; // Hide the player
                
                console.log("stopAndClearAudioPlayer: Audio player stopped, cleared, and hidden.");
            } catch (e) {
                console.error("stopAndClearAudioPlayer: Error during audio player cleanup:", e);
            }
        } else {
            console.log("stopAndClearAudioPlayer: No active audio player instance to clear.");
        }
        
        viewerApp.state.currentAudioElement = null; // Nullify the reference in app state
        console.log("stopAndClearAudioPlayer: Cleanup complete. currentAudioElement is null.");
    }
    function applySpotlightEffect(targetObject) { /* SVG version preferred, this might be removed */ }
    function removeSpotlightEffect() { /* SVG version preferred, this might be removed */ }

    function checkVideoTimeForQuestions() {
        if (!isYouTubePlayerAvailable() || !viewerApp.state.ytPlayer || typeof viewerApp.state.ytPlayer.getCurrentTime !== 'function' || !viewerApp.state.currentVideoQuestions) return;
        const currentTime = safeGetCurrentTime(viewerApp.state.ytPlayer);
        for (let i = 0; i < viewerApp.state.currentVideoQuestions.length; i++) {
            const question = viewerApp.state.currentVideoQuestions[i];
            if (currentTime >= question.timestamp && !viewerApp.state.askedQuestionIndices.includes(i)) {
                if(isYouTubePlayerAvailable() && viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.pauseVideo === 'function') viewerApp.state.ytPlayer.pauseVideo();
                viewerApp.state.askedQuestionIndices.push(i);
                // Interval is cleared in onPlayerStateChange when paused/ended. No need to clear here
                // if the pause for the question itself triggers the state change that clears it.
                displayQuestion(question, viewerApp.state.currentMediaType); 
                break; 
            }
        }
    }

    function displayQuestion(question, mediaType) { 
        const canvas = viewerApp.state.viewerFabricCanvas; if (!canvas) return;

        // Ensure canvas is interactive for the question
        if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'auto';
        if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '1';

        const dialogWidth = Math.min(canvas.width * 0.9, 600); // Max width for dialog
        const dialogHeightRatio = canvas.height > 500 ? 0.75 : 0.85; // Adjust height ratio for smaller canvases
        let dialogHeight = canvas.height * dialogHeightRatio; 

        const dialogBackground = new fabric.Rect({
            left: canvas.width / 2, top: canvas.height / 2, originX: 'center', originY: 'center',
            width: dialogWidth, height: dialogHeight, fill: 'rgba(20, 20, 20, 0.92)', 
            rx: 15, ry: 15, stroke: 'rgba(200, 200, 200, 0.5)', strokeWidth: 1,
            shadow: 'rgba(0,0,0,0.6) 8px 8px 20px',
            selectable: false, evented: false, customType: 'videoQuestionOverlay'
        });

        const questionFontSize = Math.max(16, Math.min(28, dialogWidth / 25)); // Responsive font size
        const questionText = new fabric.Textbox(question.questionText, {
            left: dialogBackground.left, top: dialogBackground.top - dialogBackground.height / 2 + (questionFontSize * 1.5), 
            originX: 'center', originY: 'top', width: dialogWidth * 0.85, 
            fontSize: questionFontSize, fill: '#EFEFEF', textAlign: 'center', padding: 10,
            selectable: false, evented: false, customType: 'videoQuestionOverlay'
        });
        
        const optionFontSize = Math.max(14, Math.min(22, dialogWidth / 30));
        const optionHeight = optionFontSize * 2.2; // Proportional height
        const optionMargin = optionFontSize * 0.8;
        const optionsContainerWidth = dialogWidth * 0.8;
        const totalOptionsContentHeight = question.options.length * (optionHeight + optionMargin) - optionMargin;
        
        // Recalculate dialogHeight if content (question + options) is too large
        const minContentHeight = questionText.height + totalOptionsContentHeight + (questionFontSize * 2) + (optionMargin * 2); // Approx.
        if (minContentHeight > dialogHeight) {
            dialogHeight = minContentHeight + 40; // Add some padding
            dialogBackground.set('height', dialogHeight);
        }
        // Re-adjust questionText top if dialogHeight changed
        questionText.set('top', dialogBackground.top - dialogBackground.height / 2 + (questionFontSize * 1.5));


        let startY = questionText.top + questionText.height + optionMargin * 1.5; 
        const remainingDialogHeightForOptions = dialogBackground.height - (questionText.top - (dialogBackground.top - dialogBackground.height/2)) - questionText.height - (optionMargin * 1.5);
        if (totalOptionsContentHeight < remainingDialogHeightForOptions) { // Center options in remaining space
            startY = questionText.top + questionText.height + (remainingDialogHeightForOptions - totalOptionsContentHeight) / 2;
        }
        
        canvas.add(dialogBackground); // Add background first
        canvas.add(questionText);   // Then question text

        question.options.forEach((optionStr, index) => {
            const optionGroupY = startY + index * (optionHeight + optionMargin);
            const optionRect = new fabric.Rect({
                width: optionsContainerWidth, height: optionHeight, fill: 'rgba(60, 60, 60, 0.95)', 
                stroke: '#888', strokeWidth: 1, rx: 8, ry: 8, originX: 'center', originY: 'top'
            });
            const optionTextContent = new fabric.Textbox(optionStr, {
                fontSize: optionFontSize, fill: '#DADADA', width: optionRect.width - 20, 
                textAlign: 'center', originX: 'center', originY: 'center', top: optionRect.height / 2 
            });
            const optionGroup = new fabric.Group([optionRect, optionTextContent], {
                left: dialogBackground.left, top: optionGroupY, originX: 'center', originY: 'top', 
                selectable: false, evented: true, customType: 'videoQuestionOverlay', 
                customAnswerIndex: index, hoverCursor: 'pointer'
            });
            canvas.add(optionGroup);

            optionGroup.on('mousedown', function() {
                const isCorrect = (this.customAnswerIndex === question.correctOptionIndex);
                this.item(0).set('fill', isCorrect ? 'rgba(40, 180, 99, 0.95)' : 'rgba(231, 76, 60, 0.95)');
                
                const feedbackSymbolText = isCorrect ? '✓' : '✗';
                const feedbackSymbolColor = isCorrect ? '#D5F5E3' : '#FADBD8';
                const existingSymbol = this.getObjects().find(obj => obj.isFeedbackSymbol);
                if (existingSymbol) this.remove(existingSymbol); // Remove if one exists

                const feedbackSymbol = new fabric.Text(feedbackSymbolText, {
                    fontSize: optionFontSize * 1.2, fill: feedbackSymbolColor,
                    left: this.item(0).width / 2 - (optionFontSize * 0.5), // Position to the right
                    top: this.item(0).height / 2, originX: 'right', originY: 'center',
                    selectable: false, evented: false, isFeedbackSymbol: true
                });
                this.addWithUpdate(feedbackSymbol);
                this.item(1).set('width', optionRect.width - (optionFontSize * 2)); // Adjust text width for symbol

                canvas.renderAll();
                canvas.getObjects('group').forEach(obj => { if (obj.customType === 'videoQuestionOverlay' && obj.customAnswerIndex !== undefined) obj.evented = false;});

                setTimeout(() => {
                    canvas.getObjects().forEach(obj => { if (obj.customType === 'videoQuestionOverlay') canvas.remove(obj);});
                    
                    // Determine canvas state after question
                    // Use the new activeOverlays map (DOM elements)
                    if (viewerApp.state.activeOverlays && viewerApp.state.activeOverlays.size > 0) {
                         if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '1'; // Or based on updateViewerCanvasInteractivity logic
                         if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'auto'; // Or based on updateViewerCanvasInteractivity
                         // Calling updateViewerCanvasInteractivity directly might be better here
                         updateViewerCanvasInteractivity();
                    } else {
                         if (viewerFabricCanvasEl) viewerFabricCanvasEl.style.opacity = '0';
                         if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.pointerEvents = 'none';
                    }
                    canvas.renderAll();
                    if(viewerApp.state.ytPlayer && typeof viewerApp.state.ytPlayer.playVideo === 'function') viewerApp.state.ytPlayer.playVideo();
                }, 1500); 
            });
        });
        canvas.renderAll();
    }

    // updateCanvasInteractivity was renamed to updateViewerCanvasInteractivity, the placeholder below can be removed.
    // function updateCanvasInteractivity() { ... } // This is now updateViewerCanvasInteractivity

    // --- Timeline Reset Function ---
    function resetTimeline() {
        // console.log("Resetting timeline..."); // Removed for reduced noise
        if (viewerApp && viewerApp.state) {
            viewerApp.state.currentVideoDuration = 0;
            // console.log("Timeline: currentVideoDuration reset to 0."); // Commented out
        } else {
            console.warn("Timeline: viewerApp.state not available to reset currentVideoDuration.");
        }

        if (viewerVideoTimelineContainerEl) {
            viewerVideoTimelineContainerEl.style.display = 'none';
            // console.log("Timeline: viewerVideoTimelineContainerEl hidden."); // Commented out
        } else {
            console.warn("Timeline: viewerVideoTimelineContainerEl not found.");
        }

        if (viewerTimelineProgressEl) {
            viewerTimelineProgressEl.style.width = '0%';
            // console.log("Timeline: viewerTimelineProgressEl width reset to 0%."); // Commented out
        } else {
            console.warn("Timeline: viewerTimelineProgressEl not found.");
        }

        if (viewerCurrentTimeEl) {
            viewerCurrentTimeEl.textContent = formatTime(0);
            // console.log("Timeline: viewerCurrentTimeEl reset."); // Commented out
        } else {
            console.warn("Timeline: viewerCurrentTimeEl not found.");
        }

        if (viewerTotalDurationEl) {
            viewerTotalDurationEl.textContent = formatTime(0);
            // console.log("Timeline: viewerTotalDurationEl reset."); // Commented out
        } else {
            console.warn("Timeline: viewerTotalDurationEl not found.");
        }

        if (viewerTimelineTrackEl) {
            const existingMarkers = viewerTimelineTrackEl.querySelectorAll('.timeline-marker');
            existingMarkers.forEach(marker => marker.remove());
            // console.log("Timeline: Cleared timeline markers from viewerTimelineTrackEl."); // Commented out
        } else {
            console.warn("Timeline: viewerTimelineTrackEl not found.");
        }
        // console.log("Timeline reset complete."); // Removed for reduced noise
    }
  </script>