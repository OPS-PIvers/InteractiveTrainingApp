<script>
    // Namespace for the viewer application
    window.viewerApp = {};

    // --- Global Variables ---
    let ytPlayer; // Global variable to hold the YouTube player instance
    let isYouTubeApiReady = false; // Flag to track API readiness

    // --- Application State ---
    viewerApp.state = {
      isLoading: false,
      currentProjectData: null, 
      currentSlideIndex: 0,
      viewerFabricCanvas: null,
      defaultCanvasWidth: 960, 
      defaultCanvasHeight: 540,
      currentAudioElement: null // Reference to the currently playing audio element
    };
  
    // --- DOM Element References ---
    let viewerProjectListContainerEl, messageAreaElViewer, loadingSpinnerElViewer;
    let viewerListViewContainerEl, viewerProjectDisplayAreaEl, viewingProjectTitleEl;
    let viewerMediaContainerEl, youtubePlayerContainerEl, // New media container refs
        viewerCanvasContainerEl, viewerFabricCanvasEl;
    let viewerPrevSlideButtonEl, viewerNextSlideButtonEl, viewerSlideIndicatorEl, backToViewerListButtonEl;
    let viewerModalEl, viewerModalCloseButtonEl, viewerModalBodyEl;
    let viewerAudioPlayerEl; // Ref for the audio element
  
    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function() {
      console.log("Viewer_JS: DOMContentLoaded event fired!");
      
      viewerApp.setupDOMReferences();
      viewerApp.attachEventListeners(); 
      
      loadViewerProjectsList(); 
      
      console.log("Viewer_JS: Initialization complete.");
    });
  
    viewerApp.setupDOMReferences = function() {
      viewerProjectListContainerEl = document.getElementById('viewerProjectListContainer');
      messageAreaElViewer = document.getElementById('messageAreaViewer'); 
      loadingSpinnerElViewer = document.getElementById('loadingSpinner'); 

      viewerListViewContainerEl = document.getElementById('viewerListViewContainer');
      viewerProjectDisplayAreaEl = document.getElementById('viewerProjectDisplayArea');
      viewingProjectTitleEl = document.getElementById('viewingProjectTitle');
      
      viewerMediaContainerEl = document.getElementById('viewerMediaContainer'); // New
      youtubePlayerContainerEl = document.getElementById('youtubePlayerContainer'); // New
      viewerCanvasContainerEl = document.getElementById('viewerCanvasContainer'); // Container for the canvas
      viewerFabricCanvasEl = document.getElementById('viewerFabricCanvas'); // The actual canvas element
      
      viewerPrevSlideButtonEl = document.getElementById('viewerPrevSlideButton');
      viewerNextSlideButtonEl = document.getElementById('viewerNextSlideButton');
      viewerSlideIndicatorEl = document.getElementById('viewerSlideIndicator');
      backToViewerListButtonEl = document.getElementById('backToViewerListButton');

      viewerModalEl = document.getElementById('viewerModal');
      viewerModalCloseButtonEl = document.getElementById('viewerModalCloseButton');
      viewerModalBodyEl = document.getElementById('viewerModalBody');

      viewerAudioPlayerEl = document.getElementById('viewerAudioPlayer'); // New Audio Ref
  
      if (!viewerProjectListContainerEl) console.error("CRITICAL: viewerProjectListContainerEl not found!");
      if (!viewerModalEl) console.error("CRITICAL: viewerModalEl not found!");
      if (!viewerAudioPlayerEl) console.error("CRITICAL: viewerAudioPlayerEl not found!");
      console.log("Viewer_JS: DOM references set up.");
    };

    viewerApp.attachEventListeners = function() {
        if (backToViewerListButtonEl) backToViewerListButtonEl.addEventListener('click', showProjectListView);
        if (viewerPrevSlideButtonEl) viewerPrevSlideButtonEl.addEventListener('click', navigateToPrevSlide);
        if (viewerNextSlideButtonEl) viewerNextSlideButtonEl.addEventListener('click', navigateToNextSlide);
        if (viewerModalCloseButtonEl) viewerModalCloseButtonEl.addEventListener('click', hideViewerModal);
        if (viewerModalEl) { // Close modal if background is clicked
            viewerModalEl.addEventListener('click', function(event) {
                if (event.target === viewerModalEl) {
                    hideViewerModal();
                }
            });
        }
    };
  
    // --- UI Utils & Server Error Handling ---
    function showLoadingViewer(show) {
      viewerApp.state.isLoading = show;
      if (loadingSpinnerElViewer) {
        loadingSpinnerElViewer.style.display = show ? 'flex' : 'none';
      } else if (show) { 
          console.warn("showLoadingViewer(true) called but loadingSpinnerElViewer not yet available.");
      }
    }
  
    function displayMessageViewer(message, isSuccess) {
      if (messageAreaElViewer) {
        messageAreaElViewer.innerHTML = ''; 
        const p = document.createElement('p');
        p.textContent = message;
        messageAreaElViewer.appendChild(p);
        messageAreaElViewer.className = isSuccess ? 'success' : 'error'; 
        setTimeout(() => {
          if (messageAreaElViewer) {
            messageAreaElViewer.innerHTML = '';
            messageAreaElViewer.className = '';
          }
        }, 7000); 
      } else {
        console.warn("displayMessageViewer called but messageAreaElViewer not available. Message:", message);
      }
    }
    
    function onServerErrorViewer(errorObject) {
      showLoadingViewer(false);
      console.error('Viewer Server Error Object:', errorObject);
      let errorMessage = "An unknown error occurred on the server.";
      if (typeof errorObject === 'string') { 
          errorMessage = errorObject;
      } else if (errorObject && errorObject.message && typeof errorObject.message === 'string') { 
          errorMessage = errorObject.message;
      } else if (errorObject && errorObject.name && errorObject.message) { 
          errorMessage = `Error: ${errorObject.name} - ${errorObject.message}`;
      } else if (errorObject && errorObject.error && typeof errorObject.error === 'string') { // Handle {success:false, error:"..."}
          errorMessage = errorObject.error;
      }
      displayMessageViewer('Server Error: ' + errorMessage, false);
    }
  
    // --- Project List Loading/Display ---
    function loadViewerProjectsList() {
      console.log("loadViewerProjectsList called");
      if (!google || !google.script || !google.script.run) {
        console.error("google.script.run is not available for loadViewerProjectsList!");
        displayMessageViewer("Error: Client-server communication bridge unavailable.", false); return;
      }
      if (!viewerProjectListContainerEl) {
          console.warn("loadViewerProjectsList: viewerProjectListContainerEl not ready yet.");
          showLoadingViewer(false);
          return; 
      }
      showLoadingViewer(true);
      google.script.run
        .withSuccessHandler(displayViewerProjects)
        .withFailureHandler(onServerErrorViewer)
        .getActiveProjectsList(); 
    }
  
    function displayViewerProjects(projectsArray) {
      showLoadingViewer(false);
      console.log("displayViewerProjects received:", projectsArray ? projectsArray.length : 0, "projects");
      if (!viewerProjectListContainerEl) {
          console.error("displayViewerProjects: viewerProjectListContainerEl is not found!");
          return;
      }
      viewerProjectListContainerEl.innerHTML = ''; 
      if (!projectsArray || projectsArray.length === 0) {
        viewerProjectListContainerEl.innerHTML = '<p>No active training modules found at this time.</p>';
        return;
      }
  
      const ul = document.createElement('ul');
      ul.className = 'project-list-viewer'; 
  
      projectsArray.forEach(project => {
        if (!project || !project.projectId) { 
            console.warn("Skipping display of invalid project object:", project);
            return; 
        }
        const listItem = document.createElement('li');
        listItem.className = 'project-card-viewer'; 
        
        const titleHeader = document.createElement('h3');
        titleHeader.textContent = project.projectTitle || 'Untitled Project';
        
        const viewButton = document.createElement('button');
        viewButton.textContent = 'View Project';
        viewButton.className = 'view-project-button'; 
        viewButton.setAttribute('data-project-id', project.projectId); 
        viewButton.onclick = function() { 
          console.log("View Project button clicked for project ID:", project.projectId);
          loadProjectForViewing(project.projectId);
        };
  
        listItem.appendChild(titleHeader);
        listItem.appendChild(viewButton);
        ul.appendChild(listItem);
      });
      viewerProjectListContainerEl.appendChild(ul);
    }

    // --- View Switching & Cleanup ---
    function showProjectListView() {
        if (viewerListViewContainerEl) viewerListViewContainerEl.style.display = 'block';
        if (viewerProjectDisplayAreaEl) viewerProjectDisplayAreaEl.style.display = 'none';
        
        // Cleanup media players
        stopAndDestroyYouTubePlayer();
        stopAndClearAudioPlayer();

        if (viewerApp.state.viewerFabricCanvas) {
            viewerApp.state.viewerFabricCanvas.dispose();
            viewerApp.state.viewerFabricCanvas = null;
        }
        viewerApp.state.currentProjectData = null;
        viewerApp.state.currentSlideIndex = 0;
        loadViewerProjectsList(); 
    }

    function showProjectView() {
        if (viewerListViewContainerEl) viewerListViewContainerEl.style.display = 'none';
        if (viewerProjectDisplayAreaEl) viewerProjectDisplayAreaEl.style.display = 'block';
    }

    // --- Project Data Loading ---
    function loadProjectForViewing(projectId) {
        if (!projectId) {
            displayMessageViewer("Invalid project ID.", false);
            return;
        }
        showLoadingViewer(true);
        displayMessageViewer("Loading project...", true);
        google.script.run
            .withSuccessHandler(onProjectViewDataReceived)
            .withFailureHandler(onServerErrorViewer)
            .getProjectViewData(projectId);
    }

    function onProjectViewDataReceived(response) {
        showLoadingViewer(false);
        if (!response || !response.success || !response.data) {
            onServerErrorViewer(response || { error: "Failed to load project data or project is not active." });
             showProjectListView(); // Go back to list on error
            return;
        }
        try {
            viewerApp.state.currentProjectData = JSON.parse(response.data);
             // Ensure slides array exists and has slideMedia initialized
             if (viewerApp.state.currentProjectData && Array.isArray(viewerApp.state.currentProjectData.slides)) {
                 viewerApp.state.currentProjectData.slides.forEach(slide => {
                    if (!slide.slideMedia) {
                        slide.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
                    }
                 });
             } else {
                 throw new Error("Project data is missing slides array.");
             }

            if (viewerApp.state.currentProjectData.slides.length === 0) {
                displayMessageViewer("Project loaded, but it has no slides.", false);
                 showProjectListView(); // Go back to list if project is empty
                return;
            }

            console.log("Project for viewing loaded:", viewerApp.state.currentProjectData);
            viewerApp.state.currentSlideIndex = 0;
            showProjectView();
            if (viewingProjectTitleEl) viewingProjectTitleEl.textContent = viewerApp.state.currentProjectData.title || "Untitled Project";
            initializeViewerCanvas(); // Initialize canvas once per project load
            renderSlideForViewing(viewerApp.state.currentSlideIndex); // Render the first slide
            displayMessageViewer("Project loaded.", true);
        } catch (e) {
            console.error("Error parsing project data for viewing:", e);
            displayMessageViewer("Error loading project: Invalid data format.", false);
            viewerApp.state.currentProjectData = null;
             showProjectListView(); // Go back to list on error
        }
    }

    // --- Canvas & Slide Rendering ---
    function initializeViewerCanvas() {
        if (viewerApp.state.viewerFabricCanvas) {
            viewerApp.state.viewerFabricCanvas.dispose();
            viewerApp.state.viewerFabricCanvas = null;
        }
        if (!viewerFabricCanvasEl) {
            console.error("Viewer Fabric canvas element not found!");
            return;
        }
        try {
            viewerApp.state.viewerFabricCanvas = new fabric.Canvas(viewerFabricCanvasEl, {
                width: viewerApp.state.defaultCanvasWidth,
                height: viewerApp.state.defaultCanvasHeight,
                selection: false, 
                hoverCursor: 'default',
                backgroundColor: 'transparent' // Default to transparent for layering
            });
             // Make canvas non-interactive for drawing selection, etc.
            viewerApp.state.viewerFabricCanvas.selection = false;
            viewerApp.state.viewerFabricCanvas.renderAll(); // Initial render
            console.log("Viewer canvas initialized.");
        } catch(e) {
            console.error("Error initializing viewer Fabric canvas:", e);
            displayMessageViewer("Error initializing display canvas.", false);
        }
    }

    function renderSlideForViewing(slideIndex) {
        if (!viewerApp.state.currentProjectData || !viewerApp.state.viewerFabricCanvas) {
            console.error("Cannot render slide: Project data or canvas not ready."); return;
        }
        const slides = viewerApp.state.currentProjectData.slides;
        if (slideIndex < 0 || slideIndex >= slides.length) {
            console.error("Invalid slide index:", slideIndex); return;
        }
        
        // --- Cleanup Previous Slide Media FIRST ---
        stopAndDestroyYouTubePlayer(); 
        stopAndClearAudioPlayer();

        viewerApp.state.currentSlideIndex = slideIndex;
        const slideData = slides[slideIndex];
        const canvas = viewerApp.state.viewerFabricCanvas;

        // Ensure slideMedia exists
         if (!slideData.slideMedia) {
            slideData.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null };
         }

        // Set canvas dimensions and container dimensions
        const slideWidth = slideData.canvasWidth || viewerApp.state.defaultCanvasWidth;
        const slideHeight = slideData.canvasHeight || viewerApp.state.defaultCanvasHeight;
        // Don't set canvas size if YT is playing, let container handle it
        const media = slideData.slideMedia;
        let mediaType = (media && media.type) ? media.type : 'none';
        
        if (mediaType !== 'youtube') {
            canvas.setWidth(slideWidth);
            canvas.setHeight(slideHeight);
            if (viewerFabricCanvasEl) { 
                viewerFabricCanvasEl.width = slideWidth;
                viewerFabricCanvasEl.height = slideHeight;
            }
        } else {
             // For youtube, ensure canvas itself doesn't dictate size? Or maybe it should match?
             // Let's still set it to match for consistency in overlay positioning if we ever re-enable it.
            canvas.setWidth(slideWidth);
            canvas.setHeight(slideHeight);
             if (viewerFabricCanvasEl) { 
                viewerFabricCanvasEl.width = slideWidth;
                viewerFabricCanvasEl.height = slideHeight;
            }
        }

        // Adjust media container size to match slide aspect ratio
        if (viewerMediaContainerEl) {
            viewerMediaContainerEl.style.width = slideWidth + 'px';
            viewerMediaContainerEl.style.height = slideHeight + 'px'; 
        }
        
        // Clear canvas objects and background image
        canvas.clear(); 
        canvas.setBackgroundImage(null, () => { canvas.renderAll(); }); // Ensure BG cleared before loading new one
        canvas.backgroundColor = 'transparent'; // Default transparent for layering
        
        // Hide all media containers initially
        if (youtubePlayerContainerEl) youtubePlayerContainerEl.style.display = 'none';
        if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.display = 'none'; // Hide canvas container initially
        if (viewerAudioPlayerEl) viewerAudioPlayerEl.style.display = 'none'; 

        console.log(`Rendering slide ${slideIndex + 1}, media type: ${mediaType}`);

        switch(mediaType) {
            case 'image':
                if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.display = 'flex'; // Show canvas for image
                if (media.url && media.url.startsWith('data:image')) {
                    fabric.Image.fromURL(media.url, function(img) {
                        if (!viewerApp.state.viewerFabricCanvas || viewerApp.state.currentSlideIndex !== slideIndex) return; 
                        canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                            scaleX: canvas.width / img.width, scaleY: canvas.height / img.height
                        });
                    }, { crossOrigin: 'anonymous' });
                } else {
                     console.warn("Image media present but URL is missing or not base64:", media.url);
                     canvas.backgroundColor = '#e9e9e9'; 
                     canvas.renderAll(); 
                }
                break;

            case 'youtube':
                if (media.url) {
                    const videoId = extractYouTubeVideoId(media.url);
                    if (videoId) {
                        if (youtubePlayerContainerEl) youtubePlayerContainerEl.style.display = 'block'; // Show YT container
                        // Note: Canvas container remains hidden
                        if (isYouTubeApiReady) {
                             setupYouTubePlayer(videoId); 
                        } else {
                             console.warn("YouTube API not ready yet when trying to render slide.");
                             // Consider queuing setupYouTubePlayer if API not ready
                        }
                         // No need to set canvas background as canvas container is hidden
                    } else {
                        console.error("Could not extract YouTube Video ID from URL:", media.url);
                         // Show canvas container with error BG if YT fails
                         if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.display = 'flex';
                         canvas.backgroundColor = '#555'; 
                         canvas.renderAll(); 
                    }
                } else {
                     console.warn("YouTube media type set but URL is missing.");
                      if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.display = 'flex'; // Show canvas
                     canvas.backgroundColor = '#e9e9e9'; 
                     canvas.renderAll(); 
                }
                break;

            case 'audio':
                 if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.display = 'flex'; // Show canvas for audio
                 if (media.driveFileId) { 
                     console.log("Audio media needs fetch from Drive ID:", media.driveFileId);
                     showLoadingViewer(true); 
                     google.script.run
                         .withSuccessHandler(function(audioResponse) {
                             showLoadingViewer(false);
                             if (viewerApp.state.currentSlideIndex !== slideIndex) return; 
                             if (audioResponse && audioResponse.success && audioResponse.base64Data) {
                                 setupAudioPlayer(audioResponse.base64Data); 
                                 if (viewerAudioPlayerEl) viewerAudioPlayerEl.style.display = 'block'; 
                                 canvas.backgroundColor = '#e0e0e0'; 
                                 canvas.renderAll(); 
                             } else {
                                 console.error("Failed to fetch audio base64 data:", audioResponse);
                                 onServerErrorViewer(audioResponse || {error: "Failed to load audio data."});
                                 canvas.backgroundColor = '#e9e9e9'; 
                                 canvas.renderAll(); 
                             }
                         })
                         .withFailureHandler(function(error) { 
                             showLoadingViewer(false);
                             onServerErrorViewer(error);
                             canvas.backgroundColor = '#e9e9e9'; 
                             canvas.renderAll(); 
                         })
                         .getAudioAsBase64(media.driveFileId);
                 } else {
                     console.warn("Audio media type set but driveFileId is missing.");
                     canvas.backgroundColor = '#e9e9e9'; 
                     canvas.renderAll(); 
                 }
                 break;

            default: // 'none' or unknown
                 if (viewerCanvasContainerEl) viewerCanvasContainerEl.style.display = 'flex'; // Show canvas
                 canvas.backgroundColor = '#e9e9e9'; 
                 canvas.renderAll(); 
                 break;
        }
        
        // Load Fabric objects (overlays) ONLY if canvas container is visible
        if (viewerCanvasContainerEl && viewerCanvasContainerEl.style.display !== 'none' && slideData.fabricCanvasJSON) {
            canvas.loadFromJSON(slideData.fabricCanvasJSON, function() {
                if (viewerApp.state.currentSlideIndex !== slideIndex) return; 
                
                canvas.forEachObject(function(obj) {
                    obj.selectable = false; 
                    obj.evented = true; // Events are fine if canvas is visible   
                    obj.hoverCursor = 'pointer'; 

                    obj.off('mousedown'); // Remove previous listeners
                    obj.off('mouseover');

                    // Attach interaction listeners
                    if (obj.customInteraction && obj.customInteraction.trigger) {
                        if (obj.customInteraction.trigger === 'click') {
                            obj.on('mousedown', function(options) { 
                                if (this.customInteraction.trigger === 'click') {
                                    handleOverlayInteraction(this, 'click');
                                    if(options.e) options.e.stopPropagation(); 
                                }
                            });
                        } else if (obj.customInteraction.trigger === 'hover') {
                             obj.on('mouseover', function() {
                                if (this.customInteraction.trigger === 'hover') {
                                    handleOverlayInteraction(this, 'hover');
                                }
                            });
                        }
                    }
                });
                canvas.renderAll(); 
            });
        } else if (viewerCanvasContainerEl && viewerCanvasContainerEl.style.display !== 'none') {
             // If canvas is shown but no JSON, ensure it's rendered (already done by BG set)
             // canvas.renderAll(); 
        }
        updateSlideNavigationUI();
    }

    // --- Interaction & Modal Handling ---
    function handleOverlayInteraction(fabricObject, eventType) { /* ... no changes ... */ }
    function showViewerModal(htmlContent) { /* ... no changes ... */ }
    function hideViewerModal() { /* ... no changes ... */ }
    
    // --- Slide Navigation ---
    function updateSlideNavigationUI() { /* ... no changes ... */ }
    function navigateToPrevSlide() { /* ... no changes ... */ }
    function navigateToNextSlide() { /* ... no changes ... */ }


    // --- YouTube Player API Functions ---
    function onYouTubeIframeAPIReady() {
        console.log("YouTube IFrame API Ready (called by external script).");
        isYouTubeApiReady = true; 
    }

    function setupYouTubePlayer(videoId) {
        if (!youtubePlayerContainerEl) {
            console.error("YouTube player container element not found."); return;
        }
        youtubePlayerContainerEl.innerHTML = '<div id="youtube-player-div" style="width: 100%; height: 100%;"></div>'; 
        youtubePlayerContainerEl.style.display = 'block';
        console.log("Setting up YouTube player for video ID:", videoId);
        
        if (!isYouTubeApiReady || typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
            console.error("YT object or YT.Player is not available or API not ready.");
            displayMessageViewer("YouTube Player API not ready. Please wait or reload.", false);
            return;
        }

        try {
             if(ytPlayer && typeof ytPlayer.destroy === 'function') {
                 console.log("Destroying previous YT player instance.");
                 ytPlayer.destroy();
                 ytPlayer = null;
             }
             console.log("Creating new YT.Player instance.");
             ytPlayer = new YT.Player('youtube-player-div', {
                height: '100%', 
                width: '100%', 
                videoId: videoId,
                playerVars: { 
                    'autoplay': 0,       
                    'controls': 0, // Keep controls off
                    'rel': 0,            
                    'showinfo': 0,       
                    'modestbranding': 1, 
                    'iv_load_policy': 3, 
                    'fs': 0,             
                    'disablekb': 1,      
                    'playsinline': 1     
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': onPlayerError 
                }
            });
             console.log("YT.Player instance potentially created (check console for errors/readiness).");
        } catch (e) {
            console.error("Error creating YouTube player instance:", e);
            displayMessageViewer(`Error initializing YouTube player: ${e.message}`, false);
             if (youtubePlayerContainerEl) youtubePlayerContainerEl.style.display = 'none'; 
        }
    }

    function onPlayerReady(event) {
        console.log("YouTube Player Ready for video:", event.target.getVideoData().video_id);
        
         // Add click listener to the CONTAINER div now
         if(youtubePlayerContainerEl && !youtubePlayerContainerEl.hasAttribute('click-listener-added')){
             console.log("Adding click-to-play listener to YT player container.");
             youtubePlayerContainerEl.addEventListener('click', function() {
                 console.log("Player container clicked.");
                 if (ytPlayer && typeof ytPlayer.playVideo === 'function' && typeof ytPlayer.pauseVideo === 'function' && typeof ytPlayer.getPlayerState === 'function') {
                     const state = ytPlayer.getPlayerState();
                     if (state !== YT.PlayerState.PLAYING) {
                         console.log("Calling playVideo().");
                         ytPlayer.playVideo();
                     } else {
                         console.log("Calling pauseVideo().");
                         ytPlayer.pauseVideo(); 
                     }
                 } else {
                     console.warn("Cannot play/pause: Player or methods not available.");
                 }
             });
             youtubePlayerContainerEl.setAttribute('click-listener-added', 'true');
         }
    }

    function onPlayerStateChange(event) {
        console.log("YouTube Player State Change:", event.data, "(Playing:", YT.PlayerState.PLAYING, "Paused:", YT.PlayerState.PAUSED, "Ended:", YT.PlayerState.ENDED, ")");
    }

    function onPlayerError(event) {
        console.error("YouTube Player Error Code:", event.data);
        let errorMsg = `YouTube Player Error: Code ${event.data}. `;
        switch (event.data) {
            case 2: errorMsg += "Invalid video ID."; break;
            case 5: errorMsg += "HTML5 player error."; break;
            case 100: errorMsg += "Video not found or private."; break;
            case 101: 
            case 150: errorMsg += "Playback forbidden by owner."; break;
            default: errorMsg += "Unknown error."; break;
        }
        displayMessageViewer(errorMsg, false);
    }

    function stopAndDestroyYouTubePlayer() {
        try {
            if (ytPlayer && typeof ytPlayer.stopVideo === 'function') {
                ytPlayer.stopVideo();
                console.log("Called ytPlayer.stopVideo()");
            }
            if (ytPlayer && typeof ytPlayer.destroy === 'function') {
                ytPlayer.destroy();
                 console.log("YouTube Player Destroyed.");
            }
             ytPlayer = null; 
        } catch (e) {
            console.error("Error stopping/destroying YouTube player:", e);
        } finally {
             if (youtubePlayerContainerEl) {
                 // Remove click listener? Maybe not necessary if innerHTML is cleared.
                 youtubePlayerContainerEl.removeAttribute('click-listener-added'); 
                 youtubePlayerContainerEl.innerHTML = ''; 
                 youtubePlayerContainerEl.style.display = 'none';
             }
        }
    }

    function extractYouTubeVideoId(url) {
        if (!url) return null;
        let videoId = null;
        try {
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            videoId = (match && match[2].length === 11) ? match[2] : null;
        } catch (e) {
            console.error("Error extracting YouTube Video ID with Regex:", e);
            videoId = null;
        }
        console.log(`Extracted Video ID: ${videoId} from URL: ${url}`);
        return videoId;
    }

     // --- Audio Player Functions ---
    function setupAudioPlayer(audioDataURI) { // Now expects base64 data URI
        if (!viewerAudioPlayerEl) { console.error("Audio player element not found."); return;}
        console.log("Setting up audio player with base64 data URI.");
        try {
             viewerAudioPlayerEl.src = audioDataURI;
             viewerAudioPlayerEl.load(); 
             const playPromise = viewerAudioPlayerEl.play();
             if (playPromise !== undefined) {
                 playPromise.then(() => {
                     console.log("Audio playback started.");
                 }).catch(error => { 
                     console.error("Audio playback failed (likely autoplay blocked):", error);
                  }); 
             }
             viewerAudioPlayerEl.style.display = 'block'; 
             viewerApp.state.currentAudioElement = viewerAudioPlayerEl; // Store ref
        } catch (e) {
             console.error("Error setting up audio player:", e);
             displayMessageViewer("Error loading audio.", false);
        }
    }

    function stopAndClearAudioPlayer() {
        const audioPlayer = viewerApp.state.currentAudioElement || viewerAudioPlayerEl; // Get ref
        if (audioPlayer) {
             try {
                 if (!audioPlayer.paused) {
                     audioPlayer.pause();
                 }
                 audioPlayer.removeAttribute('src'); 
                 audioPlayer.load(); 
                 audioPlayer.style.display = 'none'; 
                 console.log("Audio Player Stopped and Cleared.");
             } catch (e) {
                  console.error("Error stopping/clearing audio player:", e);
             }
        }
         viewerApp.state.currentAudioElement = null; // Clear ref
    }

  </script>