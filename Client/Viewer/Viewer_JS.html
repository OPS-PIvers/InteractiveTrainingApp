<script>
    // Namespace for the viewer application
    window.viewerApp = {};

    // --- Global Variables ---
    const CLICK_AND_HOLD_DURATION = 750;
    const ANIMATION_SPEED_PRESETS = {
      slow: { duration: 1500 },
      normal: { duration: 1000 },
      fast: { duration: 500 }
    };

    // --- Application State ---
    viewerApp.state = {
      isLoading: false,
      currentProjectData: null,
      currentSlideIndex: 0,
      currentMediaType: null, // 'youtube', 'audio', 'image', etc.
      // Player instances (ytPlayer, audioPlayer) and API ready state (isYouTubeApiReady) are managed by MediaManager.
      viewerFabricCanvas: null,
      defaultCanvasWidth: 960,
      defaultCanvasHeight: 540,
      currentModalOverlay: null,
      modalSequence: [],
      currentModalSequenceIndex: -1,
      isSpotlightActive: false,
      currentSpotlightInfo: null,
      originalViewportTransform: null,
      isCanvasPannedOrZoomed: false,
      panZoomTargetObject: null, 
      activeAnimations: new Map(),
      // currentVideoQuestions and videoOverlays will be sourced from current slide data directly.
      askedQuestionIndices: [], // Tracks indices of questions already asked for the current video
      activeOverlays: new Map(), // Tracks active DOM overlays by their ID
      imageSlideTimelineEvents: [],
      currentImageSlideEventIndex: -1,
      currentImageTimelineEvents: []
    };

    // --- DOM Element References ---
    let viewerProjectListContainerEl, messageAreaElViewer, loadingSpinnerElViewer;
    let viewerListViewContainerEl, viewerProjectDisplayAreaEl, viewingProjectTitleEl;
    let viewerMediaContainerEl, youtubePlayerContainerEl, viewerAudioPlayerEl;
    let viewerCanvasContainerEl, viewerFabricCanvasEl;
    let viewerPrevSlideButtonEl, viewerNextSlideButtonEl, viewerSlideIndicatorEl, backToViewerListButtonEl;
    let viewerModalEl, viewerModalCloseButtonEl, viewerModalBodyEl,
        modalPrevButtonEl, modalNextButtonEl;

    let viewerTimelineTrackEl, viewerTimelineProgressEl,
        viewerCurrentTimeEl, viewerTotalDurationEl;

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', function() {
      console.log("Viewer_JS: DOMContentLoaded event fired!");
      viewerApp.setupDOMReferences();
      viewerApp.attachEventListeners();
      loadViewerProjectsList();
      console.log("Viewer_JS: Initialization complete.");
    });

    viewerApp.setupDOMReferences = function() {
      viewerProjectListContainerEl = document.getElementById('viewerProjectListContainer');
      messageAreaElViewer = document.getElementById('messageAreaViewer');
      loadingSpinnerElViewer = document.getElementById('loadingSpinner');
      viewerListViewContainerEl = document.getElementById('viewerListViewContainer');
      viewerProjectDisplayAreaEl = document.getElementById('viewerProjectDisplayArea');
      viewingProjectTitleEl = document.getElementById('viewingProjectTitle');
      viewerMediaContainerEl = document.getElementById('viewerMediaContainer');
      youtubePlayerContainerEl = document.getElementById('youtubePlayerContainer');
      viewerAudioPlayerEl = document.getElementById('viewerAudioPlayer');
      viewerCanvasContainerEl = document.getElementById('viewerCanvasContainer');
      viewerFabricCanvasEl = document.getElementById('viewerFabricCanvas');
      viewerPrevSlideButtonEl = document.getElementById('viewerPrevSlideButton');
      viewerNextSlideButtonEl = document.getElementById('viewerNextSlideButton');
      viewerSlideIndicatorEl = document.getElementById('viewerSlideIndicator');
      backToViewerListButtonEl = document.getElementById('backToViewerListButton');
      viewerModalEl = document.getElementById('viewerModal');
      viewerModalCloseButtonEl = document.getElementById('viewerModalCloseButton');
      viewerModalBodyEl = document.getElementById('viewerModalBody');
      modalPrevButtonEl = document.getElementById('modalPrevButton');
      modalNextButtonEl = document.getElementById('modalNextButton');
      viewerTimelineTrackEl = document.getElementById('viewerTimelineTrack'); 
      viewerTimelineProgressEl = document.getElementById('viewerTimelineProgress');
      viewerCurrentTimeEl = document.getElementById('viewerCurrentTime');
      viewerTotalDurationEl = document.getElementById('viewerTotalDuration');
      viewerApp.dom = viewerApp.dom || {};
      viewerApp.dom.viewerPrevImageEventButtonEl = document.getElementById('viewerPrevImageEventButton');
      viewerApp.dom.viewerImageEventIndicatorEl = document.getElementById('viewerImageEventIndicator');
      viewerApp.dom.viewerNextImageEventButtonEl = document.getElementById('viewerNextImageEventButton');
      if (!viewerProjectDisplayAreaEl) console.error("CRITICAL: viewerProjectDisplayAreaEl not found!");
      console.log("Viewer_JS: DOM references set up.");
      mediaManager.loadYouTubeAPI(); // Ensure YouTube API is loaded if Viewer is standalone
    };

    viewerApp.attachEventListeners = function() {
        if (backToViewerListButtonEl) backToViewerListButtonEl.addEventListener('click', showProjectListView);
        if (viewerPrevSlideButtonEl) viewerPrevSlideButtonEl.addEventListener('click', navigateToPrevSlide);
        if (viewerNextSlideButtonEl) viewerNextSlideButtonEl.addEventListener('click', navigateToNextSlide);
        if (viewerModalCloseButtonEl) viewerModalCloseButtonEl.addEventListener('click', hideViewerModal);
        if (viewerModalEl) {
            viewerModalEl.addEventListener('click', function(event) {
                if (event.target === viewerModalEl) hideViewerModal();
            });
        }
        if (modalPrevButtonEl) modalPrevButtonEl.addEventListener('click', navigateModalPrevious);
        if (modalNextButtonEl) modalNextButtonEl.addEventListener('click', navigateModalNext);
        if (viewerApp.dom.viewerPrevImageEventButtonEl) viewerApp.dom.viewerPrevImageEventButtonEl.addEventListener('click', navigateToPrevImageEvent);
        if (viewerApp.dom.viewerNextImageEventButtonEl) viewerApp.dom.viewerNextImageEventButtonEl.addEventListener('click', navigateToNextImageEvent);

        if (viewerTimelineTrackEl) {
            viewerTimelineTrackEl.addEventListener('click', function(e) {
                const mediaType = viewerApp.state.currentMediaType;
                let duration = 0;

                if (mediaType === 'youtube') {
                    duration = mediaManager.getDuration();
                } else if (mediaType === 'audio') {
                    duration = mediaManager.getAudioDuration();
                }

                if (duration > 0) {
                    const rect = viewerTimelineTrackEl.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const percentage = clickX / rect.width;
                    const seekTime = percentage * duration;

                    if (mediaType === 'youtube') {
                        mediaManager.seekTo(seekTime);
                         if (mediaManager.getPlayerState() !== YT.PlayerState.PLAYING) mediaManager.playVideo();
                    } else if (mediaType === 'audio') {
                        mediaManager.seekAudioTo(seekTime);
                        if (!mediaManager.state.audioPlayer || mediaManager.state.audioPlayer.paused) mediaManager.playAudio();
                    }
                }
            });
        }
        document.addEventListener('keydown', function(event) { /* ... existing keyboard nav logic ... */ });
    };

    let _optimizedRenderRAFId = null;
    function optimizedRenderAll(canvasInstance) { if (!canvasInstance) return; if (_optimizedRenderRAFId) { fabric.util.cancelAnimFrame(_optimizedRenderRAFId); } _optimizedRenderRAFId = fabric.util.requestAnimFrame(() => { canvasInstance.renderAll(); _optimizedRenderRAFId = null; }, canvasInstance.getElement()); }
    function smoothAnimate(drawCallback, duration = 300, easingFunction = easeInOutQuad) { /* ... content ... */ }
    function easeInOutQuad(t) { return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; }
    optimizedRenderAll = window.sharedUtils ? window.sharedUtils.debounce(optimizedRenderAll, 50) : optimizedRenderAll;

    function loadViewerProjectsList() {
      console.log("loadViewerProjectsList called");
      if (!google || !google.script || !google.script.run) {
        baseApp.displayMessage("Error: Client-server communication bridge unavailable.", false, 'messageAreaViewer'); return;
      }
      if (!viewerProjectListContainerEl) {
          // baseApp.showLoading(false, 'loadingSpinner'); // Spinner might not have been shown yet
          console.warn("loadViewerProjectsList: viewerProjectListContainerEl not found. Cannot display projects.");
          return;
      }
      baseApp.showLoading(true, 'loadingSpinner');
      viewerApp.state.isLoading = true;
      google.script.run
        .withSuccessHandler(displayViewerProjects)
        .withFailureHandler(error => baseApp.onServerError(error, 'messageAreaViewer')) // onServerError now handles isLoading=false
        .getActiveProjectsList();
    }

    function displayViewerProjects(response) {
        baseApp.showLoading(false, 'loadingSpinner'); // Handled by onServerError too, but good for success path
        viewerApp.state.isLoading = false;
        if (!response || !response.success) {
            // Error already handled by withFailureHandler calling baseApp.onServerError
            // baseApp.onServerError(response || { error: "Failed to load projects" }, 'messageAreaViewer');
            return;
        }
        const projectsArray = response.data && response.data.projects ? response.data.projects : [];
        if (!viewerProjectListContainerEl) { console.error("displayViewerProjects: viewerProjectListContainerEl is not found!"); return; }
        viewerProjectListContainerEl.innerHTML = '';
        if (!projectsArray || projectsArray.length === 0) {
          viewerProjectListContainerEl.innerHTML = '<p>No active training modules found at this time.</p>'; return;
        }
          const ul = document.createElement('ul');
          ul.className = 'project-list-viewer';
          projectsArray.forEach(project => {
            if (!project || !project.projectId) { console.warn("Skipping display of invalid project object:", project); return; }
            const listItem = document.createElement('li'); listItem.className = 'project-card-viewer';
            const titleHeader = document.createElement('h3'); titleHeader.textContent = project.projectTitle || 'Untitled Project';
            const viewButton = document.createElement('button'); viewButton.textContent = 'View Project'; viewButton.className = 'view-project-button';
            viewButton.setAttribute('data-project-id', project.projectId);
            viewButton.onclick = function() { loadProjectForViewing(project.projectId); };
            listItem.appendChild(titleHeader); listItem.appendChild(viewButton); ul.appendChild(listItem);
          });
          viewerProjectListContainerEl.appendChild(ul);
    }

    function showProjectListView() {
        if (viewerListViewContainerEl) viewerListViewContainerEl.style.display = 'block';
        if (viewerProjectDisplayAreaEl) viewerProjectDisplayAreaEl.style.display = 'none';

        // Use MediaManager to stop players
        if (viewerApp.state.currentMediaType === 'youtube') {
            mediaManager.stopAndDestroyPlayer();
        } else if (viewerApp.state.currentMediaType === 'audio') {
            mediaManager.stopAndClearAudioPlayer();
        }
        viewerApp.state.currentMediaType = null; // Reset media type

        hideSpotlightSVG();
        if(viewerApp.state.isCanvasPannedOrZoomed) resetPanZoomWithAnimation(true);
        if (viewerApp.state.viewerFabricCanvas) {
            viewerApp.state.viewerFabricCanvas.dispose(); viewerApp.state.viewerFabricCanvas = null;
        }
        viewerApp.state.currentProjectData = null; viewerApp.state.currentSlideIndex = 0;
        // messageAreaElViewer might need clearing if returning to list view with a persistent message
        // However, loadViewerProjectsList will likely display a new message or clear it if successful (no projects).
        loadViewerProjectsList();
    }

    function showProjectView() { /* ... content ... */ }

    function loadProjectForViewing(projectId) {
      if (!projectId) {
        baseApp.displayMessage("Invalid project ID.", false, 'messageAreaViewer');
        return;
      }
      baseApp.showLoading(true, 'loadingSpinner');
      viewerApp.state.isLoading = true;
      google.script.run
        .withSuccessHandler(onProjectViewDataReceived)
        .withFailureHandler(error => baseApp.onServerError(error, 'messageAreaViewer'))
        .getProjectViewById(projectId);
    }

    function onProjectViewDataReceived(response) {
      baseApp.showLoading(false, 'loadingSpinner');
      viewerApp.state.isLoading = false;
      if (!response || !response.success || !response.data || !response.data.projectDataJSON) {
        baseApp.onServerError(response || { error: "Failed to load project data." }, 'messageAreaViewer');
        viewerApp.state.currentProjectData = null;
        return;
      }
      try {
        const projectData = JSON.parse(response.data.projectDataJSON);
        if (!projectData.slides || projectData.slides.length === 0) {
          baseApp.displayMessage("This project has no slides.", false, 'messageAreaViewer');
          viewerApp.state.currentProjectData = null;
          return;
        }
        viewerApp.state.currentProjectData = projectData;
        viewerApp.state.currentSlideIndex = 0;
        if (viewingProjectTitleEl) viewingProjectTitleEl.textContent = projectData.title || 'Untitled Project';

        if (!viewerApp.state.viewerFabricCanvas && viewerFabricCanvasEl) {
            initializeViewerCanvas();
        }

        renderSlideForViewing(0);
        showProjectView(); // Ensure this is called after canvas is potentially initialized
      } catch (e) {
        console.error("Error parsing project data:", e);
        baseApp.onServerError({ message: "Error processing project data." }, 'messageAreaViewer');
        viewerApp.state.currentProjectData = null;
      }
    }

    function getCurrentSlide() { /* ... content ... */ }
    function getActionButtonText(action) { /* ... content ... */ }
    function createOverlayElement(overlay) { /* ... content, use mediaManager.getTemplateColor ... */ }
    function applyTemplateStyles(element, overlay) { /* ... content, use mediaManager.getTemplateColor ... */ }
    function handleOverlayAction(overlay) { /* ... content ... */ }
    function dismissOverlay(overlayId) { /* ... content, ensure mediaManager.state.ytPlayer or audioPlayer is used for play/pause ... */ }
    function initializeVideoOverlays() { /* ... content ... */ }
    function clearOverlayDisplayArea() { /* ... content ... */ }
    
    // --- MediaManager Callbacks for Viewer ---
    viewerApp.handleMediaPlayerReady = function(mediaTypeInfo) {
        console.log("ViewerApp: Media Player Ready. Type:", mediaTypeInfo.type);
        viewerApp.showLoading(false); // Hide general loading spinner
        sharedUtils.showElement(viewerTimelineContainerEl); // Show timeline for media
        viewerApp.renderTimelineMarkers();

        const currentSlide = getCurrentSlide();
        if (!currentSlide || !currentSlide.slideMedia) return;

        let startBehavior = 'clickToBegin'; // Default
        if (mediaTypeInfo.type === 'youtube' && currentSlide.slideMedia.youtubeOptions) {
            startBehavior = currentSlide.slideMedia.youtubeOptions.startBehavior;
        } else if (mediaTypeInfo.type === 'audio' && currentSlide.slideMedia.audioOptions) { // Assuming audioOptions for audio
            startBehavior = currentSlide.slideMedia.audioOptions.startBehavior;
        }

        const clickToBeginButton = document.getElementById('viewerClickToBeginButton'); // Ensure this element exists and is referenced correctly

        if (startBehavior === 'autoPlay') {
            sharedUtils.hideElement(clickToBeginButton);
            if (mediaTypeInfo.type === 'youtube') mediaManager.playVideo();
            else if (mediaTypeInfo.type === 'audio') mediaManager.playAudio();
        } else if (startBehavior === 'clickToBegin') {
            sharedUtils.showElement(clickToBeginButton);
             // Click listener for this button should call mediaManager.playVideo() or playAudio()
        } else { // Default 'none'
            sharedUtils.hideElement(clickToBeginButton);
        }
        updateViewerCanvasInteractivity(); // Consider canvas interaction based on player state
    };

    // Specific audio ready if different logic is needed than generic ready
    viewerApp.handleAudioPlayerReady = function(mediaTypeInfo) {
        console.log("ViewerApp: Audio Player Ready.");
        viewerApp.handleMediaPlayerReady(mediaTypeInfo); // Can reuse generic logic
    };

    viewerApp.handleMediaPlayerStateChange = function(eventData) { // eventData: {type, data}
        console.log("ViewerApp: Media Player State Change. Type:", eventData.type, "Data:", eventData.data);
        // Logic for YouTube: eventData.data is YT.PlayerState
        // Logic for Audio: eventData.data could be 'playing', 'paused', 'ended' (custom from MediaManager)
        updateViewerCanvasInteractivity();
    };

    viewerApp.handleAudioStateChange = function(eventData) { // If specific audio state handling is needed
        viewerApp.handleMediaPlayerStateChange(eventData); // Can reuse or add specific audio logic
    };

    viewerApp.handleMediaPlayerError = function(errorData) { // errorData: {type, data/error}
        baseApp.displayMessage(`${errorData.type} Player Error: ${errorData.data || (errorData.error ? errorData.error.message : 'Unknown error')}`, false, 'messageAreaViewer');
        updateViewerCanvasInteractivity();
    };

    viewerApp.handleAudioPlayerError = function(errorData) {
        viewerApp.handleMediaPlayerError(errorData); // Can reuse
    };

    viewerApp.handleMediaTimeUpdate = function(currentTime, duration, mediaType) {
        if (viewerCurrentTimeEl) viewerCurrentTimeEl.textContent = sharedUtils.formatTime(currentTime);
        if (viewerTotalDurationEl) viewerTotalDurationEl.textContent = sharedUtils.formatTime(duration);
        if (viewerTimelineProgressEl && duration > 0) {
            viewerTimelineProgressEl.style.width = (currentTime / duration) * 100 + '%';
        }
    };

    viewerApp.handleMediaQuestionTrigger = function(currentTime) { // Primarily for YouTube
        const currentSlide = getCurrentSlide();
        if (!currentSlide || !currentSlide.slideMedia || currentSlide.slideMedia.type !== 'youtube' || !currentSlide.slideMedia.videoQuestions || currentSlide.slideMedia.videoQuestions.length === 0) {
            return;
        }
        for (let i = 0; i < currentSlide.slideMedia.videoQuestions.length; i++) {
            const question = currentSlide.slideMedia.videoQuestions[i];
            if (!viewerApp.state.askedQuestionIndices.includes(i) && currentTime >= question.timestamp && currentTime < question.timestamp + 1.5) { // 1.5s window
                mediaManager.pauseVideo(); // Use MediaManager
                viewerApp.state.askedQuestionIndices.push(i);
                viewerApp.displayQuestion(question); // displayQuestion needs to be adapted if it directly accesses player
                break;
            }
        }
    };

    viewerApp.handleMediaOverlayUpdate = function(currentTime, mediaType) {
        viewerApp.updateVideoOverlays(currentTime); // Existing logic to show/hide overlays
    };

    viewerApp.handleMediaEnded = function(mediaTypeInfo) {
        console.log(`ViewerApp: ${mediaTypeInfo.type} media ended.`);
        if (mediaTypeInfo.type === 'youtube') {
            viewerApp.state.askedQuestionIndices = []; // Reset for replay
        }
        // Consider auto-advancing or showing an end-of-content message
        // viewerApp.changeSlide(1); // Example: auto-advance
    };

    function initializeViewerCanvas() { /* ... content as before, ensure no media player direct access ... */ }

    function renderSlideForViewing(slideIndex) {
        if (!viewerApp.state.currentProjectData || !viewerApp.state.viewerFabricCanvas) return;
        const slides = viewerApp.state.currentProjectData.slides;
        if (slideIndex < 0 || slideIndex >= slides.length) return;

        // MediaManager calls in showProjectListView handle player stop/destroy.
        hideSpotlightSVG();
        if(viewerApp.state.isCanvasPannedOrZoomed) resetPanZoomWithAnimation(true);

        const slideData = slides[slideIndex];
        const canvas = viewerApp.state.viewerFabricCanvas;
        viewerApp.state.currentSlideIndex = slideIndex;
        viewerApp.state.currentMediaType = (slideData.slideMedia && slideData.slideMedia.type) ? slideData.slideMedia.type : 'none';
        viewerApp.state.askedQuestionIndices = [];
        viewerApp.state.currentImageEventIndex = 0;
        viewerApp.state.currentImageTimelineEvents = (slideData.timelineEvents && Array.isArray(slideData.timelineEvents)) ? slideData.timelineEvents : [];

        const isImageWithTimeline = viewerApp.state.currentMediaType === 'image' && viewerApp.state.currentImageTimelineEvents.length > 0;
        // ... (UI updates for nav buttons as before) ...

        const interactiveTimelineBar = document.getElementById('interactiveTimelineBar');
        sharedUtils.safeDOMUpdate(interactiveTimelineBar, el => el.style.display = (viewerApp.state.currentMediaType === 'youtube' || viewerApp.state.currentMediaType === 'audio') ? 'block' : 'none');
        
        initializeVideoOverlays();

        if (canvas) {
            canvas.getObjects().forEach(obj => {
                if (obj.customType === 'videoTimestampOverlay' || obj.isTimestampOverlay) canvas.remove(obj);
            });
        }

        if (!slideData.slideMedia) slideData.slideMedia = { type: null, url: null, driveFileId: null, mimeType: null, originalName: null, youtubeOptions: { showClickToBeginButton: false } };
        else if (slideData.slideMedia.type === 'youtube' && typeof slideData.slideMedia.youtubeOptions === 'undefined') slideData.slideMedia.youtubeOptions = { showClickToBeginButton: false };

        const slideWidth = slideData.canvasWidth || viewerApp.state.defaultCanvasWidth;
        const slideHeight = slideData.canvasHeight || viewerApp.state.defaultCanvasHeight;
        canvas.setWidth(slideWidth); canvas.setHeight(slideHeight);
        if (viewerFabricCanvasEl) { viewerFabricCanvasEl.width = slideWidth; viewerFabricCanvasEl.height = slideHeight; }
        if (viewerMediaContainerEl) { viewerMediaContainerEl.style.width = slideWidth + 'px'; viewerMediaContainerEl.style.height = slideHeight + 'px'; }
        canvas.clear(); canvas.setBackgroundImage(null, () => { canvas.renderAll(); }); canvas.backgroundColor = 'transparent';

        const media = slideData.slideMedia;
        sharedUtils.safeDOMUpdate(youtubePlayerContainerEl, el => el.style.display = 'none');
        sharedUtils.safeDOMUpdate(viewerAudioPlayerEl, el => el.style.display = 'none');
        sharedUtils.safeDOMUpdate(viewerCanvasContainerEl, el => el.style.display = 'flex');

        console.log(`Rendering slide ${slideIndex + 1}, media type: ${viewerApp.state.currentMediaType}`);

        switch(viewerApp.state.currentMediaType) {
            case 'image':
                // ... (image loading logic as before) ...
                sharedUtils.safeDOMUpdate(viewerMediaContainerEl, el => el.style.backgroundColor = '#333'); // Example
                sharedUtils.safeDOMUpdate(viewerFabricCanvasEl, el => el.style.opacity = '1');
                sharedUtils.safeDOMUpdate(viewerCanvasContainerEl, el => el.style.pointerEvents = 'auto');
                 if (media && media.driveFileId) {
                    baseApp.showLoading(true, 'loadingSpinner');
                    viewerApp.state.isLoading = true;
                    google.script.run
                        .withSuccessHandler(function(imageResponse) {
                            baseApp.showLoading(false, 'loadingSpinner');
                            viewerApp.state.isLoading = false;
                            if (viewerApp.state.currentSlideIndex !== slideIndex) return;
                            if (imageResponse && imageResponse.success && imageResponse.base64Data) {
                                fabric.Image.fromURL(imageResponse.base64Data, function(img) {
                                    if (!viewerApp.state.viewerFabricCanvas) return;
                                    viewerApp.state.viewerFabricCanvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                                        scaleX: canvas.width / img.width, scaleY: canvas.height / img.height
                                    });
                                });
                            } else { baseApp.onServerError(imageResponse || {error:"Failed to load image"}, 'messageAreaViewer');}
                             if (slideData.fabricCanvasJSON) canvas.loadFromJSON(slideData.fabricCanvasJSON, canvas.renderAll.bind(canvas)); else canvas.renderAll();
                        })
                        .withFailureHandler(error => {baseApp.onServerError(error, 'messageAreaViewer'); canvas.renderAll();})
                        .getImageAsBase64(media.driveFileId);
                } else { if (slideData.fabricCanvasJSON) canvas.loadFromJSON(slideData.fabricCanvasJSON, canvas.renderAll.bind(canvas)); else canvas.renderAll(); }
                break;
             case 'youtube':
                sharedUtils.safeDOMUpdate(viewerMediaContainerEl, el => el.style.backgroundColor = 'transparent');
                canvas.backgroundColor = 'rgba(0,0,0,0)'; // Make Fabric canvas transparent
                const videoId = sharedUtils.extractYouTubeVideoId(media.url);
                if (videoId && youtubePlayerContainerEl) {
                    sharedUtils.safeDOMUpdate(youtubePlayerContainerEl, el => {
                        el.innerHTML = '<div id="viewerYouTubePlayerDiv" style="width: 100%; height: 100%;"></div>';
                        el.style.display = 'block';
                    });
                    const playerVars = { 'autoplay': 0, 'controls': 0, 'rel': 0, 'showinfo': 0, 'modestbranding': 1, 'iv_load_policy': 3, 'fs': 0, 'disablekb': 1, 'playsinline': 1 };
                    // Callbacks are already set generally, or can be re-set if specific to YT here
                    mediaManager.setupPlayer(videoId, 'viewerYouTubePlayerDiv', playerVars);
                } else {
                    baseApp.displayMessage("Invalid YouTube URL.", false, 'messageAreaViewer');
                }
                // Load Fabric content on top if any
                if (slideData.fabricCanvasJSON) canvas.loadFromJSON(slideData.fabricCanvasJSON, canvas.renderAll.bind(canvas)); else canvas.renderAll();
                updateViewerCanvasInteractivity();
                break;
             case 'audio':
                sharedUtils.safeDOMUpdate(viewerMediaContainerEl, el => el.style.backgroundColor = '#333'); // Example background
                sharedUtils.safeDOMUpdate(viewerAudioPlayerEl, el => el.style.display = 'block'); // Ensure audio element container is visible
                const interactiveTimeline = document.getElementById('interactiveTimelineBar'); // Assuming this is your timeline container
                sharedUtils.safeDOMUpdate(interactiveTimeline, el => el.style.display = 'block');

                if (media && media.driveFileId) {
                    baseApp.showLoading(true, 'loadingSpinner');
                    google.script.run
                        .withSuccessHandler(function(audioResponse) {
                            baseApp.showLoading(false, 'loadingSpinner');
                            if (viewerApp.state.currentSlideIndex !== slideIndex) return;
                            if (audioResponse && audioResponse.success && audioResponse.base64Data) {
                                // Specific callbacks for audio
                                mediaManager.state.callbacks.onReady = viewerApp.handleAudioPlayerReady;
                                mediaManager.state.callbacks.onError = viewerApp.handleAudioPlayerError;
                                mediaManager.state.callbacks.onStateChange = viewerApp.handleAudioStateChange; // If specific audio state changes are needed

                                mediaManager.setupAudio(audioResponse.base64Data, 'viewerAudioPlayer', {});
                            } else { 
                               baseApp.onServerError(audioResponse || {error: "Failed to load audio data."}, 'messageAreaViewer');
                            }
                            if (slideData.fabricCanvasJSON) canvas.loadFromJSON(slideData.fabricCanvasJSON, canvas.renderAll.bind(canvas)); else canvas.renderAll();
                        })
                        .withFailureHandler(error => {
                            baseApp.onServerError(error, 'messageAreaViewer');
                            if (slideData.fabricCanvasJSON) canvas.loadFromJSON(slideData.fabricCanvasJSON, canvas.renderAll.bind(canvas)); else canvas.renderAll();
                        })
                        .getAudioAsBase64(media.driveFileId);
                } else {
                    baseApp.displayMessage("Audio source missing.", false, 'messageAreaViewer');
                    if (slideData.fabricCanvasJSON) canvas.loadFromJSON(slideData.fabricCanvasJSON, canvas.renderAll.bind(canvas)); else canvas.renderAll();
                }
                updateViewerCanvasInteractivity();
                break;
             default: // For other types like PDF, Website, or if no media
                if (slideData.fabricCanvasJSON) canvas.loadFromJSON(slideData.fabricCanvasJSON, canvas.renderAll.bind(canvas)); else canvas.renderAll();
                updateViewerCanvasInteractivity(); // Default interactivity for non-media slides
                break;
        }
        updateSlideNavigationUI();
    }
    
    viewerApp.renderTimelineMarkers = function() {
        if (!viewerTimelineTrackEl || !viewerApp.state.currentProjectData) return;

        const currentSlide = getCurrentSlide();
        if (!currentSlide || !currentSlide.slideMedia) return;

        const questions = (viewerApp.state.currentMediaType === 'youtube' && Array.isArray(currentSlide.slideMedia.videoQuestions))
                           ? currentSlide.slideMedia.videoQuestions
                           : [];
        const overlays = (Array.isArray(currentSlide.slideMedia.videoOverlays))
                           ? currentSlide.slideMedia.videoOverlays
                           : [];

        // Call MediaManager to render markers
        // Duration and player availability checks are handled within mediaManager.renderTimelineMarkers
        mediaManager.renderTimelineMarkers('viewerTimelineTrack', questions, overlays);
    };

    viewerApp.displayQuestion = function(question) {
        // Assumes mediaManager.pauseVideo() was called by handleMediaQuestionTrigger
        // ... existing displayQuestion logic ...
    };
    viewerApp.updateVideoOverlays = function(currentTime) {
        // This function now receives currentTime from MediaManager
        // ... existing logic to show/hide/update DOM overlays based on currentTime ...
    };

    // renderImageTimelineEvent, updateImageTimelineNavUI, navigateToPrevImageEvent, navigateToNextImageEvent
    // handleOverlayInteraction, executeAnimation, and animation helpers
    // Modal functions, Spotlight functions, updateSlideNavigationUI, resetTimeline
    // updateViewerCanvasInteractivity - all remain, ensure they use MediaManager methods (e.g. mediaManager.pauseVideo())
    // The timeline click listener was updated to use mediaManager methods.
  </script>
