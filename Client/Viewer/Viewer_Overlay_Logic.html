<script>
    function checkVideoTimeForTimestampOverlays(currentTime) {
        // console.log(`checkVideoTimeForTimestampOverlays called at time: ${currentTime}`);
        if (!viewerApp.state.viewerFabricCanvas) { 
            // console.log(" - viewerFabricCanvas not ready for overlays.");
            updateViewerCanvasInteractivity(); // Update interactivity state even if no canvas for overlays
            return;
        }
        // Ensure currentTimestampOverlays is an array, even if empty, for safe iteration.
        if (!Array.isArray(viewerApp.state.currentTimestampOverlays)) {
            viewerApp.state.currentTimestampOverlays = [];
        }

        const canvas = viewerApp.state.viewerFabricCanvas;
        let changesMadeToCanvasObjects = false; // To track if a re-render is needed from object changes

        viewerApp.state.currentTimestampOverlays.forEach(overlayDefinition => {
            // Basic validation of the overlay definition
            if (!overlayDefinition || typeof overlayDefinition.overlayId === 'undefined' || 
                !overlayDefinition.fabricObjectJSON || typeof overlayDefinition.timestampShow !== 'number') {
                console.warn("Skipping invalid overlayDefinition:", overlayDefinition);
                return;
            }

            const shouldBeVisible = currentTime >= overlayDefinition.timestampShow &&
                                (typeof overlayDefinition.timestampHide !== 'number' || currentTime < overlayDefinition.timestampHide);
            const isActive = viewerApp.state.activeTimestampOverlayIds.has(overlayDefinition.overlayId);

            // console.log(` - Overlay ID: ${overlayDefinition.overlayId}, Show: ${overlayDefinition.timestampShow}, Hide: ${overlayDefinition.timestampHide}, IsActive: ${isActive}, ShouldBeVisible: ${shouldBeVisible}, Interactive: ${overlayDefinition.isInteractive}`);

            if (shouldBeVisible && !isActive) {
                // console.log(`   - Adding Overlay ID: ${overlayDefinition.overlayId}`);
                fabric.util.enlivenObjects([overlayDefinition.fabricObjectJSON], function(enlivenedObjects) {
                    if (enlivenedObjects && enlivenedObjects.length > 0) {
                        const newFabricObject = enlivenedObjects[0];
                        newFabricObject.selectable = false;
                        newFabricObject.evented = !!overlayDefinition.isInteractive; // Ensure it's a boolean
                        newFabricObject.timestampOverlayId = overlayDefinition.overlayId; // Assign ID for tracking
                        newFabricObject.hoverCursor = newFabricObject.evented ? 'pointer' : 'default';

                        if (overlayDefinition.isInteractive) {
                            newFabricObject.off('mousedown'); // Remove any prior listeners to be safe
                            newFabricObject.on('mousedown', function(options) {
                                // console.log("Interactive overlay mousedown:", this.timestampOverlayId);
                                if (this.evented) { // Double check evented status
                                    // Assuming handleOverlayInteraction is globally available or part of viewerApp
                                    if (typeof handleOverlayInteraction === 'function') {
                                        handleOverlayInteraction(this, 'click'); 
                                    } else if (viewerApp && typeof viewerApp.handleOverlayInteraction === 'function') { // Check if it's part of viewerApp namespace
                                        viewerApp.handleOverlayInteraction(this, 'click');
                                    } else {
                                        console.error('handleOverlayInteraction function not found.');
                                    }
                                    if(options.e) options.e.stopPropagation(); // Prevent event bubbling
                                }
                            });
                        }
                        
                        // Double-check if still not active due to async nature of enlivenObjects
                        if (!viewerApp.state.activeTimestampOverlayIds.has(overlayDefinition.overlayId)) {
                            canvas.add(newFabricObject);
                            viewerApp.state.activeTimestampOverlayIds.add(overlayDefinition.overlayId);
                            changesMadeToCanvasObjects = true;
                            // console.log(`   - Overlay ID: ${overlayDefinition.overlayId} ADDED to canvas. Active count: ${viewerApp.state.activeTimestampOverlayIds.size}`);
                            canvas.requestRenderAll(); // Render after adding the object
                        }
                    } else {
                        console.warn("Failed to enliven overlay object for ID:", overlayDefinition.overlayId, "JSON:", overlayDefinition.fabricObjectJSON);
                    }
                }, ''); // Namespace argument, usually empty
            } else if (!shouldBeVisible && isActive) {
                // console.log(`   - Removing Overlay ID: ${overlayDefinition.overlayId}`);
                let objectToRemove = null;
                // Iterate over canvas objects to find the one with the matching timestampOverlayId
                canvas.forEachObject(function(obj) {
                    if (obj.timestampOverlayId === overlayDefinition.overlayId) {
                        objectToRemove = obj;
                    }
                });
                if (objectToRemove) {
                    canvas.remove(objectToRemove);
                    viewerApp.state.activeTimestampOverlayIds.delete(overlayDefinition.overlayId);
                    changesMadeToCanvasObjects = true;
                    // console.log(`   - Overlay ID: ${overlayDefinition.overlayId} REMOVED from canvas. Active count: ${viewerApp.state.activeTimestampOverlayIds.size}`);
                }
            }
        });

        if (changesMadeToCanvasObjects) {
            // console.log("Total changes made to overlay objects, requesting final render if not done by individual adds.");
            canvas.requestRenderAll(); // Final render if any objects were added/removed
        }
        // This function is critical as it determines if the canvas should be clickable or transparent.
        // It needs to run after every check, regardless of whether Fabric objects were changed this cycle,
        // because the set of *active* overlays (even if visually unchanged) dictates interactivity.
        updateViewerCanvasInteractivity();
    }

    function updateViewerCanvasInteractivity() {
        // console.log("updateViewerCanvasInteractivity called.");
        const canvas = viewerApp.state.viewerFabricCanvas; 
        
        // DOM elements are expected to be globally available from Viewer_JS.html
        // These are direct references to global variables.
        const localViewerCanvasContainerEl = viewerCanvasContainerEl; 
        const localViewerFabricCanvasEl = viewerFabricCanvasEl;

        if (!canvas || !localViewerCanvasContainerEl || !localViewerFabricCanvasEl) {
            // console.log(" - Canvas or container elements not found for interactivity update.");
            return;
        }

        let isInteractiveOverlayActive = false;
        if (viewerApp.state.activeTimestampOverlayIds && viewerApp.state.activeTimestampOverlayIds.size > 0 && Array.isArray(viewerApp.state.currentTimestampOverlays)) {
            viewerApp.state.currentTimestampOverlays.forEach(overlay => {
                if (viewerApp.state.activeTimestampOverlayIds.has(overlay.overlayId) && overlay.isInteractive) {
                isInteractiveOverlayActive = true;
                }
            });
        }
        
        const isQuestionActive = canvas.getObjects().some(obj => obj.customType === 'videoQuestionOverlay' && obj.evented);
        const isClickToBeginActive = canvas.getObjects().some(obj => obj.customType === 'clickToBeginButton' && obj.evented);

        // console.log(` - Interactivity check: ClickToBegin=${isClickToBeginActive}, Question=${isQuestionActive}, OverlayInteractive=${isInteractiveOverlayActive}, AnyOverlayVisible=${viewerApp.state.activeTimestampOverlayIds ? viewerApp.state.activeTimestampOverlayIds.size : 0}`);

        if (isQuestionActive || isClickToBeginActive || isInteractiveOverlayActive) {
            // console.log("   - Canvas IS interactive (button, question, or interactive overlay active).");
            localViewerFabricCanvasEl.style.opacity = '1';
            localViewerCanvasContainerEl.style.pointerEvents = 'auto';
        } else if (viewerApp.state.activeTimestampOverlayIds && viewerApp.state.activeTimestampOverlayIds.size > 0) { 
            // Overlays are visible, but none of them are interactive (e.g., display-only text/shapes)
            // console.log("   - Canvas IS VISIBLE for non-interactive overlays, but NOT pointer-interactive.");
            localViewerFabricCanvasEl.style.opacity = '1'; 
            localViewerCanvasContainerEl.style.pointerEvents = 'none'; // Click-through to player
        } else {
            // Default behavior when no interactive elements OR visible non-interactive overlays are present
            if (viewerApp.state.currentMediaType === 'youtube') {
                // console.log("   - Canvas IS HIDDEN for YouTube (no active elements or visible non-interactive overlays).");
                localViewerFabricCanvasEl.style.opacity = '0';
                localViewerCanvasContainerEl.style.pointerEvents = 'none';
            } else {
                // For other media types (image, audio, or no media) where canvas might be inherently interactive
                // console.log("   - Canvas has default interactivity for non-YouTube media.");
                localViewerFabricCanvasEl.style.opacity = '1'; 
                localViewerCanvasContainerEl.style.pointerEvents = 'auto';
            }
        }
        if(canvas) canvas.requestRenderAll();
    }
</script>