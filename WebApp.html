<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Training</title>
  <style>
    /* Reset and base styles */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; overflow: hidden; } /* Prevent body scroll */
    body {
      font-family: 'Roboto', Arial, sans-serif;
      font-size: 16px;
      line-height: 1.5;
      color: #333;
      background-color: #f5f5f5;
      display: flex; /* Use flex for layout */
      flex-direction: column;
      position: relative; /* Needed for fixed overlays */
    }

    /* Main container */
    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

    /* Header */
    .header {
      padding: 15px;
      background-color: #1a73e8;
      color: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 10;
      flex-shrink: 0;
    }
    .header h1 { font-size: 1.5rem; font-weight: 400; margin: 0; }
    .nav-controls { display: flex; align-items: center; gap: 15px; }
    #slideTitle { font-size: 0.9rem; opacity: 0.8; max-width: 50%; text-overflow: ellipsis; white-space: nowrap; overflow: hidden; }

    /* Slide container - uses flex to center the slide */
    .slide-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      background-color: #f5f5f5; /* Light gray background around the slide */
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px; /* Padding around the slide */
      min-height: 400px; /* Ensure a minimum height */
    }

    /* The slide itself - aspect ratio maintained by JS */
    .slide {
      position: relative; /* Crucial for absolute positioning of children */
      background-color: white; /* Background of the slide area itself */
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      overflow: hidden;
      /* Width and height set by JS to maintain aspect ratio */
    }

    /* Background image within the slide div */
    .slide-background {
      display: block; /* Remove extra space below img */
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      z-index: 1;
      object-fit: cover; /* Fills the entire area, cropping if necessary */
      object-position: center; /* Center the image if it needs to be cropped */
    }

    /* Overlay elements - positioned relative to .slide */
    .overlay {
        position: absolute;
        z-index: 2;
        cursor: pointer;
        /* Base styles - Specifics (color, border, etc.) set by JS */
        background-color: transparent; /* Set by JS */
        border: none; /* Set by JS */
        border-radius: 0; /* Set by JS based on shape */
        box-shadow: none; /* Set by JS */
        /* Smooth Transitions for all properties */
        transition: background-color 0.2s, border-color 0.2s, border-style 0.2s,
                    border-width 0.2s, box-shadow 0.2s, transform 0.2s ease-out,
                    opacity 0.5s ease-out, border-radius 0.2s; /* Added border-radius transition */
        /* Position for overlay text */
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden; /* Prevent text overflow if needed */
    }

    .overlay-text {
        padding: 4px 8px;
        border-radius: 4px;
        font-weight: 500;
        text-align: center;
        max-width: 90%;
        word-break: break-word;
        line-height: 1.2;
        pointer-events: none;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8); /* Add shadow for better readability */
    }

    /* Styles for different overlay shapes (applied by JS) */
    .overlay.shape-rectangle { border-radius: 3px; } /* Slight rounding for default rectangle */
    .overlay.shape-roundedRectangle { border-radius: 15px; } /* More pronounced rounding */
    .overlay.shape-oval { border-radius: 50%; } /* Makes it an oval or circle */


    /* Revealed elements */
    .overlay.revealed {
        opacity: 0; /* Start hidden */
        transition: opacity 0.5s ease-in-out, background-color 0.2s,
                    border-color 0.2s, border-style 0.2s;
    }

    /* Hover Text (using data attribute set by JS) */
    .overlay::after {
        content: attr(data-hover-text); /* Get text from data attribute */
        position: absolute;
        bottom: -30px; /* Position below the overlay */
        left: 50%;
        transform: translateX(-50%); /* Center the text */
        background-color: rgba(0, 0, 0, 0.7); /* Dark background */
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap; /* Prevent text wrapping */
        z-index: 3;
        opacity: 0;
        visibility: hidden;
        pointer-events: none; /* Prevent interference */
        transition: opacity 0.2s ease-out, visibility 0.2s ease-out;
    }

    .overlay:hover {
        /* Hover effects can be subtle now as primary style is dynamic */
        filter: brightness(1.1); /* Slightly brighten on hover */
         /* Keep prominent border on hover IF outline is enabled */
         /* This is tricky with dynamic styles, JS might need to handle hover border */
         /* Example: JS could add a class on hover */
    }
     /* Example hover class (add/remove with JS) */
    .overlay.is-hovering {
         filter: brightness(1.1);
         /* You could potentially override border here if needed,
            but it might conflict with dynamic styles. */
         /* border-width: 3px !important; */ /* Use with caution */
    }


    /* Show the hover text - only if no overlay text is present */
    .overlay:not(.has-overlay-text):hover::after {
        opacity: 1;
        visibility: visible;
    }

    /* Style for element when its modal is open */
    .overlay.highlighted-for-modal {
        /* Use outline instead of border to avoid layout shifts */
        outline: 3px solid #1a73e8;
        outline-offset: 2px; /* Space between element and outline */
        box-shadow: 0 0 12px rgba(26, 115, 232, 0.5);
        z-index: 105; /* Ensure it's above dimmer and modal */
         /* Slightly dim the element itself to make outline pop */
         /* filter: brightness(0.9); */
    }

    /* Style for temporary highlight interaction */
     .overlay.highlighted-temporary {
        /* Apply styles directly via JS for immediate feedback */
        transition: background-color 0.1s, box-shadow 0.1s, filter 0.1s;
     }

    /* Control bar */
    .control-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 15px;
      background-color: #f5f5f5;
      border-top: 1px solid #ddd;
      flex-shrink: 0;
    }
    .slide-nav { display: flex; align-items: center; gap: 10px; }
    .nav-button {
      background-color: #1a73e8; color: white; border: none; border-radius: 4px;
      padding: 8px 15px; cursor: pointer; font-size: 0.9rem; display: flex;
      align-items: center; gap: 5px; transition: background-color 0.2s;
    }
    .nav-button:hover { background-color: #1558b7; }
    .nav-button:disabled { background-color: #b0bec5; cursor: not-allowed; }
    .slide-indicator { padding: 0 15px; color: #666; font-size: 0.9rem; }

    /* Text modal */
    #textModal {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.75);
      display: none; justify-content: center; align-items: center; z-index: 100;
      opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s;
    }
    #textModal.visible { opacity: 1; visibility: visible; display: flex; }
    #textModalContent {
      background-color: white; padding: 30px; border-radius: 8px;
      max-width: 80%; max-height: 80%; overflow: auto;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3); position: relative;
      transform: scale(0.9); transition: transform 0.3s;
    }
     #textModal.visible #textModalContent { transform: scale(1); }
    #closeModal {
      position: absolute; top: 10px; right: 10px; background: none; border: none;
      font-size: 1.8rem; cursor: pointer; color: #aaa; line-height: 1; padding: 0 5px;
    }
     #closeModal:hover { color: #333; }
    #modalText { margin-bottom: 15px; line-height: 1.6; }
    .modal-navigation {
      display: flex; justify-content: space-between; margin-top: 20px;
      padding-top: 15px; border-top: 1px solid #eee;
      gap: 15px; /* Add gap between buttons */
    }
    .modal-navigation button {
      padding: 8px 16px; background-color: #1a73e8; color: white; border: none;
      border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 5px;
      min-width: 100px; /* Set minimum width */
    }

    /* Animations, Loading, Error, Spotlight, Debug etc. - UNCHANGED from previous version */
    /* --- Animation Keyframes & Classes --- */
      /* --- Animation Keyframes & Classes --- */
    /* Existing */
    @keyframes pulse_anim { 0%, 100% { transform: scale(1); opacity: 0.7; } 50% { transform: scale(1.05); opacity: 1; } }
    @keyframes wiggle_anim { 0%, 100% { transform: rotate(0deg); } 25% { transform: rotate(3deg); } 75% { transform: rotate(-3deg); } }
    @keyframes float_anim { 0%, 100% { transform: translateY(0px); } 50% { transform: translateY(-8px); } }
    /* NEW Keyframes */
    @keyframes bounce_anim { 0%, 20%, 50%, 80%, 100% { transform: translateY(0); } 40% { transform: translateY(-10px); } 60% { transform: translateY(-5px); } }
    @keyframes shake_anim { 0% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); } 20%, 40%, 60%, 80%, 100% { transform: translateX(4px); } }
    @keyframes flash_anim { 0%, 100% { opacity: 1; } 50% { opacity: 0.2; } }
    @keyframes growShrink_anim { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.08); } }
    /* Spotlight text bubble animation */
    @keyframes bubbleFadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    #spotlightTextBubble {
        animation: bubbleFadeIn 0.3s ease-out forwards;
    }

    /* Notes panel animation */
    @keyframes notesPanelFadeIn {
        from { opacity: 0; transform: translate(-50%, 20px); }
        to { opacity: 1; transform: translate(-50%, 0); }
    }

    #spotlightNotesPanel {
        animation: notesPanelFadeIn 0.3s ease-out forwards;
    }

    /* Base Animation Classes */
    .animate-pulse { animation: pulse_anim 2s infinite ease-in-out; }
    .animate-wiggle { animation: wiggle_anim 0.5s infinite ease-in-out; }
    .animate-float { animation: float_anim 3s infinite ease-in-out; }
    .animate-bounce { animation: bounce_anim 1.5s infinite ease-in-out; }
    .animate-shake { animation: shake_anim 0.6s infinite ease-in-out; }
    .animate-flash { animation: flash_anim 1s infinite steps(1, end); }
    .animate-growShrink { animation: growShrink_anim 2s infinite ease-in-out; }

    /* Speed/Intensity Variants */
    /* Pulse */
    .animate-pulse.slow { animation-duration: 3s; }
    .animate-pulse.medium { animation-duration: 2s; }
    .animate-pulse.fast { animation-duration: 1s; }
    /* Wiggle */
    .animate-wiggle.gentle { animation-duration: 1s; transform-origin: center; } /* Gentle needs longer duration */
    .animate-wiggle.medium { animation-duration: 0.5s; transform-origin: center; }
    .animate-wiggle.strong { animation-duration: 0.3s; transform-origin: center; }
    /* Float */
    .animate-float.slow { animation-duration: 4s; }
    .animate-float.medium { animation-duration: 3s; }
    .animate-float.fast { animation-duration: 2s; }

    /* Loading overlay */
    .loading-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(255, 255, 255, 0.8); display: flex; flex-direction: column;
      justify-content: center; align-items: center; z-index: 1000;
    }
    .loading-spinner {
      border: 5px solid #f3f3f3; border-top: 5px solid #1a73e8; border-radius: 50%;
      width: 50px; height: 50px; animation: spin 1s linear infinite; margin-bottom: 20px;
    }
    .loading-message { font-size: 1.2rem; color: #333; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* Error message */
    .error-message {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      background-color: #f44336; color: white; padding: 15px 20px; border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1001; max-width: 80%;
      display: none; /* Initially hidden */
    }

    /* Dim/Spotlight Overlay */
    .dim-overlay {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.7); /* Adjust darkness */
      z-index: 90; /* Below modal, above most content */
      opacity: 0;
      visibility: hidden;
      pointer-events: none; /* Prevent interaction when hidden */
      transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
      cursor: pointer; /* Indicate it's clickable to dismiss */
    }
    .dim-overlay.active {
      opacity: 1;
      visibility: visible;
      pointer-events: auto; /* Allow clicking the overlay to dismiss */
    }
    /* Style for the element being spotlighted */
    .overlay.spotlight-active {
        z-index: 95 !important; /* Ensure spotlighted element is above dimmer */
        background-color: transparent !important;
        border: 2px solid rgba(255, 255, 255, 0.9) !important; /* White highlight */
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.7), 
                    0 0 30px rgba(255, 255, 255, 0.3) !important; /* Glowing effect */
        cursor: default !important; /* Don't show click cursor */
        pointer-events: none !important; /* Prevent interaction with the highlighted element */
    }

    /* Hide the "Click here" text when spotlighted */
    .overlay.spotlight-active::after {
        display: none !important;
    }
    
    /* --- Spotlight Navigation Buttons --- */
    @keyframes buttonPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .spotlight-nav-button {
      padding: 6px 12px;
      background-color: #1a73e8;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: background-color 0.2s, opacity 0.2s;
    }

    .spotlight-nav-button:hover:not(:disabled) {
      background-color: #1558b7;
      animation: buttonPulse 0.5s ease-in-out;
    }

    .spotlight-nav-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .spotlight-nav-button span {
      font-size: 16px;
      line-height: 1;
    }

    /* Spotlight text bubble animations */
    @keyframes bubbleEnter {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    #spotlightTextBubble {
      animation: bubbleEnter 0.3s forwards;
    }

    /* Navigation container in spotlight text */
    .spotlight-nav-container {
      display: flex;
      justify-content: space-between;
      margin-top: 12px;
      padding-top: 10px;
      border-top: 1px solid #eee;
    }

    /* Debug Tools */
    .debug-info {
      position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7);
      color: white; padding: 10px; border-radius: 4px; font-size: 12px;
      z-index: 1000; max-width: 300px; max-height: 200px; overflow: auto;
      display: none; /* Hidden by default */
    }
    .debug-toggle {
      position: fixed; bottom: 10px; right: 10px; /* Position toggle initially */
      background: #1a73e8; color: white; border: none; border-radius: 4px;
      padding: 5px 10px; font-size: 12px; cursor: pointer; z-index: 1001;
      display: none; /* Hidden by default, enabled via debugMode flag */
    }
    .debug-toggle.active {
       right: 320px; /* Move toggle when info panel is shown */
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .header h1 { font-size: 1.2rem; }
      #slideTitle { max-width: 40%; }
      #textModalContent { max-width: 95%; padding: 15px; }
      .nav-button { padding: 6px 10px; font-size: 0.8rem; }
      .slide-indicator { padding: 0 10px; }
      .control-bar { padding: 8px 10px; }
    }
  </style>
</head>
<body>
  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div class="loading-message">Loading presentation...</div>
  </div>

  <!-- Dim/Spotlight Overlay -->
  <div class="dim-overlay" id="dimOverlay"></div>

  <!-- Main Container -->
  <div class="container">
    <div class="header">
      <h1>Interactive Training</h1>
      <div class="nav-controls">
        <span id="slideTitle"></span>
      </div>
    </div>

    <div class="slide-container" id="slideContainer">
      <div class="slide" id="slide">
        <img class="slide-background" id="slideBackground" src="" alt="Slide background">
        <!-- Overlays will be added here dynamically -->
      </div>
    </div>

    <div class="control-bar">
      <div class="slide-nav">
        <button id="prevSlideBtn" class="nav-button" disabled>
          <span>←</span> Previous
        </button>
        <span class="slide-indicator" id="slideIndicator">Slide 1 of 1</span>
        <button id="nextSlideBtn" class="nav-button" disabled>
          Next <span>→</span>
        </button>
      </div>
      <div>
        <button id="restartBtn" class="nav-button">
          <span>↺</span> Restart
        </button>
      </div>
    </div>
  </div>

  <!-- Text modal -->
  <div id="textModal">
    <div id="textModalContent">
      <button id="closeModal">×</button>
      <div id="modalText"></div>
      <div class="modal-navigation">
        <button id="prevElementBtn">
          <span>←</span> Previous
        </button>
        <button id="nextElementBtn">
          Next <span>→</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Error Message Area -->
  <div id="errorMessage" class="error-message"></div>

  <!-- Debug tools -->
  <button id="debugToggle" class="debug-toggle">Debug</button>
  <div id="debugInfo" class="debug-info"></div>


<script>
    // ---------- Global Variables ----------
    const presentationId = "<?= presentationId ?>"; // Injected by GAS doGet
    let currentSlide = null;
    let currentSlideIndex = 0;
    let totalSlides = 0;
    let overlayElementsMap = new Map(); // Map<elementId, overlayDiv>
    // Store full element data received from backend
    let currentSlideElementsData = [];
    let interactiveElements = []; // Subset of currentSlideElementsData with interactions/animations
    let currentModalElementIndex = -1;
    let currentSpotlightElementIndex = -1;
    let lastActiveElementId = null; // NEW: Track the last element interacted with
    let spotlightableElements = [];
    let isSpotlightActive = false;
    let debugMode = false; // Set true for local debugging
    let permanentlyHiddenElementsPerSlide = {}; // NEW: Track hidden elements { slideIndex: Set<elementId> }
    let navSequenceElements = []; // Stores all navigable elements in sequence order
    
    // NEW: Store global overlay defaults received from backend
    let globalOverlayDefaults = {
        shape: 'rectangle', color: '#e53935', opacity: 15, outlineEnabled: true,
        outlineColor: '#e53935', outlineWidth: 1, outlineStyle: 'dashed',
        textColor: '#ffffff', textSize: 14, hoverText: 'Click here'
    };

    // DOM element references (mostly unchanged)
    const slideContainer = document.getElementById('slideContainer');
    const slideElement = document.getElementById('slide');
    const slideBackground = document.getElementById('slideBackground');
    const slideIndicator = document.getElementById('slideIndicator');
    const prevSlideBtn = document.getElementById('prevSlideBtn');
    const nextSlideBtn = document.getElementById('nextSlideBtn');
    const restartBtn = document.getElementById('restartBtn');
    const slideTitleElement = document.getElementById('slideTitle');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const textModal = document.getElementById('textModal');
    const modalTextDiv = document.getElementById('modalText');
    const closeModalBtn = document.getElementById('closeModal');
    const prevElementBtn = document.getElementById('prevElementBtn');
    const nextElementBtn = document.getElementById('nextElementBtn');
    const dimOverlay = document.getElementById('dimOverlay');
    const errorElement = document.getElementById('errorMessage');
    const debugToggle = document.getElementById('debugToggle');
    const debugInfo = document.getElementById('debugInfo');

    // ---------- Initialization ----------
    window.addEventListener('load', () => { /* ... unchanged ... */
      logDebug(`[WebApp] Starting with presentation ID: ${presentationId}`);
      setupEventListeners();
      setupDebugTools();
      loadSlide(0); // Load the first slide
      window.addEventListener('resize', handleResize);
    });

    function setupEventListeners() { /* ... unchanged ... */
      prevSlideBtn.addEventListener('click', () => loadSlide(currentSlideIndex - 1));
      nextSlideBtn.addEventListener('click', () => loadSlide(currentSlideIndex + 1));
      restartBtn.addEventListener('click', () => loadSlide(0));
      closeModalBtn.addEventListener('click', hideTextModal);
      textModal.addEventListener('click', (e) => { if (e.target === textModal) hideTextModal(); });
      dimOverlay.addEventListener('click', hideSpotlight);
      prevElementBtn.addEventListener('click', navigateToPrevElement);
      nextElementBtn.addEventListener('click', navigateToNextElement);
    }

    function setupDebugTools() { /* ... unchanged ... */
      if (debugMode) {
        debugToggle.style.display = 'block';
        debugToggle.addEventListener('click', () => {
          const showDebug = debugInfo.style.display === 'none';
          debugInfo.style.display = showDebug ? 'block' : 'none';
          debugToggle.classList.toggle('active', showDebug);
          debugToggle.textContent = showDebug ? 'Hide Debug' : 'Debug';
        });
      } else {
         debugToggle.style.display = 'none';
         debugInfo.style.display = 'none';
      }
    }

    function logDebug(message, data) { /* ... unchanged ... */
        if (debugMode) {
            console.log(message, data !== undefined ? data : '');
            if (debugInfo.style.display !== 'none') {
               const time = new Date().toLocaleTimeString();
               debugInfo.innerHTML = `[${time}] ${message}<br>` + debugInfo.innerHTML;
            }
        }
    }

    function updateDebugInfo(info) { /* ... unchanged ... */
        if (!debugMode || debugInfo.style.display === 'none') return;
        const time = new Date().toLocaleTimeString();
        debugInfo.innerHTML = `[${time}] ${info}<br>` + debugInfo.innerHTML;
    }

    function handleResize() { /* ... unchanged ... */
      if (currentSlide) {
        adjustSlideSize();
        renderOverlays();
      }
    }

    // ---------- Slide Loading ----------
    function loadSlide(index) {
        if (index < 0 || (totalSlides > 0 && index >= totalSlides)) {
            logDebug(`[WebApp] Invalid slide index requested: ${index}`);
            return;
        }
        logDebug(`[WebApp] Requesting slide index: ${index}`);

        // Initialize hidden set for the target slide index if it doesn't exist
        if (!permanentlyHiddenElementsPerSlide[index]) {
            permanentlyHiddenElementsPerSlide[index] = new Set();
            logDebug(`[WebApp] Initialized hidden set for slide index ${index}. Current state of all sets:`, permanentlyHiddenElementsPerSlide); // LOGGING
        } else {
            // Log the existing set for this slide
            logDebug(`[WebApp] Hidden set for slide index ${index} already exists with elements:`, Array.from(permanentlyHiddenElementsPerSlide[index])); // LOGGING
            logDebug(`[WebApp] Current state of all sets:`, permanentlyHiddenElementsPerSlide); // LOGGING
        }

        showLoading("Loading slide...");
        hideTextModal();
        clearOverlays();
        overlayElementsMap.clear();
        currentSlideElementsData = []; // Clear previous element data
        interactiveElements = [];
        currentModalElementIndex = -1;
        currentSpotlightElementIndex = -1;
        lastActiveElementId = null; // Reset last active element on slide change
        navSequenceElements = []; // Reset nav sequence

        // If changing slides, save current state of hidden elements for the slide we're leaving
        if (currentSlideIndex !== index && currentSlideElementsData.length > 0) {
            // Create map of currently visible elements
            const visibleElements = new Set(overlayElementsMap.keys());
            const allInteractiveIds = interactiveElements.map(el => el.id);
            
            // Track which elements are hidden on the current slide before switching
            if (!permanentlyHiddenElementsPerSlide[currentSlideIndex]) {
                permanentlyHiddenElementsPerSlide[currentSlideIndex] = new Set();
            }
            
            // Any interactive element that's not visible should be marked as hidden
            allInteractiveIds.forEach(id => {
                if (!visibleElements.has(id)) {
                    permanentlyHiddenElementsPerSlide[currentSlideIndex].add(id);
                    logDebug(`[WebApp] Marked element ${id} as hidden for slide ${currentSlideIndex}`);
                }
            });
            
            logDebug(`[WebApp] Saved hidden state for slide ${currentSlideIndex}: ${Array.from(permanentlyHiddenElementsPerSlide[currentSlideIndex]).join(', ')}`);
        }

        google.script.run
            .withSuccessHandler(handleSlideData)
            .withFailureHandler(handleLoadError)
            .getSlideDataForWebApp(presentationId, index);
    }

    /**
     * Handles slide data received from the backend and prepares it for display.
     * @param {Object} data - The slide data object from the backend.
     */
    function handleSlideData(data) {
      logDebug(`[WebApp] Received slide data:`, data);
      
      // Safety timeout - ensure loading overlay gets hidden even if image loading hangs
      const loadingTimeout = setTimeout(() => {
        console.warn("[WebApp] Loading timeout reached, forcing hide of loading overlay");
        hideLoading();
      }, 5000); // 5 seconds timeout
      
      if (data.error) {
        handleLoadError(data.error);
        // Try to show minimal info if possible
        currentSlideIndex = data.currentSlideIndex !== undefined ? data.currentSlideIndex : currentSlideIndex;
        totalSlides = data.totalSlides !== undefined ? data.totalSlides : totalSlides;
        updateSlideNavControls(); // Update nav buttons even on error
        clearTimeout(loadingTimeout); // Clear the safety timeout
        return;
      }

      currentSlide = data;
      currentSlideIndex = data.index; // Use the correct property (index instead of currentSlideIndex)
      totalSlides = data.total; // Use the correct property (total instead of totalSlides)
      
      // IMPORTANT: Store all element data, including non-interactive elements
      currentSlideElementsData = data.elements || [];
      
      // Handle global overlay settings
      if (data.globalOverlayDefaults) {
        // Use the new structure (preferred)
        logDebug("[WebApp] Using globalOverlayDefaults structure:", data.globalOverlayDefaults);
        globalOverlayDefaults = data.globalOverlayDefaults;
        overlayOpacity = data.globalOverlayDefaults.opacity !== undefined ? data.globalOverlayDefaults.opacity : 15;
        overlayShadow = !!data.globalOverlayDefaults.outlineEnabled;
      } else {
        // Fallback to deprecated fields
        logDebug("[WebApp] Using deprecated overlayOpacity/overlayShadow fields");
        overlayOpacity = typeof data.overlayOpacity === 'number' ? data.overlayOpacity : 15;
        overlayShadow = !!data.overlayShadow;
      }
      logDebug(`[WebApp] Applied overlay settings: Opacity=${overlayOpacity}%, Shadow=${overlayShadow}`);

      // Filter interactive elements more carefully
      interactiveElements = currentSlideElementsData.filter(el => {
        const hasInteraction = el.interaction && 
                              el.interaction.type && 
                              el.interaction.type !== 'none';
        const hasAnimation = el.animation && 
                            el.animation.type && 
                            el.animation.type !== 'none';
        
        // Also consider elements with overlay style but no interaction type as interactive
        const hasOverlayStyle = el.interaction && 
                              el.interaction.overlayStyle &&
                              Object.keys(el.interaction.overlayStyle).length > 0;
                              
        return hasInteraction || hasAnimation || hasOverlayStyle;
      });
      
      logDebug(`[WebApp] Found ${interactiveElements.length} interactive elements out of ${currentSlideElementsData.length} total`);
      
      currentModalElementIndex = -1; // Reset modal index

      updateSlideNavControls(); // Update buttons and indicator
      slideTitleElement.textContent = data.notes || ''; // Display speaker notes as title

      // Simplified background handling - don't rely on events that might not fire
      if (data.backgroundUrl) {
        logDebug("[WebApp] Setting background image...");
        slideBackground.src = data.backgroundUrl;
        // Don't wait for image load events - proceed immediately
        setTimeout(() => {
          clearTimeout(loadingTimeout);
          onSlideContentReady();
        }, 200); // Short delay to allow DOM updates
      } else {
        logDebug("[WebApp] No background image, using blank slide");
        slideBackground.src = '';
        clearTimeout(loadingTimeout);
        setTimeout(onSlideContentReady, 50);
      }
    }

    // Modified onSlideContentReady function to add error handling
    function onSlideContentReady() {
      try {
        logDebug("[WebApp] Preparing slide content...");
        adjustSlideSize(); // Calculate and apply slide dimensions
        renderOverlays(); // Render interactive overlays based on new size
        
        // Now restore visibility states based on our tracked hidden elements
        if (permanentlyHiddenElementsPerSlide[currentSlideIndex]) {
          const hiddenElements = permanentlyHiddenElementsPerSlide[currentSlideIndex];
          logDebug(`[WebApp] Found ${hiddenElements.size} elements to keep hidden on slide ${currentSlideIndex}`);
          
          hiddenElements.forEach(id => {
            if (overlayElementsMap.has(id)) {
              const overlay = overlayElementsMap.get(id);
              overlay.style.opacity = '0';
              overlay.style.pointerEvents = 'none';
              logDebug(`[WebApp] Restored hidden state for element ${id}`);
            }
          });
        } else {
          logDebug(`[WebApp] No hidden elements to restore for slide ${currentSlideIndex}`);
        }
        
        // Update navigation sequence to reflect visible elements
        buildNavigationSequence();
        
        hideLoading(); // Hide loading indicator
        logDebug("[WebApp] Slide ready!");
      } catch (err) {
      
      // Calculate dimensions that preserve aspect ratio and fit in container
      if (containerWidth / slideAspectRatio <= containerHeight) {
        // Width is the limiting factor
        targetWidth = containerWidth;
        targetHeight = targetWidth / slideAspectRatio;
      } else {
        // Height is the limiting factor
        targetHeight = containerHeight;
        targetWidth = targetHeight * slideAspectRatio;
      }
      
      // Apply calculated dimensions to slide
      slideElement.style.width = `${targetWidth}px`;
      slideElement.style.height = `${targetHeight}px`;
      
      // Store scale factors for element positioning
      const scaleX = targetWidth / slideWidthOrig;
      const scaleY = targetHeight / slideHeightOrig;
      
      // Store scale factors as data attributes
      slideElement.dataset.scaleX = scaleX;
      slideElement.dataset.scaleY = scaleY;
      slideElement.dataset.origWidth = slideWidthOrig;
      slideElement.dataset.origHeight = slideHeightOrig;
      
      logDebug(`[WebApp] Adjusted slide size: ${targetWidth.toFixed(1)}x${targetHeight.toFixed(1)}, Scale: ${scaleX.toFixed(4)}x${scaleY.toFixed(4)}`);
    }

    function updateSlideNavControls() { /* ... unchanged ... */
        slideIndicator.textContent = `Slide ${currentSlideIndex + 1} of ${totalSlides}`;
        prevSlideBtn.disabled = currentSlideIndex === 0;
        nextSlideBtn.disabled = currentSlideIndex >= totalSlides - 1;
    }

    // ---------- Overlay Rendering (UPDATED) ----------

    // Helper to convert HEX and opacity (0-100) to RGBA CSS string
    function hexToRgba(hex, opacityPercent) {
        // Added default hex color if input is invalid
        if (!hex || typeof hex !== 'string' || !/^#([0-9A-F]{3}){1,2}$/i.test(hex)) {
            hex = '#000000'; // Default to black if invalid hex
            console.warn(`[WebApp] Invalid hex color received ('${hex}'), defaulting to black.`);
        }
        hex = hex.replace('#', '');
        let r, g, b;

        try { // Add try-catch for safety during parsing
            if (hex.length === 3) {
                r = parseInt(hex[0] + hex[0], 16);
                g = parseInt(hex[1] + hex[1], 16);
                b = parseInt(hex[2] + hex[2], 16);
            } else { // Assume 6 length after regex check
                r = parseInt(hex.substring(0, 2), 16);
                g = parseInt(hex.substring(2, 4), 16);
                b = parseInt(hex.substring(4, 6), 16);
            }
        } catch (e) {
            console.error("Error parsing hex color:", hex, e);
            r = g = b = 0; // Default to black on error
        }

        // Clamp opacityPercent between 0 and 100, default to 0 if invalid, then convert to 0-1 alpha
        const numOpacity = parseFloat(opacityPercent);
        // Default to 15 if NaN or undefined, otherwise clamp
        const clampedOpacity = (isNaN(numOpacity) || typeof opacityPercent === 'undefined') ? 15 : Math.max(0, Math.min(100, numOpacity));
        const alpha = clampedOpacity / 100;

        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Main function to apply styles (custom or global)
    function applyOverlayStyle(overlay, element) {
      // Default opacity from global settings (which is now 0%)
      let opacityValue = overlayOpacity / 100;
      
      try {
        // Check if the element has custom opacity settings
        if (element && element.interaction) {
          if (element.interaction.useCustomOpacity && 
              typeof element.interaction.customOpacity === 'number') {
            // Use element-specific opacity
            opacityValue = element.interaction.customOpacity / 100;
            logDebug(`[WebApp] Using custom opacity: ${element.interaction.customOpacity}% for element ${element.id}`);
          }
          
          // Check if the element has custom overlay style
          if (element.interaction.overlayStyle) {
            const customStyle = element.interaction.overlayStyle;
            
            // If custom style includes opacity setting, use that
            if (typeof customStyle.opacity === 'number') {
              opacityValue = customStyle.opacity / 100;
              logDebug(`[WebApp] Using overlayStyle.opacity: ${customStyle.opacity}% for element ${element.id}`);
            }
            
            // Special handling for zero opacity
            if (opacityValue <= 0.01) {
              // Make completely invisible but keep interactive
              overlay.style.backgroundColor = 'rgba(0, 0, 0, 0)';
              overlay.style.border = 'none';
              overlay.style.boxShadow = 'none';
              logDebug(`[WebApp] Applied zero opacity (invisible but interactive) for element ${element.id}`);
              return; // Skip further styling
            }
            
            // Apply custom color if specified
            if (customStyle.color) {
              // Get the RGB color components
              let r = 229, g = 57, b = 53; // Default red
              
              try {
                // Try to parse color from hex
                if (customStyle.color.startsWith('#')) {
                  const hex = customStyle.color.substring(1);
                  if (hex.length === 3) {
                    r = parseInt(hex[0] + hex[0], 16);
                    g = parseInt(hex[1] + hex[1], 16);
                    b = parseInt(hex[2] + hex[2], 16);
                  } else if (hex.length === 6) {
                    r = parseInt(hex.substring(0, 2), 16);
                    g = parseInt(hex.substring(2, 4), 16);
                    b = parseInt(hex.substring(4, 6), 16);
                  }
                }
              } catch (colorErr) {
                console.error("[WebApp] Error parsing custom color:", colorErr);
              }
              
              // Apply the color with calculated opacity
              overlay.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacityValue})`;
              logDebug(`[WebApp] Applied custom color: rgba(${r}, ${g}, ${b}, ${opacityValue})`);
            } else {
              // No custom color, use default red with calculated opacity
              overlay.style.backgroundColor = `rgba(229, 57, 53, ${opacityValue})`;
            }
            
            // Apply other custom style properties if needed
            if (customStyle.shape === 'roundedRectangle') {
              overlay.style.borderRadius = '8px';
            } else if (customStyle.shape === 'oval') {
              overlay.style.borderRadius = '50%';
            }
            
            // Apply custom outline
            if (customStyle.outlineEnabled) {
              const outlineColor = customStyle.outlineColor || '#e53935';
              const outlineWidth = customStyle.outlineWidth || 1;
              const outlineStyle = customStyle.outlineStyle || 'dashed';
              overlay.style.border = `${outlineWidth}px ${outlineStyle} ${outlineColor}`;
            } else {
              overlay.style.border = 'none';
            }
            
            return; // Skip default styling
          }
        }
      } catch (err) {
        console.error("[WebApp] Error applying custom style:", err);
        // Fall back to default styling below
      }
      
      // Special handling for zero opacity in default styling
      if (opacityValue <= 0.01) {
        // Make completely invisible but keep interactive
        overlay.style.backgroundColor = 'rgba(0, 0, 0, 0)';
        overlay.style.border = 'none';
        overlay.style.boxShadow = 'none';
        logDebug(`[WebApp] Applied zero opacity (invisible but interactive) with default styling`);
        return; // Skip further styling
      }
      
      // Default styling if no custom style or on error
      overlay.style.backgroundColor = `rgba(229, 57, 53, ${opacityValue})`;
      
      // Apply default border/outline
      if (overlayShadow) {
        overlay.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.3)';
        overlay.style.border = '1px dashed rgba(229, 57, 53, 0.5)';
      } else {
        overlay.style.border = '1px dashed rgba(229, 57, 53, 0.5)';
        overlay.style.boxShadow = 'none';
      }
    }

    function addOverlayText(overlay, text) {
        if (!text || !text.trim()) return;

        const textElement = document.createElement('div');
        textElement.className = 'overlay-text';
        textElement.textContent = text;
        
        // Find the style settings - either from element's custom style or global defaults
        let textColor = '#ffffff';
        let textSize = 14;
        let useBackground = false; // New setting for background
        
        try {
            // First check for element-specific data
            const elementId = overlay.dataset.elementId;
            const elementData = currentSlideElementsData.find(el => el.id === elementId);
            
            if (elementData && elementData.interaction && elementData.interaction.overlayStyle) {
                // Use element's custom style if available
                textColor = elementData.interaction.overlayStyle.textColor || globalOverlayDefaults.textColor;
                textSize = elementData.interaction.overlayStyle.textSize || globalOverlayDefaults.textSize;
                useBackground = elementData.interaction.overlayStyle.textBackground || false;
            } else {
                // Fall back to global defaults
                textColor = globalOverlayDefaults.textColor;
                textSize = globalOverlayDefaults.textSize;
                useBackground = globalOverlayDefaults.textBackground || false;
            }
        } catch (err) {
            console.error("[WebApp] Error applying text styles:", err);
            // Use fallback values already set
        }

        // Apply the styles directly
        textElement.style.color = textColor;
        textElement.style.fontSize = `${textSize}px`;
        
        // Only add background if configured
        if (useBackground) {
            textElement.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        } else {
            textElement.style.textShadow = '1px 1px 2px rgba(0, 0, 0, 0.8)';
        }
        
        overlay.appendChild(textElement);
        overlay.classList.add('has-overlay-text');
        logDebug(`[WebApp] Added overlay text "${text}" with color ${textColor}, size ${textSize}px to element ${overlay.dataset.elementId}`);
    }

    /**
     * Renders all interactive overlay elements onto the current slide.
     * Updated to handle sequential appearance behavior.
     */
    function renderOverlays() {
        logDebug(`[WebApp] [renderOverlays] Start - Rendering overlays for ${interactiveElements.length} interactive elements on slide ${currentSlideIndex}`);

        // Force-clear any previous overlays
        const existingOverlays = slideElement.querySelectorAll('.overlay');
        logDebug(`[WebApp] [renderOverlays] Found ${existingOverlays.length} existing overlays to remove.`);
        existingOverlays.forEach(overlay => {
            if (overlay.parentNode) {
                overlay.parentNode.removeChild(overlay);
            }
        });
        overlayElementsMap.clear();
        logDebug(`[WebApp] [renderOverlays] Cleared existing overlays and map.`);

        // Reset appearance tracking
        pendingAppearanceElements = new Map(); // Map<elementId, {data, behavior, dependsOn}>
        visibleElementIds = new Set(); // Track which elements are currently visible

        if (!currentSlide || !currentSlideElementsData) {
            logDebug('[WebApp] [renderOverlays] No current slide data, skipping overlay rendering.');
            return;
        }

        // Re-filter interactive elements to be safe
        interactiveElements = currentSlideElementsData.filter(el => {
            const hasInteraction = el.interaction && el.interaction.type && el.interaction.type !== 'none';
            const hasAnimation = el.animation && el.animation.type && el.animation.type !== 'none';
            const hasOverlayStyle = el.interaction && el.interaction.overlayStyle && Object.keys(el.interaction.overlayStyle).length > 0;
            return hasInteraction || hasAnimation || hasOverlayStyle;
        });
        logDebug(`[WebApp] [renderOverlays] Re-filtered interactive elements count: ${interactiveElements.length}`);

        if (interactiveElements.length === 0) {
            logDebug('[WebApp] [renderOverlays] No interactive elements to render.');
            return;
        }

        // Get the set of hidden elements for the CURRENT slide index
        const currentHiddenSet = permanentlyHiddenElementsPerSlide[currentSlideIndex] || new Set();
        logDebug(`[WebApp] [renderOverlays] Checking against hidden set for slide ${currentSlideIndex}. Set contains ${currentHiddenSet.size} elements:`, Array.from(currentHiddenSet));

        // First pass: determine which elements should be visible immediately and which should be deferred
        interactiveElements.forEach((element) => {
            // Skip if element is marked as permanently hidden
            if (currentHiddenSet.has(element.id)) {
                logDebug(`[WebApp] [renderOverlays] SKIPPING render (permanently hidden): ${element.id}`);
                return;
            }

            // Skip elements targeted by 'revealElement' that shouldn not be visible initially
            if (isTargetOfReveal(element.id)) {
                logDebug(`[WebApp] [renderOverlays] SKIPPING initial render (reveal target): ${element.id}`);
                return;
            }

            // Check appearance behavior
            const interaction = element.interaction || {};
            const appearanceBehavior = interaction.appearanceBehavior || 'withPresentation';
            
            if (appearanceBehavior === 'withPresentation') {
                // Show immediately with the presentation
                renderElement(element);
                visibleElementIds.add(element.id);
                logDebug(`[WebApp] [renderOverlays] Rendered element with presentation: ${element.id}`);
            } else {
                // Store for later appearance
                pendingAppearanceElements.set(element.id, {
                    data: element,
                    behavior: appearanceBehavior,
                    dependsOn: interaction.appearAfterElementId || null
                });
                logDebug(`[WebApp] [renderOverlays] Element ${element.id} will appear ${appearanceBehavior} (depends on: ${interaction.appearAfterElementId || 'none'})`);
            }
        });

        // After rendering initial elements, check for any that should appear with them
        checkPendingAppearances();
        
        // Build the navigation sequence once all initially visible elements are rendered
        buildNavigationSequence();

        logDebug(`[WebApp] [renderOverlays] Finished rendering. Visible: ${visibleElementIds.size}, Pending: ${pendingAppearanceElements.size}`);
    }

    /**
     * Renders a single element on the slide.
     * @param {Object} element - The element data to render
     * @returns {HTMLElement|null} - The created overlay element or null if failed
     */
    function renderElement(element) {
        try {
            // *** Check for DIRECT position properties ***
            if (!element || typeof element.top !== 'number' || typeof element.left !== 'number' ||
                typeof element.width !== 'number' || typeof element.height !== 'number') {
                logError(`[WebApp] [renderElement] Invalid element data received, missing direct position properties: ${JSON.stringify(element)}`);
                return null; // Skip rendering this element
            }
            // *** END CHECK ***

            // Get the precise scaling factors
            const scaleX = parseFloat(slideElement.dataset.scaleX) || 1;
            const scaleY = parseFloat(slideElement.dataset.scaleY) || 1;
            
            // Get original slide dimensions for reference
            const slideWidthOrig = parseFloat(slideElement.dataset.origWidth) || 960;
            const slideHeightOrig = parseFloat(slideElement.dataset.origHeight) || 540;

            // Calculate position/size with precise scaling
            // Position is relative to slide origin (0,0)
            const left = Math.round(element.left * scaleX * 100) / 100;
            const top = Math.round(element.top * scaleY * 100) / 100;
            // Ensure minimum dimensions after scaling
            const width = Math.round(Math.max(element.width * scaleX, 10) * 100) / 100;
            const height = Math.round(Math.max(element.height * scaleY, 10) * 100) / 100;

            // *** ADDED DEBUG LOGGING START ***
            logDebug(`[WebApp] [renderElement ${element.id}] Scales: x=${scaleX.toFixed(4)}, y=${scaleY.toFixed(4)}`);
            logDebug(`[WebApp] [renderElement ${element.id}] Original Slide Size: ${slideWidthOrig}x${slideHeightOrig}`);
            logDebug(`[WebApp] [renderElement ${element.id}] Original Element Pos: T=${element.top}, L=${element.left}, W=${element.width}, H=${element.height}`);
            logDebug(`[WebApp] [renderElement ${element.id}] Calculated Style: T=${top.toFixed(2)}px, L=${left.toFixed(2)}px, W=${width.toFixed(2)}px, H=${height.toFixed(2)}px`);
            // *** ADDED DEBUG LOGGING END ***

            const overlay = document.createElement('div');
            overlay.className = 'overlay';
            overlay.dataset.elementId = element.id;
            
            // Apply the calculated position and size
            overlay.style.left = `${left}px`;
            overlay.style.top = `${top}px`;
            overlay.style.width = `${width}px`;
            overlay.style.height = `${height}px`;

            // Apply overlay styles based on element configuration
            applyOverlayStyle(overlay, element);

            // Add text to overlay if configured
            if (element.interaction && element.interaction.showOverlayText && element.interaction.overlayText) {
                addOverlayText(overlay, element.interaction.overlayText);
            }

            // Add hover text (displayed as tooltip)
            if (element.interaction?.overlayStyle?.hoverText || globalOverlayDefaults.hoverText) {
                const hoverText = element.interaction?.overlayStyle?.hoverText || globalOverlayDefaults.hoverText;
                overlay.dataset.hoverText = hoverText;
            }

            // Set tooltip for debugging
            let tooltipParts = [`ID: ${element.id}`];
            if (element.interaction?.type && element.interaction.type !== 'none') tooltipParts.push(`I: ${element.interaction.type}`);
            if (element.interaction?.overlayStyle) tooltipParts.push(`[Style]`);
            if (element.animation?.type && element.animation.type !== 'none') tooltipParts.push(`A: ${element.animation.type}`);
            overlay.title = tooltipParts.join(' | ');

            // Add event listeners
            overlay.addEventListener('click', () => handleOverlayClick(element, element.id));
            overlay.addEventListener('mouseenter', () => overlay.classList.add('is-hovering'));
            overlay.addEventListener('mouseleave', () => overlay.classList.remove('is-hovering'));

            // Apply animation if configured
            if (element.animation && element.animation.type && element.animation.type !== 'none') {
                applyAnimation(overlay, element.animation);
            }

            // Add overlay to the slide and tracking Map
            slideElement.appendChild(overlay);
            overlayElementsMap.set(element.id, overlay);
            logDebug(`[WebApp] [renderElement] Successfully rendered overlay for ${element.id}`);

            return overlay;
        } catch (err) {
            // Use logError which includes console.error
            logError(`[WebApp] [renderElement] Error rendering element ${element?.id || 'unknown'}: ${err.message}`, err);
            return null;
        }
    }

    function isTargetOfReveal(elementId) { /* ... unchanged ... */
        if (!currentSlide || !currentSlideElementsData) return false;
        return currentSlideElementsData.some(el =>
            el.interaction &&
            el.interaction.type === 'revealElement' &&
            el.interaction.targetElementId === elementId
        );
    }

    function applyAnimation(overlay, animation) {
        const animationClass = getAnimationClass(animation.type);
        if (!animationClass) {
            logDebug(`[WebApp] Unknown animation type: ${animation.type}`);
            return;
        }
        
        let speedClass = '';
        // Set speed/intensity classes
        if (animation.type === 'pulse' && animation.pulseSpeed) {
            speedClass = animation.pulseSpeed;
        } else if (animation.type === 'wiggle' && animation.wiggleIntensity) {
            speedClass = animation.wiggleIntensity;
        } else if (animation.type === 'float' && animation.floatSpeed) {
            speedClass = animation.floatSpeed;
        }
        
        const trigger = animation.trigger || 'automatic';
        logDebug(`[WebApp] Applying animation: ${animation.type} (${trigger}) to ${overlay.dataset.elementId} with speed/intensity: ${speedClass || 'default'}`);
        
        // For debugging, add a data attribute to confirm animation is applied
        overlay.dataset.animationType = animation.type;
        overlay.dataset.animationTrigger = trigger;
        
        switch (trigger) {
            case 'automatic':
                overlay.classList.add(animationClass);
                if (speedClass) overlay.classList.add(speedClass);
                break;
            case 'onHover':
                overlay.addEventListener('mouseenter', () => {
                    overlay.classList.add(animationClass);
                    if (speedClass) overlay.classList.add(speedClass);
                    logDebug(`[WebApp] Hover animation started: ${animationClass}`);
                });
                overlay.addEventListener('mouseleave', () => {
                    overlay.classList.remove(animationClass);
                    if (speedClass) overlay.classList.remove(speedClass);
                    logDebug(`[WebApp] Hover animation stopped: ${animationClass}`);
                });
                break;
            case 'onClick':
                overlay.dataset.animationClass = animationClass;
                if (speedClass) overlay.dataset.speedClass = speedClass;
                break;
        }
        
        // Log confirmation that animation was applied
        if (trigger === 'automatic') {
            logDebug(`[WebApp] Automatic animation ${animationClass} applied to element ${overlay.dataset.elementId}`);
        }
    }

    /**
     * Checks for elements that should appear based on currently visible elements.
     * Handles cascading appearances where one element triggers others.
     */
    function checkPendingAppearances() {
        let newlyVisible = false;
        
        // First check elements that should appear WITH other elements
        pendingAppearanceElements.forEach((info, elementId) => {
            if (info.behavior === 'withPrevious' && info.dependsOn && visibleElementIds.has(info.dependsOn)) {
                // The element it depends on is visible, so this one should also be visible
                logDebug(`[WebApp] [checkPendingAppearances] Element ${elementId} should appear with ${info.dependsOn}`);
                
                if (renderElement(info.data)) {
                    visibleElementIds.add(elementId);
                    pendingAppearanceElements.delete(elementId);
                    newlyVisible = true;
                    logDebug(`[WebApp] [checkPendingAppearances] Rendered element ${elementId} with ${info.dependsOn}`);
                }
            }
        });
        
        // If any new elements became visible, recursively check again
        // This handles cascading dependencies: A → B → C
        if (newlyVisible) {
            logDebug(`[WebApp] [checkPendingAppearances] New elements became visible, checking again`);
            checkPendingAppearances();
        }
    }

    function clearOverlays() { /* ... unchanged ... */
      overlayElementsMap.forEach(overlay => {
        if (overlay.parentNode) {
          overlay.parentNode.removeChild(overlay);
        }
      });
      overlayElementsMap.clear();
      logDebug('[WebApp] Cleared overlays');
    }

    function getAnimationClass(type) {
        switch (type) {
            case 'pulse': return 'animate-pulse';
            case 'wiggle': return 'animate-wiggle';
            case 'float': return 'animate-float';
            case 'bounce': return 'animate-bounce';
            case 'shake': return 'animate-shake';
            case 'flash': return 'animate-flash';
            case 'growShrink': return 'animate-growShrink';
            default: return null;
        }
    }

    /**
     * Handles click events on overlay elements, managing interactions, animations, and sequential appearances.
     * @param {Object} element - The element data object
     * @param {string} clickedElementId - The ID of the clicked element
     */
    function handleOverlayClick(element, clickedElementId) {
        // Debug logging
        logDebug(`[WebApp] Click handler triggered for: ${clickedElementId || 'unknown'}`, element);
        
        // Use the passed elementId or fall back to the element's id property
        const elementId = clickedElementId || element?.id;
        
        if (!elementId) {
            console.error("[WebApp] No element ID available in click handler:", {element, clickedElementId});
            return;
        }
        
        // Find the most up-to-date element data
        const currentElementData = currentSlideElementsData.find(el => el.id === elementId);
        
        if (!currentElementData) {
            console.error(`[WebApp] Clicked element data not found: ${elementId}`);
            return;
        }

        logDebug(`[WebApp] Processing click for element: ${elementId}`);

        let interactionHandled = false;
        let interactionType = 'none'; // Keep track of the type handled

        // --- Handle Interactions First ---
        if (currentElementData.interaction && 
            currentElementData.interaction.type && 
            currentElementData.interaction.type !== 'none') {
            
          const interaction = currentElementData.interaction;
          const overlay = overlayElementsMap.get(elementId);
          interactionType = interaction.type; // Store the type

          switch (interaction.type) {
            case 'showText':
              if (interaction.text) {
                showTextModal(interaction.text, elementId);
                interactionHandled = true;
              } else {
                showError("Missing text for showText interaction");
              }
              break;
              
            case 'highlight':
              if (overlay) {
                logDebug(`[WebApp] Highlight interaction: ${elementId}`);
                overlay.style.transition = 'background-color 0.1s, box-shadow 0.1s, filter 0.1s';
                overlay.style.filter = 'brightness(1.2) contrast(1.1)';
                overlay.classList.add('highlighted-temporary');
                setTimeout(() => {
                  if(overlayElementsMap.has(elementId)) {
                    overlay.style.transition = '';
                    overlay.style.filter = '';
                    overlay.classList.remove('highlighted-temporary');
                    applyOverlayStyle(overlay, currentElementData);
                  }
                }, 800);
              }
              interactionHandled = true;
              break;
              
            case 'openUrl':
              if (interaction.url) {
                logDebug(`[WebApp] Open URL interaction: ${interaction.url}`);
                try {
                  window.open(interaction.url, '_blank');
                  interactionHandled = true;
                } catch (error) {
                  console.error(`[WebApp] Error opening URL: ${interaction.url}`, error);
                  showError(`Failed to open URL: ${interaction.url}`);
                }
              } else {
                showError("Missing URL for openUrl interaction");
              }
              break;
              
            case 'spotlight':
              logDebug(`[WebApp] Spotlight interaction: ${elementId}`);
              showSpotlight(elementId, interaction);
              interactionHandled = true;
              break;
              
            case 'goToSlide':
              if (interaction.targetSlide) {
                const targetIndex = parseInt(interaction.targetSlide, 10) - 1;
                logDebug(`[WebApp] Go to Slide interaction: Target ${interaction.targetSlide} (Index ${targetIndex})`);
                if (targetIndex >= 0 && targetIndex < totalSlides && targetIndex !== currentSlideIndex) {
                  loadSlide(targetIndex);
                } else if (targetIndex === currentSlideIndex) {
                  logDebug('[WebApp] Already on target slide.');
                } else {
                  showError(`Invalid target slide number: ${interaction.targetSlide}`);
                }
                interactionHandled = true;
              } else {
                showError("Missing target slide for goToSlide interaction");
              }
              break;
              
            case 'revealElement':
              if (interaction.targetElementId) {
                logDebug(`[WebApp] Reveal Element interaction: Target ${interaction.targetElementId}`);
                revealElement(interaction.targetElementId, elementId);
                interactionHandled = true;
              } else {
                showError("Missing target ID for revealElement");
              }
              break;
              
            case 'revealAndSpotlight':
              if (interaction.targetElementId) {
                const targetId = interaction.targetElementId;
                logDebug(`[WebApp] Reveal and Spotlight interaction: Target ${targetId}`);
                
                // Check if target exists in current slide data, including in _debug data
                const targetElementData = currentSlideElementsData.find(el => el.id === targetId);
                const allSlideElementIds = currentSlide._debug?.allSlideElementIds || [];
                
                // First check if the element exists in our data or in the complete list of IDs received from backend
                if (!targetElementData && !allSlideElementIds.includes(targetId)) {
                  // Log available IDs to help with debugging
                  const availableIds = currentSlideElementsData.map(el => el.id);
                  logDebug(`[WebApp] WARNING: Target ID not found in current slide data. Target: ${targetId}`);
                  logDebug(`[WebApp] Available element IDs: ${JSON.stringify(availableIds)}`);
                  logDebug(`[WebApp] All slide IDs from debug data: ${JSON.stringify(allSlideElementIds)}`);
                  showError(`Target element ID not found: ${targetId.substring(0,8)}... Check your ID and try again.`);
                  return;
                }
                
                // Even if we don't have the full element data, we can still reveal it if we know it exists on the slide
                logDebug(`[WebApp] Target element ID ${targetId} validation passed. Proceeding with reveal.`);
                revealElement(targetId, elementId, false);
                
                // Use a longer timeout and additional checks
                setTimeout(() => {
                  if (overlayElementsMap.has(targetId)) {
                    logDebug(`[WebApp] Triggering spotlight for revealed element: ${targetId}`);
                    showSpotlight(targetId, interaction);
                  } else {
                    logDebug(`[WebApp] Failed to spotlight element ${targetId} - element not in overlay map after reveal`);
                    // Try to diagnose the issue
                    if (permanentlyHiddenElementsPerSlide[currentSlideIndex]?.has(targetId)) {
                      logDebug(`[WebApp] Element ${targetId} is permanently hidden`);
                    }
                    showError(`Failed to spotlight target element. Please try again.`);
                  }
                }, 500); // Increased timeout for more reliability
                
                interactionHandled = true;
              } else {
                showError("Missing target ID for reveal and spotlight");
              }
              break;
              
            default:
              logDebug(`[WebApp] Unknown interaction type: ${interaction.type}`);
          }
        }

        // --- Handle Animation Triggered by Click ---
        if (!interactionHandled && currentElementData.animation && 
            currentElementData.animation.trigger === 'onClick') {
            
          const animation = currentElementData.animation;
          const overlay = overlayElementsMap.get(elementId);
          logDebug(`[WebApp] Click animation triggered: ${animation.type}`);

          if (overlay && animation.type && animation.type !== 'none') {
            const animationClass = overlay.dataset.animationClass || 
                                  getAnimationClass(animation.type);
            const speedClass = overlay.dataset.speedClass || '';

            if (animationClass) {
              overlay.classList.add(animationClass);
              if (speedClass) overlay.classList.add(speedClass);

              const duration = speedClass.includes('fast') ? 1000 : 
                              (speedClass.includes('slow') ? 3000 : 2000);
              logDebug(`[WebApp] Playing click animation ${animationClass} for ${duration}ms`);

              setTimeout(() => {
                if(overlayElementsMap.has(elementId)) {
                  overlay.classList.remove(animationClass);
                  if (speedClass) overlay.classList.remove(speedClass);
                  logDebug(`[WebApp] Click animation ${animationClass} finished.`);
                }
              }, duration);
            }
          }
        }
        
        // --- Handle Disappear On Click Functionality ---
        if (currentElementData.interaction && currentElementData.interaction.disappearOnClick) {
          logDebug(`[WebApp] Element has disappearOnClick enabled: ${elementId}`);
          
          setTimeout(() => {
            const overlay = overlayElementsMap.get(elementId);
            if (overlay && overlay.parentNode) {
              logDebug(`[WebApp] Starting disappear animation for: ${elementId}`);
              
              overlay.style.transition = 'opacity 0.5s ease-out';
              overlay.style.opacity = '0';
              overlay.style.pointerEvents = 'none';
              
              setTimeout(() => {
                if (overlay.parentNode) {
                  overlay.parentNode.removeChild(overlay);
                  logDebug(`[WebApp] Removed element from DOM: ${elementId}`);
                }
                
                overlayElementsMap.delete(elementId);
                
                // Add to the set of permanently hidden elements for this slide
                if (!permanentlyHiddenElementsPerSlide[currentSlideIndex]) {
                  permanentlyHiddenElementsPerSlide[currentSlideIndex] = new Set();
                }
                permanentlyHiddenElementsPerSlide[currentSlideIndex].add(elementId);
                
                // Remove from navigation sequence and rebuild it
                buildNavigationSequence();
                
                logDebug(`[WebApp] Added ${elementId} to hidden set for slide ${currentSlideIndex}`);
              }, 500);
            }
          }, 100);
        }
        
        // --- Handle Sequential Appearances ---
        // Check for elements that should appear after this one was clicked
        setTimeout(() => {
          let newlyVisible = false;
          
          pendingAppearanceElements.forEach((info, elementId) => {
            if (info.behavior === 'afterPrevious' && info.dependsOn === elementId) {
              logDebug(`[WebApp] Element ${elementId} should appear after clicking ${elementId}`);
              
              if (renderElement(info.data)) {
                visibleElementIds.add(elementId);
                pendingAppearanceElements.delete(elementId);
                newlyVisible = true;
                logDebug(`[WebApp] Rendered element ${elementId} after clicking ${elementId}`);
              }
            }
          });
          
          // If any new elements appeared, trigger another check for cascading appearances
          if (newlyVisible) {
            checkPendingAppearances();
            // Rebuild navigation sequence to include new elements
            buildNavigationSequence();
          }
        }, 500);
        
        // --- NEW: Update lastActiveElementId AFTER handling interaction ---
        lastActiveElementId = elementId;
        logDebug(`[WebApp] Updated lastActiveElementId to: ${lastActiveElementId}`);
        // --- End NEW ---

        // Update navigation sequence and buttons slightly later
        setTimeout(() => {
          buildNavigationSequence(); // Rebuild sequence after potential reveals/hides
          // If a modal or spotlight was opened by this click, force enable its buttons
          if (interactionType === 'showText' || interactionType === 'spotlight' || interactionType === 'revealAndSpotlight') {
            forceEnableNavigationButtons();
          }
          logDebug(`[WebApp] handleOverlayClick completed for ${elementId}, navigation updated`);
        }, 600); // Keep delay
    }


    function hasSpotlightCapability(element) {
      return element && 
             element.interaction && 
             element.interaction.type === 'spotlight' &&
             element.interaction.showText &&
             element.interaction.text;
    }

    /**
     * Builds a list of elements that can be navigated through spotlight
     */
    function buildSpotlightableElementsList() {
      // Reset the list
      spotlightableElements = [];
      
      // Get currently visible elements
      const currentlyVisibleElements = Array.from(overlayElementsMap.keys());
      
      // First try to find all interactive elements with spotlight interactions
      const elementsWithSpotlight = interactiveElements.filter(el => 
        currentlyVisibleElements.includes(el.id) &&
        hasSpotlightCapability(el)
      );
      
      // Log what we found
      logDebug(`[WebApp] Found ${elementsWithSpotlight.length} elements with spotlight capability`);
      
      // Check if there are enough elements to enable navigation
      if (elementsWithSpotlight.length > 1) {
        spotlightableElements = elementsWithSpotlight;
      } else {
        // If only one or no spotlight elements, disable navigation
        logDebug(`[WebApp] Not enough spotlight elements for navigation`);
      }
      
      // Return the number of elements found
      return spotlightableElements.length;
    }

    /**
     * Shows a spotlight effect with a true cutout that shows the underlying content.
     * Updated version with integration to navigation sequence.
     */
    function showSpotlight(elementId, interactionData) {
        // Always hide any existing spotlight first
        hideSpotlight();
        
        // Get the target element ID (either the specified target or the clicked element)
        const targetId = interactionData.spotlightTarget || elementId;
        
        logDebug(`[WebApp] Spotlight requested for ${elementId}, targeting: ${targetId}`);
        
        // Find the target overlay element
        const targetOverlay = overlayElementsMap.get(targetId);
        if (!targetOverlay) {
            logDebug(`[WebApp] Spotlight target not found: ${targetId}`);
            showError(`Spotlight target not found (ID: ${targetId.substring(0,8)}...)`);
            return;
        }
        
        // Ensure we have a navigation sequence
        if (navSequenceElements.length === 0) {
            buildNavigationSequence();
        }
        
        // Find the index of this element in the navigation sequence
        currentSpotlightElementIndex = navSequenceElements.findIndex(el => 
            el.id === elementId || // Either the triggering element
            (interactionData.spotlightTarget && el.id === interactionData.spotlightTarget) // Or its target
        );
        
        logDebug(`[WebApp] Current spotlight element index: ${currentSpotlightElementIndex} of ${navSequenceElements.length}`);
        
        // Get the target's position and dimensions
        const targetRect = targetOverlay.getBoundingClientRect();
        const slideRect = slideElement.getBoundingClientRect();
        
        // Calculate position relative to the viewport
        const viewportLeft = targetRect.left;
        const viewportTop = targetRect.top;
        const viewportWidth = targetRect.width;
        const viewportHeight = targetRect.height;
        
        // Create SVG with mask for the dimming overlay
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("id", "spotlightSVG");
        svg.setAttribute("width", "100%");
        svg.setAttribute("height", "100%");
        svg.style.position = "fixed";
        svg.style.top = "0";
        svg.style.left = "0";
        svg.style.zIndex = "90";
        svg.style.pointerEvents = "none"; // Allow clicks to pass through initially
        
        // Create the mask
        const mask = document.createElementNS(svgNS, "mask");
        mask.setAttribute("id", "spotlightMask");
        
        // Background rectangle (white = opaque, black = transparent)
        const bgRect = document.createElementNS(svgNS, "rect");
        bgRect.setAttribute("x", "0");
        bgRect.setAttribute("y", "0");
        bgRect.setAttribute("width", "100%");
        bgRect.setAttribute("height", "100%");
        bgRect.setAttribute("fill", "white"); // White = opaque part of mask
        
        // Cutout rectangle (black = transparent hole in the mask)
        const cutoutRect = document.createElementNS(svgNS, "rect");
        cutoutRect.setAttribute("x", viewportLeft);
        cutoutRect.setAttribute("y", viewportTop);
        cutoutRect.setAttribute("width", viewportWidth);
        cutoutRect.setAttribute("height", viewportHeight);
        cutoutRect.setAttribute("fill", "black"); // Black = transparent part of mask
        cutoutRect.setAttribute("rx", "3"); // Rounded corners
        cutoutRect.setAttribute("ry", "3"); // Rounded corners
        
        // Add the rectangles to the mask
        mask.appendChild(bgRect);
        mask.appendChild(cutoutRect);
        
        // Add mask to SVG
        svg.appendChild(mask);
        
        // Create the dimming rectangle that uses the mask
        const dimRect = document.createElementNS(svgNS, "rect");
        dimRect.setAttribute("x", "0");
        dimRect.setAttribute("y", "0");
        dimRect.setAttribute("width", "100%");
        dimRect.setAttribute("height", "100%");
        dimRect.setAttribute("fill", "rgba(0, 0, 0, 0.75)"); // Semi-transparent black
        dimRect.setAttribute("mask", "url(#spotlightMask)");
        svg.appendChild(dimRect);
        
        // Add the SVG to the document
        document.body.appendChild(svg);
        
        // Create a transparent overlay to capture clicks for dismissing the spotlight
        const clickCatcher = document.createElement('div');
        clickCatcher.id = 'spotlightClickCatcher';
        clickCatcher.style.position = 'fixed';
        clickCatcher.style.top = '0';
        clickCatcher.style.left = '0';
        clickCatcher.style.width = '100%';
        clickCatcher.style.height = '100%';
        clickCatcher.style.zIndex = '89'; // Below the SVG
        clickCatcher.style.cursor = 'pointer';
        
        // Add click handler to dismiss
        clickCatcher.addEventListener('click', hideSpotlight);
        
        // Add the click catcher to the document
        document.body.appendChild(clickCatcher);
        
        // Highlight the target with a glowing border
        targetOverlay.classList.add('spotlight-active');
        
        // Store references for cleanup
        window.currentSpotlight = {
            svg: svg,
            clickCatcher: clickCatcher,
            targetId: targetId,
            elementId: elementId, // Store the original element ID
            interactionData: interactionData // Store the interaction data
        };
        
        // Set global state
        isSpotlightActive = true;
        
        // Handle text display if configured
        if (interactionData.showText && interactionData.text) {
            showSpotlightText(interactionData.text, targetRect);
        }
        
        // Handle notes display if configured
        if (interactionData.showNotes && currentSlide.slideNotes) {
            showSpotlightNotes(currentSlide.slideNotes);
        }
        
        logDebug(`[WebApp] Spotlight activated for ${targetId}`);
        
        // After spotlight is shown, check if any pending elements should be shown
        setTimeout(() => {
            // Check if any elements are configured to appear after this one
            pendingAppearanceElements.forEach((info, elementId) => {
                if (info.behavior === 'afterPrevious' && info.dependsOn === targetId) {
                    // This element should appear after the spotlighted one
                    if (renderElement(info.data)) {
                        visibleElementIds.add(elementId);
                        pendingAppearanceElements.delete(elementId);
                        logDebug(`[WebApp] Showing element ${elementId} after spotlighting ${targetId}`);
                        
                        // Check for cascading appearances
                        checkPendingAppearances();
                    }
                }
            });
        }, 800); // Delay to allow spotlight effect to complete
      // Force rebuild navigation sequence
      setTimeout(() => {
          buildNavigationSequence();
          
          // Force enable navigation buttons
          setTimeout(forceEnableNavigationButtons, 100);
          
          logDebug(`[WebApp] Spotlight active, navigation sequence rebuilt with ${navSequenceElements.length} elements`);
      }, 200);
    }

    /**
     * Hides the spotlight effect and cleans up all related elements.
     */
    function hideSpotlight() {
        if (!isSpotlightActive && !window.currentSpotlight) {
            return;
        }
        
        logDebug('[WebApp] Hiding spotlight');
        
        // Remove SVG and click catcher
        if (window.currentSpotlight) {
            if (window.currentSpotlight.svg) {
                document.body.removeChild(window.currentSpotlight.svg);
            }
            
            if (window.currentSpotlight.clickCatcher) {
                document.body.removeChild(window.currentSpotlight.clickCatcher);
            }
            
            // Remove highlight from target element
            if (window.currentSpotlight.targetId) {
                const targetOverlay = overlayElementsMap.get(window.currentSpotlight.targetId);
                if (targetOverlay) {
                    targetOverlay.classList.remove('spotlight-active');
                }
            }
            
            // Clean up text/notes
            hideSpotlightText();
            hideSpotlightNotes();
            
            // Clean up the reference
            window.currentSpotlight = null;
        }
        
        // Reset state
        isSpotlightActive = false;
        currentSpotlightElementIndex = -1;
    }

    /**
     * Shows text in a bubble next to the spotlight target.
     * Fixed version that ensures navigation buttons are always available.
     */
    function showSpotlightText(text, targetRect) {
        // Create text bubble container
        const textBubble = document.createElement('div');
        textBubble.id = 'spotlightTextBubble';
        textBubble.style.position = 'fixed';
        textBubble.style.maxWidth = '300px';
        textBubble.style.padding = '15px';
        textBubble.style.backgroundColor = 'white';
        textBubble.style.color = '#333';
        textBubble.style.borderRadius = '8px';
        textBubble.style.boxShadow = '0 4px 15px rgba(0,0,0,0.3)';
        textBubble.style.zIndex = '95'; // Above the dimming layer
        textBubble.style.fontSize = '14px';
        textBubble.style.lineHeight = '1.5';
        
        // Content container - format text with simple HTML
        const contentDiv = document.createElement('div');
        contentDiv.style.marginBottom = '10px';
        contentDiv.innerHTML = text.replace(/\n/g, '<br>');
        textBubble.appendChild(contentDiv);
        
        // If we have a navigation sequence, add navigation buttons
        if (navSequenceElements.length > 1) {
            const navDiv = document.createElement('div');
            navDiv.className = 'spotlight-nav-container';
            navDiv.style.display = 'flex';
            navDiv.style.justifyContent = 'space-between';
            navDiv.style.marginTop = '10px';
            
            // Previous button - always create regardless of position
            const prevButton = document.createElement('button');
            prevButton.id = 'spotlightPrevBtn';
            prevButton.className = 'spotlight-nav-button';
            prevButton.style.padding = '5px 10px';
            prevButton.style.border = '1px solid #ccc';
            prevButton.style.borderRadius = '4px';
            prevButton.style.backgroundColor = '#f8f8f8';
            prevButton.style.cursor = 'pointer';
            prevButton.style.fontSize = '13px';
            prevButton.innerHTML = '<span>←</span> Previous';
            
            // Next button - always create regardless of position
            const nextButton = document.createElement('button');
            nextButton.id = 'spotlightNextBtn';
            nextButton.className = 'spotlight-nav-button';
            nextButton.style.padding = '5px 10px';
            nextButton.style.border = '1px solid #ccc';
            nextButton.style.borderRadius = '4px';
            nextButton.style.backgroundColor = '#f8f8f8';
            nextButton.style.cursor = 'pointer';
            nextButton.style.fontSize = '13px';
            nextButton.innerHTML = 'Next <span>→</span>';
            
            // Add click handlers with try/catch and proper event prevention
            prevButton.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                try {
                    hideSpotlight();
                    navigateToPrevElement();
                } catch (err) {
                    console.error('[WebApp] Error in prev button handler:', err);
                    showError("Navigation error: " + (err.message || "Unknown error"));
                }
            });
            
            nextButton.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                try {
                    hideSpotlight();
                    navigateToNextElement();
                } catch (err) {
                    console.error('[WebApp] Error in next button handler:', err);
                    showError("Navigation error: " + (err.message || "Unknown error"));
                }
            });
            
            // Add buttons to the container
            navDiv.appendChild(prevButton);
            navDiv.appendChild(nextButton);
            textBubble.appendChild(navDiv);
        }
        
        // Add to body to calculate size
        document.body.appendChild(textBubble);
        
        // Position relative to target
        const bubbleRect = textBubble.getBoundingClientRect();
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        
        // Default to positioning below the target
        let top = targetRect.bottom + 15;
        let left = targetRect.left + (targetRect.width / 2) - (bubbleRect.width / 2);
        
        // Check if it would go off-screen and adjust accordingly
        if (top + bubbleRect.height > windowHeight) {
            // Position above if it would go off the bottom
            top = targetRect.top - bubbleRect.height - 15;
        }
        
        // Adjust horizontal position if needed
        if (left < 20) {
            left = 20; // Left margin
        } else if (left + bubbleRect.width > windowWidth - 20) {
            left = windowWidth - bubbleRect.width - 20; // Right margin
        }
        
        // Apply position
        textBubble.style.top = `${top}px`;
        textBubble.style.left = `${left}px`;
        
        // Add to window object for cleanup
        if (!window.currentSpotlight) {
            window.currentSpotlight = {};
        }
        window.currentSpotlight.textBubble = textBubble;
        
        logDebug(`[WebApp] Spotlight text shown with navigation. Current index: ${currentSpotlightElementIndex}, Total elements: ${navSequenceElements.length}`);
    }

    /**
     * Hides any spotlight text bubble.
     */
    function hideSpotlightText() {
        const bubble = document.getElementById('spotlightTextBubble');
        if (bubble) {
            document.body.removeChild(bubble);
        }
    }

    /**
     * Shows speaker notes when spotlight is active.
     */
    function showSpotlightNotes(notes) {
        // Create notes panel
        const notesPanel = document.createElement('div');
        notesPanel.id = 'spotlightNotesPanel';
        notesPanel.style.position = 'fixed';
        notesPanel.style.bottom = '20px';
        notesPanel.style.left = '50%';
        notesPanel.style.transform = 'translateX(-50%)';
        notesPanel.style.maxWidth = '80%';
        notesPanel.style.width = '600px';
        notesPanel.style.padding = '15px';
        notesPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        notesPanel.style.color = 'white';
        notesPanel.style.borderRadius = '8px';
        notesPanel.style.boxShadow = '0 4px 15px rgba(0,0,0,0.5)';
        notesPanel.style.zIndex = '95'; // Above the dimming layer
        notesPanel.style.fontSize = '14px';
        notesPanel.style.lineHeight = '1.5';
        
        // Add a title and the notes content
        notesPanel.innerHTML = `<div style="font-weight: bold; margin-bottom: 8px; color: #ccc;">Speaker Notes:</div>${notes.replace(/\n/g, '<br>')}`;
        
        // Add to document
        document.body.appendChild(notesPanel);
        
        // Add to window object for cleanup
        if (!window.currentSpotlight) {
            window.currentSpotlight = {};
        }
        window.currentSpotlight.notesPanel = notesPanel;
    }

    /**
     * Hides any spotlight notes panel.
     */
    function hideSpotlightNotes() {
        const panel = document.getElementById('spotlightNotesPanel');
        if (panel) {
            document.body.removeChild(panel);
        }
    }

    /**
     * Updates the next/prev button states for spotlight navigation
     */
    function updateSpotlightNavButtons() {
        const prevBtn = document.getElementById('spotlightPrevBtn');
        const nextBtn = document.getElementById('spotlightNextBtn');
        
        if (!prevBtn || !nextBtn) return;
        
        // Disable/enable based on current position in spotlightable elements
        prevBtn.disabled = currentSpotlightElementIndex <= 0;
        prevBtn.style.opacity = prevBtn.disabled ? '0.5' : '1';
        prevBtn.style.cursor = prevBtn.disabled ? 'not-allowed' : 'pointer';
        
        nextBtn.disabled = currentSpotlightElementIndex >= spotlightableElements.length - 1;
        nextBtn.style.opacity = nextBtn.disabled ? '0.5' : '1';
        nextBtn.style.cursor = nextBtn.disabled ? 'not-allowed' : 'pointer';
    }

    /**
     * Navigate to the previous element with spotlight capability
     */
    function navigateToPrevSpotlight() {
        if (currentSpotlightElementIndex <= 0 || !window.currentSpotlight) return;
        
        // Get the previous element
        const prevElement = spotlightableElements[currentSpotlightElementIndex - 1];
        if (!prevElement) return;
        
        logDebug(`[WebApp] Navigating to previous spotlight: ${prevElement.id}`);
        
        // Hide current spotlight
        hideSpotlight();
        
        // Show spotlight for the previous element
        if (prevElement.interaction?.type === 'spotlight') {
            showSpotlight(prevElement.id, prevElement.interaction);
        }
    }

    /**
     * Navigate to the next element with spotlight capability
     */
    function navigateToNextSpotlight() {
        if (currentSpotlightElementIndex >= spotlightableElements.length - 1 || !window.currentSpotlight) return;
        
        // Get the next element
        const nextElement = spotlightableElements[currentSpotlightElementIndex + 1];
        if (!nextElement) return;
        
        logDebug(`[WebApp] Navigating to next spotlight: ${nextElement.id}`);
        
        // Hide current spotlight
        hideSpotlight();
        
        // Show spotlight for the next element
        if (nextElement.interaction?.type === 'spotlight') {
            showSpotlight(nextElement.id, nextElement.interaction);
        }
    }

    // ---------- Modal Functions ----------
    /**
     * Updates the text modal to integrate with the navigation system.
     * This replaces the original showTextModal function.
     * 
     * @param {string} text - The text to display in the modal
     * @param {string} elementId - The ID of the element that triggered the modal
     */
    function showTextModal(text, elementId) {
        logDebug(`[WebApp] Showing text modal for element: ${elementId}`);
        
        // Sanitize text slightly before inserting
        modalTextDiv.innerHTML = text.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br>");
        textModal.classList.add('visible');

        // Ensure navigation buttons exist and have correct listeners
        const modalPrevBtn = document.getElementById('prevElementBtn'); // Assuming this ID is used in the modal
        const modalNextBtn = document.getElementById('nextElementBtn'); // Assuming this ID is used in the modal

        if (modalPrevBtn && modalNextBtn) {
            // Remove existing listeners to prevent duplicates
            modalPrevBtn.replaceWith(modalPrevBtn.cloneNode(true));
            modalNextBtn.replaceWith(modalNextBtn.cloneNode(true));
            // Get fresh references after cloning
            const freshPrevBtn = document.getElementById('prevElementBtn');
            const freshNextBtn = document.getElementById('nextElementBtn');

            freshPrevBtn.addEventListener('click', navigateToPrevElement);
            freshNextBtn.addEventListener('click', navigateToNextElement);

            // Update button states based on the sequence (using elementId passed to this function)
            buildNavigationSequence(); // Ensure sequence is up-to-date
            const currentIndex = navSequenceElements.findIndex(el => el.id === elementId);
            freshPrevBtn.disabled = currentIndex <= 0;
            freshNextBtn.disabled = currentIndex >= navSequenceElements.length - 1;

            // Show/hide based on sequence length
            const modalNavigation = document.querySelector('.modal-navigation');
            if (modalNavigation) {
                modalNavigation.style.display = navSequenceElements.length > 1 ? 'flex' : 'none';
            }
             // Force enable after a moment
             setTimeout(forceEnableNavigationButtons, 100);
        } else {
             logDebug("[WebApp] Modal navigation buttons not found in showTextModal");
        }

        highlightActiveModalElement(elementId);
        lastActiveElementId = elementId; // Update last active ID when modal is shown
        logDebug(`[WebApp] showTextModal set lastActiveElementId to: ${lastActiveElementId}`);
    }

    function hideTextModal() {
      // Also ensure spotlight is off when modal closes
      hideSpotlight();
      if (textModal.classList.contains('visible')) {
          logDebug('[WebApp] Hiding text modal');
          textModal.classList.remove('visible');
          resetModalElementHighlights();
          currentModalElementIndex = -1; // Reset index
      }
    }

    function highlightActiveModalElement(elementId) {
      resetModalElementHighlights(); // Reset all first
      const overlay = overlayElementsMap.get(elementId);
      if (overlay) {
        overlay.classList.add('highlighted-for-modal');
      }
    }

    function resetModalElementHighlights() {
      overlayElementsMap.forEach(overlay => {
        overlay.classList.remove('highlighted-for-modal');
      });
    }

    // Update modal Prev/Next buttons based on the list of navigable elements
    function updateModalNavigation(modalNavElements) {
      const numNavigable = modalNavElements.length;
      const hasMultiple = numNavigable > 1;

      // Show/hide buttons based on whether there's more than one item
      prevElementBtn.style.display = hasMultiple ? 'flex' : 'none';
      nextElementBtn.style.display = hasMultiple ? 'flex' : 'none';

      if (hasMultiple) {
        prevElementBtn.disabled = currentModalElementIndex <= 0;
        nextElementBtn.disabled = currentModalElementIndex >= numNavigable - 1;
         logDebug(`[WebApp] Modal nav updated: Index ${currentModalElementIndex}, Total ${numNavigable}`);
      }
    }

    // Navigate modal to the previous element that can show text
    function navigateToPrevModalElement() {
      // Recalculate navigable elements in case state changed (e.g., reveal)
      const currentlyVisibleElements = Array.from(overlayElementsMap.keys());
      const modalNavElements = interactiveElements.filter(el =>
         currentlyVisibleElements.includes(el.id) &&
         ( (el.interaction?.type === 'showText' && el.interaction.text) ||
           (el.animation?.trigger === 'onClick' && el.animation.showTextOnClick && el.animation.text)
         )
      );

      if (currentModalElementIndex > 0 && currentModalElementIndex < modalNavElements.length) {
        const prevNavElement = modalNavElements[currentModalElementIndex - 1];
        // Determine which text to show (interaction takes precedence)
        let textToShow = prevNavElement.interaction?.text || prevNavElement.animation?.text || 'Error: Text not found.';
        showTextModal(textToShow, prevNavElement.id); // Will update index and buttons
      } else {
         logDebug("[WebApp] Already at first modal element or index invalid.");
      }
    }

    // Navigate modal to the next element that can show text
    function navigateToNextModalElement() {
      // Recalculate navigable elements
       const currentlyVisibleElements = Array.from(overlayElementsMap.keys());
       const modalNavElements = interactiveElements.filter(el =>
          currentlyVisibleElements.includes(el.id) &&
          ( (el.interaction?.type === 'showText' && el.interaction.text) ||
            (el.animation?.trigger === 'onClick' && el.animation.showTextOnClick && el.animation.text)
          )
       );

      if (currentModalElementIndex >= 0 && currentModalElementIndex < modalNavElements.length - 1) {
        const nextNavElement = modalNavElements[currentModalElementIndex + 1];
        let textToShow = nextNavElement.interaction?.text || nextNavElement.animation?.text || 'Error: Text not found.';
        showTextModal(textToShow, nextNavElement.id);
      } else {
         logDebug("[WebApp] Already at last modal element or index invalid.");
      }
    }

    function revealElement(targetElementId, triggerElementId, keepTriggerVisible = false) {
        logDebug(`[WebApp] [revealElement] Start - Target: ${targetElementId}, Trigger: ${triggerElementId}, KeepTrigger: ${keepTriggerVisible}`);

        // --- Enhanced target ID validation and error handling ---
        if (!targetElementId) {
            showError("Missing target element ID for reveal operation");
            return;
        }

        // If the target is already in the overlay map, just ensure it's visible
        if (overlayElementsMap.has(targetElementId)) {
            logDebug(`[WebApp] [revealElement] Target element ${targetElementId} is already visible in overlayElementsMap.`);
            const existingOverlay = overlayElementsMap.get(targetElementId);
            if (existingOverlay) {
                existingOverlay.style.opacity = '1';
                existingOverlay.style.pointerEvents = 'auto';
            }
            
            // Hide the trigger element if configured
            if (!keepTriggerVisible && triggerElementId && overlayElementsMap.has(triggerElementId)) {
                 logDebug(`[WebApp] [revealElement] Hiding trigger element (already visible target): ${triggerElementId}`);
                 const triggerOverlay = overlayElementsMap.get(triggerElementId);
                 triggerOverlay.style.transition = 'opacity 0.3s ease-out';
                 triggerOverlay.style.opacity = '0';
                 triggerOverlay.style.pointerEvents = 'none';
                 if (!permanentlyHiddenElementsPerSlide[currentSlideIndex]) {
                     permanentlyHiddenElementsPerSlide[currentSlideIndex] = new Set();
                 }
                 permanentlyHiddenElementsPerSlide[currentSlideIndex].add(triggerElementId);
                 setTimeout(() => {
                     if (overlayElementsMap.has(triggerElementId)) {
                         overlayElementsMap.delete(triggerElementId);
                         buildNavigationSequence(); // Rebuild after hiding
                     }
                 }, 300);
            }
            return; // Element already visible
        }

        // Find target element data from our stored elements list
        let targetElementData = currentSlideElementsData.find(el => el.id === targetElementId);

        // If the element data isn't in our main array, check if the ID exists in the presentation metadata
        if (!targetElementData) {
            // Check the debug info for all element IDs that exist on this slide
            const allElementIds = currentSlide?._debug?.allSlideElementIds || [];
            
            if (allElementIds.includes(targetElementId)) {
                // ID is valid according to metadata, but we don't have full element data
                logDebug(`[WebApp] [revealElement] Target ID ${targetElementId} found in metadata but missing from element data`);
                
                // Create a minimal element data object since we know this ID is valid
                targetElementData = {
                    id: targetElementId,
                    // Set reasonable default position in the middle of the slide
                    left: (currentSlide.slideWidth || 960) / 2,
                    top: (currentSlide.slideHeight || 540) / 2,
                    width: 100, // Default width
                    height: 100, // Default height
                    type: 'shape', // Default type
                    interaction: {
                        type: 'none',
                        overlayStyle: {
                            color: '#e53935',
                            opacity: 15,
                            outlineEnabled: true,
                        }
                    }
                };
                
                // Add to our tracked elements
                currentSlideElementsData.push(targetElementData);
                logDebug(`[WebApp] [revealElement] Created fallback element data for ${targetElementId}`);
            } else {
                // The element ID is completely invalid for this slide
                logDebug(`[WebApp] [revealElement] ERROR: Target ID ${targetElementId} not found in any element data or metadata`);
                showError(`Cannot reveal element (ID: ${targetElementId.substring(0,8)}...). It does not exist on this slide according to server data.`);
                return;
            }
        }

        // Now that we have element data (either real or fallback), create the overlay
        try {
            const scaleX = parseFloat(slideElement.dataset.scaleX || '1');
            const scaleY = parseFloat(slideElement.dataset.scaleY || '1');
            
            // Apply precise positioning with proper rounding
            const left = Math.round(targetElementData.left * scaleX * 100) / 100;
            const top = Math.round(targetElementData.top * scaleY * 100) / 100;
            const width = Math.round(Math.max(targetElementData.width * scaleX, 10) * 100) / 100;
            const height = Math.round(Math.max(targetElementData.height * scaleY, 10) * 100) / 100;

            const overlay = document.createElement('div');
            overlay.className = 'overlay revealed'; // Start with 'revealed' class (opacity 0)
            overlay.dataset.elementId = targetElementData.id;
            overlay.style.left = `${left}px`;
            overlay.style.top = `${top}px`;
            overlay.style.width = `${width}px`;
            overlay.style.height = `${height}px`;

            applyOverlayStyle(overlay, targetElementData);
            logDebug(`[WebApp] [revealElement] Applied styles to revealed element ${targetElementId}`);

            // Add overlay text if configured
            if (targetElementData.interaction && targetElementData.interaction.showOverlayText && targetElementData.interaction.overlayText) {
                addOverlayText(overlay, targetElementData.interaction.overlayText);
            }

            // Add event handlers
            overlay.addEventListener('click', () => handleOverlayClick(targetElementData, targetElementId));
            overlay.addEventListener('mouseenter', () => overlay.classList.add('is-hovering'));
            overlay.addEventListener('mouseleave', () => overlay.classList.remove('is-hovering'));

            // Apply animation if configured
            if (targetElementData.animation && targetElementData.animation.type && targetElementData.animation.type !== 'none') {
                applyAnimation(overlay, targetElementData.animation);
            }

            // Add to slide and track in map
            slideElement.appendChild(overlay);
            overlayElementsMap.set(targetElementId, overlay);
            
            // Log confirmation and map state
            logDebug(`[WebApp] [revealElement] Element ${targetElementId} added to overlayElementsMap. Map now has ${overlayElementsMap.size} elements`);
            logDebug(`[WebApp] [revealElement] Current map keys: ${Array.from(overlayElementsMap.keys()).join(', ')}`);

            // Make sure the element is in interactiveElements list if it should be
            if (targetElementData.interaction?.type !== 'none' || targetElementData.animation?.type !== 'none') {
                if (!interactiveElements.some(el => el.id === targetElementId)) {
                    interactiveElements.push(targetElementData);
                    logDebug(`[WebApp] [revealElement] Added element to interactiveElements list: ${targetElementId}`);
                }
            }

            // Fade in the revealed element after a brief delay
            setTimeout(() => {
                if (overlayElementsMap.has(targetElementId)) {
                    const overlay = overlayElementsMap.get(targetElementId);
                    overlay.classList.remove('revealed');
                    overlay.style.opacity = '1';
                    logDebug(`[WebApp] [revealElement] Revealed element now visible: ${targetElementId}`);
                }
            }, 50);

            // Hide the trigger element if configured
            if (!keepTriggerVisible && triggerElementId && overlayElementsMap.has(triggerElementId)) {
                logDebug(`[WebApp] [revealElement] Hiding trigger element: ${triggerElementId}`);
                const triggerOverlay = overlayElementsMap.get(triggerElementId);
                triggerOverlay.style.transition = 'opacity 0.3s ease-out';
                triggerOverlay.style.opacity = '0';
                triggerOverlay.style.pointerEvents = 'none';
                
                if (!permanentlyHiddenElementsPerSlide[currentSlideIndex]) {
                    permanentlyHiddenElementsPerSlide[currentSlideIndex] = new Set();
                }
                permanentlyHiddenElementsPerSlide[currentSlideIndex].add(triggerElementId);
                logDebug(`[WebApp] [revealElement] Added trigger ${triggerElementId} to hidden set for slide ${currentSlideIndex}`);
                
                setTimeout(() => {
                    if (overlayElementsMap.has(triggerElementId)) {
                        const triggerElement = overlayElementsMap.get(triggerElementId);
                        if (triggerElement.parentNode) {
                            triggerElement.parentNode.removeChild(triggerElement);
                        }
                        overlayElementsMap.delete(triggerElementId);
                        logDebug(`[WebApp] [revealElement] Removed trigger from DOM and map: ${triggerElementId}`);
                    }
                }, 300);
            }

            // Update navigation sequence after reveal
            setTimeout(() => {
                buildNavigationSequence();
                logDebug(`[WebApp] [revealElement] Updated navigation sequence after reveal`);
            }, 200);

        } catch (err) {
            console.error(`[WebApp] [revealElement] Error creating revealed element ${targetElementId}:`, err);
            showError(`Navigation Error: Revealed element ${targetElementId.substring(0,8)}... not found.`);
        }
    }

    /**
     * Enhanced function to build the navigation sequence, ensuring all interactive elements
     * are included and properly ordered
     */
    function buildNavigationSequence() {
        // Reset the sequence array
        navSequenceElements = [];
        
        // Get the current slide data and elements
        if (!currentSlide || !currentSlideElementsData) {
            logDebug(`[WebApp] Cannot build navigation sequence - no current slide data`);
            return;
        }
        
        try {
            // Get currently visible elements
            const visibleElements = Array.from(overlayElementsMap.keys())
                .map(id => currentSlideElementsData.find(el => el.id === id))
                .filter(el => el !== undefined);
            
            // First check if the slide has a saved custom sequence
            if (currentSlide.hasCustomSequence && currentSlide.customSequence && 
                Array.isArray(currentSlide.customSequence) && currentSlide.customSequence.length > 0) {
                
                // Use the custom sequence to order the elements
                const orderedElements = [];
                const remainingElements = [...visibleElements]; // Copy to track what's left
                
                currentSlide.customSequence.forEach(id => {
                    const elementIndex = remainingElements.findIndex(el => el.id === id);
                    if (elementIndex !== -1) {
                        orderedElements.push(remainingElements[elementIndex]);
                        remainingElements.splice(elementIndex, 1); // Remove from remaining
                    }
                });
                
                // Add any visible elements not in the sequence at the end
                navSequenceElements = [...orderedElements, ...remainingElements];
                logDebug(`[WebApp] Using custom navigation sequence with ${navSequenceElements.length} elements`);
            } else {
                // No custom sequence - use natural order of elements on slide (based on current slide data)
                navSequenceElements = [...visibleElements];
                logDebug(`[WebApp] Using default navigation sequence with ${navSequenceElements.length} elements`);
            }
            
            // Update spotlightable elements list based on the sequence
            buildSpotlightableElementsList();
            
            logDebug(`[WebApp] Navigation sequence built with ${navSequenceElements.length} elements`);
        } catch (err) {
            console.error("[WebApp] Error building navigation sequence:", err);
            // Create a fallback navigation sequence using visible elements
            const visibleElements = Array.from(overlayElementsMap.keys())
                .map(id => currentSlideElementsData.find(el => el.id === id))
                .filter(el => el !== undefined);
            
            navSequenceElements = [...visibleElements];
            logDebug(`[WebApp] Using fallback navigation sequence with ${navSequenceElements.length} elements due to error`);
        }
    }

    /**
     * Updates to the navigation functions to ensure they work with all interaction types
     */
    function navigateToNextElement() {
        logDebug('[WebApp] navigateToNextElement called');
        
        // Force rebuild navigation sequence to ensure it's current
        buildNavigationSequence();
        
        if (navSequenceElements.length <= 0) {
            logDebug('[WebApp] No navigation sequence available.');
            return false;
        }
        
        // Determine current index based on active modal or spotlight or lastActiveElementId
        let currentIndex = -1;
        
        if (isSpotlightActive && window.currentSpotlight?.targetId) {
            // If spotlight is active, use its target as reference
            currentIndex = navSequenceElements.findIndex(el => el.id === window.currentSpotlight.targetId);
            logDebug(`[WebApp] Current index based on spotlight: ${currentIndex} (Target ID: ${window.currentSpotlight.targetId})`);
        } else if (textModal.classList.contains('visible') && currentModalElementIndex !== -1) {
            // If modal is active, use the modal index
            currentIndex = currentModalElementIndex;
            logDebug(`[WebApp] Current index based on modal: ${currentIndex}`);
        } else if (lastActiveElementId) {
            // Try to use the last active element if it's in the sequence
            currentIndex = navSequenceElements.findIndex(el => el.id === lastActiveElementId);
            logDebug(`[WebApp] Current index based on lastActiveElementId: ${currentIndex} (ID: ${lastActiveElementId})`);
        } else {
            // If nothing is active, assume we start from the beginning
            currentIndex = -1;
            logDebug('[WebApp] No active context found, starting navigation from beginning.');
        }
        
        // Get next index (with wrap-around)
        const nextIndex = (currentIndex >= navSequenceElements.length - 1 || currentIndex < 0) ? 
                          0 : currentIndex + 1;
        
        // Get the next element data
        const nextElement = navSequenceElements[nextIndex];
        if (!nextElement || !nextElement.id) {
            logDebug('[WebApp] Could not find valid next element data.');
            return false;
        }
        
        logDebug(`[WebApp] Navigating TO element: index=${nextIndex}, id=${nextElement.id}, type=${nextElement.interaction?.type}`);
        
        // Clean up current state BEFORE triggering the next
        hideSpotlight();
        hideTextModal();
        
        // Short delay to ensure clean state and DOM updates
        setTimeout(() => {
            logDebug(`[WebApp] Triggering interaction for next element: ${nextElement.id}`);
            const interactionType = nextElement.interaction?.type || 'none';
            
            // Update lastActiveElementId and indices
            lastActiveElementId = nextElement.id;
            currentModalElementIndex = nextIndex;
            currentSpotlightElementIndex = nextIndex;

            // Trigger the appropriate interaction for the next element based on its type
            switch (interactionType) {
                case 'spotlight':
                    showSpotlight(nextElement.id, nextElement.interaction);
                    break;
                case 'showText':
                    showTextModal(nextElement.interaction.text, nextElement.id);
                    break;
                case 'revealElement':
                    if (nextElement.interaction.targetElementId) {
                        revealElement(nextElement.interaction.targetElementId, nextElement.id);
                    }
                    break;
                case 'revealAndSpotlight':
                    if (nextElement.interaction.targetElementId) {
                        const targetElementId = nextElement.interaction.targetElementId;
                        logDebug(`[WebApp][NextNav] Handling revealAndSpotlight. Trigger: ${nextElement.id}, Target: ${targetElementId}`);

                        // Reveal the element first, but don't hide the trigger yet
                        revealElement(targetElementId, nextElement.id, true); // Keep trigger visible for now

                        // Delay spotlight and sequence rebuild until after reveal animation
                        setTimeout(() => {
                            logDebug(`[WebApp][NextNav] Post-reveal for ${targetElementId}. Checking visibility...`);
                            if (overlayElementsMap.has(targetElementId)) {
                                logDebug(`[WebApp][NextNav] Target ${targetElementId} is visible in map.`);
                                // Find the target element's data
                                const targetElementData = currentSlideElementsData.find(el => el.id === targetElementId);
                                if (targetElementData) {
                                    // *** CRITICAL: Update lastActiveElementId to the REVEALED target ***
                                    lastActiveElementId = targetElementId;
                                    logDebug(`[WebApp][NextNav] Updated lastActiveElementId to revealed target: ${targetElementId}`);

                                    // *** CRITICAL: Rebuild sequence AFTER updating lastActiveElementId ***
                                    buildNavigationSequence();
                                    logDebug(`[WebApp][NextNav] Navigation sequence rebuilt. Length: ${navSequenceElements.length}`);

                                    // Now show the spotlight on the revealed element
                                    showSpotlight(targetElementId, {
                                        ...nextElement.interaction,
                                        spotlightTarget: targetElementId // Ensure spotlight targets the revealed element
                                    });
                                    logDebug(`[WebApp][NextNav] Spotlight shown for ${targetElementId}`);

                                    // Force enable buttons again after spotlight
                                    setTimeout(forceEnableNavigationButtons, 150);

                                } else {
                                    logDebug(`[WebApp][NextNav] Warning: Could not find element data for ${targetElementId} after reveal`);
                                    // Fallback: Try to show spotlight anyway
                                    showSpotlight(targetElementId, nextElement.interaction);
                                }
                            } else {
                                logDebug(`[WebApp][NextNav] ERROR: Failed to find revealed element ${targetElementId} in overlayElementsMap after reveal timeout.`);
                                showError(`Navigation Error: Revealed element ${targetElementId.substring(0,8)}... not found.`);
                            }
                        }, 600); // Increased delay to ensure reveal animation completes
                    } else {
                        logDebug(`[WebApp][NextNav] revealAndSpotlight missing targetElementId`);
                        showError("Missing target element ID for reveal and spotlight");
                    }
                    break;
                case 'openUrl':
                case 'highlight':
                case 'goToSlide': 
                case 'none':
                default:
                    // Simulate a click on the element's overlay for other interaction types
                    handleOverlayClick(nextElement, nextElement.id);
                    break;
            }
            
            // Force enable buttons if needed for modal or spotlight navigation
            if (interactionType === 'showText' || interactionType === 'spotlight' || 
                interactionType === 'revealAndSpotlight') {
                setTimeout(forceEnableNavigationButtons, 150);
            }
        }, 150); // Delay to allow hide animations/cleanup
        
        return true;
    }

    /**
     * Navigates to the previous element in the defined sequence and triggers its interaction.
     */
    function navigateToPrevElement() {
        logDebug('[WebApp] navigateToPrevElement called');
        
        // Force rebuild navigation sequence
        buildNavigationSequence();
        
        if (navSequenceElements.length <= 0) {
            logDebug('[WebApp] No navigation sequence available.');
            return false;
        }
        
        // Determine current index
        let currentIndex = -1;
        if (isSpotlightActive && window.currentSpotlight?.targetId) {
            currentIndex = navSequenceElements.findIndex(el => el.id === window.currentSpotlight.targetId);
            logDebug(`[WebApp] Current index based on spotlight: ${currentIndex} (Target ID: ${window.currentSpotlight.targetId})`);
        } else if (textModal.classList.contains('visible') && currentModalElementIndex !== -1) {
            currentIndex = currentModalElementIndex;
            logDebug(`[WebApp] Current index based on modal: ${currentIndex}`);
        } else if (lastActiveElementId) {
            // Try to use the last active element if it's in the sequence
            currentIndex = navSequenceElements.findIndex(el => el.id === lastActiveElementId);
            logDebug(`[WebApp] Current index based on lastActiveElementId: ${currentIndex} (ID: ${lastActiveElementId})`);
        } else {
            // If nothing is active, assume we wrap around from the end
            currentIndex = navSequenceElements.length; // Will become length-1 after we subtract 1
            logDebug('[WebApp] No active context, starting navigation from end for previous.');
        }
        
        // Get previous index (with wrap-around)
        const prevIndex = (currentIndex <= 0) ? 
                          navSequenceElements.length - 1 : currentIndex - 1;
        
        // Get the previous element data
        const prevElement = navSequenceElements[prevIndex];
        if (!prevElement || !prevElement.id) {
            logDebug('[WebApp] Could not find valid previous element data.');
            return false;
        }
        
        logDebug(`[WebApp] Navigating TO previous element: index=${prevIndex}, id=${prevElement.id}, type=${prevElement.interaction?.type}`);
        
        // Clean up current state BEFORE triggering the previous
        hideSpotlight();
        hideTextModal();
        
        // Short delay
        setTimeout(() => {
            logDebug(`[WebApp] Triggering interaction for previous element: ${prevElement.id}`);
            const interactionType = prevElement.interaction?.type || 'none';

            // Update lastActiveElementId and indices
            lastActiveElementId = prevElement.id;
            currentModalElementIndex = prevIndex;
            currentSpotlightElementIndex = prevIndex;

            // Trigger the appropriate interaction
            switch (interactionType) {
                case 'spotlight':
                    showSpotlight(prevElement.id, prevElement.interaction);
                    break;
                case 'showText':
                    showTextModal(prevElement.interaction.text, prevElement.id);
                    break;
                case 'revealElement':
                    if (prevElement.interaction.targetElementId) {
                        revealElement(prevElement.interaction.targetElementId, prevElement.id);
                    }
                    break;
                case 'revealAndSpotlight':
                    if (prevElement.interaction.targetElementId) {
                        const targetId = prevElement.interaction.targetElementId;
                        logDebug(`[WebApp] Navigating to previous revealAndSpotlight: Target ${targetId}`);
                        
                        revealElement(targetId, prevElement.id, false);
                        
                        setTimeout(() => {
                            if (overlayElementsMap.has(targetId)) {
                                const targetData = currentSlideElementsData.find(el => el.id === targetId);
                                
                                if (targetData) {
                                    lastActiveElementId = targetId;
                                    buildNavigationSequence();
                                    
                                    showSpotlight(targetId, {
                                        ...prevElement.interaction,
                                        spotlightTarget: targetId
                                    });
                                } else {
                                    showSpotlight(targetId, prevElement.interaction);
                                }
                            }
                        }, 500);
                    }
                    break;
                case 'openUrl':
                case 'highlight':
                case 'goToSlide':
                case 'none':
                default:
                    // Simulate a click on the element's overlay
                    handleOverlayClick(prevElement, prevElement.id);
                    break;
            }
            
            // Force enable buttons if needed
            if (interactionType === 'showText' || interactionType === 'spotlight' || 
                interactionType === 'revealAndSpotlight') {
                setTimeout(forceEnableNavigationButtons, 150);
            }
        }, 150); // Delay
        
        return true;
    }

    /**
     * IMPORTANT: Function to force enable navigation buttons
     * Call this after any spotlight or modal is shown
     */
    function forceEnableNavigationButtons() {
        // Get all navigation buttons
        const spotlightPrevBtn = document.getElementById('spotlightPrevBtn');
        const spotlightNextBtn = document.getElementById('spotlightNextBtn');
        const modalPrevBtn = document.getElementById('prevElementBtn');
        const modalNextBtn = document.getElementById('nextElementBtn');
        
        // Log the initial button states for debugging
        logDebug(`[WebApp] forceEnableNavigationButtons - Initial states:
            Spotlight Prev: ${spotlightPrevBtn ? (spotlightPrevBtn.disabled ? 'Disabled' : 'Enabled') : 'Not found'}
            Spotlight Next: ${spotlightNextBtn ? (spotlightNextBtn.disabled ? 'Disabled' : 'Enabled') : 'Not found'}
            Modal Prev: ${modalPrevBtn ? (modalPrevBtn.disabled ? 'Disabled' : 'Enabled') : 'Not found'}
            Modal Next: ${modalNextBtn ? (modalNextBtn.disabled ? 'Disabled' : 'Enabled') : 'Not found'}`);
        
        // Force enable spotlight buttons if they exist
        if (spotlightPrevBtn) {
            spotlightPrevBtn.disabled = false;
            spotlightPrevBtn.style.opacity = '1';
            spotlightPrevBtn.style.cursor = 'pointer';
            // Re-attach event listener
            spotlightPrevBtn.onclick = navigateToPrevElement;
        }
        
        if (spotlightNextBtn) {
            spotlightNextBtn.disabled = false;
            spotlightNextBtn.style.opacity = '1';
            spotlightNextBtn.style.cursor = 'pointer';
            // Re-attach event listener
            spotlightNextBtn.onclick = navigateToNextElement;
        }
        
        // Force enable modal buttons if they exist
        if (modalPrevBtn) {
            modalPrevBtn.disabled = false;
            // Re-attach event listener
            modalPrevBtn.onclick = navigateToPrevElement;
        }
        
        if (modalNextBtn) {
            modalNextBtn.disabled = false;
            // Re-attach event listener
            modalNextBtn.onclick = navigateToNextElement;
        }
        
        logDebug('[WebApp] Navigation buttons force enabled');
    }

    // ---------- Loading and Error Handling ----------
    function showLoading(message) {
      loadingOverlay.querySelector('.loading-message').textContent = message || 'Loading...';
      loadingOverlay.style.display = 'flex';
      logDebug(`[WebApp] Showing loading: ${message}`);
    }
    function hideLoading() {
      loadingOverlay.style.display = 'none';
      logDebug(`[WebApp] Hiding loading`);
    }
    function showError(message) {
      const errorMessageText = String(message || "An unknown error occurred.");
      console.error(`[WebApp] Error: ${errorMessageText}`);
      errorElement.textContent = errorMessageText;
      errorElement.style.display = 'block';
      // Auto-hide after a delay
      setTimeout(() => { errorElement.style.display = 'none'; }, 5000);
    }
    function handleLoadError(error) {
      hideLoading();
      const errorMessage = (typeof error === 'object' && error !== null && error.message) ? error.message : String(error);
      showError(`Failed to load slide data: ${errorMessage}. Please check console logs or presentation access.`);
      console.error(`[WebApp] Full load error object: `, error); // Log full details
    }
    
    /**
     * Handles the escape key and closing modals/spotlights properly
     */
    function handleEscapeKey() {
      if (isSpotlightActive) {
        hideSpotlight();
        return true; // Handled
      }
      if (textModal.classList.contains('visible')) {
        hideTextModal();
        return true; // Handled
      }
      return false; // Not handled
    }

    /**
     * Handles keyboard navigation for the presentation
     * @param {string} key - The key that was pressed
     * @returns {boolean} True if the key was handled
     */
    function tryNavigateWithKeyboard(key) {
        // Handle modal or spotlight navigation first
        if (isSpotlightActive || textModal.classList.contains('visible')) {
            if (key === 'ArrowLeft') {
                return navigateToPrevElement();
            } else if (key === 'ArrowRight') {
                return navigateToNextElement();
            }
        } else {
            // Normal slide navigation
            if (key === 'ArrowLeft' && !prevSlideBtn.disabled) {
                loadSlide(currentSlideIndex - 1);
                return true;
            } else if (key === 'ArrowRight' && !nextSlideBtn.disabled) {
                loadSlide(currentSlideIndex + 1);
                return true;
            }
        }
        return false; // Not handled
    }

    // Keyboard event handler for navigation
    document.addEventListener('keydown', (e) => {
      // Handle Escape key for modals/spotlights
      if (e.key === 'Escape') {
        if (handleEscapeKey()) {
          e.preventDefault();
          return;
        }
      }
      
      // Handle arrow keys for navigation
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        if (tryNavigateWithKeyboard(e.key)) {
          e.preventDefault();
          return;
        }
      }
      
      // Handle space bar to dismiss spotlight (optional)
      if (e.key === ' ' && isSpotlightActive) {
        hideSpotlight();
        e.preventDefault();
        return;
      }
    });

    // Add this function to create and expose the missing element data when we only have IDs
    function createElementDataFromId(targetId) {
        logDebug(`[WebApp] Creating element data from ID: ${targetId}`);
        
        // First check if we already have this element in our data
        const existingData = currentSlideElementsData.find(el => el.id === targetId);
        if (existingData) return existingData;
        
        // Get the debug data that contains all slide elements
        const allSlideElementIds = currentSlide._debug?.allSlideElementIds || [];
        const elementTypes = currentSlide._debug?.elementTypes || {};
        
        // If this ID isn't in the list of all slide elements, we can't create data for it
        if (!allSlideElementIds.includes(targetId)) {
            logDebug(`[WebApp] ID ${targetId} not found in all slide elements list`);
            return null;
        }
        
        // Get the element type if available
        const elementType = elementTypes[targetId] || {type: 'unknown', hasDesc: 'no'};
        
        // Create a minimal element data object - we don't have position/dimensions
        // but we'll need to ask the server for these in a future request
        const elementData = {
            id: targetId,
            type: elementType.type,
            // Assume position in the center of the slide for now
            left: currentSlide.slideWidth / 2,
            top: currentSlide.slideHeight / 2,
            width: 100,
            height: 100,
            // Create a minimal default interaction
            interaction: {
                type: 'none',
                overlayStyle: {
                    opacity: 0,  // Transparent by default
                    outlineEnabled: true,
                    outlineColor: '#e53935',
                    outlineWidth: 1,
                    outlineStyle: 'solid'
                }
            }
        };
        
        // Add this to our currentSlideElementsData array so we have it for future reference
        currentSlideElementsData.push(elementData);
        
        logDebug(`[WebApp] Created minimal element data for ${targetId}`, elementData);
        return elementData;
    }
</script>
</body>
</html>
