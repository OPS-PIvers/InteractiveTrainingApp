<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Training</title>
  <style>
    /* Reset and base styles */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; overflow: hidden; } /* Prevent body scroll */
    body {
      font-family: 'Roboto', Arial, sans-serif;
      font-size: 16px;
      line-height: 1.5;
      color: #333;
      background-color: #f5f5f5;
      display: flex; /* Use flex for layout */
      flex-direction: column;
      position: relative; /* Needed for fixed overlays */
    }

    /* Main container */
    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

    /* Header */
    .header {
      padding: 15px;
      background-color: #1a73e8;
      color: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 10;
      flex-shrink: 0;
    }
    .header h1 { font-size: 1.5rem; font-weight: 400; margin: 0; }
    .nav-controls { display: flex; align-items: center; gap: 15px; }
    #slideTitle { font-size: 0.9rem; opacity: 0.8; max-width: 50%; text-overflow: ellipsis; white-space: nowrap; overflow: hidden; }

    /* Slide container - uses flex to center the slide */
    .slide-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      background-color: #f5f5f5; /* Light gray background around the slide */
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px; /* Padding around the slide */
      min-height: 400px; /* Ensure a minimum height */
    }

    /* The slide itself - aspect ratio maintained by JS */
    .slide {
      position: relative; /* Crucial for absolute positioning of children */
      background-color: white; /* Background of the slide area itself */
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      overflow: hidden;
      /* Width and height set by JS to maintain aspect ratio */
    }

    /* Background image within the slide div */
    .slide-background {
      display: block; /* Remove extra space below img */
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      z-index: 1;
      object-fit: cover; /* Fills the entire area, cropping if necessary */
      object-position: center; /* Center the image if it needs to be cropped */
    }

    /* Overlay elements - positioned relative to .slide */
    .overlay {
        position: absolute;
        z-index: 2;
        cursor: pointer;
        /* Base styles - Specifics (color, border, etc.) set by JS */
        background-color: transparent; /* Set by JS */
        border: none; /* Set by JS */
        border-radius: 0; /* Set by JS based on shape */
        box-shadow: none; /* Set by JS */
        /* Smooth Transitions for all properties */
        transition: background-color 0.2s, border-color 0.2s, border-style 0.2s,
                    border-width 0.2s, box-shadow 0.2s, transform 0.2s ease-out,
                    opacity 0.5s ease-out, border-radius 0.2s; /* Added border-radius transition */
        /* Position for overlay text */
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden; /* Prevent text overflow if needed */
    }

    .overlay-text {
        padding: 4px 8px;
        border-radius: 4px;
        font-weight: 500;
        text-align: center;
        max-width: 90%;
        word-break: break-word;
        line-height: 1.2;
        pointer-events: none;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8); /* Add shadow for better readability */
    }

    /* Styles for different overlay shapes (applied by JS) */
    .overlay.shape-rectangle { border-radius: 3px; } /* Slight rounding for default rectangle */
    .overlay.shape-roundedRectangle { border-radius: 15px; } /* More pronounced rounding */
    .overlay.shape-oval { border-radius: 50%; } /* Makes it an oval or circle */


    /* Revealed elements */
    .overlay.revealed {
        opacity: 0; /* Start hidden */
        transition: opacity 0.5s ease-in-out, background-color 0.2s,
                    border-color 0.2s, border-style 0.2s;
    }

    /* Hover Text (using data attribute set by JS) */
    .overlay::after {
        content: attr(data-hover-text); /* Get text from data attribute */
        position: absolute;
        bottom: -30px; /* Position below the overlay */
        left: 50%;
        transform: translateX(-50%); /* Center the text */
        background-color: rgba(0, 0, 0, 0.7); /* Dark background */
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap; /* Prevent text wrapping */
        z-index: 3;
        opacity: 0;
        visibility: hidden;
        pointer-events: none; /* Prevent interference */
        transition: opacity 0.2s ease-out, visibility 0.2s ease-out;
    }

    .overlay:hover {
        /* Hover effects can be subtle now as primary style is dynamic */
        filter: brightness(1.1); /* Slightly brighten on hover */
         /* Keep prominent border on hover IF outline is enabled */
         /* This is tricky with dynamic styles, JS might need to handle hover border */
         /* Example: JS could add a class on hover */
    }
     /* Example hover class (add/remove with JS) */
    .overlay.is-hovering {
         filter: brightness(1.1);
         /* You could potentially override border here if needed,
            but it might conflict with dynamic styles. */
         /* border-width: 3px !important; */ /* Use with caution */
    }


    /* Show the hover text - only if no overlay text is present */
    .overlay:not(.has-overlay-text):hover::after {
        opacity: 1;
        visibility: visible;
    }

    /* Style for element when its modal is open */
    .overlay.highlighted-for-modal {
        /* Use outline instead of border to avoid layout shifts */
        outline: 3px solid #1a73e8;
        outline-offset: 2px; /* Space between element and outline */
        box-shadow: 0 0 12px rgba(26, 115, 232, 0.5);
        z-index: 105; /* Ensure it's above dimmer and modal */
         /* Slightly dim the element itself to make outline pop */
         /* filter: brightness(0.9); */
    }

    /* Style for temporary highlight interaction */
     .overlay.highlighted-temporary {
        /* Apply styles directly via JS for immediate feedback */
        transition: background-color 0.1s, box-shadow 0.1s, filter 0.1s;
     }

    /* Control bar */
    .control-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 15px;
      background-color: #f5f5f5;
      border-top: 1px solid #ddd;
      flex-shrink: 0;
    }
    .slide-nav { display: flex; align-items: center; gap: 10px; }
    .nav-button {
      background-color: #1a73e8; color: white; border: none; border-radius: 4px;
      padding: 8px 15px; cursor: pointer; font-size: 0.9rem; display: flex;
      align-items: center; gap: 5px; transition: background-color 0.2s;
    }
    .nav-button:hover { background-color: #1558b7; }
    .nav-button:disabled { background-color: #b0bec5; cursor: not-allowed; }
    .slide-indicator { padding: 0 15px; color: #666; font-size: 0.9rem; }

    /* Text modal */
    #textModal {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.75);
      display: none; justify-content: center; align-items: center; z-index: 100;
      opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s;
    }
    #textModal.visible { opacity: 1; visibility: visible; display: flex; }
    #textModalContent {
      background-color: white; padding: 30px; border-radius: 8px;
      max-width: 80%; max-height: 80%; overflow: auto;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3); position: relative;
      transform: scale(0.9); transition: transform 0.3s;
    }
     #textModal.visible #textModalContent { transform: scale(1); }
    #closeModal {
      position: absolute; top: 10px; right: 10px; background: none; border: none;
      font-size: 1.8rem; cursor: pointer; color: #aaa; line-height: 1; padding: 0 5px;
    }
     #closeModal:hover { color: #333; }
    #modalText { margin-bottom: 15px; line-height: 1.6; }
    .modal-navigation {
      display: flex; justify-content: space-between; margin-top: 20px;
      padding-top: 15px; border-top: 1px solid #eee;
      gap: 15px; /* Add gap between buttons */
    }
    .modal-navigation button {
      padding: 8px 16px; background-color: #1a73e8; color: white; border: none;
      border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 5px;
      min-width: 100px; /* Set minimum width */
    }

    /* Animations, Loading, Error, Spotlight, Debug etc. - UNCHANGED from previous version */
    /* --- Animation Keyframes & Classes --- */
      /* --- Animation Keyframes & Classes --- */
    /* Existing */
    @keyframes pulse_anim { 0%, 100% { transform: scale(1); opacity: 0.7; } 50% { transform: scale(1.05); opacity: 1; } }
    @keyframes wiggle_anim { 0%, 100% { transform: rotate(0deg); } 25% { transform: rotate(3deg); } 75% { transform: rotate(-3deg); } }
    @keyframes float_anim { 0%, 100% { transform: translateY(0px); } 50% { transform: translateY(-8px); } }
    /* NEW Keyframes */
    @keyframes bounce_anim { 0%, 20%, 50%, 80%, 100% { transform: translateY(0); } 40% { transform: translateY(-10px); } 60% { transform: translateY(-5px); } }
    @keyframes shake_anim { 0% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); } 20%, 40%, 60%, 80%, 100% { transform: translateX(4px); } }
    @keyframes flash_anim { 0%, 100% { opacity: 1; } 50% { opacity: 0.2; } }
    @keyframes growShrink_anim { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.08); } }
    /* Spotlight text bubble animation */
    @keyframes bubbleFadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    #spotlightTextBubble {
        animation: bubbleFadeIn 0.3s ease-out forwards;
    }

    /* Notes panel animation */
    @keyframes notesPanelFadeIn {
        from { opacity: 0; transform: translate(-50%, 20px); }
        to { opacity: 1; transform: translate(-50%, 0); }
    }

    #spotlightNotesPanel {
        animation: notesPanelFadeIn 0.3s ease-out forwards;
    }

    /* Base Animation Classes */
    .animate-pulse { animation: pulse_anim 2s infinite ease-in-out; }
    .animate-wiggle { animation: wiggle_anim 0.5s infinite ease-in-out; }
    .animate-float { animation: float_anim 3s infinite ease-in-out; }
    .animate-bounce { animation: bounce_anim 1.5s infinite ease-in-out; }
    .animate-shake { animation: shake_anim 0.6s infinite ease-in-out; }
    .animate-flash { animation: flash_anim 1s infinite steps(1, end); }
    .animate-growShrink { animation: growShrink_anim 2s infinite ease-in-out; }

    /* Speed/Intensity Variants */
    /* Pulse */
    .animate-pulse.slow { animation-duration: 3s; }
    .animate-pulse.medium { animation-duration: 2s; }
    .animate-pulse.fast { animation-duration: 1s; }
    /* Wiggle */
    .animate-wiggle.gentle { animation-duration: 1s; transform-origin: center; } /* Gentle needs longer duration */
    .animate-wiggle.medium { animation-duration: 0.5s; transform-origin: center; }
    .animate-wiggle.strong { animation-duration: 0.3s; transform-origin: center; }
    /* Float */
    .animate-float.slow { animation-duration: 4s; }
    .animate-float.medium { animation-duration: 3s; }
    .animate-float.fast { animation-duration: 2s; }

    /* Loading overlay */
    .loading-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(255, 255, 255, 0.8); display: flex; flex-direction: column;
      justify-content: center; align-items: center; z-index: 1000;
    }
    .loading-spinner {
      border: 5px solid #f3f3f3; border-top: 5px solid #1a73e8; border-radius: 50%;
      width: 50px; height: 50px; animation: spin 1s linear infinite; margin-bottom: 20px;
    }
    .loading-message { font-size: 1.2rem; color: #333; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* Error message */
    .error-message {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      background-color: #f44336; color: white; padding: 15px 20px; border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1001; max-width: 80%;
      display: none; /* Initially hidden */
    }

    /* Dim/Spotlight Overlay */
    .dim-overlay {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.7); /* Adjust darkness */
      z-index: 90; /* Below modal, above most content */
      opacity: 0;
      visibility: hidden;
      pointer-events: none; /* Prevent interaction when hidden */
      transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
      cursor: pointer; /* Indicate it's clickable to dismiss */
    }
    .dim-overlay.active {
      opacity: 1;
      visibility: visible;
      pointer-events: auto; /* Allow clicking the overlay to dismiss */
    }
    /* Style for the element being spotlighted */
    .overlay.spotlight-active {
        z-index: 95 !important; /* Ensure spotlighted element is above dimmer */
        background-color: transparent !important;
        border: 2px solid rgba(255, 255, 255, 0.9) !important; /* White highlight */
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.7), 
                    0 0 30px rgba(255, 255, 255, 0.3) !important; /* Glowing effect */
        cursor: default !important; /* Don't show click cursor */
        pointer-events: none !important; /* Prevent interaction with the highlighted element */
    }

    /* Hide the "Click here" text when spotlighted */
    .overlay.spotlight-active::after {
        display: none !important;
    }
    
    /* --- Spotlight Navigation Buttons --- */
    @keyframes buttonPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .spotlight-nav-button {
      padding: 6px 12px;
      background-color: #1a73e8;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: background-color 0.2s, opacity 0.2s;
    }

    .spotlight-nav-button:hover:not(:disabled) {
      background-color: #1558b7;
      animation: buttonPulse 0.5s ease-in-out;
    }

    .spotlight-nav-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .spotlight-nav-button span {
      font-size: 16px;
      line-height: 1;
    }

    /* Spotlight text bubble animations */
    @keyframes bubbleEnter {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    #spotlightTextBubble {
      animation: bubbleEnter 0.3s forwards;
    }

    /* Navigation container in spotlight text */
    .spotlight-nav-container {
      display: flex;
      justify-content: space-between;
      margin-top: 12px;
      padding-top: 10px;
      border-top: 1px solid #eee;
    }

    /* Debug Tools */
    .debug-info {
      position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7);
      color: white; padding: 10px; border-radius: 4px; font-size: 12px;
      z-index: 1000; max-width: 300px; max-height: 200px; overflow: auto;
      display: none; /* Hidden by default */
    }
    .debug-toggle {
      position: fixed; bottom: 10px; right: 10px; /* Position toggle initially */
      background: #1a73e8; color: white; border: none; border-radius: 4px;
      padding: 5px 10px; font-size: 12px; cursor: pointer; z-index: 1001;
      display: none; /* Hidden by default, enabled via debugMode flag */
    }
    .debug-toggle.active {
       right: 320px; /* Move toggle when info panel is shown */
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .header h1 { font-size: 1.2rem; }
      #slideTitle { max-width: 40%; }
      #textModalContent { max-width: 95%; padding: 15px; }
      .nav-button { padding: 6px 10px; font-size: 0.8rem; }
      .slide-indicator { padding: 0 10px; }
      .control-bar { padding: 8px 10px; }
    }
  </style>
</head>
<body>
  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div class="loading-message">Loading presentation...</div>
  </div>

  <!-- Dim/Spotlight Overlay -->
  <div class="dim-overlay" id="dimOverlay"></div>

  <!-- Main Container -->
  <div class="container">
    <div class="header">
      <h1>Interactive Training</h1>
      <div class="nav-controls">
        <span id="slideTitle"></span>
      </div>
    </div>

    <div class="slide-container" id="slideContainer">
      <div class="slide" id="slide">
        <img class="slide-background" id="slideBackground" src="" alt="Slide background">
        <!-- Overlays will be added here dynamically -->
      </div>
    </div>

    <div class="control-bar">
      <div class="slide-nav">
        <button id="prevSlideBtn" class="nav-button" disabled>
          <span>←</span> Previous
        </button>
        <span class="slide-indicator" id="slideIndicator">Slide 1 of 1</span>
        <button id="nextSlideBtn" class="nav-button" disabled>
          Next <span>→</span>
        </button>
      </div>
      <div>
        <button id="restartBtn" class="nav-button">
          <span>↺</span> Restart
        </button>
      </div>
    </div>
  </div>

  <!-- Text modal -->
  <div id="textModal">
    <div id="textModalContent">
      <button id="closeModal">×</button>
      <div id="modalText"></div>
      <div class="modal-navigation">
        <button id="prevElementBtn">
          <span>←</span> Previous
        </button>
        <button id="nextElementBtn">
          Next <span>→</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Error Message Area -->
  <div id="errorMessage" class="error-message"></div>

  <!-- Debug tools -->
  <button id="debugToggle" class="debug-toggle">Debug</button>
  <div id="debugInfo" class="debug-info"></div>


<script>
    // ---------- Global Variables ----------
    const presentationId = "<?= presentationId ?>"; // Injected by GAS doGet
    let currentSlide = null;
    let currentSlideIndex = 0;
    let totalSlides = 0;
    let overlayElementsMap = new Map(); // Map<elementId, overlayDiv>
    // Store full element data received from backend
    let currentSlideElementsData = [];
    let interactiveElements = []; // Subset of currentSlideElementsData with interactions/animations
    let currentModalElementIndex = -1;
    let currentSpotlightElementIndex = -1;
    let lastActiveElementId = null; // NEW: Track the last element interacted with
    let spotlightableElements = [];
    let isSpotlightActive = false;
    let debugMode = false; // Set true for local debugging
    let permanentlyHiddenElementsPerSlide = {}; // NEW: Track hidden elements { slideIndex: Set<elementId> }
    let navSequenceElements = [];
    
    // NEW: Store global overlay defaults received from backend
    let globalOverlayDefaults = {
        shape: 'rectangle', color: '#e53935', opacity: 15, outlineEnabled: true,
        outlineColor: '#e53935', outlineWidth: 1, outlineStyle: 'dashed',
        textColor: '#ffffff', textSize: 14, hoverText: 'Click here'
    };

    // DOM element references (mostly unchanged)
    const slideContainer = document.getElementById('slideContainer');
    const slideElement = document.getElementById('slide');
    const slideBackground = document.getElementById('slideBackground');
    const slideIndicator = document.getElementById('slideIndicator');
    const prevSlideBtn = document.getElementById('prevSlideBtn');
    const nextSlideBtn = document.getElementById('nextSlideBtn');
    const restartBtn = document.getElementById('restartBtn');
    const slideTitleElement = document.getElementById('slideTitle');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const textModal = document.getElementById('textModal');
    const modalTextDiv = document.getElementById('modalText');
    const closeModalBtn = document.getElementById('closeModal');
    const prevElementBtn = document.getElementById('prevElementBtn');
    const nextElementBtn = document.getElementById('nextElementBtn');
    const dimOverlay = document.getElementById('dimOverlay');
    const errorElement = document.getElementById('errorMessage');
    const debugToggle = document.getElementById('debugToggle');
    const debugInfo = document.getElementById('debugInfo');

    // ---------- Initialization ----------
    window.addEventListener('load', () => { /* ... unchanged ... */
      logDebug(`[WebApp] Starting with presentation ID: ${presentationId}`);
      setupEventListeners();
      setupDebugTools();
      loadSlide(0); // Load the first slide
      window.addEventListener('resize', handleResize);
    });

    function setupEventListeners() { /* ... unchanged ... */
      prevSlideBtn.addEventListener('click', () => loadSlide(currentSlideIndex - 1));
      nextSlideBtn.addEventListener('click', () => loadSlide(currentSlideIndex + 1));
      restartBtn.addEventListener('click', () => loadSlide(0));
      closeModalBtn.addEventListener('click', hideTextModal);
      textModal.addEventListener('click', (e) => { if (e.target === textModal) hideTextModal(); });
      dimOverlay.addEventListener('click', hideSpotlight);
      prevElementBtn.addEventListener('click', navigateToPrevElement);
      nextElementBtn.addEventListener('click', navigateToNextElement);
    }

    function setupDebugTools() { /* ... unchanged ... */
      if (debugMode) {
        debugToggle.style.display = 'block';
        debugToggle.addEventListener('click', () => {
          const showDebug = debugInfo.style.display === 'none';
          debugInfo.style.display = showDebug ? 'block' : 'none';
          debugToggle.classList.toggle('active', showDebug);
          debugToggle.textContent = showDebug ? 'Hide Debug' : 'Debug';
        });
      } else {
         debugToggle.style.display = 'none';
         debugInfo.style.display = 'none';
      }
    }

    function logDebug(message, data) { /* ... unchanged ... */
        if (debugMode) {
            console.log(message, data !== undefined ? data : '');
            if (debugInfo.style.display !== 'none') {
               const time = new Date().toLocaleTimeString();
               debugInfo.innerHTML = `[${time}] ${message}<br>` + debugInfo.innerHTML;
            }
        }
    }

    function updateDebugInfo(info) { /* ... unchanged ... */
        if (!debugMode || debugInfo.style.display === 'none') return;
        const time = new Date().toLocaleTimeString();
        debugInfo.innerHTML = `[${time}] ${info}<br>` + debugInfo.innerHTML;
    }

    function handleResize() { /* ... unchanged ... */
      if (currentSlide) {
        adjustSlideSize();
        renderOverlays();
      }
    }

    // ---------- Slide Loading ----------
    /**
     * Loads a slide by index and prepares it for display.
     * Improved version with better visibility state tracking.
     * @param {number} index - The 0-based index of the slide to load
     */
    function loadSlide(index) {
        if (index < 0 || (totalSlides > 0 && index >= totalSlides)) {
            logDebug(`[WebApp] Invalid slide index requested: ${index}`);
            return;
        }
        
        logDebug(`[WebApp] Loading slide index: ${index}, current index: ${currentSlideIndex}`);

        // Save visibility states before changing slides
        if (currentSlideIndex !== index && interactiveElements.length > 0) {
            // Get all currently visible element IDs
            const visibleElementIds = new Set(overlayElementsMap.keys());
            
            // Get all interactive element IDs 
            const allInteractiveIds = interactiveElements.map(el => el.id);
            
            // Initialize the set if it doesn't exist
            if (!permanentlyHiddenElementsPerSlide[currentSlideIndex]) {
                permanentlyHiddenElementsPerSlide[currentSlideIndex] = new Set();
            }
            
            // Update the hidden set: any element not in the visible set is hidden
            allInteractiveIds.forEach(id => {
                if (!visibleElementIds.has(id)) {
                    permanentlyHiddenElementsPerSlide[currentSlideIndex].add(id);
                    logDebug(`[WebApp] Saving element ${id} as hidden for slide ${currentSlideIndex}`);
                }
            });
            
            logDebug(`[WebApp] Saved hidden state for slide ${currentSlideIndex}. Hidden: ${Array.from(permanentlyHiddenElementsPerSlide[currentSlideIndex]).length} elements`);
        }

        showLoading("Loading slide...");
        hideTextModal();
        hideSpotlight();
        clearOverlays();
        overlayElementsMap.clear();
        
        // Reset all state variables
        currentSlideElementsData = [];
        interactiveElements = [];
        currentModalElementIndex = -1;
        currentSpotlightElementIndex = -1;
        lastActiveElementId = null;
        navSequenceElements = [];

        // Initialize the hidden set for the target slide if it doesn't exist
        if (!permanentlyHiddenElementsPerSlide[index]) {
            permanentlyHiddenElementsPerSlide[index] = new Set();
            logDebug(`[WebApp] Initialized hidden set for slide ${index}`);
        } else {
            logDebug(`[WebApp] Using existing hidden set for slide ${index} with ${permanentlyHiddenElementsPerSlide[index].size} elements`);
        }

        google.script.run
            .withSuccessHandler(handleSlideData)
            .withFailureHandler(handleLoadError)
            .getSlideDataForWebApp(presentationId, index);
    }

    /**
     * Handles slide data received from the backend and prepares it for display.
     * Improved version with better error handling and background caching integration.
     * @param {Object} data - The slide data object from the backend.
     */
    function handleSlideData(data) {
      logDebug(`[WebApp] Received slide data:`, data);
      
      // Safety timeout - ensure loading overlay gets hidden even if image loading hangs
      const loadingTimeout = setTimeout(() => {
        console.warn("[WebApp] Loading timeout reached, forcing hide of loading overlay");
        hideLoading();
      }, 5000); // 5 seconds timeout
      
      if (data.error) {
        handleLoadError(data.error);
        // Try to show minimal info if possible
        currentSlideIndex = data.index !== undefined ? data.index : currentSlideIndex;
        totalSlides = data.total !== undefined ? data.total : totalSlides;
        updateSlideNavControls(); // Update nav buttons even on error
        clearTimeout(loadingTimeout); // Clear the safety timeout
        return;
      }

      currentSlide = data;
      currentSlideIndex = data.index;
      totalSlides = data.total;
      
      // Store all element data, including non-interactive elements
      currentSlideElementsData = data.elements || [];
      
      // Handle global overlay settings from Code.gs
      if (data.globalOverlayDefaults) {
        logDebug("[WebApp] Using globalOverlayDefaults from server:", data.globalOverlayDefaults);
        globalOverlayDefaults = data.globalOverlayDefaults;
        overlayOpacity = data.globalOverlayDefaults.opacity !== undefined ? 
                         data.globalOverlayDefaults.opacity : 0;
        overlayShadow = data.globalOverlayDefaults.outlineEnabled !== undefined ? 
                        data.globalOverlayDefaults.outlineEnabled : true;
      } else {
        // Fallback to defaults
        logDebug("[WebApp] No globalOverlayDefaults provided, using defaults");
        overlayOpacity = 0;
        overlayShadow = true;
      }
      logDebug(`[WebApp] Applied overlay settings: Opacity=${overlayOpacity}%, Shadow=${overlayShadow}`);

      // Filter interactive elements
      interactiveElements = currentSlideElementsData.filter(el => {
        const hasInteraction = el.interaction && 
                              el.interaction.type && 
                              el.interaction.type !== 'none';
        const hasAnimation = el.animation && 
                            el.animation.type && 
                            el.animation.type !== 'none';
        
        // Also consider elements with overlay style but no interaction type as interactive
        const hasOverlayStyle = el.interaction && 
                              el.interaction.overlayStyle &&
                              Object.keys(el.interaction.overlayStyle).length > 0;
                              
        return hasInteraction || hasAnimation || hasOverlayStyle;
      });
      
      logDebug(`[WebApp] Found ${interactiveElements.length} interactive elements out of ${currentSlideElementsData.length} total`);
      
      currentModalElementIndex = -1; // Reset modal index

      updateSlideNavControls(); // Update buttons and indicator
      slideTitleElement.textContent = data.notes || ''; // Display speaker notes as title

      // Handle background image loading with proper error handling
      if (data.backgroundUrl) {
        logDebug("[WebApp] Setting background image from server cache...");
        slideBackground.src = data.backgroundUrl;
        
        // Set up proper loading events
        slideBackground.onload = () => {
          clearTimeout(loadingTimeout);
          logDebug("[WebApp] Background image loaded successfully");
          onSlideContentReady();
        };
        
        slideBackground.onerror = () => {
          clearTimeout(loadingTimeout);
          logDebug("[WebApp] Background image failed to load, continuing with blank background");
          slideBackground.src = ''; // Clear the source to avoid broken image icon
          onSlideContentReady();
        };
        
        // Failsafe in case events don't fire
        setTimeout(() => {
          if (loadingOverlay.style.display !== 'none') {
            clearTimeout(loadingTimeout);
            logDebug("[WebApp] Background image loading timeout, continuing anyway");
            onSlideContentReady();
          }
        }, 2000);
      } else {
        logDebug("[WebApp] No background image, using blank slide");
        slideBackground.src = '';
        clearTimeout(loadingTimeout);
        setTimeout(onSlideContentReady, 100);
      }
    }

    function onSlideContentReady() {
      try {
        logDebug("[WebApp] Preparing slide content...");
        adjustSlideSize(); // Calculate and apply slide dimensions
        renderOverlays(); // Render interactive overlays based on new size
        
        // Now restore visibility states based on our tracked hidden elements
        restoreHiddenElementState();
        
        // Update navigation sequence to reflect visible elements
        buildNavigationSequence();
        
        hideLoading(); // Hide loading indicator
        logDebug("[WebApp] Slide ready!");
      } catch (err) {
        console.error("[WebApp] Error in onSlideContentReady:", err);
        showError("Failed to prepare slide: " + err.message);
        hideLoading(); // Ensure loading indicator is hidden even on error
      }
    }

    function updateSlideNavControls() { /* ... unchanged ... */
        slideIndicator.textContent = `Slide ${currentSlideIndex + 1} of ${totalSlides}`;
        prevSlideBtn.disabled = currentSlideIndex === 0;
        nextSlideBtn.disabled = currentSlideIndex >= totalSlides - 1;
    }

    // ---------- Overlay Rendering (UPDATED) ----------

    // Helper to convert HEX and opacity (0-100) to RGBA CSS string
    function hexToRgba(hex, opacityPercent) {
        // Added default hex color if input is invalid
        if (!hex || typeof hex !== 'string' || !/^#([0-9A-F]{3}){1,2}$/i.test(hex)) {
            hex = '#000000'; // Default to black if invalid hex
            console.warn(`[WebApp] Invalid hex color received ('${hex}'), defaulting to black.`);
        }
        
        hex = hex.replace('#', '');
        let r, g, b;
    
        try { // Add try-catch for safety during parsing
            if (hex.length === 3) {
                r = parseInt(hex[0] + hex[0], 16);
                g = parseInt(hex[1] + hex[1], 16);
                b = parseInt(hex[2] + hex[2], 16);
            } else { // Assume 6 length after regex check
                r = parseInt(hex.substring(0, 2), 16);
                g = parseInt(hex.substring(2, 4), 16);
                b = parseInt(hex.substring(4, 6), 16);
            }
        } catch (e) {
            console.error("Error parsing hex color:", hex, e);
            r = g = b = 0; // Default to black on error
        }
    
        // Clamp opacityPercent between 0 and 100, default to 0 if invalid, then convert to 0-1 alpha
        const numOpacity = parseFloat(opacityPercent);
        // Default to 15 if NaN or undefined, otherwise clamp
        const clampedOpacity = (isNaN(numOpacity) || typeof opacityPercent === 'undefined') ? 15 : Math.max(0, Math.min(100, numOpacity));
        const alpha = clampedOpacity / 100;
    
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function adjustSlideSize() {
        const containerWidth = slideContainer.clientWidth;
        const containerHeight = slideContainer.clientHeight;
        
        // Get slide aspect ratio (16:9 is standard for presentations)
        const slideAspectRatio = currentSlide.slideWidth / currentSlide.slideHeight || 16 / 9;
        
        // Calculate dimensions that fit within the container while maintaining aspect ratio
        let targetWidth, targetHeight;
        
        // Use container width and calculate height based on aspect ratio
        if (containerWidth / containerHeight > slideAspectRatio) {
            // Container is wider than slide aspect ratio, so height is the limiting factor
            targetHeight = containerHeight;
            targetWidth = targetHeight * slideAspectRatio;
        } else {
            // Container is taller than slide aspect ratio, so width is the limiting factor
            targetWidth = containerWidth;
            targetHeight = targetWidth / slideAspectRatio;
        }
        
        // Apply the calculated dimensions to the slide
        slideElement.style.width = `${targetWidth}px`;
        slideElement.style.height = `${targetHeight}px`;
        
        // Calculate scaling factors to scale the position and size of overlays
        const scaleX = targetWidth / (currentSlide.slideWidth || 960);
        const scaleY = targetHeight / (currentSlide.slideHeight || 540);
        
        // Store scale values as data attributes for later use
        slideElement.dataset.scaleX = scaleX;
        slideElement.dataset.scaleY = scaleY;
        slideElement.dataset.origWidth = currentSlide.slideWidth || 960;
        slideElement.dataset.origHeight = currentSlide.slideHeight || 540;
        
        logDebug(`[WebApp] Slide dimensions adjusted to ${targetWidth.toFixed(1)}x${targetHeight.toFixed(1)}, Scale: ${scaleX.toFixed(4)}x${scaleY.toFixed(4)}`);
    }

    // Main function to apply styles (custom or global)
    function applyOverlayStyle(overlay, element) {
        // Default opacity from global settings
        let opacityValue = overlayOpacity / 100;
        
        try {
            // Check if the element has custom opacity settings
            if (element && element.interaction) {
                if (element.interaction.useCustomOpacity && 
                    typeof element.interaction.customOpacity === 'number') {
                    // Use element-specific opacity
                    opacityValue = element.interaction.customOpacity / 100;
                    logDebug(`[WebApp] Using custom opacity: ${element.interaction.customOpacity}% for element ${element.id}`);
                }
                
                // Check if the element has custom overlay style
                if (element.interaction.overlayStyle) {
                    const customStyle = element.interaction.overlayStyle;
                    
                    // If custom style includes opacity setting, use that
                    if (typeof customStyle.opacity === 'number') {
                        opacityValue = customStyle.opacity / 100;
                        logDebug(`[WebApp] Using overlayStyle.opacity: ${customStyle.opacity}% for element ${element.id}`);
                    }
                    
                    // Special handling for zero opacity
                    if (opacityValue <= 0.01) {
                        // Make completely invisible but keep interactive
                        overlay.style.backgroundColor = 'rgba(0, 0, 0, 0)';
                        overlay.style.border = 'none';
                        overlay.style.boxShadow = 'none';
                        logDebug(`[WebApp] Applied zero opacity (invisible but interactive) for element ${element.id}`);
                        return; // Skip further styling
                    }
                    
                    // Apply custom color if specified
                    if (customStyle.color) {
                        // Get the RGB color components
                        let r = 229, g = 57, b = 53; // Default red
                        
                        try {
                            // Try to parse color from hex
                            if (customStyle.color.startsWith('#')) {
                                const hex = customStyle.color.substring(1);
                                if (hex.length === 3) {
                                    r = parseInt(hex[0] + hex[0], 16);
                                    g = parseInt(hex[1] + hex[1], 16);
                                    b = parseInt(hex[2] + hex[2], 16);
                                } else if (hex.length === 6) {
                                    r = parseInt(hex.substring(0, 2), 16);
                                    g = parseInt(hex.substring(2, 4), 16);
                                    b = parseInt(hex.substring(4, 6), 16);
                                }
                            }
                        } catch (colorErr) {
                            console.error("[WebApp] Error parsing custom color:", colorErr);
                        }
                        
                        // Apply the color with calculated opacity
                        overlay.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacityValue})`;
                        logDebug(`[WebApp] Applied custom color: rgba(${r}, ${g}, ${b}, ${opacityValue})`);
                    } else {
                        // No custom color, use default red with calculated opacity
                        overlay.style.backgroundColor = `rgba(229, 57, 53, ${opacityValue})`;
                    }
                    
                    // Apply other custom style properties if needed
                    if (customStyle.shape === 'roundedRectangle') {
                        overlay.style.borderRadius = '8px';
                    } else if (customStyle.shape === 'oval') {
                        overlay.style.borderRadius = '50%';
                    }
                    
                    // Apply custom outline
                    if (customStyle.outlineEnabled) {
                        const outlineColor = customStyle.outlineColor || '#e53935';
                        const outlineWidth = customStyle.outlineWidth || 1;
                        const outlineStyle = customStyle.outlineStyle || 'dashed';
                        overlay.style.border = `${outlineWidth}px ${outlineStyle} ${outlineColor}`;
                    } else {
                        overlay.style.border = 'none';
                    }
                    
                    return; // Skip default styling
                }
            }
        } catch (err) {
            console.error("[WebApp] Error applying custom style:", err);
            // Fall back to default styling below
        }
        
        // Special handling for zero opacity in default styling
        if (opacityValue <= 0.01) {
            // Make completely invisible but keep interactive
            overlay.style.backgroundColor = 'rgba(0, 0, 0, 0)';
            overlay.style.border = 'none';
            overlay.style.boxShadow = 'none';
            logDebug(`[WebApp] Applied zero opacity (invisible but interactive) with default styling`);
            return; // Skip further styling
        }
        
        // Default styling if no custom style or on error
        overlay.style.backgroundColor = `rgba(229, 57, 53, ${opacityValue})`;
        
        // Apply default border/outline
        if (overlayShadow) {
            overlay.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.3)';
            overlay.style.border = '1px dashed rgba(229, 57, 53, 0.5)';
        } else {
            overlay.style.border = '1px dashed rgba(229, 57, 53, 0.5)';
            overlay.style.boxShadow = 'none';
        }
    }

    function addOverlayText(overlay, text) {
        if (!text || !text.trim()) return;

        const textElement = document.createElement('div');omStyle.outlineEnabled) {
        textElement.className = 'overlay-text';le.outlineColor || '#e53935';
        textElement.textContent = text; const outlineWidth = customStyle.outlineWidth || 1;
          const outlineStyle = customStyle.outlineStyle || 'dashed';
        // Find the style settings - either from element's custom style or global defaultslineWidth}px ${outlineStyle} ${outlineColor}`;
        let textColor = '#ffffff'; } else {
        let textSize = 14;     overlay.style.border = 'none';
        let useBackground = false; // New setting for background
        
        try {
            // First check for element-specific data   }
            const elementId = overlay.dataset.elementId;  }
            const elementData = currentSlideElementsData.find(el => el.id === elementId);
            rror applying custom style:", err);
            if (elementData && elementData.interaction && elementData.interaction.overlayStyle) {
                // Use element's custom style if available
                textColor = elementData.interaction.overlayStyle.textColor || globalOverlayDefaults.textColor;
                textSize = elementData.interaction.overlayStyle.textSize || globalOverlayDefaults.textSize;y in default styling
                useBackground = elementData.interaction.overlayStyle.textBackground || false;
            } else {t keep interactive
                // Fall back to global defaults overlay.style.backgroundColor = 'rgba(0, 0, 0, 0)';
                textColor = globalOverlayDefaults.textColor;  overlay.style.border = 'none';
                textSize = globalOverlayDefaults.textSize;
                useBackground = globalOverlayDefaults.textBackground || false; with default styling`);
            }  return; // Skip further styling
        } catch (err) {
            console.error("[WebApp] Error applying text styles:", err);
            // Use fallback values already set
        }alue})`;

        // Apply the styles directly
        textElement.style.color = textColor;
        textElement.style.fontSize = `${textSize}px`; overlay.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.3)';
           overlay.style.border = '1px dashed rgba(229, 57, 53, 0.5)';
        // Only add background if configured      } else {
        if (useBackground) {gba(229, 57, 53, 0.5)';
            textElement.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        } else {      }
            textElement.style.textShadow = '1px 1px 2px rgba(0, 0, 0, 0.8)';
        }
        xt) {
        overlay.appendChild(textElement);if (!text || !text.trim()) return;
        overlay.classList.add('has-overlay-text');
        logDebug(`[WebApp] Added overlay text "${text}" with color ${textColor}, size ${textSize}px to element ${overlay.dataset.elementId}`);nt.createElement('div');
    }ame = 'overlay-text';

    /**
     * Renders all interactive overlay elements onto the current slide.nd the style settings - either from element's custom style or global defaults
     * Updated to handle sequential appearance behavior.
     */
    function renderOverlays() {
        logDebug(`[WebApp] [renderOverlays] Start - Rendering overlays for ${interactiveElements.length} interactive elements on slide ${currentSlideIndex}`);

        // Force-clear any previous overlays
        const existingOverlays = slideElement.querySelectorAll('.overlay');
        logDebug(`[WebApp] [renderOverlays] Found ${existingOverlays.length} existing overlays to remove.`);
        existingOverlays.forEach(overlay => {
            if (overlay.parentNode) {entData && elementData.interaction && elementData.interaction.overlayStyle) {
                overlay.parentNode.removeChild(overlay);f available
            }tyle.textColor || globalOverlayDefaults.textColor;
        });Style.textSize || globalOverlayDefaults.textSize;
        overlayElementsMap.clear();round || false;
        logDebug(`[WebApp] [renderOverlays] Cleared existing overlays and map.`); else {
 back to global defaults
        // Reset appearance tracking
        pendingAppearanceElements = new Map(); // Map<elementId, {data, behavior, dependsOn}>ts.textSize;
        visibleElementIds = new Set(); // Track which elements are currently visible       useBackground = globalOverlayDefaults.textBackground || false;
            }
        if (!currentSlide || !currentSlideElementsData) {
            logDebug('[WebApp] [renderOverlays] No current slide data, skipping overlay rendering.');plying text styles:", err);
            return;
        }}

        // Re-filter interactive elements to be safedirectly
        interactiveElements = currentSlideElementsData.filter(el => {
            const hasInteraction = el.interaction && el.interaction.type && el.interaction.type !== 'none';ent.style.fontSize = `${textSize}px`;
            const hasAnimation = el.animation && el.animation.type && el.animation.type !== 'none';
            const hasOverlayStyle = el.interaction && el.interaction.overlayStyle && Object.keys(el.interaction.overlayStyle).length > 0;/ Only add background if configured
            return hasInteraction || hasAnimation || hasOverlayStyle;if (useBackground) {
        });olor = 'rgba(0, 0, 0, 0.5)';
        logDebug(`[WebApp] [renderOverlays] Re-filtered interactive elements count: ${interactiveElements.length}`);

        if (interactiveElements.length === 0) {   }
            logDebug('[WebApp] [renderOverlays] No interactive elements to render.');        
            return; overlay.appendChild(textElement);
        }
with color ${textColor}, size ${textSize}px to element ${overlay.dataset.elementId}`);
        // Get the set of hidden elements for the CURRENT slide index
        const currentHiddenSet = permanentlyHiddenElementsPerSlide[currentSlideIndex] || new Set();
        logDebug(`[WebApp] [renderOverlays] Checking against hidden set for slide ${currentSlideIndex}. Set contains ${currentHiddenSet.size} elements:`, Array.from(currentHiddenSet));
     * Renders all interactive overlay elements onto the current slide.
        // First pass: determine which elements should be visible immediately and which should be deferredce behavior.
        interactiveElements.forEach((element) => {
            // Skip if element is marked as permanently hidden
            if (currentHiddenSet.has(element.id)) {tart - Rendering overlays for ${interactiveElements.length} interactive elements on slide ${currentSlideIndex}`);
                logDebug(`[WebApp] [renderOverlays] SKIPPING render (permanently hidden): ${element.id}`);
                return;
            } existingOverlays = slideElement.querySelectorAll('.overlay');
Debug(`[WebApp] [renderOverlays] Found ${existingOverlays.length} existing overlays to remove.`);
            // Skip elements targeted by 'revealElement' that shouldn not be visible initiallyerlay => {
            if (isTargetOfReveal(element.id)) {
                logDebug(`[WebApp] [renderOverlays] SKIPPING initial render (reveal target): ${element.id}`);                overlay.parentNode.removeChild(overlay);
                return;
            }

            // Check appearance behavior        logDebug(`[WebApp] [renderOverlays] Cleared existing overlays and map.`);
            const interaction = element.interaction || {};
            const appearanceBehavior = interaction.appearanceBehavior || 'withPresentation';
            aranceElements = new Map(); // Map<elementId, {data, behavior, dependsOn}>
            if (appearanceBehavior === 'withPresentation') {isibleElementIds = new Set(); // Track which elements are currently visible
                // Show immediately with the presentation
                renderElement(element);ta) {
                visibleElementIds.add(element.id);, skipping overlay rendering.');
                logDebug(`[WebApp] [renderOverlays] Rendered element with presentation: ${element.id}`);
            } else {
                // Store for later appearance
                pendingAppearanceElements.set(element.id, {
                    data: element,eractiveElements = currentSlideElementsData.filter(el => {
                    behavior: appearanceBehavior,
                    dependsOn: interaction.appearAfterElementId || null            const hasAnimation = el.animation && el.animation.type && el.animation.type !== 'none';
                });ion && el.interaction.overlayStyle && Object.keys(el.interaction.overlayStyle).length > 0;
                logDebug(`[WebApp] [renderOverlays] Element ${element.id} will appear ${appearanceBehavior} (depends on: ${interaction.appearAfterElementId || 'none'})`);
            }
        });ogDebug(`[WebApp] [renderOverlays] Re-filtered interactive elements count: ${interactiveElements.length}`);

        // After rendering initial elements, check for any that should appear with them
        checkPendingAppearances();
        
        // Build the navigation sequence once all initially visible elements are rendered        }
        buildNavigationSequence();
CURRENT slide index
        logDebug(`[WebApp] [renderOverlays] Finished rendering. Visible: ${visibleElementIds.size}, Pending: ${pendingAppearanceElements.size}`);lide[currentSlideIndex] || new Set();
    }g against hidden set for slide ${currentSlideIndex}. Set contains ${currentHiddenSet.size} elements:`, Array.from(currentHiddenSet));

    /**determine which elements should be visible immediately and which should be deferred
     * Renders a single element on the slide.activeElements.forEach((element) => {
     * @param {Object} element - The element data to render            // Skip if element is marked as permanently hidden
     * @returns {HTMLElement|null} - The created overlay element or null if failed
     */ays] SKIPPING render (permanently hidden): ${element.id}`);
    function renderElement(element) {
        try {
            // *** Check for DIRECT position properties ***
            if (!element || typeof element.top !== 'number' || typeof element.left !== 'number' ||            // Skip elements targeted by 'revealElement' that shouldn not be visible initially
                typeof element.width !== 'number' || typeof element.height !== 'number') {.id)) {
                logError(`[WebApp] [renderElement] Invalid element data received, missing direct position properties: ${JSON.stringify(element)}`);NG initial render (reveal target): ${element.id}`);
                return null; // Skip rendering this element
            }}
            // *** END CHECK ***

            // Get the precise scaling factors.interaction || {};
            const scaleX = parseFloat(slideElement.dataset.scaleX) || 1;.appearanceBehavior || 'withPresentation';
            const scaleY = parseFloat(slideElement.dataset.scaleY) || 1;
            aranceBehavior === 'withPresentation') {
            // Get original slide dimensions for referencepresentation
            const slideWidthOrig = parseFloat(slideElement.dataset.origWidth) || 960;
            const slideHeightOrig = parseFloat(slideElement.dataset.origHeight) || 540;add(element.id);
s] Rendered element with presentation: ${element.id}`);
            // Calculate position/size with precise scaling
            // Position is relative to slide origin (0,0)Store for later appearance
            const left = Math.round(element.left * scaleX * 100) / 100;
            const top = Math.round(element.top * scaleY * 100) / 100;       data: element,
            // Ensure minimum dimensions after scaling         behavior: appearanceBehavior,
            const width = Math.round(Math.max(element.width * scaleX, 10) * 100) / 100;                    dependsOn: interaction.appearAfterElementId || null
            const height = Math.round(Math.max(element.height * scaleY, 10) * 100) / 100;
 [renderOverlays] Element ${element.id} will appear ${appearanceBehavior} (depends on: ${interaction.appearAfterElementId || 'none'})`);
            // *** ADDED DEBUG LOGGING START ***    }
            logDebug(`[WebApp] [renderElement ${element.id}] Scales: x=${scaleX.toFixed(4)}, y=${scaleY.toFixed(4)}`);
            logDebug(`[WebApp] [renderElement ${element.id}] Original Slide Size: ${slideWidthOrig}x${slideHeightOrig}`);
            logDebug(`[WebApp] [renderElement ${element.id}] Original Element Pos: T=${element.top}, L=${element.left}, W=${element.width}, H=${element.height}`);        // After rendering initial elements, check for any that should appear with them
            logDebug(`[WebApp] [renderElement ${element.id}] Calculated Style: T=${top.toFixed(2)}px, L=${left.toFixed(2)}px, W=${width.toFixed(2)}px, H=${height.toFixed(2)}px`);
            // *** ADDED DEBUG LOGGING END ***   
        // Build the navigation sequence once all initially visible elements are rendered
            const overlay = document.createElement('div'); buildNavigationSequence();
            overlay.className = 'overlay';
            overlay.dataset.elementId = element.id;ing. Visible: ${visibleElementIds.size}, Pending: ${pendingAppearanceElements.size}`);
            
            // Apply the calculated position and size
            overlay.style.left = `${left}px`;
            overlay.style.top = `${top}px`;s a single element on the slide.
            overlay.style.width = `${width}px`;
            overlay.style.height = `${height}px`;

            // Apply overlay styles based on element configuration
            applyOverlayStyle(overlay, element);
/ *** Check for DIRECT position properties ***
            // Add text to overlay if configuredof element.top !== 'number' || typeof element.left !== 'number' ||
            if (element.interaction && element.interaction.showOverlayText && element.interaction.overlayText) {                typeof element.width !== 'number' || typeof element.height !== 'number') {
                addOverlayText(overlay, element.interaction.overlayText);ent] Invalid element data received, missing direct position properties: ${JSON.stringify(element)}`);
            }

            // Add hover text (displayed as tooltip)// *** END CHECK ***
            if (element.interaction?.overlayStyle?.hoverText || globalOverlayDefaults.hoverText) {
                const hoverText = element.interaction?.overlayStyle?.hoverText || globalOverlayDefaults.hoverText;
                overlay.dataset.hoverText = hoverText;
            }            const scaleY = parseFloat(slideElement.dataset.scaleY) || 1;

            // Set tooltip for debugginge
            let tooltipParts = [`ID: ${element.id}`];Width) || 960;
            if (element.interaction?.type && element.interaction.type !== 'none') tooltipParts.push(`I: ${element.interaction.type}`);rigHeight) || 540;
            if (element.interaction?.overlayStyle) tooltipParts.push(`[Style]`);
            if (element.animation?.type && element.animation.type !== 'none') tooltipParts.push(`A: ${element.animation.type}`);
            overlay.title = tooltipParts.join(' | ');
            const left = Math.round(element.left * scaleX * 100) / 100;
            // Add event listeners scaleY * 100) / 100;
            overlay.addEventListener('click', () => handleOverlayClick(element, element.id));
            overlay.addEventListener('mouseenter', () => overlay.classList.add('is-hovering'));
            overlay.addEventListener('mouseleave', () => overlay.classList.remove('is-hovering'));

            // Apply animation if configured**
            if (element.animation && element.animation.type && element.animation.type !== 'none') {            logDebug(`[WebApp] [renderElement ${element.id}] Scales: x=${scaleX.toFixed(4)}, y=${scaleY.toFixed(4)}`);
                applyAnimation(overlay, element.animation);}] Original Slide Size: ${slideWidthOrig}x${slideHeightOrig}`);
            }ent ${element.id}] Original Element Pos: T=${element.top}, L=${element.left}, W=${element.width}, H=${element.height}`);
ment.id}] Calculated Style: T=${top.toFixed(2)}px, L=${left.toFixed(2)}px, W=${width.toFixed(2)}px, H=${height.toFixed(2)}px`);
            // Add overlay to the slide and tracking Map// *** ADDED DEBUG LOGGING END ***
            slideElement.appendChild(overlay);
            overlayElementsMap.set(element.id, overlay);ement('div');
            logDebug(`[WebApp] [renderElement] Successfully rendered overlay for ${element.id}`);
.id;
            return overlay;
        } catch (err) {            // Apply the calculated position and size
            // Use logError which includes console.error
            logError(`[WebApp] [renderElement] Error rendering element ${element?.id || 'unknown'}: ${err.message}`, err);
            return null;            overlay.style.width = `${width}px`;
        };
    }

    function isTargetOfReveal(elementId) { /* ... unchanged ... */pplyOverlayStyle(overlay, element);
        if (!currentSlide || !currentSlideElementsData) return false;
        return currentSlideElementsData.some(el =>
            el.interaction &&overlayText) {
            el.interaction.type === 'revealElement' &&
            el.interaction.targetElementId === elementId
        );
    }            // Add hover text (displayed as tooltip)
rlayStyle?.hoverText || globalOverlayDefaults.hoverText) {
    function applyAnimation(overlay, animation) {?.overlayStyle?.hoverText || globalOverlayDefaults.hoverText;
        const animationClass = getAnimationClass(animation.type);
        if (!animationClass) {
            logDebug(`[WebApp] Unknown animation type: ${animation.type}`);
            return;
        }            let tooltipParts = [`ID: ${element.id}`];
        n?.type && element.interaction.type !== 'none') tooltipParts.push(`I: ${element.interaction.type}`);
        let speedClass = '';
        // Set speed/intensity classes(`A: ${element.animation.type}`);
        if (animation.type === 'pulse' && animation.pulseSpeed) {
            speedClass = animation.pulseSpeed;
        } else if (animation.type === 'wiggle' && animation.wiggleIntensity) {
            speedClass = animation.wiggleIntensity;
        } else if (animation.type === 'float' && animation.floatSpeed) {erlay.classList.add('is-hovering'));
            speedClass = animation.floatSpeed;verlay.addEventListener('mouseleave', () => overlay.classList.remove('is-hovering'));
        }
        
        const trigger = animation.trigger || 'automatic';nimation.type && element.animation.type !== 'none') {
        logDebug(`[WebApp] Applying animation: ${animation.type} (${trigger}) to ${overlay.dataset.elementId} with speed/intensity: ${speedClass || 'default'}`);n);
        
        // For debugging, add a data attribute to confirm animation is applied
        overlay.dataset.animationType = animation.type;to the slide and tracking Map
        overlay.dataset.animationTrigger = trigger;t.appendChild(overlay);
        
        switch (trigger) {
            case 'automatic':
                overlay.classList.add(animationClass);   return overlay;
                if (speedClass) overlay.classList.add(speedClass);   } catch (err) {
                break;            // Use logError which includes console.error
            case 'onHover':ment ${element?.id || 'unknown'}: ${err.message}`, err);
                overlay.addEventListener('mouseenter', () => {
                    overlay.classList.add(animationClass);
                    if (speedClass) overlay.classList.add(speedClass);
                    logDebug(`[WebApp] Hover animation started: ${animationClass}`);
                });ged ... */
                overlay.addEventListener('mouseleave', () => { (!currentSlide || !currentSlideElementsData) return false;
                    overlay.classList.remove(animationClass);   return currentSlideElementsData.some(el =>
                    if (speedClass) overlay.classList.remove(speedClass);            el.interaction &&
                    logDebug(`[WebApp] Hover animation stopped: ${animationClass}`);t' &&
                });
                break;
            case 'onClick':
                overlay.dataset.animationClass = animationClass;
                if (speedClass) overlay.dataset.speedClass = speedClass;ion applyAnimation(overlay, animation) {
                break;const animationClass = getAnimationClass(animation.type);
        } {
         animation type: ${animation.type}`);
        // Log confirmation that animation was applied
        if (trigger === 'automatic') {
            logDebug(`[WebApp] Automatic animation ${animationClass} applied to element ${overlay.dataset.elementId}`);
        }
    }
ation.pulseSpeed) {
    /**   speedClass = animation.pulseSpeed;
     * Checks for elements that should appear based on currently visible elements.} else if (animation.type === 'wiggle' && animation.wiggleIntensity) {
     * Handles cascading appearances where one element triggers others.
     */
    function checkPendingAppearances() {    speedClass = animation.floatSpeed;
        let newlyVisible = false;
        
        // First check elements that should appear WITH other elementsatic';
        pendingAppearanceElements.forEach((info, elementId) => {logDebug(`[WebApp] Applying animation: ${animation.type} (${trigger}) to ${overlay.dataset.elementId} with speed/intensity: ${speedClass || 'default'}`);
            if (info.behavior === 'withPrevious' && info.dependsOn && visibleElementIds.has(info.dependsOn)) {
                // The element it depends on is visible, so this one should also be visible a data attribute to confirm animation is applied
                logDebug(`[WebApp] [checkPendingAppearances] Element ${elementId} should appear with ${info.dependsOn}`);;
                
                if (renderElement(info.data)) {
                    visibleElementIds.add(elementId);
                    pendingAppearanceElements.delete(elementId);
                    newlyVisible = true;
                    logDebug(`[WebApp] [checkPendingAppearances] Rendered element ${elementId} with ${info.dependsOn}`);
                }
            }nHover':
        });
        
        // If any new elements became visible, recursively check again
        // This handles cascading dependencies: A → B → C
        if (newlyVisible) {
            logDebug(`[WebApp] [checkPendingAppearances] New elements became visible, checking again`);y.addEventListener('mouseleave', () => {
            checkPendingAppearances();.classList.remove(animationClass);
        }edClass);
    }ionClass}`);

    function clearOverlays() { /* ... unchanged ... */       break;
      overlayElementsMap.forEach(overlay => {    case 'onClick':
        if (overlay.parentNode) {tionClass;
          overlay.parentNode.removeChild(overlay);y.dataset.speedClass = speedClass;
        }
      });
      overlayElementsMap.clear();   
      logDebug('[WebApp] Cleared overlays');        // Log confirmation that animation was applied
    } if (trigger === 'automatic') {
ement ${overlay.dataset.elementId}`);
    function getAnimationClass(type) {
        switch (type) {
            case 'pulse': return 'animate-pulse';
            case 'wiggle': return 'animate-wiggle';
            case 'float': return 'animate-float';hecks for elements that should appear based on currently visible elements.
            case 'bounce': return 'animate-bounce';.
            case 'shake': return 'animate-shake';
            case 'flash': return 'animate-flash';
            case 'growShrink': return 'animate-growShrink';
            default: return null;
        } check elements that should appear WITH other elements
    }, elementId) => {
nfo.dependsOn && visibleElementIds.has(info.dependsOn)) {
    /** one should also be visible
     * Handles click events on overlay elements, managing interactions, animations, and sequential appearances.kPendingAppearances] Element ${elementId} should appear with ${info.dependsOn}`);
     * @param {Object} element - The element data object
     * @param {string} clickedElementId - The ID of the clicked elementf (renderElement(info.data)) {
     */       visibleElementIds.add(elementId);
    function handleOverlayClick(element, clickedElementId) {         pendingAppearanceElements.delete(elementId);
        // Debug logging            newlyVisible = true;
        logDebug(`[WebApp] Click handler triggered for: ${clickedElementId || 'unknown'}`, element);red element ${elementId} with ${info.dependsOn}`);
        
        // Use the passed elementId or fall back to the element's id property
        const elementId = clickedElementId || element?.id;
        
        if (!elementId) {/ If any new elements became visible, recursively check again
            console.error("[WebApp] No element ID available in click handler:", {element, clickedElementId});   // This handles cascading dependencies: A → B → C
            return;        if (newlyVisible) {
        }s] New elements became visible, checking again`);
        
        // Find the most up-to-date element data
        const currentElementData = currentSlideElementsData.find(el => el.id === elementId);
        
        if (!currentElementData) {ion clearOverlays() { /* ... unchanged ... */
            console.error(`[WebApp] Clicked element data not found: ${elementId}`);overlay => {
            return;
        }     overlay.parentNode.removeChild(overlay);
        }
        logDebug(`[WebApp] Processing click for element: ${elementId}`);
p.clear();
        let interactionHandled = false;
        let interactionType = 'none'; // Keep track of the type handled

        // --- Handle Interactions First ---
        if (currentElementData.interaction && 
            currentElementData.interaction.type && 
            currentElementData.interaction.type !== 'none') {
            'animate-float';
          const interaction = currentElementData.interaction;   case 'bounce': return 'animate-bounce';
          const overlay = overlayElementsMap.get(elementId);       case 'shake': return 'animate-shake';
          interactionType = interaction.type; // Store the type            case 'flash': return 'animate-flash';
     case 'growShrink': return 'animate-growShrink';
          switch (interaction.type) {
            case 'showText':
              if (interaction.text) {
                showTextModal(interaction.text, elementId);
                interactionHandled = true;
              } else {nts on overlay elements, managing interactions, animations, and sequential appearances.
                showError("Missing text for showText interaction");
              }param {string} clickedElementId - The ID of the clicked element
              break;
               {
            case 'highlight':// Debug logging
              if (overlay) {] Click handler triggered for: ${clickedElementId || 'unknown'}`, element);
                logDebug(`[WebApp] Highlight interaction: ${elementId}`);
                overlay.style.transition = 'background-color 0.1s, box-shadow 0.1s, filter 0.1s';passed elementId or fall back to the element's id property
                overlay.style.filter = 'brightness(1.2) contrast(1.1)';onst elementId = clickedElementId || element?.id;
                overlay.classList.add('highlighted-temporary');
                setTimeout(() => {
                  if(overlayElementsMap.has(elementId)) {ickedElementId});
                    overlay.style.transition = '';    return;
                    overlay.style.filter = '';
                    overlay.classList.remove('highlighted-temporary');
                    applyOverlayStyle(overlay, currentElementData); most up-to-date element data
                  }onst currentElementData = currentSlideElementsData.find(el => el.id === elementId);
                }, 800);        
              }
              interactionHandled = true;            console.error(`[WebApp] Clicked element data not found: ${elementId}`);
              break;
              
            case 'openUrl':
              if (interaction.url) {for element: ${elementId}`);
                logDebug(`[WebApp] Open URL interaction: ${interaction.url}`);
                try {
                  window.open(interaction.url, '_blank');pe handled
                  interactionHandled = true;
                } catch (error) {
                  console.error(`[WebApp] Error opening URL: ${interaction.url}`, error);
                  showError(`Failed to open URL: ${interaction.url}`);
                }            currentElementData.interaction.type !== 'none') {
              } else {
                showError("Missing URL for openUrl interaction");= currentElementData.interaction;
              }entsMap.get(elementId);
              break;type
              
            case 'spotlight':raction.type) {
              logDebug(`[WebApp] Spotlight interaction: ${elementId}`);
              showSpotlight(elementId, interaction);f (interaction.text) {
              interactionHandled = true;TextModal(interaction.text, elementId);
              break;  interactionHandled = true;
              
            case 'goToSlide':issing text for showText interaction");
              if (interaction.targetSlide) {
                const targetIndex = parseInt(interaction.targetSlide, 10) - 1;
                logDebug(`[WebApp] Go to Slide interaction: Target ${interaction.targetSlide} (Index ${targetIndex})`);
                if (targetIndex >= 0 && targetIndex < totalSlides && targetIndex !== currentSlideIndex) {
                  loadSlide(targetIndex);
                } else if (targetIndex === currentSlideIndex) { ${elementId}`);
                  logDebug('[WebApp] Already on target slide.');ound-color 0.1s, box-shadow 0.1s, filter 0.1s';
                } else {ness(1.2) contrast(1.1)';
                  showError(`Invalid target slide number: ${interaction.targetSlide}`);
                }
                interactionHandled = true;f(overlayElementsMap.has(elementId)) {
              } else {lay.style.transition = '';
                showError("Missing target slide for goToSlide interaction");     overlay.style.filter = '';
              }move('highlighted-temporary');
              break;applyOverlayStyle(overlay, currentElementData);
                  }
            case 'revealElement':
              if (interaction.targetElementId) {
                logDebug(`[WebApp] Reveal Element interaction: Target ${interaction.targetElementId}`);
                revealElement(interaction.targetElementId, elementId);
                interactionHandled = true;
              } else {
                showError("Missing target ID for revealElement");) {
              }
              break;
               window.open(interaction.url, '_blank');
            case 'revealAndSpotlight':ractionHandled = true;
              if (interaction.targetElementId) {
                const targetId = interaction.targetElementId;   console.error(`[WebApp] Error opening URL: ${interaction.url}`, error);
                logDebug(`[WebApp] Reveal and Spotlight interaction: Target ${targetId}`);owError(`Failed to open URL: ${interaction.url}`);
                  }
                // Check if target exists in current slide data, including in _debug data
                const targetElementData = currentSlideElementsData.find(el => el.id === targetId);
                const allSlideElementIds = currentSlide._debug?.allSlideElementIds || [];
                
                // First check if the element exists in our data or in the complete list of IDs received from backend
                if (!targetElementData && !allSlideElementIds.includes(targetId)) {se 'spotlight':
                  // Log available IDs to help with debuggingpp] Spotlight interaction: ${elementId}`);
                  const availableIds = currentSlideElementsData.map(el => el.id);action);
                  logDebug(`[WebApp] WARNING: Target ID not found in current slide data. Target: ${targetId}`);
                  logDebug(`[WebApp] Available element IDs: ${JSON.stringify(availableIds)}`);
                  logDebug(`[WebApp] All slide IDs from debug data: ${JSON.stringify(allSlideElementIds)}`);
                  showError(`Target element ID not found: ${targetId.substring(0,8)}... Check your ID and try again.`);
                  return;
                }lide, 10) - 1;
                (`[WebApp] Go to Slide interaction: Target ${interaction.targetSlide} (Index ${targetIndex})`);
                // Even if we don't have the full element data, we can still reveal it if we know it exists on the sliderrentSlideIndex) {
                logDebug(`[WebApp] Target element ID ${targetId} validation passed. Proceeding with reveal.`); loadSlide(targetIndex);
                revealElement(targetId, elementId, false); currentSlideIndex) {
                ebug('[WebApp] Already on target slide.');
                // Use a longer timeout and additional checks
                setTimeout(() => {   showError(`Invalid target slide number: ${interaction.targetSlide}`);
                  if (overlayElementsMap.has(targetId)) {
                    logDebug(`[WebApp] Triggering spotlight for revealed element: ${targetId}`);  interactionHandled = true;
                    showSpotlight(targetId, interaction);
                  } else {for goToSlide interaction");
                    logDebug(`[WebApp] Failed to spotlight element ${targetId} - element not in overlay map after reveal`);
                    // Try to diagnose the issue
                    if (permanentlyHiddenElementsPerSlide[currentSlideIndex]?.has(targetId)) {
                      logDebug(`[WebApp] Element ${targetId} is permanently hidden`);alElement':
                    }
                    showError(`Failed to spotlight target element. Please try again.`); logDebug(`[WebApp] Reveal Element interaction: Target ${interaction.targetElementId}`);
                  }alElement(interaction.targetElementId, elementId);
                }, 500); // Increased timeout for more reliability  interactionHandled = true;
                
                interactionHandled = true; revealElement");
              } else {
                showError("Missing target ID for reveal and spotlight");
              }
              break;
              
            default:
              logDebug(`[WebApp] Unknown interaction type: ${interaction.type}`);logDebug(`[WebApp] Reveal and Spotlight interaction: Target ${targetId}`);
          }
        }g data
sData.find(el => el.id === targetId);
        // --- Handle Animation Triggered by Click ---s || [];
        if (!interactionHandled && currentElementData.animation && 
            currentElementData.animation.trigger === 'onClick') {s received from backend
            
          const animation = currentElementData.animation;
          const overlay = overlayElementsMap.get(elementId);vailableIds = currentSlideElementsData.map(el => el.id);
          logDebug(`[WebApp] Click animation triggered: ${animation.type}`); logDebug(`[WebApp] WARNING: Target ID not found in current slide data. Target: ${targetId}`);
  logDebug(`[WebApp] Available element IDs: ${JSON.stringify(availableIds)}`);
          if (overlay && animation.type && animation.type !== 'none') {
            const animationClass = overlay.dataset.animationClass || again.`);
                                  getAnimationClass(animation.type);
            const speedClass = overlay.dataset.speedClass || '';}

            if (animationClass) {t have the full element data, we can still reveal it if we know it exists on the slide
              overlay.classList.add(animationClass);rgetId} validation passed. Proceeding with reveal.`);
              if (speedClass) overlay.classList.add(speedClass);

              const duration = speedClass.includes('fast') ? 1000 : onger timeout and additional checks
                              (speedClass.includes('slow') ? 3000 : 2000);
              logDebug(`[WebApp] Playing click animation ${animationClass} for ${duration}ms`);getId)) {
);
              setTimeout(() => {
                if(overlayElementsMap.has(elementId)) {lse {
                  overlay.classList.remove(animationClass);t not in overlay map after reveal`);
                  if (speedClass) overlay.classList.remove(speedClass); // Try to diagnose the issue
                  logDebug(`[WebApp] Click animation ${animationClass} finished.`);lideIndex]?.has(targetId)) {
                }      logDebug(`[WebApp] Element ${targetId} is permanently hidden`);
              }, duration);
            }owError(`Failed to spotlight target element. Please try again.`);
          }
        } }, 500); // Increased timeout for more reliability
        
        // --- Handle Disappear On Click Functionality ---  interactionHandled = true;
        if (currentElementData.interaction && currentElementData.interaction.disappearOnClick) { {
          logDebug(`[WebApp] Element has disappearOnClick enabled: ${elementId}`);
             }
          setTimeout(() => {     break;
            const overlay = overlayElementsMap.get(elementId);              
            if (overlay && overlay.parentNode) {
              logDebug(`[WebApp] Starting disappear animation for: ${elementId}`);ction.type}`);
              
              overlay.style.transition = 'opacity 0.5s ease-out';
              overlay.style.opacity = '0';
              overlay.style.pointerEvents = 'none';
              
              setTimeout(() => {            currentElementData.animation.trigger === 'onClick') {
                if (overlay.parentNode) {
                  overlay.parentNode.removeChild(overlay);
                  logDebug(`[WebApp] Removed element from DOM: ${elementId}`);
                }ion.type}`);
                
                overlayElementsMap.delete(elementId);n.type && animation.type !== 'none') {
                nimationClass || 
                // Add to the set of permanently hidden elements for this slidepe);
                if (!permanentlyHiddenElementsPerSlide[currentSlideIndex]) {            const speedClass = overlay.dataset.speedClass || '';
                  permanentlyHiddenElementsPerSlide[currentSlideIndex] = new Set();
                }
                permanentlyHiddenElementsPerSlide[currentSlideIndex].add(elementId);
                              if (speedClass) overlay.classList.add(speedClass);
                // Remove from navigation sequence and rebuild it
                buildNavigationSequence();t') ? 1000 : 
                ? 3000 : 2000);
                logDebug(`[WebApp] Added ${elementId} to hidden set for slide ${currentSlideIndex}`);ss} for ${duration}ms`);
              }, 500);
            }Timeout(() => {
          }, 100);lementsMap.has(elementId)) {
        }     overlay.classList.remove(animationClass);
               if (speedClass) overlay.classList.remove(speedClass);
        // --- Handle Sequential Appearances ---         logDebug(`[WebApp] Click animation ${animationClass} finished.`);
        // Check for elements that should appear after this one was clicked        }
        setTimeout(() => {
          let newlyVisible = false;
          
          pendingAppearanceElements.forEach((info, elementId) => {
            if (info.behavior === 'afterPrevious' && info.dependsOn === elementId) {
              logDebug(`[WebApp] Element ${elementId} should appear after clicking ${elementId}`);
              rrentElementData.interaction.disappearOnClick) {
              if (renderElement(info.data)) {
                visibleElementIds.add(elementId);
                pendingAppearanceElements.delete(elementId);
                newlyVisible = true;sMap.get(elementId);
                logDebug(`[WebApp] Rendered element ${elementId} after clicking ${elementId}`);
              }logDebug(`[WebApp] Starting disappear animation for: ${elementId}`);
            }
          });'opacity 0.5s ease-out';
          
          // If any new elements appeared, trigger another check for cascading appearances
          if (newlyVisible) {
            checkPendingAppearances();tTimeout(() => {
            // Rebuild navigation sequence to include new elements
            buildNavigationSequence();  overlay.parentNode.removeChild(overlay);
          }
        }, 500);
        
        // --- NEW: Update lastActiveElementId AFTER handling interaction ---verlayElementsMap.delete(elementId);
        lastActiveElementId = elementId;
        logDebug(`[WebApp] Updated lastActiveElementId to: ${lastActiveElementId}`);// Add to the set of permanently hidden elements for this slide
        // --- End NEW ---deIndex]) {
sPerSlide[currentSlideIndex] = new Set();
        // Update navigation sequence and buttons slightly later}
        setTimeout(() => {
          buildNavigationSequence(); // Rebuild sequence after potential reveals/hides
          // If a modal or spotlight was opened by this click, force enable its buttons   // Remove from navigation sequence and rebuild it
          if (interactionType === 'showText' || interactionType === 'spotlight' || interactionType === 'revealAndSpotlight') {ildNavigationSequence();
            forceEnableNavigationButtons();       
          }        logDebug(`[WebApp] Added ${elementId} to hidden set for slide ${currentSlideIndex}`);
          logDebug(`[WebApp] handleOverlayClick completed for ${elementId}, navigation updated`);
        }, 600); // Keep delay
    }


    function hasSpotlightCapability(element) {
      return element && 
             element.interaction && 
             element.interaction.type === 'spotlight' &&newlyVisible = false;
             element.interaction.showText &&
             element.interaction.text;, elementId) => {
    }pendsOn === elementId) {
ment ${elementId} should appear after clicking ${elementId}`);
    /**
     * Builds a list of elements that can be navigated through spotlightf (renderElement(info.data)) {
     */   visibleElementIds.add(elementId);
    function buildSpotlightableElementsList() {   pendingAppearanceElements.delete(elementId);
      // Reset the list      newlyVisible = true;
      spotlightableElements = [];d}`);
      
      // Get currently visible elements
      const currentlyVisibleElements = Array.from(overlayElementsMap.keys());
      
      // First try to find all interactive elements with spotlight interactions/ If any new elements appeared, trigger another check for cascading appearances
      const elementsWithSpotlight = interactiveElements.filter(el => wlyVisible) {
        currentlyVisibleElements.includes(el.id) &&    checkPendingAppearances();
        hasSpotlightCapability(el)
      );
      
      // Log what we found
      logDebug(`[WebApp] Found ${elementsWithSpotlight.length} elements with spotlight capability`);        
      teraction ---
      // Check if there are enough elements to enable navigationd = elementId;
      if (elementsWithSpotlight.length > 1) {
        spotlightableElements = elementsWithSpotlight;
      } else {
        // If only one or no spotlight elements, disable navigationuttons slightly later
        logDebug(`[WebApp] Not enough spotlight elements for navigation`);Timeout(() => {
      }
      tlight was opened by this click, force enable its buttons
      // Return the number of elements found     if (interactionType === 'showText' || interactionType === 'spotlight' || interactionType === 'revealAndSpotlight') {
      return spotlightableElements.length;            forceEnableNavigationButtons();
    }          }
k completed for ${elementId}, navigation updated`);
    /** delay
     * Shows a spotlight effect with a true cutout that shows the underlying content.
     * Updated version with integration to navigation sequence.
     */
    function showSpotlight(elementId, interactionData) {ement) {
        // Always hide any existing spotlight first return element && 
        hideSpotlight();             element.interaction && 
              element.interaction.type === 'spotlight' &&
        // Get the target element ID (either the specified target or the clicked element)
        const targetId = interactionData.spotlightTarget || elementId;      element.interaction.text;
        
        logDebug(`[WebApp] Spotlight requested for ${elementId}, targeting: ${targetId}`);
        
        // Find the target overlay element Builds a list of elements that can be navigated through spotlight
        const targetOverlay = overlayElementsMap.get(targetId);
        if (!targetOverlay) {
            logDebug(`[WebApp] Spotlight target not found: ${targetId}`);// Reset the list
            showError(`Spotlight target not found (ID: ${targetId.substring(0,8)}...)`);
            return;
        }
        ts = Array.from(overlayElementsMap.keys());
        // Ensure we have a navigation sequence
        if (navSequenceElements.length === 0) {// First try to find all interactive elements with spotlight interactions
            buildNavigationSequence();otlight = interactiveElements.filter(el => 
        }
          hasSpotlightCapability(el)
        // Find the index of this element in the navigation sequence
        currentSpotlightElementIndex = navSequenceElements.findIndex(el => 
            el.id === elementId || // Either the triggering element
            (interactionData.spotlightTarget && el.id === interactionData.spotlightTarget) // Or its target(`[WebApp] Found ${elementsWithSpotlight.length} elements with spotlight capability`);
        );
        
        logDebug(`[WebApp] Current spotlight element index: ${currentSpotlightElementIndex} of ${navSequenceElements.length}`);f (elementsWithSpotlight.length > 1) {
          spotlightableElements = elementsWithSpotlight;
        // Get the target's position and dimensions
        const targetRect = targetOverlay.getBoundingClientRect();ments, disable navigation
        const slideRect = slideElement.getBoundingClientRect();   logDebug(`[WebApp] Not enough spotlight elements for navigation`);
              }
        // Calculate position relative to the viewport
        const viewportLeft = targetRect.left;
        const viewportTop = targetRect.top;
        const viewportWidth = targetRect.width;
        const viewportHeight = targetRect.height;
        
        // Create SVG with mask for the dimming overlay effect with a true cutout that shows the underlying content.
        const svgNS = "http://www.w3.org/2000/svg";pdated version with integration to navigation sequence.
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("id", "spotlightSVG");
        svg.setAttribute("width", "100%");// Always hide any existing spotlight first
        svg.setAttribute("height", "100%");
        svg.style.position = "fixed";
        svg.style.top = "0";er the specified target or the clicked element)
        svg.style.left = "0";mentId;
        svg.style.zIndex = "90";
        svg.style.pointerEvents = "none"; // Allow clicks to pass through initiallyg: ${targetId}`);
        
        // Create the mask target overlay element
        const mask = document.createElementNS(svgNS, "mask");onst targetOverlay = overlayElementsMap.get(targetId);
        mask.setAttribute("id", "spotlightMask");if (!targetOverlay) {
         not found: ${targetId}`);
        // Background rectangle (white = opaque, black = transparent)nd (ID: ${targetId.substring(0,8)}...)`);
        const bgRect = document.createElementNS(svgNS, "rect");
        bgRect.setAttribute("x", "0");
        bgRect.setAttribute("y", "0");
        bgRect.setAttribute("width", "100%");
        bgRect.setAttribute("height", "100%");
        bgRect.setAttribute("fill", "white"); // White = opaque part of mask
        
        // Cutout rectangle (black = transparent hole in the mask)
        const cutoutRect = document.createElementNS(svgNS, "rect");// Find the index of this element in the navigation sequence
        cutoutRect.setAttribute("x", viewportLeft);
        cutoutRect.setAttribute("y", viewportTop);    el.id === elementId || // Either the triggering element
        cutoutRect.setAttribute("width", viewportWidth);id === interactionData.spotlightTarget) // Or its target
        cutoutRect.setAttribute("height", viewportHeight);
        cutoutRect.setAttribute("fill", "black"); // Black = transparent part of mask
        cutoutRect.setAttribute("rx", "3"); // Rounded cornerslogDebug(`[WebApp] Current spotlight element index: ${currentSpotlightElementIndex} of ${navSequenceElements.length}`);
        cutoutRect.setAttribute("ry", "3"); // Rounded corners
        nsions
        // Add the rectangles to the masktBoundingClientRect();
        mask.appendChild(bgRect);ingClientRect();
        mask.appendChild(cutoutRect);
        // Calculate position relative to the viewport
        // Add mask to SVG
        svg.appendChild(mask);
        
        // Create the dimming rectangle that uses the maskt;
        const dimRect = document.createElementNS(svgNS, "rect");
        dimRect.setAttribute("x", "0");ming overlay
        dimRect.setAttribute("y", "0");org/2000/svg";
        dimRect.setAttribute("width", "100%");.createElementNS(svgNS, "svg");
        dimRect.setAttribute("height", "100%");, "spotlightSVG");
        dimRect.setAttribute("fill", "rgba(0, 0, 0, 0.75)"); // Semi-transparent black, "100%");
        dimRect.setAttribute("mask", "url(#spotlightMask)");
        svg.appendChild(dimRect);svg.style.position = "fixed";
        ";
        // Add the SVG to the document
        document.body.appendChild(svg);
        svg.style.pointerEvents = "none"; // Allow clicks to pass through initially
        // Create a transparent overlay to capture clicks for dismissing the spotlight
        const clickCatcher = document.createElement('div');
        clickCatcher.id = 'spotlightClickCatcher';ementNS(svgNS, "mask");
        clickCatcher.style.position = 'fixed';ightMask");
        clickCatcher.style.top = '0';
        clickCatcher.style.left = '0';e, black = transparent)
        clickCatcher.style.width = '100%';
        clickCatcher.style.height = '100%';bgRect.setAttribute("x", "0");
        clickCatcher.style.zIndex = '89'; // Below the SVG
        clickCatcher.style.cursor = 'pointer';
        
        // Add click handler to dismisshite = opaque part of mask
        clickCatcher.addEventListener('click', hideSpotlight);
        he mask)
        // Add the click catcher to the document
        document.body.appendChild(clickCatcher);
        
        // Highlight the target with a glowing bordercutoutRect.setAttribute("width", viewportWidth);
        targetOverlay.classList.add('spotlight-active'); viewportHeight);
        fill", "black"); // Black = transparent part of mask
        // Store references for cleanup "3"); // Rounded corners
        window.currentSpotlight = {cutoutRect.setAttribute("ry", "3"); // Rounded corners
            svg: svg,
            clickCatcher: clickCatcher,to the mask
            targetId: targetId,mask.appendChild(bgRect);
            elementId: elementId, // Store the original element ID
            interactionData: interactionData // Store the interaction data
        };
        
        // Set global state
        isSpotlightActive = true;es the mask
        
        // Handle text display if configured
        if (interactionData.showText && interactionData.text) { "0");
            showSpotlightText(interactionData.text, targetRect);dimRect.setAttribute("width", "100%");
        } "100%");
        gba(0, 0, 0, 0.75)"); // Semi-transparent black
        // Handle notes display if configureddimRect.setAttribute("mask", "url(#spotlightMask)");
        if (interactionData.showNotes && currentSlide.slideNotes) {
            showSpotlightNotes(currentSlide.slideNotes);
        }
        
        logDebug(`[WebApp] Spotlight activated for ${targetId}`);
        y to capture clicks for dismissing the spotlight
        // After spotlight is shown, check if any pending elements should be shownteElement('div');
        setTimeout(() => {tcher';
            // Check if any elements are configured to appear after this one
            pendingAppearanceElements.forEach((info, elementId) => {
                if (info.behavior === 'afterPrevious' && info.dependsOn === targetId) {clickCatcher.style.left = '0';
                    // This element should appear after the spotlighted one%';
                    if (renderElement(info.data)) {
                        visibleElementIds.add(elementId);clickCatcher.style.zIndex = '89'; // Below the SVG
                        pendingAppearanceElements.delete(elementId);
                        logDebug(`[WebApp] Showing element ${elementId} after spotlighting ${targetId}`);
                        // Add click handler to dismiss
                        // Check for cascading appearancesotlight);
                        checkPendingAppearances();
                    }// Add the click catcher to the document
                }Catcher);
            });
        }, 800); // Delay to allow spotlight effect to completethe target with a glowing border
      // Force rebuild navigation sequenceotlight-active');
      setTimeout(() => {
          buildNavigationSequence();
          
          // Force enable navigation buttons  svg: svg,
          setTimeout(forceEnableNavigationButtons, 100);    clickCatcher: clickCatcher,
          tId,
          logDebug(`[WebApp] Spotlight active, navigation sequence rebuilt with ${navSequenceElements.length} elements`); // Store the original element ID
      }, 200);    interactionData: interactionData // Store the interaction data
    }

    /**
     * Hides the spotlight effect and cleans up all related elements.sSpotlightActive = true;
     */
    function hideSpotlight() {
        if (!isSpotlightActive && !window.currentSpotlight) {
            return;etRect);
        }
        
        logDebug('[WebApp] Hiding spotlight');
        if (interactionData.showNotes && currentSlide.slideNotes) {
        // Remove SVG and click catcher
        if (window.currentSpotlight) {
            if (window.currentSpotlight.svg) {
                document.body.removeChild(window.currentSpotlight.svg);
            }
            e shown
            if (window.currentSpotlight.clickCatcher) {
                document.body.removeChild(window.currentSpotlight.clickCatcher);pear after this one
            }
            
            // Remove highlight from target elementhis element should appear after the spotlighted one
            if (window.currentSpotlight.targetId) {
                const targetOverlay = overlayElementsMap.get(window.currentSpotlight.targetId);entId);
                if (targetOverlay) {   pendingAppearanceElements.delete(elementId);
                    targetOverlay.classList.remove('spotlight-active');       logDebug(`[WebApp] Showing element ${elementId} after spotlighting ${targetId}`);
                }         
            }
            ances();
            // Clean up text/notes
            hideSpotlightText();
            hideSpotlightNotes();  });
             effect to complete
            // Clean up the reference
            window.currentSpotlight = null;imeout(() => {
        }
        
        // Reset state     // Force enable navigation buttons
        isSpotlightActive = false;          setTimeout(forceEnableNavigationButtons, 100);
        currentSpotlightElementIndex = -1;   
    }built with ${navSequenceElements.length} elements`);
, 200);
    /**
     * Shows text in a bubble next to the spotlight target.
     * Fixed version that ensures navigation buttons are always available.
     */des the spotlight effect and cleans up all related elements.
    function showSpotlightText(text, targetRect) {
        // Create text bubble container
        const textBubble = document.createElement('div');if (!isSpotlightActive && !window.currentSpotlight) {
        textBubble.id = 'spotlightTextBubble';
        textBubble.style.position = 'fixed';
        textBubble.style.maxWidth = '300px';
        textBubble.style.padding = '15px';
        textBubble.style.backgroundColor = 'white';
        textBubble.style.color = '#333';emove SVG and click catcher
        textBubble.style.borderRadius = '8px';
        textBubble.style.boxShadow = '0 4px 15px rgba(0,0,0,0.3)';
        textBubble.style.zIndex = '95'; // Above the dimming layer   document.body.removeChild(window.currentSpotlight.svg);
        textBubble.style.fontSize = '14px';}
        textBubble.style.lineHeight = '1.5';
        r) {
        // Content container - format text with simple HTML
        const contentDiv = document.createElement('div');
        contentDiv.style.marginBottom = '10px';
        contentDiv.innerHTML = text.replace(/\n/g, '<br>');move highlight from target element
        textBubble.appendChild(contentDiv);f (window.currentSpotlight.targetId) {
            const targetOverlay = overlayElementsMap.get(window.currentSpotlight.targetId);
        // If we have a navigation sequence, add navigation buttons {
        if (navSequenceElements.length > 1) {y.classList.remove('spotlight-active');
            const navDiv = document.createElement('div');
            navDiv.className = 'spotlight-nav-container';}
            navDiv.style.display = 'flex';
            navDiv.style.justifyContent = 'space-between';
            navDiv.style.marginTop = '10px';   hideSpotlightText();
                hideSpotlightNotes();
            // Previous button - always create regardless of position
            const prevButton = document.createElement('button');nce
            prevButton.id = 'spotlightPrevBtn';;
            prevButton.className = 'spotlight-nav-button';   }
            prevButton.style.padding = '5px 10px';        
            prevButton.style.border = '1px solid #ccc'; // Reset state
            prevButton.style.borderRadius = '4px';
            prevButton.style.backgroundColor = '#f8f8f8';
            prevButton.style.cursor = 'pointer';
            prevButton.style.fontSize = '13px';
            prevButton.innerHTML = '<span>←</span> Previous';
            t.
            // Next button - always create regardless of positionuttons are always available.
            const nextButton = document.createElement('button');
            nextButton.id = 'spotlightNextBtn';ect) {
            nextButton.className = 'spotlight-nav-button';
            nextButton.style.padding = '5px 10px';div');
            nextButton.style.border = '1px solid #ccc';bble';
            nextButton.style.borderRadius = '4px';
            nextButton.style.backgroundColor = '#f8f8f8';
            nextButton.style.cursor = 'pointer';
            nextButton.style.fontSize = '13px';'white';
            nextButton.innerHTML = 'Next <span>→</span>';
            textBubble.style.borderRadius = '8px';
            // Add click handlers with try/catch and proper event prevention,0.3)';
            prevButton.addEventListener('click', function(e) {ing layer
                e.preventDefault();
                e.stopPropagation();
                try {
                    hideSpotlight();// Content container - format text with simple HTML
                    navigateToPrevElement();
                } catch (err) {';
                    console.error('[WebApp] Error in prev button handler:', err););
                    showError("Navigation error: " + (err.message || "Unknown error"));
                }
            });n buttons
            {
            nextButton.addEventListener('click', function(e) {const navDiv = document.createElement('div');
                e.preventDefault();
                e.stopPropagation();
                try {e-between';
                    hideSpotlight();
                    navigateToNextElement();
                } catch (err) {ss of position
                    console.error('[WebApp] Error in next button handler:', err);ent('button');
                    showError("Navigation error: " + (err.message || "Unknown error"));
                }v-button';
            });x';
            
            // Add buttons to the containerprevButton.style.borderRadius = '4px';
            navDiv.appendChild(prevButton);
            navDiv.appendChild(nextButton);
            textBubble.appendChild(navDiv);
        }s';
        
        // Add to body to calculate sizef position
        document.body.appendChild(textBubble);ent('button');
        
        // Position relative to targetv-button';
        const bubbleRect = textBubble.getBoundingClientRect();x';
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;nextButton.style.borderRadius = '4px';
        
        // Default to positioning below the target
        let top = targetRect.bottom + 15;ze = '13px';
        let left = targetRect.left + (targetRect.width / 2) - (bubbleRect.width / 2);Next <span>→</span>';
        
        // Check if it would go off-screen and adjust accordinglyth try/catch and proper event prevention
        if (top + bubbleRect.height > windowHeight) {ck', function(e) {
            // Position above if it would go off the bottomt();
            top = targetRect.top - bubbleRect.height - 15;
        }
           hideSpotlight();
        // Adjust horizontal position if needed     navigateToPrevElement();
        if (left < 20) {    } catch (err) {
            left = 20; // Left marginon handler:', err);
        } else if (left + bubbleRect.width > windowWidth - 20) {gation error: " + (err.message || "Unknown error"));
            left = windowWidth - bubbleRect.width - 20; // Right margin
        }
        
        // Apply positionck', function(e) {
        textBubble.style.top = `${top}px`;t();
        textBubble.style.left = `${left}px`;
        
        // Add to window object for cleanup   hideSpotlight();
        if (!window.currentSpotlight) {     navigateToNextElement();
            window.currentSpotlight = {};    } catch (err) {
        } Error in next button handler:', err);
        window.currentSpotlight.textBubble = textBubble;rror: " + (err.message || "Unknown error"));
        
        logDebug(`[WebApp] Spotlight text shown with navigation. Current index: ${currentSpotlightElementIndex}, Total elements: ${navSequenceElements.length}`);
    }   
    // Add buttons to the container
    /**n);
     * Hides any spotlight text bubble.
     */    textBubble.appendChild(navDiv);
    function hideSpotlightText() {
        const bubble = document.getElementById('spotlightTextBubble');
        if (bubble) {
            document.body.removeChild(bubble);
        }
    }
BoundingClientRect();
    /**
     * Shows speaker notes when spotlight is active.const windowHeight = window.innerHeight;
     */
    function showSpotlightNotes(notes) {
        // Create notes panel
        const notesPanel = document.createElement('div');) - (bubbleRect.width / 2);
        notesPanel.id = 'spotlightNotesPanel';
        notesPanel.style.position = 'fixed';// Check if it would go off-screen and adjust accordingly
        notesPanel.style.bottom = '20px';ght) {
        notesPanel.style.left = '50%';above if it would go off the bottom
        notesPanel.style.transform = 'translateX(-50%)';bbleRect.height - 15;
        notesPanel.style.maxWidth = '80%';
        notesPanel.style.width = '600px';
        notesPanel.style.padding = '15px';/ Adjust horizontal position if needed
        notesPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';if (left < 20) {
        notesPanel.style.color = 'white'; Left margin
        notesPanel.style.borderRadius = '8px'; > windowWidth - 20) {
        notesPanel.style.boxShadow = '0 4px 15px rgba(0,0,0,0.5)';width - 20; // Right margin
        notesPanel.style.zIndex = '95'; // Above the dimming layer}
        notesPanel.style.fontSize = '14px';
        notesPanel.style.lineHeight = '1.5';
        ;
        // Add a title and the notes contentextBubble.style.left = `${left}px`;
        notesPanel.innerHTML = `<div style="font-weight: bold; margin-bottom: 8px; color: #ccc;">Speaker Notes:</div>${notes.replace(/\n/g, '<br>')}`;
        // Add to window object for cleanup
        // Add to document
        document.body.appendChild(notesPanel);       window.currentSpotlight = {};
                }
        // Add to window object for cleanup window.currentSpotlight.textBubble = textBubble;
        if (!window.currentSpotlight) {
            window.currentSpotlight = {}; logDebug(`[WebApp] Spotlight text shown with navigation. Current index: ${currentSpotlightElementIndex}, Total elements: ${navSequenceElements.length}`);
        }
        window.currentSpotlight.notesPanel = notesPanel;
    }

    /**
     * Hides any spotlight notes panel.unction hideSpotlightText() {
     */        const bubble = document.getElementById('spotlightTextBubble');
    function hideSpotlightNotes() { if (bubble) {
        const panel = document.getElementById('spotlightNotesPanel');
        if (panel) { }
            document.body.removeChild(panel);
        }
    }
ctive.
    /**
     * Updates the next/prev button states for spotlight navigation
     */
    function updateSpotlightNavButtons() {;
        const prevBtn = document.getElementById('spotlightPrevBtn');el';
        const nextBtn = document.getElementById('spotlightNextBtn');d';
        
        if (!prevBtn || !nextBtn) return;
        nslateX(-50%)';
        // Disable/enable based on current position in spotlightable elements
        prevBtn.disabled = currentSpotlightElementIndex <= 0;
        prevBtn.style.opacity = prevBtn.disabled ? '0.5' : '1';
        prevBtn.style.cursor = prevBtn.disabled ? 'not-allowed' : 'pointer';'rgba(0, 0, 0, 0.8)';
        
        nextBtn.disabled = currentSpotlightElementIndex >= spotlightableElements.length - 1;notesPanel.style.borderRadius = '8px';
        nextBtn.style.opacity = nextBtn.disabled ? '0.5' : '1';15px rgba(0,0,0,0.5)';
        nextBtn.style.cursor = nextBtn.disabled ? 'not-allowed' : 'pointer';
    }notesPanel.style.fontSize = '14px';
ineHeight = '1.5';
    /**
     * Navigate to the previous element with spotlight capability// Add a title and the notes content
     */"font-weight: bold; margin-bottom: 8px; color: #ccc;">Speaker Notes:</div>${notes.replace(/\n/g, '<br>')}`;
    function navigateToPrevSpotlight() {
        if (currentSpotlightElementIndex <= 0 || !window.currentSpotlight) return;
        ocument.body.appendChild(notesPanel);
        // Get the previous element
        const prevElement = spotlightableElements[currentSpotlightElementIndex - 1];   // Add to window object for cleanup
        if (!prevElement) return;        if (!window.currentSpotlight) {
             window.currentSpotlight = {};
        logDebug(`[WebApp] Navigating to previous spotlight: ${prevElement.id}`);
         window.currentSpotlight.notesPanel = notesPanel;
        // Hide current spotlight
        hideSpotlight();
        
        // Show spotlight for the previous element
        if (prevElement.interaction?.type === 'spotlight') {
            showSpotlight(prevElement.id, prevElement.interaction);unction hideSpotlightNotes() {
        }        const panel = document.getElementById('spotlightNotesPanel');
    } if (panel) {

    /** }
     * Navigate to the next element with spotlight capability
     */
    function navigateToNextSpotlight() {
        if (currentSpotlightElementIndex >= spotlightableElements.length - 1 || !window.currentSpotlight) return;pdates the next/prev button states for spotlight navigation
        
        // Get the next elementtion updateSpotlightNavButtons() {
        const nextElement = spotlightableElements[currentSpotlightElementIndex + 1];
        if (!nextElement) return;tBtn');
        
        logDebug(`[WebApp] Navigating to next spotlight: ${nextElement.id}`);
        
        // Hide current spotlight
        hideSpotlight();
        
        // Show spotlight for the next element   prevBtn.style.cursor = prevBtn.disabled ? 'not-allowed' : 'pointer';
        if (nextElement.interaction?.type === 'spotlight') {        
            showSpotlight(nextElement.id, nextElement.interaction); nextBtn.disabled = currentSpotlightElementIndex >= spotlightableElements.length - 1;
        }
    } nextBtn.style.cursor = nextBtn.disabled ? 'not-allowed' : 'pointer';

    // ---------- Modal Functions ----------
    /**
     * Updates the text modal to integrate with the navigation system.ment with spotlight capability
     * This replaces the original showTextModal function.
     * ght() {
     * @param {string} text - The text to display in the modalif (currentSpotlightElementIndex <= 0 || !window.currentSpotlight) return;
     * @param {string} elementId - The ID of the element that triggered the modal
     */// Get the previous element
    function showTextModal(text, elementId) {ightableElements[currentSpotlightElementIndex - 1];
        logDebug(`[WebApp] Showing text modal for element: ${elementId}`);) return;
        
        // Sanitize text slightly before insertingspotlight: ${prevElement.id}`);
        modalTextDiv.innerHTML = text.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br>");
        textModal.classList.add('visible');
ideSpotlight();
        // Ensure navigation buttons exist and have correct listeners   
        const modalPrevBtn = document.getElementById('prevElementBtn'); // Assuming this ID is used in the modal        // Show spotlight for the previous element
        const modalNextBtn = document.getElementById('nextElementBtn'); // Assuming this ID is used in the modal if (prevElement.interaction?.type === 'spotlight') {
tion);
        if (modalPrevBtn && modalNextBtn) { }
            // Remove existing listeners to prevent duplicates
            modalPrevBtn.replaceWith(modalPrevBtn.cloneNode(true));
            modalNextBtn.replaceWith(modalNextBtn.cloneNode(true));
            // Get fresh references after cloningment with spotlight capability
            const freshPrevBtn = document.getElementById('prevElementBtn');
            const freshNextBtn = document.getElementById('nextElementBtn');ght() {
if (currentSpotlightElementIndex >= spotlightableElements.length - 1 || !window.currentSpotlight) return;
            freshPrevBtn.addEventListener('click', navigateToPrevElement);
            freshNextBtn.addEventListener('click', navigateToNextElement);// Get the next element
ightableElements[currentSpotlightElementIndex + 1];
            // Update button states based on the sequence (using elementId passed to this function)) return;
            buildNavigationSequence(); // Ensure sequence is up-to-date
            const currentIndex = navSequenceElements.findIndex(el => el.id === elementId);spotlight: ${nextElement.id}`);
            freshPrevBtn.disabled = currentIndex <= 0;
            freshNextBtn.disabled = currentIndex >= navSequenceElements.length - 1;
ideSpotlight();
            // Show/hide based on sequence length   
            const modalNavigation = document.querySelector('.modal-navigation');        // Show spotlight for the next element
            if (modalNavigation) {= 'spotlight') {
                modalNavigation.style.display = navSequenceElements.length > 1 ? 'flex' : 'none';     showSpotlight(nextElement.id, nextElement.interaction);
            }
             // Force enable after a moment
             setTimeout(forceEnableNavigationButtons, 100);
        } else {
             logDebug("[WebApp] Modal navigation buttons not found in showTextModal");
        }Updates the text modal to integrate with the navigation system.
al function.
        highlightActiveModalElement(elementId);
        lastActiveElementId = elementId; // Update last active ID when modal is shownparam {string} text - The text to display in the modal
        logDebug(`[WebApp] showTextModal set lastActiveElementId to: ${lastActiveElementId}`);lement that triggered the modal
    }
 {
    function hideTextModal() {        logDebug(`[WebApp] Showing text modal for element: ${elementId}`);
      // Also ensure spotlight is off when modal closes
      hideSpotlight();
      if (textModal.classList.contains('visible')) {
          logDebug('[WebApp] Hiding text modal');        textModal.classList.add('visible');
          textModal.classList.remove('visible');
          resetModalElementHighlights();steners
          currentModalElementIndex = -1; // Reset indexn'); // Assuming this ID is used in the modal
      }n'); // Assuming this ID is used in the modal
    }

    function highlightActiveModalElement(elementId) {
      resetModalElementHighlights(); // Reset all first            modalPrevBtn.replaceWith(modalPrevBtn.cloneNode(true));
      const overlay = overlayElementsMap.get(elementId);
      if (overlay) {
        overlay.classList.add('highlighted-for-modal');            const freshPrevBtn = document.getElementById('prevElementBtn');
      }
    }

    function resetModalElementHighlights() {igateToNextElement);
      overlayElementsMap.forEach(overlay => {
        overlay.classList.remove('highlighted-for-modal');            // Update button states based on the sequence (using elementId passed to this function)
      });sequence is up-to-date
    }lementId);
= currentIndex <= 0;
    // Update modal Prev/Next buttons based on the list of navigable elements
    function updateModalNavigation(modalNavElements) {
      const numNavigable = modalNavElements.length;length
      const hasMultiple = numNavigable > 1;'.modal-navigation');
modalNavigation) {
      // Show/hide buttons based on whether there's more than one item' : 'none';
      prevElementBtn.style.display = hasMultiple ? 'flex' : 'none';   }
      nextElementBtn.style.display = hasMultiple ? 'flex' : 'none';             // Force enable after a moment
ttons, 100);
      if (hasMultiple) {
        prevElementBtn.disabled = currentModalElementIndex <= 0;
        nextElementBtn.disabled = currentModalElementIndex >= numNavigable - 1;   }
         logDebug(`[WebApp] Modal nav updated: Index ${currentModalElementIndex}, Total ${numNavigable}`);
      }ement(elementId);
    } active ID when modal is shown
App] showTextModal set lastActiveElementId to: ${lastActiveElementId}`);
    // Navigate modal to the previous element that can show text
    function navigateToPrevModalElement() {
      // Recalculate navigable elements in case state changed (e.g., reveal)
      const currentlyVisibleElements = Array.from(overlayElementsMap.keys());en modal closes
      const modalNavElements = interactiveElements.filter(el =>
         currentlyVisibleElements.includes(el.id) &&f (textModal.classList.contains('visible')) {
         ( (el.interaction?.type === 'showText' && el.interaction.text) ||     logDebug('[WebApp] Hiding text modal');
           (el.animation?.trigger === 'onClick' && el.animation.showTextOnClick && el.animation.text)          textModal.classList.remove('visible');
         )
      );

      if (currentModalElementIndex > 0 && currentModalElementIndex < modalNavElements.length) {
        const prevNavElement = modalNavElements[currentModalElementIndex - 1];
        // Determine which text to show (interaction takes precedence)ction highlightActiveModalElement(elementId) {
        let textToShow = prevNavElement.interaction?.text || prevNavElement.animation?.text || 'Error: Text not found.'; resetModalElementHighlights(); // Reset all first
        showTextModal(textToShow, prevNavElement.id); // Will update index and buttons      const overlay = overlayElementsMap.get(elementId);
      } else {
         logDebug("[WebApp] Already at first modal element or index invalid.");r-modal');
      }
    }

    // Navigate modal to the next element that can show text    function resetModalElementHighlights() {
    function navigateToNextModalElement() {
      // Recalculate navigable elementsl');
       const currentlyVisibleElements = Array.from(overlayElementsMap.keys());
       const modalNavElements = interactiveElements.filter(el =>
          currentlyVisibleElements.includes(el.id) &&
          ( (el.interaction?.type === 'showText' && el.interaction.text) ||lements
            (el.animation?.trigger === 'onClick' && el.animation.showTextOnClick && el.animation.text)
          )
       );      const hasMultiple = numNavigable > 1;

      if (currentModalElementIndex >= 0 && currentModalElementIndex < modalNavElements.length - 1) {e item
        const nextNavElement = modalNavElements[currentModalElementIndex + 1];
        let textToShow = nextNavElement.interaction?.text || nextNavElement.animation?.text || 'Error: Text not found.';
        showTextModal(textToShow, nextNavElement.id);
      } else { if (hasMultiple) {
         logDebug("[WebApp] Already at last modal element or index invalid.");        prevElementBtn.disabled = currentModalElementIndex <= 0;
      }mNavigable - 1;
    }ed: Index ${currentModalElementIndex}, Total ${numNavigable}`);

    function revealElement(targetElementId, triggerElementId, keepTriggerVisible = false) {
        logDebug(`[WebApp] [revealElement] Start - Target: ${targetElementId}, Trigger: ${triggerElementId}, KeepTrigger: ${keepTriggerVisible}`);
an show text
        // --- Enhanced target ID validation and error handling ---
        if (!targetElementId) {
            showError("Missing target element ID for reveal operation");t currentlyVisibleElements = Array.from(overlayElementsMap.keys());
            return;nst modalNavElements = interactiveElements.filter(el =>
        }         currentlyVisibleElements.includes(el.id) &&

        // If the target is already in the overlay map, just ensure it's visiblek && el.animation.text)
        if (overlayElementsMap.has(targetElementId)) {
            logDebug(`[WebApp] [revealElement] Target element ${targetElementId} is already visible in overlayElementsMap.`);
            const existingOverlay = overlayElementsMap.get(targetElementId);
            if (existingOverlay) {entModalElementIndex > 0 && currentModalElementIndex < modalNavElements.length) {
                existingOverlay.style.opacity = '1';
                existingOverlay.style.pointerEvents = 'auto'; // Determine which text to show (interaction takes precedence)
            }   let textToShow = prevNavElement.interaction?.text || prevNavElement.animation?.text || 'Error: Text not found.';
                    showTextModal(textToShow, prevNavElement.id); // Will update index and buttons
            // Hide the trigger element if configured
            if (!keepTriggerVisible && triggerElementId && overlayElementsMap.has(triggerElementId)) {t modal element or index invalid.");
                 logDebug(`[WebApp] [revealElement] Hiding trigger element (already visible target): ${triggerElementId}`);
                 const triggerOverlay = overlayElementsMap.get(triggerElementId);
                 triggerOverlay.style.transition = 'opacity 0.3s ease-out';
                 triggerOverlay.style.opacity = '0';ow text
                 triggerOverlay.style.pointerEvents = 'none';
                 if (!permanentlyHiddenElementsPerSlide[currentSlideIndex]) {
                     permanentlyHiddenElementsPerSlide[currentSlideIndex] = new Set();t currentlyVisibleElements = Array.from(overlayElementsMap.keys());
                 }nst modalNavElements = interactiveElements.filter(el =>
                 permanentlyHiddenElementsPerSlide[currentSlideIndex].add(triggerElementId);          currentlyVisibleElements.includes(el.id) &&
                 setTimeout(() => {
                     if (overlayElementsMap.has(triggerElementId)) {ck && el.animation.text)
                         overlayElementsMap.delete(triggerElementId);
                         buildNavigationSequence(); // Rebuild after hiding
                     }
                 }, 300);Elements.length - 1) {
            } const nextNavElement = modalNavElements[currentModalElementIndex + 1];
            return; // Element already visible   let textToShow = nextNavElement.interaction?.text || nextNavElement.animation?.text || 'Error: Text not found.';
        }        showTextModal(textToShow, nextNavElement.id);

        // Find target element data from our stored elements list
        let targetElementData = currentSlideElementsData.find(el => el.id === targetElementId);      }

        // If the element data isn't in our main array, check if the ID exists in the presentation metadata
        if (!targetElementData) {rVisible = false) {
            // Check the debug info for all element IDs that exist on this slideWebApp] [revealElement] Start - Target: ${targetElementId}, Trigger: ${triggerElementId}, KeepTrigger: ${keepTriggerVisible}`);
            const allElementIds = currentSlide?._debug?.allSlideElementIds || [];
                    // --- Enhanced target ID validation and error handling ---
            if (allElementIds.includes(targetElementId)) {
                // ID is valid according to metadata, but we don't have full element dataeveal operation");
                logDebug(`[WebApp] [revealElement] Target ID ${targetElementId} found in metadata but missing from element data`);
                
                // Create a minimal element data object since we know this ID is valid
                targetElementData = {ap, just ensure it's visible
                    id: targetElementId,
                    // Set reasonable default position in the middle of the slideogDebug(`[WebApp] [revealElement] Target element ${targetElementId} is already visible in overlayElementsMap.`);
                    left: (currentSlide.slideWidth || 960) / 2,const existingOverlay = overlayElementsMap.get(targetElementId);
                    top: (currentSlide.slideHeight || 540) / 2,
                    width: 100, // Default width
                    height: 100, // Default height
                    type: 'shape', // Default type
                    interaction: {
                        type: 'none',d
                        overlayStyle: {erlayElementsMap.has(triggerElementId)) {
                            color: '#e53935',lready visible target): ${triggerElementId}`);
                            opacity: 15,
                            outlineEnabled: true,riggerOverlay.style.transition = 'opacity 0.3s ease-out';
                        }
                    }le.pointerEvents = 'none';
                };Index]) {
                dex] = new Set();
                // Add to our tracked elements
                currentSlideElementsData.push(targetElementData);nentlyHiddenElementsPerSlide[currentSlideIndex].add(triggerElementId);
                logDebug(`[WebApp] [revealElement] Created fallback element data for ${targetElementId}`);ut(() => {
            } else {        if (overlayElementsMap.has(triggerElementId)) {
                // The element ID is completely invalid for this slidelete(triggerElementId);
                logDebug(`[WebApp] [revealElement] ERROR: Target ID ${targetElementId} not found in any element data or metadata`);                buildNavigationSequence(); // Rebuild after hiding
                showError(`Cannot reveal element (ID: ${targetElementId.substring(0,8)}...). It does not exist on this slide according to server data.`);                     }
                return;
            }
        }            return; // Element already visible

        // Now that we have element data (either real or fallback), create the overlay
        try {
            const scaleX = parseFloat(slideElement.dataset.scaleX || '1');getElementId);
            const scaleY = parseFloat(slideElement.dataset.scaleY || '1');
            eck if the ID exists in the presentation metadata
            // Apply precise positioning with proper rounding
            const left = Math.round(targetElementData.left * scaleX * 100) / 100;
            const top = Math.round(targetElementData.top * scaleY * 100) / 100;t allElementIds = currentSlide?._debug?.allSlideElementIds || [];
            const width = Math.round(Math.max(targetElementData.width * scaleX, 10) * 100) / 100;
            const height = Math.round(Math.max(targetElementData.height * scaleY, 10) * 100) / 100;s(targetElementId)) {
 to metadata, but we don't have full element data
            const overlay = document.createElement('div');ound in metadata but missing from element data`);
            overlay.className = 'overlay revealed'; // Start with 'revealed' class (opacity 0)
            overlay.dataset.elementId = targetElementData.id;e know this ID is valid
            overlay.style.left = `${left}px`;
            overlay.style.top = `${top}px`;
            overlay.style.width = `${width}px`;tion in the middle of the slide
            overlay.style.height = `${height}px`;Slide.slideWidth || 960) / 2,
e.slideHeight || 540) / 2,
            applyOverlayStyle(overlay, targetElementData);ult width
            logDebug(`[WebApp] [revealElement] Applied styles to revealed element ${targetElementId`);eight
fault type
            // Add overlay text if configured
            if (targetElementData.interaction && targetElementData.interaction.showOverlayText && targetElementData.interaction.overlayText) {ype: 'none',
                addOverlayText(overlay, targetElementData.interaction.overlayText);   overlayStyle: {
            }          color: '#e53935',
            opacity: 15,
            // Add event handlersue,
            overlay.addEventListener('click', () => handleOverlayClick(targetElementData, targetElementId));
            overlay.addEventListener('mouseenter', () => overlay.classList.add('is-hovering'));
            overlay.addEventListener('mouseleave', () => overlay.classList.remove('is-hovering'));

            // Apply animation if configured
            if (targetElementData.animation && targetElementData.animation.type && targetElementData.animation.type !== 'none') {
                applyAnimation(overlay, targetElementData.animation);g(`[WebApp] [revealElement] Created fallback element data for ${targetElementId}`);
            } else {
       // The element ID is completely invalid for this slide
            // Add to slide and track in map                logDebug(`[WebApp] [revealElement] ERROR: Target ID ${targetElementId} not found in any element data or metadata`);
            slideElement.appendChild(overlay);}...). It does not exist on this slide according to server data.`);
            overlayElementsMap.set(targetElementId, overlay);   return;
            
            // Log confirmation and map state

        // Now that we have element data (either real or fallback), create the overlay
        try {
            const scaleX = parseFloat(slideElement.dataset.scaleX || '1');
            const scaleY = parseFloat(slideElement.dataset.scaleY || '1');
            
            // Apply precise positioning with proper rounding
            const left = Math.round(targetElementData.left * scaleX * 100) / 100;
            const top = Math.round(targetElementData.top * scaleY * 100) / 100;
            const width = Math.round(Math.max(targetElementData.width * scaleX, 10) * 100) / 100;
            const height = Math.round(Math.max(targetElementData.height * scaleY, 10) * 100) / 100;

            const overlay = document.createElement('div');
            overlay.className = 'overlay revealed'; // Start with 'revealed' class (opacity 0)
            overlay.dataset.elementId = targetElementData.id;
            overlay.style.left = `${left}px`;
            overlay.style.top = `${top}px`;
            overlay.style.width = `${width}px`;
            overlay.style.height = `${height}px`;

            applyOverlayStyle(overlay, targetElementData);
            logDebug(`[WebApp] [revealElement] Applied styles to revealed element ${targetElementId`);

            // Add overlay text if configured
            if (targetElementData.interaction && targetElementData.interaction.showOverlayText && targetElementData.interaction.overlayText) {
                addOverlayText(overlay, targetElementData.interaction.overlayText);
            }

            // Add event handlers
            overlay.addEventListener('click', () => handleOverlayClick(targetElementData, targetElementId));
            overlay.addEventListener('mouseenter', () => overlay.classList.add('is-hovering'));
            overlay.addEventListener('mouseleave', () => overlay.classList.remove('is-hovering'));

            // Apply animation if configured
            if (targetElementData.animation && targetElementData.animation.type && targetElementData.animation.type !== 'none') {
                applyAnimation(overlay, targetElementData.animation);
            }

            // Add to slide and track in map
            slideElement.appendChild(overlay);
            overlayElementsMap.set(targetElementId, overlay);
            
            // Log confirmation and map state
            logDebug(`[WebApp] [revealElement] Element ${targetElementId} added to overlayElementsMap. Map now has ${overlayElementsMap.size} elements`);
            logDebug(`[WebApp] [revealElement] Current map keys: ${Array.from(overlayElementsMap.keys()).join(', ')}`);

            // Make sure the element is in interactiveElements list if it should be
            if (targetElementData.interaction?.type !== 'none' || targetElementData.animation?.type !== 'none') {
                if (!interactiveElements.some(el => el.id === targetElementId)) {
                    interactiveElements.push(targetElementData);
                    logDebug(`[WebApp] [revealElement] Added element to interactiveElements list: ${targetElementId}`);
                }
            }

            // Fade in the revealed element after a brief delay
            setTimeout(() => {
                if (overlayElementsMap.has(targetElementId)) {
                    const overlay = overlayElementsMap.get(targetElementId);
                    overlay.classList.remove('revealed');
                    overlay.style.opacity = '1';
                    logDebug(`[WebApp] [revealElement] Revealed element now visible: ${targetElementId}`);
                }
            }, 50);

            // Hide the trigger element if configured
            if (!keepTriggerVisible && triggerElementId && overlayElementsMap.has(triggerElementId)) {
                logDebug(`[WebApp] [revealElement] Hiding trigger element: ${triggerElementId}`);
                const triggerOverlay = overlayElementsMap.get(triggerElementId);
                triggerOverlay.style.transition = 'opacity 0.3s ease-out';
                triggerOverlay.style.opacity = '0';
                triggerOverlay.style.pointerEvents = 'none';
                
                if (!permanentlyHiddenElementsPerSlide[currentSlideIndex]) {
                    permanentlyHiddenElementsPerSlide[currentSlideIndex] = new Set();
                }
                permanentlyHiddenElementsPerSlide[currentSlideIndex].add(triggerElementId);
                logDebug(`[WebApp] [revealElement] Added trigger ${triggerElementId} to hidden set for slide ${currentSlideIndex}`);
                
                setTimeout(() => {
                    if (overlayElementsMap.has(triggerElementId)) {
                        const triggerElement = overlayElementsMap.get(triggerElementId);
                        if (triggerElement.parentNode) {
                            triggerElement.parentNode.removeChild(triggerElement);
                        }
                        overlayElementsMap.delete(triggerElementId);
                        logDebug(`[WebApp] [revealElement] Removed trigger from DOM and map: ${triggerElementId}`);
                    }
                }, 300);
            }

            // Update navigation sequence after reveal
            setTimeout(() => {
                buildNavigationSequence();
                logDebug(`[WebApp] [revealElement] Updated navigation sequence after reveal`);
            }, 200);

        } catch (err) {
            console.error(`[WebApp] [revealElement] Error creating revealed element ${targetElementId}:`, err);
            showError(`Navigation Error: Revealed element ${targetElementId.substring(0,8)}... not found.`);
        }
    }

    /**
     * Enhanced function to build the navigation sequence, ensuring all interactive elements
     * are included and properly ordered
     */
    function buildNavigationSequence() {
        // Reset the sequence array
        navSequenceElements = [];
        
        // Get the current slide data and elements
        if (!currentSlide || !currentSlideElementsData) {
            logDebug(`[WebApp] Cannot build navigation sequence - no current slide data`);
            return;
        }
        
        try {
            // Get currently visible elements
            const visibleElements = Array.from(overlayElementsMap.keys())
                .map(id => currentSlideElementsData.find(el => el.id === id))
                .filter(el => el !== undefined);
            
            // First check if the slide has a saved custom sequence
            if (currentSlide.hasCustomSequence && currentSlide.customSequence && 
                Array.isArray(currentSlide.customSequence) && currentSlide.customSequence.length > 0) {
                
                // Use the custom sequence to order the elements
                const orderedElements = [];
                const remainingElements = [...visibleElements]; // Copy to track what's left
                
                currentSlide.customSequence.forEach(id => {
                    const elementIndex = remainingElements.findIndex(el => el.id === id);
                    if (elementIndex !== -1) {
                        orderedElements.push(remainingElements[elementIndex]);
                        remainingElements.splice(elementIndex, 1); // Remove from remaining
                    }
                });
                
                // Add any visible elements not in the sequence at the end
                navSequenceElements = [...orderedElements, ...remainingElements];
                logDebug(`[WebApp] Using custom navigation sequence with ${navSequenceElements.length} elements`);
            } else {
                // No custom sequence - use natural order of elements on slide (based on current slide data)
                navSequenceElements = [...visibleElements];
                logDebug(`[WebApp] Using default navigation sequence with ${navSequenceElements.length} elements`);
            }
            
            // Update spotlightable elements list based on the sequence
            buildSpotlightableElementsList();
            
            logDebug(`[WebApp] Navigation sequence built with ${navSequenceElements.length} elements`);
        } catch (err) {
            console.error("[WebApp] Error building navigation sequence:", err);
            // Create a fallback navigation sequence using visible elements
            const visibleElements = Array.from(overlayElementsMap.keys())
                .map(id => currentSlideElementsData.find(el => el.id === id))
                .filter(el => el !== undefined);
            
            navSequenceElements = [...visibleElements];
            logDebug(`[WebApp] Using fallback navigation sequence with ${navSequenceElements.length} elements due to error`);
        }
    }

    /**
     * Updates to the navigation functions to ensure they work with all interaction types
     */
    function navigateToNextElement() {
        logDebug('[WebApp] navigateToNextElement called');
        
        // Force rebuild navigation sequence to ensure it's current
        buildNavigationSequence();
        
        if (navSequenceElements.length <= 0) {
            logDebug('[WebApp] No navigation sequence available.');
            return false;
        }
        
        // Determine current index based on active modal or spotlight or lastActiveElementId
        let currentIndex = -1;
        
        if (isSpotlightActive && window.currentSpotlight?.targetId) {
            // If spotlight is active, use its target as reference
            currentIndex = navSequenceElements.findIndex(el => el.id === window.currentSpotlight.targetId);
            logDebug(`[WebApp] Current index based on spotlight: ${currentIndex} (Target ID: ${window.currentSpotlight.targetId})`);
        } else if (textModal.classList.contains('visible') && currentModalElementIndex !== -1) {
            // If modal is active, use the modal index
            currentIndex = currentModalElementIndex;
            logDebug(`[WebApp] Current index based on modal: ${currentIndex}`);
        } else if (lastActiveElementId) {
            // Try to use the last active element if it's in the sequence
            currentIndex = navSequenceElements.findIndex(el => el.id === lastActiveElementId);
            logDebug(`[WebApp] Current index based on lastActiveElementId: ${currentIndex} (ID: ${lastActiveElementId})`);
        } else {
            // If nothing is active, assume we start from the beginning
            currentIndex = -1;
            logDebug('[WebApp] No active context found, starting navigation from beginning.');
        }
        
        // Get next index (with wrap-around)
        const nextIndex = (currentIndex >= navSequenceElements.length - 1 || currentIndex < 0) ? 
                          0 : currentIndex + 1;
        
        // Get the next element data
        const nextElement = navSequenceElements[nextIndex];
        if (!nextElement || !nextElement.id) {
            logDebug('[WebApp] Could not find valid next element data.');
            return false;
        }
        
        logDebug(`[WebApp] Navigating TO element: index=${nextIndex}, id=${nextElement.id}, type=${nextElement.interaction?.type}`);
        
        // Clean up current state BEFORE triggering the next
        hideSpotlight();
        hideTextModal();
        
        // Short delay to ensure clean state and DOM updates
        setTimeout(() => {
            logDebug(`[WebApp] Triggering interaction for next element: ${nextElement.id}`);
            const interactionType = nextElement.interaction?.type || 'none';
            
            // Update lastActiveElementId and indices
            lastActiveElementId = nextElement.id;
            currentModalElementIndex = nextIndex;
            currentSpotlightElementIndex = nextIndex;

            // Trigger the appropriate interaction for the next element based on its type
            switch (interactionType) {
                case 'spotlight':
                    showSpotlight(nextElement.id, nextElement.interaction);
                    break;
                case 'showText':
                    showTextModal(nextElement.interaction.text, nextElement.id);
                    break;
                case 'revealElement':
                    if (nextElement.interaction.targetElementId) {
                        revealElement(nextElement.interaction.targetElementId, nextElement.id);
                    }
                    break;
                case 'revealAndSpotlight':
                    if (nextElement.interaction.targetElementId) {
                        const targetElementId = nextElement.interaction.targetElementId;
                        logDebug(`[WebApp][NextNav] Handling revealAndSpotlight. Trigger: ${nextElement.id}, Target: ${targetElementId}`);

                        // Reveal the element first, but don't hide the trigger yet
                        revealElement(targetElementId, nextElement.id, true); // Keep trigger visible for now

                        // Delay spotlight and sequence rebuild until after reveal animation
                        setTimeout(() => {
                            logDebug(`[WebApp][NextNav] Post-reveal for ${targetElementId}. Checking visibility...`);
                            if (overlayElementsMap.has(targetElementId)) {
                                logDebug(`[WebApp][NextNav] Target ${targetElementId} is visible in map.`);
                                // Find the target element's data
                                const targetElementData = currentSlideElementsData.find(el => el.id === targetElementId);
                                if (targetElementData) {
                                    // *** CRITICAL: Update lastActiveElementId to the REVEALED target ***
                                    lastActiveElementId = targetElementId;
                                    logDebug(`[WebApp][NextNav] Updated lastActiveElementId to revealed target: ${targetElementId}`);

                                    // *** CRITICAL: Rebuild sequence AFTER updating lastActiveElementId ***
                                    buildNavigationSequence();
                                    logDebug(`[WebApp][NextNav] Navigation sequence rebuilt. Length: ${navSequenceElements.length}`);

                                    // Now show the spotlight on the revealed element
                                    showSpotlight(targetElementId, {
                                        ...nextElement.interaction,
                                        spotlightTarget: targetElementId // Ensure spotlight targets the revealed element
                                    });
                                    logDebug(`[WebApp][NextNav] Spotlight shown for ${targetElementId}`);

                                    // Force enable buttons again after spotlight
                                    setTimeout(forceEnableNavigationButtons, 150);

                                } else {
                                    logDebug(`[WebApp][NextNav] Warning: Could not find element data for ${targetElementId} after reveal`);
                                    // Fallback: Try to show spotlight anyway
                                    showSpotlight(targetElementId, nextElement.interaction);
                                }
                            } else {
                                logDebug(`[WebApp][NextNav] ERROR: Failed to find revealed element ${targetElementId} in overlayElementsMap after reveal timeout.`);
                                showError(`Navigation Error: Revealed element ${targetElementId.substring(0,8)}... not found.`);
                            }
                        }, 600); // Increased delay to ensure reveal animation completes
                    } else {
                        logDebug(`[WebApp][NextNav] revealAndSpotlight missing targetElementId`);
                        showError("Missing target element ID for reveal and spotlight");
                    }
                    break;
                case 'openUrl':
                case 'highlight':
                case 'goToSlide': 
                case 'none':
                default:
                    // Simulate a click on the element's overlay for other interaction types
                    handleOverlayClick(nextElement, nextElement.id);
                    break;
            }
            
            // Force enable buttons if needed for modal or spotlight navigation
            if (interactionType === 'showText' || interactionType === 'spotlight' || 
                interactionType === 'revealAndSpotlight') {
                setTimeout(forceEnableNavigationButtons, 150);
            }
        }, 150); // Delay to allow hide animations/cleanup
        
        return true;
    }

    /**
     * Navigates to the previous element in the defined sequence and triggers its interaction.
     */
    function navigateToPrevElement() {
        logDebug('[WebApp] navigateToPrevElement called');
        
        // Force rebuild navigation sequence
        buildNavigationSequence();
        
        if (navSequenceElements.length <= 0) {
            logDebug('[WebApp] No navigation sequence available.');
            return false;
        }
        
        // Determine current index
        let currentIndex = -1;
        if (isSpotlightActive && window.currentSpotlight?.targetId) {
            currentIndex = navSequenceElements.findIndex(el => el.id === window.currentSpotlight.targetId);
            logDebug(`[WebApp] Current index based on spotlight: ${currentIndex} (Target ID: ${window.currentSpotlight.targetId})`);
        } else if (textModal.classList.contains('visible') && currentModalElementIndex !== -1) {
            currentIndex = currentModalElementIndex;
            logDebug(`[WebApp] Current index based on modal: ${currentIndex}`);
        } else if (lastActiveElementId) {
            // Try to use the last active element if it's in the sequence
            currentIndex = navSequenceElements.findIndex(el => el.id === lastActiveElementId);
            logDebug(`[WebApp] Current index based on lastActiveElementId: ${currentIndex} (ID: ${lastActiveElementId})`);
        } else {
            // If nothing is active, assume we wrap around from the end
            currentIndex = navSequenceElements.length; // Will become length-1 after we subtract 1
            logDebug('[WebApp] No active context, starting navigation from end for previous.');
        }
        
        // Get previous index (with wrap-around)
        const prevIndex = (currentIndex <= 0) ? 
                          navSequenceElements.length - 1 : currentIndex - 1;
        
        // Get the previous element data
        const prevElement = navSequenceElements[prevIndex];
        if (!prevElement || !prevElement.id) {
            logDebug('[WebApp] Could not find valid previous element data.');
            return false;
        }
        
        logDebug(`[WebApp] Navigating TO previous element: index=${prevIndex}, id=${prevElement.id}, type=${prevElement.interaction?.type}`);
        
        // Clean up current state BEFORE triggering the previous
        hideSpotlight();
        hideTextModal();
        
        // Short delay
        setTimeout(() => {
            logDebug(`[WebApp] Triggering interaction for previous element: ${prevElement.id}`);
            const interactionType = prevElement.interaction?.type || 'none';

            // Update lastActiveElementId and indices
            lastActiveElementId = prevElement.id;
            currentModalElementIndex = prevIndex;
            currentSpotlightElementIndex = prevIndex;

            // Trigger the appropriate interaction
            switch (interactionType) {
                case 'spotlight':
                    showSpotlight(prevElement.id, prevElement.interaction);
                    break;
                case 'showText':
                    showTextModal(prevElement.interaction.text, prevElement.id);
                    break;
                case 'revealElement':
                    if (prevElement.interaction.targetElementId) {
                        revealElement(prevElement.interaction.targetElementId, prevElement.id);
                    }
                    break;
                case 'revealAndSpotlight':
                    if (prevElement.interaction.targetElementId) {
                        const targetId = prevElement.interaction.targetElementId;
                        logDebug(`[WebApp] Navigating to previous revealAndSpotlight: Target ${targetId}`);
                        
                        revealElement(targetId, prevElement.id, false);
                        
                        setTimeout(() => {
                            if (overlayElementsMap.has(targetId)) {
                                const targetData = currentSlideElementsData.find(el => el.id === targetId);
                                
                                if (targetData) {
                                    lastActiveElementId = targetId;
                                    buildNavigationSequence();
                                    
                                    showSpotlight(targetId, {
                                        ...prevElement.interaction,
                                        spotlightTarget: targetId
                                    });
                                } else {
                                    showSpotlight(targetId, prevElement.interaction);
                                }
                            }
                        }, 500);
                    }
                    break;
                case 'openUrl':
                case 'highlight':
                case 'goToSlide':
                case 'none':
                default:
                    // Simulate a click on the element's overlay
                    handleOverlayClick(prevElement, prevElement.id);
                    break;
            }
            
            // Force enable buttons if needed
            if (interactionType === 'showText' || interactionType === 'spotlight' || 
                interactionType === 'revealAndSpotlight') {
                setTimeout(forceEnableNavigationButtons, 150);
            }
        }, 150); // Delay
        
        return true;
    }

    /**
     * IMPORTANT: Function to force enable navigation buttons
     * Call this after any spotlight or modal is shown
     */
    function forceEnableNavigationButtons() {
        try {
            const navButtons = [
                document.getElementById('spotlightPrevBtn'),
                document.getElementById('spotlightNextBtn'),
                document.getElementById('prevElementBtn'),
                document.getElementById('nextElementBtn')
            ];
            
            navButtons.forEach(button => {
                if (button) {
                    // Enable all buttons and restore styling
                    button.disabled = false;
                    button.style.opacity = '1';
                    button.style.cursor = 'pointer';
                    
                    // Remove and re-attach event listeners based on button ID
                    if (button.id === 'spotlightPrevBtn' || button.id === 'prevElementBtn') {
                        // Clone to remove old listeners and create fresh button
                        const newButton = button.cloneNode(true);
                        button.parentNode.replaceChild(newButton, button);
                        newButton.addEventListener('click', function(e) {
                            e.preventDefault();
                            if (textModal.classList.contains('visible')) {
                                hideTextModal();
                            }
                            if (isSpotlightActive) {
                                hideSpotlight();
                            }
                            setTimeout(() => navigateToPrevElement(), 50);
                        });
                    } else if (button.id === 'spotlightNextBtn' || button.id === 'nextElementBtn') {
                        const newButton = button.cloneNode(true);
                        button.parentNode.replaceChild(newButton, button);
                        newButton.addEventListener('click', function(e) {
                            e.preventDefault();
                            if (textModal.classList.contains('visible')) {
                                hideTextModal();
                            }
                            if (isSpotlightActive) {
                                hideSpotlight();
                            }
                            setTimeout(() => navigateToNextElement(), 50);
                        });
                    }
                }
            });
            
            logDebug('[WebApp] Navigation buttons force enabled with fresh event listeners');
        } catch (err) {
            console.error('[WebApp] Error in forceEnableNavigationButtons:', err);
        }
    }

    // ---------- Loading and Error Handling ----------
    function showLoading(message) {
      loadingOverlay.querySelector('.loading-message').textContent = message || 'Loading...';
      loadingOverlay.style.display = 'flex';
      logDebug(`[WebApp] Showing loading: ${message}`);
    }
    function hideLoading() {
      loadingOverlay.style.display = 'none';
      logDebug(`[WebApp] Hiding loading`);
    }
    function showError(message) {
      const errorMessageText = String(message || "An unknown error occurred.");
      console.error(`[WebApp] Error: ${errorMessageText}`);
      errorElement.textContent = errorMessageText;
      errorElement.style.display = 'block';
      // Auto-hide after a delay
      setTimeout(() => { errorElement.style.display = 'none'; }, 5000);
    }
    function handleLoadError(error) {
      hideLoading();
      const errorMessage = (typeof error === 'object' && error !== null && error.message) ? error.message : String(error);
      showError(`Failed to load slide data: ${errorMessage}. Please check console logs or presentation access.`);
      console.error(`[WebApp] Full load error object: `, error); // Log full details
    }
    
    /**
     * Handles the escape key and closing modals/spotlights properly
     */
    function handleEscapeKey() {
      if (isSpotlightActive) {
        hideSpotlight();
        return true; // Handled
      }
      if (textModal.classList.contains('visible')) {
        hideTextModal();
        return true; // Handled
      }
      return false; // Not handled
    }

    /**
     * Handles keyboard navigation for the presentation
     * @param {string} key - The key that was pressed
     * @returns {boolean} True if the key was handled
     */
    function tryNavigateWithKeyboard(key) {
        // Handle modal or spotlight navigation first
        if (isSpotlightActive || textModal.classList.contains('visible')) {
            if (key === 'ArrowLeft') {
                return navigateToPrevElement();
            } else if (key === 'ArrowRight') {
                return navigateToNextElement();
            }
        } else {
            // Normal slide navigation
            if (key === 'ArrowLeft' && !prevSlideBtn.disabled) {
                loadSlide(currentSlideIndex - 1);
                return true;
            } else if (key === 'ArrowRight' && !nextSlideBtn.disabled) {
                loadSlide(currentSlideIndex + 1);
                return true;
            }
        }
        return false; // Not handled
    }

    // Keyboard event handler for navigation
    document.addEventListener('keydown', (e) => {
      // Handle Escape key for modals/spotlights
      if (e.key === 'Escape') {
        if (handleEscapeKey()) {
          e.preventDefault();
          return;
        }
      }
      
      // Handle arrow keys for navigation
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        if (tryNavigateWithKeyboard(e.key)) {
          e.preventDefault();
          return;
        }
      }
      
      // Handle space bar to dismiss spotlight (optional)
      if (e.key === ' ' && isSpotlightActive) {
        hideSpotlight();
        e.preventDefault();
        return;
      }
    });

    // Add this function to create and expose the missing element data when we only have IDs
    function createElementDataFromId(targetId) {
        logDebug(`[WebApp] Creating element data from ID: ${targetId}`);
        
        // First check if we already have this element in our data
        const existingData = currentSlideElementsData.find(el => el.id === targetId);
        if (existingData) return existingData;
        
        // Get the debug data that contains all slide elements
        const allSlideElementIds = currentSlide._debug?.allSlideElementIds || [];
        const elementTypes = currentSlide._debug?.elementTypes || {};
        
        // If this ID isn't in the list of all slide elements, we can't create data for it
        if (!allSlideElementIds.includes(targetId)) {
            logDebug(`[WebApp] ID ${targetId} not found in all slide elements list`);
            return null;
        }
        
        // Get the element type if available
        const elementType = elementTypes[targetId] || {type: 'unknown', hasDesc: 'no'};
        
        // Create a minimal element data object - we don't have position/dimensions
        // but we'll need to ask the server for these in a future request
        const elementData = {
            id: targetId,
            type: elementType.type,
            // Assume position in the center of the slide for now
            left: currentSlide.slideWidth / 2,
            top: currentSlide.slideHeight / 2,
            width: 100,
            height: 100,
            // Create a minimal default interaction
            interaction: {
                type: 'none',
                overlayStyle: {
                    opacity: 0,  // Transparent by default
                    outlineEnabled: true,
                    outlineColor: '#e53935',
                    outlineWidth: 1,
                    outlineStyle: 'solid'
                }
            }
        };
        
        // Add this to our currentSlideElementsData array so we have it for future reference
        currentSlideElementsData.push(elementData);
        
        logDebug(`[WebApp] Created minimal element data for ${targetId}`, elementData);
        return elementData;
    }

    /**
     * Check the permanentlyHiddenElementsPerSlide set for the current slide
     * and hide any elements that should remain hidden after navigation
     */
    function restoreHiddenElementState() {
        // Skip if there are no tracked hidden elements
        if (!permanentlyHiddenElementsPerSlide[currentSlideIndex] || 
            permanentlyHiddenElementsPerSlide[currentSlideIndex].size === 0) {
            logDebug(`[WebApp] No hidden elements to restore for slide ${currentSlideIndex}`);
            return;
        }
        
        const hiddenElements = permanentlyHiddenElementsPerSlide[currentSlideIndex];
        logDebug(`[WebApp] Restoring hidden state for ${hiddenElements.size} elements on slide ${currentSlideIndex}`);
        
        // For each element that should be hidden
        hiddenElements.forEach(elementId => {
            const overlay = overlayElementsMap.get(elementId);
            if (overlay) {
                // Hide the overlay with transition
                overlay.style.opacity = '0';
                overlay.style.pointerEvents = 'none';
                
                logDebug(`[WebApp] Restored hidden state for element ${elementId}`);
                
                // Remove from overlay map after transition completes
                setTimeout(() => {
                    if (overlay.parentNode) {
                        overlay.parentNode.removeChild(overlay);
                    }
                    overlayElementsMap.delete(elementId);
                    logDebug(`[WebApp] Removed element ${elementId} from DOM and map`);
                }, 300);
            } else {
                logDebug(`[WebApp] Element ${elementId} marked as hidden but not found in overlay map`);
            }
        });
    }
</script>
</body>
</html>
