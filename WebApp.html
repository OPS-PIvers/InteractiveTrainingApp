<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Training</title>
  <style>
    /* Reset and base styles */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; overflow: hidden; } /* Prevent body scroll */
    body {
      font-family: 'Roboto', Arial, sans-serif;
      font-size: 16px;
      line-height: 1.5;
      color: #333;
      background-color: #f5f5f5;
      display: flex; /* Use flex for layout */
      flex-direction: column;
      position: relative; /* Needed for fixed overlays */
    }

    /* Main container */
    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

    /* Header */
    .header {
      padding: 15px;
      background-color: #1a73e8;
      color: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 10;
      flex-shrink: 0;
    }
    .header h1 { font-size: 1.5rem; font-weight: 400; margin: 0; }
    .nav-controls { display: flex; align-items: center; gap: 15px; }
    #slideTitle { font-size: 0.9rem; opacity: 0.8; max-width: 50%; text-overflow: ellipsis; white-space: nowrap; overflow: hidden; }

    /* Slide container - uses flex to center the slide */
    .slide-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      background-color: #f5f5f5; /* Light gray background around the slide */
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px; /* Padding around the slide */
      min-height: 400px; /* Ensure a minimum height */
    }

    /* The slide itself - aspect ratio maintained by JS */
    .slide {
      position: relative; /* Crucial for absolute positioning of children */
      background-color: white; /* Background of the slide area itself */
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      overflow: hidden;
      /* Width and height set by JS to maintain aspect ratio */
    }

    /* Background image within the slide div */
    .slide-background {
      display: block; /* Remove extra space below img */
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      z-index: 1;
      object-fit: cover; /* Fills the entire area, cropping if necessary */
      object-position: center; /* Center the image if it needs to be cropped */
    }

    /* Overlay elements - positioned relative to .slide */
    .overlay {
        position: absolute;
        z-index: 2;
        cursor: pointer;
        /* Base styles - Specifics (color, border, etc.) set by JS */
        background-color: transparent; /* Set by JS */
        border: none; /* Set by JS */
        border-radius: 0; /* Set by JS based on shape */
        box-shadow: none; /* Set by JS */
        /* Smooth Transitions for all properties */
        transition: background-color 0.2s, border-color 0.2s, border-style 0.2s,
                    border-width 0.2s, box-shadow 0.2s, transform 0.2s ease-out,
                    opacity 0.5s ease-out, border-radius 0.2s; /* Added border-radius transition */
        /* Position for overlay text */
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden; /* Prevent text overflow if needed */
    }

    .overlay-text {
        padding: 4px 8px;
        border-radius: 4px;
        font-weight: 500;
        text-align: center;
        max-width: 90%;
        word-break: break-word;
        line-height: 1.2;
        pointer-events: none;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8); /* Add shadow for better readability */
    }

    /* Styles for different overlay shapes (applied by JS) */
    .overlay.shape-rectangle { border-radius: 3px; } /* Slight rounding for default rectangle */
    .overlay.shape-roundedRectangle { border-radius: 15px; } /* More pronounced rounding */
    .overlay.shape-oval { border-radius: 50%; } /* Makes it an oval or circle */


    /* Revealed elements */
    .overlay.revealed {
        opacity: 0; /* Start hidden */
        transition: opacity 0.5s ease-in-out, background-color 0.2s,
                    border-color 0.2s, border-style 0.2s;
    }

    /* Hover Text (using data attribute set by JS) */
    .overlay::after {
        content: attr(data-hover-text); /* Get text from data attribute */
        position: absolute;
        bottom: -30px; /* Position below the overlay */
        left: 50%;
        transform: translateX(-50%); /* Center the text */
        background-color: rgba(0, 0, 0, 0.7); /* Dark background */
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap; /* Prevent text wrapping */
        z-index: 3;
        opacity: 0;
        visibility: hidden;
        pointer-events: none; /* Prevent interference */
        transition: opacity 0.2s ease-out, visibility 0.2s ease-out;
    }

    .overlay:hover {
        /* Hover effects can be subtle now as primary style is dynamic */
        filter: brightness(1.1); /* Slightly brighten on hover */
         /* Keep prominent border on hover IF outline is enabled */
         /* This is tricky with dynamic styles, JS might need to handle hover border */
         /* Example: JS could add a class on hover */
    }
     /* Example hover class (add/remove with JS) */
    .overlay.is-hovering {
         filter: brightness(1.1);
         /* You could potentially override border here if needed,
            but it might conflict with dynamic styles. */
         /* border-width: 3px !important; */ /* Use with caution */
    }


    /* Show the hover text - only if no overlay text is present */
    .overlay:not(.has-overlay-text):hover::after {
        opacity: 1;
        visibility: visible;
    }

    /* Style for element when its modal is open */
    .overlay.highlighted-for-modal {
        /* Use outline instead of border to avoid layout shifts */
        outline: 3px solid #1a73e8;
        outline-offset: 2px; /* Space between element and outline */
        box-shadow: 0 0 12px rgba(26, 115, 232, 0.5);
        z-index: 105; /* Ensure it's above dimmer and modal */
         /* Slightly dim the element itself to make outline pop */
         /* filter: brightness(0.9); */
    }

    /* Style for temporary highlight interaction */
     .overlay.highlighted-temporary {
        /* Apply styles directly via JS for immediate feedback */
        transition: background-color 0.1s, box-shadow 0.1s, filter 0.1s;
     }

    /* Control bar */
    .control-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 15px;
      background-color: #f5f5f5;
      border-top: 1px solid #ddd;
      flex-shrink: 0;
    }
    .slide-nav { display: flex; align-items: center; gap: 10px; }
    .nav-button {
      background-color: #1a73e8; color: white; border: none; border-radius: 4px;
      padding: 8px 15px; cursor: pointer; font-size: 0.9rem; display: flex;
      align-items: center; gap: 5px; transition: background-color 0.2s;
    }
    .nav-button:hover { background-color: #1558b7; }
    .nav-button:disabled { background-color: #b0bec5; cursor: not-allowed; }
    .slide-indicator { padding: 0 15px; color: #666; font-size: 0.9rem; }

    /* Text modal */
    #textModal {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.75);
      display: none; justify-content: center; align-items: center; z-index: 100;
      opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s;
    }
    #textModal.visible { opacity: 1; visibility: visible; display: flex; }
    #textModalContent {
      background-color: white; padding: 30px; border-radius: 8px;
      max-width: 80%; max-height: 80%; overflow: auto;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3); position: relative;
      transform: scale(0.9); transition: transform 0.3s;
    }
     #textModal.visible #textModalContent { transform: scale(1); }
    #closeModal {
      position: absolute; top: 10px; right: 10px; background: none; border: none;
      font-size: 1.8rem; cursor: pointer; color: #aaa; line-height: 1; padding: 0 5px;
    }
     #closeModal:hover { color: #333; }
    #modalText { margin-bottom: 15px; line-height: 1.6; }
    .modal-navigation {
      display: flex; justify-content: space-between; margin-top: 20px;
      padding-top: 15px; border-top: 1px solid #eee;
      gap: 15px; /* Add gap between buttons */
    }
    .modal-navigation button {
      padding: 8px 16px; background-color: #1a73e8; color: white; border: none;
      border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 5px;
      min-width: 100px; /* Set minimum width */
    }

    /* Animations, Loading, Error, Spotlight, Debug etc. - UNCHANGED from previous version */
    /* --- Animation Keyframes & Classes --- */
      /* --- Animation Keyframes & Classes --- */
    /* Existing */
    @keyframes pulse_anim { 0%, 100% { transform: scale(1); opacity: 0.7; } 50% { transform: scale(1.05); opacity: 1; } }
    @keyframes wiggle_anim { 0%, 100% { transform: rotate(0deg); } 25% { transform: rotate(3deg); } 75% { transform: rotate(-3deg); } }
    @keyframes float_anim { 0%, 100% { transform: translateY(0px); } 50% { transform: translateY(-8px); } }
    /* NEW Keyframes */
    @keyframes bounce_anim { 0%, 20%, 50%, 80%, 100% { transform: translateY(0); } 40% { transform: translateY(-10px); } 60% { transform: translateY(-5px); } }
    @keyframes shake_anim { 0% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); } 20%, 40%, 60%, 80%, 100% { transform: translateX(4px); } }
    @keyframes flash_anim { 0%, 100% { opacity: 1; } 50% { opacity: 0.2; } }
    @keyframes growShrink_anim { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.08); } }
    /* Spotlight text bubble animation */
    @keyframes bubbleFadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    #spotlightTextBubble {
        animation: bubbleFadeIn 0.3s ease-out forwards;
    }

    /* Notes panel animation */
    @keyframes notesPanelFadeIn {
        from { opacity: 0; transform: translate(-50%, 20px); }
        to { opacity: 1; transform: translate(-50%, 0); }
    }

    #spotlightNotesPanel {
        animation: notesPanelFadeIn 0.3s ease-out forwards;
    }

    /* Base Animation Classes */
    .animate-pulse { animation: pulse_anim 2s infinite ease-in-out; }
    .animate-wiggle { animation: wiggle_anim 0.5s infinite ease-in-out; }
    .animate-float { animation: float_anim 3s infinite ease-in-out; }
    .animate-bounce { animation: bounce_anim 1.5s infinite ease-in-out; }
    .animate-shake { animation: shake_anim 0.6s infinite ease-in-out; }
    .animate-flash { animation: flash_anim 1s infinite steps(1, end); }
    .animate-growShrink { animation: growShrink_anim 2s infinite ease-in-out; }

    /* Speed/Intensity Variants */
    /* Pulse */
    .animate-pulse.slow { animation-duration: 3s; }
    .animate-pulse.medium { animation-duration: 2s; }
    .animate-pulse.fast { animation-duration: 1s; }
    /* Wiggle */
    .animate-wiggle.gentle { animation-duration: 1s; transform-origin: center; } /* Gentle needs longer duration */
    .animate-wiggle.medium { animation-duration: 0.5s; transform-origin: center; }
    .animate-wiggle.strong { animation-duration: 0.3s; transform-origin: center; }
    /* Float */
    .animate-float.slow { animation-duration: 4s; }
    .animate-float.medium { animation-duration: 3s; }
    .animate-float.fast { animation-duration: 2s; }

    /* Loading overlay */
    .loading-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(255, 255, 255, 0.8); display: flex; flex-direction: column;
      justify-content: center; align-items: center; z-index: 1000;
    }
    .loading-spinner {
      border: 5px solid #f3f3f3; border-top: 5px solid #1a73e8; border-radius: 50%;
      width: 50px; height: 50px; animation: spin 1s linear infinite; margin-bottom: 20px;
    }
    .loading-message { font-size: 1.2rem; color: #333; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* Error message */
    .error-message {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      background-color: #f44336; color: white; padding: 15px 20px; border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1001; max-width: 80%;
      display: none; /* Initially hidden */
    }

    /* Dim/Spotlight Overlay */
    .dim-overlay {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.7); /* Adjust darkness */
      z-index: 90; /* Below modal, above most content */
      opacity: 0;
      visibility: hidden;
      pointer-events: none; /* Prevent interaction when hidden */
      transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
      cursor: pointer; /* Indicate it's clickable to dismiss */
    }
    .dim-overlay.active {
      opacity: 1;
      visibility: visible;
      pointer-events: auto; /* Allow clicking the overlay to dismiss */
    }
    /* Style for the element being spotlighted */
    .overlay.spotlight-active {
        z-index: 95 !important; /* Ensure spotlighted element is above dimmer */
        background-color: transparent !important;
        border: 2px solid rgba(255, 255, 255, 0.9) !important; /* White highlight */
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.7), 
                    0 0 30px rgba(255, 255, 255, 0.3) !important; /* Glowing effect */
        cursor: default !important; /* Don't show click cursor */
        pointer-events: none !important; /* Prevent interaction with the highlighted element */
    }

    /* Hide the "Click here" text when spotlighted */
    .overlay.spotlight-active::after {
        display: none !important;
    }
    
    /* --- Spotlight Navigation Buttons --- */
    @keyframes buttonPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .spotlight-nav-button {
      padding: 6px 12px;
      background-color: #1a73e8;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: background-color 0.2s, opacity 0.2s;
    }

    .spotlight-nav-button:hover:not(:disabled) {
      background-color: #1558b7;
      animation: buttonPulse 0.5s ease-in-out;
    }

    .spotlight-nav-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .spotlight-nav-button span {
      font-size: 16px;
      line-height: 1;
    }

    /* Spotlight text bubble animations */
    @keyframes bubbleEnter {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    #spotlightTextBubble {
      animation: bubbleEnter 0.3s forwards;
    }

    /* Navigation container in spotlight text */
    .spotlight-nav-container {
      display: flex;
      justify-content: space-between;
      margin-top: 12px;
      padding-top: 10px;
      border-top: 1px solid #eee;
    }

    /* Debug Tools */
    .debug-info {
      position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7);
      color: white; padding: 10px; border-radius: 4px; font-size: 12px;
      z-index: 1000; max-width: 300px; max-height: 200px; overflow: auto;
      display: none; /* Hidden by default */
    }
    .debug-toggle {
      position: fixed; bottom: 10px; right: 10px; /* Position toggle initially */
      background: #1a73e8; color: white; border: none; border-radius: 4px;
      padding: 5px 10px; font-size: 12px; cursor: pointer; z-index: 1001;
      display: none; /* Hidden by default, enabled via debugMode flag */
    }
    .debug-toggle.active {
       right: 320px; /* Move toggle when info panel is shown */
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .header h1 { font-size: 1.2rem; }
      #slideTitle { max-width: 40%; }
      #textModalContent { max-width: 95%; padding: 15px; }
      .nav-button { padding: 6px 10px; font-size: 0.8rem; }
      .slide-indicator { padding: 0 10px; }
      .control-bar { padding: 8px 10px; }
    }
  </style>
</head>
<body>
  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div class="loading-message">Loading presentation...</div>
  </div>

  <!-- Dim/Spotlight Overlay -->
  <div class="dim-overlay" id="dimOverlay"></div>

  <!-- Main Container -->
  <div class="container">
    <div class="header">
      <h1>Interactive Training</h1>
      <div class="nav-controls">
        <span id="slideTitle"></span>
      </div>
    </div>

    <div class="slide-container" id="slideContainer">
      <div class="slide" id="slide">
        <img class="slide-background" id="slideBackground" src="" alt="Slide background">
        <!-- Overlays will be added here dynamically -->
      </div>
    </div>

    <div class="control-bar">
      <div class="slide-nav">
        <button id="prevSlideBtn" class="nav-button" disabled>
          <span>←</span> Previous
        </button>
        <span class="slide-indicator" id="slideIndicator">Slide 1 of 1</span>
        <button id="nextSlideBtn" class="nav-button" disabled>
          Next <span>→</span>
        </button>
      </div>
      <div>
        <button id="restartBtn" class="nav-button">
          <span>↺</span> Restart
        </button>
      </div>
    </div>
  </div>

  <!-- Text modal -->
  <div id="textModal">
    <div id="textModalContent">
      <button id="closeModal">×</button>
      <div id="modalText"></div>
      <div class="modal-navigation">
        <button id="prevElementBtn">
          <span>←</span> Previous
        </button>
        <button id="nextElementBtn">
          Next <span>→</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Error Message Area -->
  <div id="errorMessage" class="error-message"></div>

  <!-- Debug tools -->
  <button id="debugToggle" class="debug-toggle">Debug</button>
  <div id="debugInfo" class="debug-info"></div>


<script>
    // ---------- Global Variables ----------
    const presentationId = "<?= presentationId ?>"; // Injected by GAS doGet
    let currentSlide = null;
    let currentSlideIndex = 0;
    let totalSlides = 0;
    let overlayElementsMap = new Map(); // Map<elementId, overlayDiv>
    // Store full element data received from backend
    let currentSlideElementsData = [];
    let interactiveElements = []; // Subset of currentSlideElementsData with interactions/animations
    let currentModalElementIndex = -1;
    let currentSpotlightElementIndex = -1;
    let lastActiveElementId = null; // NEW: Track the last element interacted with
    let spotlightableElements = [];
    let isSpotlightActive = false;
    let debugMode = false; // Set true for local debugging
    let permanentlyHiddenElementsPerSlide = {}; // NEW: Track hidden elements { slideIndex: Set<elementId> }
    let navSequenceElements = [];
    
    // NEW: Store global overlay defaults received from backend
    let globalOverlayDefaults = {
        shape: 'rectangle', color: '#e53935', opacity: 15, outlineEnabled: true,
        outlineColor: '#e53935', outlineWidth: 1, outlineStyle: 'dashed',
        textColor: '#ffffff', textSize: 14, hoverText: 'Click here'
    };

    // DOM element references (mostly unchanged)
    const slideContainer = document.getElementById('slideContainer');
    const slideElement = document.getElementById('slide');
    const slideBackground = document.getElementById('slideBackground');
    const slideIndicator = document.getElementById('slideIndicator');
    const prevSlideBtn = document.getElementById('prevSlideBtn');
    const nextSlideBtn = document.getElementById('nextSlideBtn');
    const restartBtn = document.getElementById('restartBtn');
    const slideTitleElement = document.getElementById('slideTitle');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const textModal = document.getElementById('textModal');
    const modalTextDiv = document.getElementById('modalText');
    const closeModalBtn = document.getElementById('closeModal');
    const prevElementBtn = document.getElementById('prevElementBtn');
    const nextElementBtn = document.getElementById('nextElementBtn');
    const dimOverlay = document.getElementById('dimOverlay');
    const errorElement = document.getElementById('errorMessage');
    const debugToggle = document.getElementById('debugToggle');
    const debugInfo = document.getElementById('debugInfo');

    // ---------- Initialization ----------
    window.addEventListener('load', () => {
      logDebug(`[WebApp] Starting with presentation ID: ${presentationId}`);
      setupEventListeners();
      setupDebugTools();
      loadSlide(0); // Load the first slide
      window.addEventListener('resize', handleResize);
    });

    function setupEventListeners() {
      prevSlideBtn.addEventListener('click', () => loadSlide(currentSlideIndex - 1));
      nextSlideBtn.addEventListener('click', () => loadSlide(currentSlideIndex + 1));
      restartBtn.addEventListener('click', () => loadSlide(0));
      closeModalBtn.addEventListener('click', hideTextModal);
      textModal.addEventListener('click', (e) => { if (e.target === textModal) hideTextModal(); });
      dimOverlay.addEventListener('click', hideSpotlight);
      prevElementBtn.addEventListener('click', navigateToPrevElement);
      nextElementBtn.addEventListener('click', navigateToNextElement);
    }

    function setupDebugTools() {
      if (debugMode) {
        debugToggle.style.display = 'block';
        debugToggle.addEventListener('click', () => {
          const showDebug = debugInfo.style.display === 'none';
          debugInfo.style.display = showDebug ? 'block' : 'none';
          debugToggle.classList.toggle('active', showDebug);
          debugToggle.textContent = showDebug ? 'Hide Debug' : 'Debug';
        });
      } else {
         debugToggle.style.display = 'none';
         debugInfo.style.display = 'none';
      }
    }

    function logDebug(message, data) {
        if (debugMode) {
            console.log(message, data !== undefined ? data : '');
            if (debugInfo.style.display !== 'none') {
               const time = new Date().toLocaleTimeString();
               debugInfo.innerHTML = `[${time}] ${message}<br>` + debugInfo.innerHTML;
            }
        }
    }

    function updateDebugInfo(info) {
        if (!debugMode || debugInfo.style.display === 'none') return;
        const time = new Date().toLocaleTimeString();
        debugInfo.innerHTML = `[${time}] ${info}<br>` + debugInfo.innerHTML;
    }

    function handleResize() {
      if (currentSlide) {
        adjustSlideSize();
        renderOverlays();
      }
    }

    // ---------- Slide Loading ----------
    /**
     * Loads a slide by index and prepares it for display.
     * Improved version with better visibility state tracking.
     * @param {number} index - The 0-based index of the slide to load
     */
    function loadSlide(index) {
        if (index < 0 || (totalSlides > 0 && index >= totalSlides)) {
            logDebug(`[WebApp] Invalid slide index requested: ${index}`);
            return;
        }
        
        logDebug(`[WebApp] Loading slide index: ${index}, current index: ${currentSlideIndex}`);

        // Save visibility states before changing slides
        if (currentSlideIndex !== index && interactiveElements.length > 0) {
            // Get all currently visible element IDs
            const visibleElementIds = new Set(overlayElementsMap.keys());
            
            // Get all interactive element IDs 
            const allInteractiveIds = interactiveElements.map(el => el.id);
            
            // Initialize the set if it doesn't exist
            if (!permanentlyHiddenElementsPerSlide[currentSlideIndex]) {
                permanentlyHiddenElementsPerSlide[currentSlideIndex] = new Set();
            }
            
            // Update the hidden set: any element not in the visible set is hidden
            allInteractiveIds.forEach(id => {
                if (!visibleElementIds.has(id)) {
                    permanentlyHiddenElementsPerSlide[currentSlideIndex].add(id);
                    logDebug(`[WebApp] Saving element ${id} as hidden for slide ${currentSlideIndex}`);
                }
            });
            
            logDebug(`[WebApp] Saved hidden state for slide ${currentSlideIndex}. Hidden: ${Array.from(permanentlyHiddenElementsPerSlide[currentSlideIndex]).length} elements`);
        }

        showLoading("Loading slide...");
        hideTextModal();
        hideSpotlight();
        clearOverlays();
        overlayElementsMap.clear();
        
        // Reset all state variables
        currentSlideElementsData = [];
        interactiveElements = [];
        currentModalElementIndex = -1;
        currentSpotlightElementIndex = -1;
        lastActiveElementId = null;
        navSequenceElements = [];

        // Initialize the hidden set for the target slide if it doesn't exist
        if (!permanentlyHiddenElementsPerSlide[index]) {
            permanentlyHiddenElementsPerSlide[index] = new Set();
            logDebug(`[WebApp] Initialized hidden set for slide ${index}`);
        } else {
            logDebug(`[WebApp] Using existing hidden set for slide ${index} with ${permanentlyHiddenElementsPerSlide[index].size} elements`);
        }

        google.script.run
            .withSuccessHandler(handleSlideData)
            .withFailureHandler(handleLoadError)
            .getSlideDataForWebApp(presentationId, index);
    }

    /**
     * Handles slide data received from the backend and prepares it for display.
     * Improved version with better error handling and background caching integration.
     * @param {Object} data - The slide data object from the backend.
     */
    function handleSlideData(data) {
      logDebug(`[WebApp] Received slide data:`, data);
      
      // Safety timeout - ensure loading overlay gets hidden even if image loading hangs
      const loadingTimeout = setTimeout(() => {
        console.warn("[WebApp] Loading timeout reached, forcing hide of loading overlay");
        hideLoading();
      }, 5000); // 5 seconds timeout
      
      if (data.error) {
        handleLoadError(data.error);
        // Try to show minimal info if possible
        currentSlideIndex = data.index !== undefined ? data.index : currentSlideIndex;
        totalSlides = data.total !== undefined ? data.total : totalSlides;
        updateSlideNavControls(); // Update nav buttons even on error
        clearTimeout(loadingTimeout); // Clear the safety timeout
        return;
      }

      currentSlide = data;
      currentSlideIndex = data.index;
      totalSlides = data.total;
      
      // Store all element data, including non-interactive elements
      currentSlideElementsData = data.elements || [];
      
      // Handle global overlay settings from Code.gs
      if (data.globalOverlayDefaults) {
        logDebug("[WebApp] Using globalOverlayDefaults from server:", data.globalOverlayDefaults);
        globalOverlayDefaults = data.globalOverlayDefaults;
        overlayOpacity = data.globalOverlayDefaults.opacity !== undefined ? 
                         data.globalOverlayDefaults.opacity : 0;
        overlayShadow = data.globalOverlayDefaults.outlineEnabled !== undefined ? 
                        data.globalOverlayDefaults.outlineEnabled : true;
      } else {
        // Fallback to defaults
        logDebug("[WebApp] No globalOverlayDefaults provided, using defaults");
        overlayOpacity = 0;
        overlayShadow = true;
      }
      logDebug(`[WebApp] Applied overlay settings: Opacity=${overlayOpacity}%, Shadow=${overlayShadow}`);

      // Filter interactive elements
      interactiveElements = currentSlideElementsData.filter(el => {
        const hasInteraction = el.interaction && 
                              el.interaction.type && 
                              el.interaction.type !== 'none';
        const hasAnimation = el.animation && 
                            el.animation.type && 
                            el.animation.type !== 'none';
        
        // Also consider elements with overlay style but no interaction type as interactive
        const hasOverlayStyle = el.interaction && 
                              el.interaction.overlayStyle &&
                              Object.keys(el.interaction.overlayStyle).length > 0;
                              
        return hasInteraction || hasAnimation || hasOverlayStyle;
      });
      
      logDebug(`[WebApp] Found ${interactiveElements.length} interactive elements out of ${currentSlideElementsData.length} total`);
      
      currentModalElementIndex = -1; // Reset modal index

      updateSlideNavControls(); // Update buttons and indicator
      slideTitleElement.textContent = data.notes || ''; // Display speaker notes as title

      // Handle background image loading with proper error handling
      if (data.backgroundUrl) {
        logDebug("[WebApp] Setting background image from server cache...");
        slideBackground.src = data.backgroundUrl;
        
        // Set up proper loading events
        slideBackground.onload = () => {
          clearTimeout(loadingTimeout);
          logDebug("[WebApp] Background image loaded successfully");
          onSlideContentReady();
        };
        
        slideBackground.onerror = () => {
          clearTimeout(loadingTimeout);
          logDebug("[WebApp] Background image failed to load, continuing with blank background");
          slideBackground.src = ''; // Clear the source to avoid broken image icon
          onSlideContentReady();
        };
        
        // Failsafe in case events don't fire
        setTimeout(() => {
          if (loadingOverlay.style.display !== 'none') {
            clearTimeout(loadingTimeout);
            logDebug("[WebApp] Background image loading timeout, continuing anyway");
            onSlideContentReady();
          }
        }, 2000);
      } else {
        logDebug("[WebApp] No background image, using blank slide");
        slideBackground.src = '';
        clearTimeout(loadingTimeout);
        setTimeout(onSlideContentReady, 100);
      }
    }

    function onSlideContentReady() {
      try {
        logDebug("[WebApp] Preparing slide content...");
        adjustSlideSize(); // Calculate and apply slide dimensions
        renderOverlays(); // Render interactive overlays based on new size
        
        // Now restore visibility states based on our tracked hidden elements
        restoreHiddenElementState();
        
        // Update navigation sequence to reflect visible elements
        buildNavigationSequence();
        
        hideLoading(); // Hide loading indicator
        logDebug("[WebApp] Slide ready!");
      } catch (err) {
        console.error("[WebApp] Error in onSlideContentReady:", err);
        showError("Failed to prepare slide: " + err.message);
        hideLoading(); // Ensure loading indicator is hidden even on error
      }
    }

    function updateSlideNavControls() {
        slideIndicator.textContent = `Slide ${currentSlideIndex + 1} of ${totalSlides}`;
        prevSlideBtn.disabled = currentSlideIndex === 0;
        nextSlideBtn.disabled = currentSlideIndex >= totalSlides - 1;
    }

    // ---------- Overlay Rendering (UPDATED) ----------

    // Helper to convert HEX and opacity (0-100) to RGBA CSS string
    function hexToRgba(hex, opacityPercent) {
        // Added default hex color if input is invalid
        if (!hex || typeof hex !== 'string' || !/^#([0-9A-F]{3}){1,2}$/i.test(hex)) {
            hex = '#000000'; // Default to black if invalid hex
            console.warn(`[WebApp] Invalid hex color received ('${hex}'), defaulting to black.`);
        }
        
        hex = hex.replace('#', '');
        let r, g, b;
    
        try { // Add try-catch for safety during parsing
            if (hex.length === 3) {
                r = parseInt(hex[0] + hex[0], 16);
                g = parseInt(hex[1] + hex[1], 16);
                b = parseInt(hex[2] + hex[2], 16);
            } else { // Assume 6 length after regex check
                r = parseInt(hex.substring(0, 2), 16);
                g = parseInt(hex.substring(2, 4), 16);
                b = parseInt(hex.substring(4, 6), 16);
            }
        } catch (e) {
            console.error("Error parsing hex color:", hex, e);
            r = g = b = 0; // Default to black on error
        }
    
        // Clamp opacityPercent between 0 and 100, default to 0 if invalid, then convert to 0-1 alpha
        const numOpacity = parseFloat(opacityPercent);
        // Default to 15 if NaN or undefined, otherwise clamp
        const clampedOpacity = (isNaN(numOpacity) || typeof opacityPercent === 'undefined') ? 15 : Math.max(0, Math.min(100, numOpacity));
        const alpha = clampedOpacity / 100;
    
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function adjustSlideSize() {
        const containerWidth = slideContainer.clientWidth;
        const containerHeight = slideContainer.clientHeight;
        
        // Get slide aspect ratio (16:9 is standard for presentations)
        const slideAspectRatio = currentSlide.slideWidth / currentSlide.slideHeight || 16 / 9;
        
        // Calculate dimensions that fit within the container while maintaining aspect ratio
        let targetWidth, targetHeight;
        
        // Use container width and calculate height based on aspect ratio
        if (containerWidth / containerHeight > slideAspectRatio) {
            // Container is wider than slide aspect ratio, so height is the limiting factor
            targetHeight = containerHeight;
            targetWidth = targetHeight * slideAspectRatio;
        } else {
            // Container is taller than slide aspect ratio, so width is the limiting factor
            targetWidth = containerWidth;
            targetHeight = targetWidth / slideAspectRatio;
        }
        
        // Apply the calculated dimensions to the slide
        slideElement.style.width = `${targetWidth}px`;
        slideElement.style.height = `${targetHeight}px`;
        
        // Calculate scaling factors to scale the position and size of overlays
        const scaleX = targetWidth / (currentSlide.slideWidth || 960);
        const scaleY = targetHeight / (currentSlide.slideHeight || 540);
        
        // Store scale values as data attributes for later use
        slideElement.dataset.scaleX = scaleX;
        slideElement.dataset.scaleY = scaleY;
        slideElement.dataset.origWidth = currentSlide.slideWidth || 960;
        slideElement.dataset.origHeight = currentSlide.slideHeight || 540;
        
        logDebug(`[WebApp] Slide dimensions adjusted to ${targetWidth.toFixed(1)}x${targetHeight.toFixed(1)}, Scale: ${scaleX.toFixed(4)}x${scaleY.toFixed(4)}`);
    }

    // Main function to apply styles (custom or global)
    function applyOverlayStyle(overlay, element) {
        // Default opacity from global settings
        let opacityValue = overlayOpacity / 100;
        
        try {
            // Check if the element has custom opacity settings
            if (element && element.interaction) {
                if (element.interaction.useCustomOpacity && 
                    typeof element.interaction.customOpacity === 'number') {
                    // Use element-specific opacity
                    opacityValue = element.interaction.customOpacity / 100;
                    logDebug(`[WebApp] Using custom opacity: ${element.interaction.customOpacity}% for element ${element.id}`);
                }
                
                // Check if the element has custom overlay style
                if (element.interaction.overlayStyle) {
                    const customStyle = element.interaction.overlayStyle;
                    
                    // If custom style includes opacity setting, use that
                    if (typeof customStyle.opacity === 'number') {
                        opacityValue = customStyle.opacity / 100;
                        logDebug(`[WebApp] Using overlayStyle.opacity: ${customStyle.opacity}% for element ${element.id}`);
                    }
                    
                    // Special handling for zero opacity
                    if (opacityValue <= 0.01) {
                        // Make completely invisible but keep interactive
                        overlay.style.backgroundColor = 'rgba(0, 0, 0, 0)';
                        overlay.style.border = 'none';
                        overlay.style.boxShadow = 'none';
                        logDebug(`[WebApp] Applied zero opacity (invisible but interactive) for element ${element.id}`);
                        return; // Skip further styling
                    }
                    
                    // Apply custom color if specified
                    if (customStyle.color) {
                        // Get the RGB color components
                        let r = 229, g = 57, b = 53; // Default red
                        
                        try {
                            // Try to parse color from hex
                            if (customStyle.color.startsWith('#')) {
                                const hex = customStyle.color.substring(1);
                                if (hex.length === 3) {
                                    r = parseInt(hex[0] + hex[0], 16);
                                    g = parseInt(hex[1] + hex[1], 16);
                                    b = parseInt(hex[2] + hex[2], 16);
                                } else if (hex.length === 6) {
                                    r = parseInt(hex.substring(0, 2), 16);
                                    g = parseInt(hex.substring(2, 4), 16);
                                    b = parseInt(hex.substring(4, 6), 16);
                                }
                            }
                        } catch (colorErr) {
                            console.error("[WebApp] Error parsing custom color:", colorErr);
                        }
                        
                        // Apply the color with calculated opacity
                        overlay.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacityValue})`;
                        logDebug(`[WebApp] Applied custom color: rgba(${r}, ${g}, ${b}, ${opacityValue})`);
                    } else {
                        // No custom color, use default red with calculated opacity
                        overlay.style.backgroundColor = `rgba(229, 57, 53, ${opacityValue})`;
                    }
                    
                    // Apply other custom style properties if needed
                    if (customStyle.shape === 'roundedRectangle') {
                        overlay.style.borderRadius = '8px';
                    } else if (customStyle.shape === 'oval') {
                        overlay.style.borderRadius = '50%';
                    }
                    
                    // Apply custom outline
                    if (customStyle.outlineEnabled) {
                        const outlineColor = customStyle.outlineColor || '#e53935';
                        const outlineWidth = customStyle.outlineWidth || 1;
                        const outlineStyle = customStyle.outlineStyle || 'dashed';
                        overlay.style.border = `${outlineWidth}px ${outlineStyle} ${outlineColor}`;
                    } else {
                        overlay.style.border = 'none';
                    }
                    
                    return; // Skip default styling
                }
            }
        } catch (err) {
            console.error("[WebApp] Error applying custom style:", err);
            // Fall back to default styling below
        }
        
        // Special handling for zero opacity in default styling
        if (opacityValue <= 0.01) {
            // Make completely invisible but keep interactive
            overlay.style.backgroundColor = 'rgba(0, 0, 0, 0)';
            overlay.style.border = 'none';
            overlay.style.boxShadow = 'none';
            logDebug(`[WebApp] Applied zero opacity (invisible but interactive) with default styling`);
            return; // Skip further styling
        }
        
        // Default styling if no custom style or on error
        overlay.style.backgroundColor = `rgba(229, 57, 53, ${opacityValue})`;
        
        // Apply default border/outline
        if (overlayShadow) {
            overlay.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.3)';
            overlay.style.border = '1px dashed rgba(229, 57, 53, 0.5)';
        } else {
            overlay.style.border = '1px dashed rgba(229, 57, 53, 0.5)';
            overlay.style.boxShadow = 'none';
        }
    }

    function addOverlayText(overlay, text, element) {
        if (!text || !text.trim()) return;

        const textElement = document.createElement('div');
        textElement.className = 'overlay-text';
        textElement.textContent = text;
        // Find the style settings - either from element's custom style or global defaults
        let textColor = '#ffffff';
        let textSize = 14;
        let useBackground = false; // New setting for background

        try {
            // Check element's custom style first
            if (element && element.interaction && element.interaction.overlayStyle) {
                const customStyle = element.interaction.overlayStyle;
                textColor = customStyle.textColor || globalOverlayDefaults.textColor;
                textSize = customStyle.textSize || globalOverlayDefaults.textSize;
                useBackground = customStyle.textBackground || false;
            } else {
                // Fall back to global defaults
                textColor = globalOverlayDefaults.textColor;
                textSize = globalOverlayDefaults.textSize;
                useBackground = globalOverlayDefaults.textBackground || false;
            }
        } catch (err) {
            console.error(`[WebApp] Error applying text style for ${overlay.dataset.elementId}:`, err);
            // Use fallback values already set
        }

        // Apply the styles directly
        textElement.style.color = textColor;
        textElement.style.fontSize = `${textSize}px`;

        // Only add background if configured
        if (useBackground) {
            textElement.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        } else {
            textElement.style.backgroundColor = 'transparent'; // Ensure no background if not set
        }

        overlay.appendChild(textElement);
        overlay.classList.add('has-overlay-text');
        logDebug(`[WebApp] Added overlay text "${text}" with color ${textColor}, size ${textSize}px to element ${overlay.dataset.elementId}`);
    }

    /**
     * Renders all interactive overlay elements onto the current slide.
     * Updated to handle sequential appearance behavior.
     */
    function renderOverlays() {
        logDebug(`[WebApp] [renderOverlays] Start - Rendering overlays for ${interactiveElements.length} interactive elements on slide ${currentSlideIndex}`);

        // Force-clear any previous overlays
        const existingOverlays = slideElement.querySelectorAll('.overlay');
        logDebug(`[WebApp] [renderOverlays] Found ${existingOverlays.length} existing overlays to remove.`);
        existingOverlays.forEach(overlay => {
            if (overlay.parentNode) {
                overlay.parentNode.removeChild(overlay);
            }
        });
        overlayElementsMap.clear();
        logDebug(`[WebApp] [renderOverlays] Cleared existing overlays and map.`);

        // Reset appearance tracking
        let pendingAppearanceElements = new Map(); // Map<elementId, {data, behavior, dependsOn}>
        let visibleElementIds = new Set(); // Track which elements are currently visible

        if (!currentSlide || !currentSlideElementsData) {
            logDebug('[WebApp] [renderOverlays] No current slide or element data, skipping overlay rendering.');
            return;
        }

        // Re-filter interactive elements to be safe
        interactiveElements = currentSlideElementsData.filter(el => {
            const hasInteraction = el.interaction && el.interaction.type && el.interaction.type !== 'none';
            const hasAnimation = el.animation && el.animation.type && el.animation.type !== 'none';
            const hasOverlayStyle = el.interaction && el.interaction.overlayStyle && Object.keys(el.interaction.overlayStyle).length > 0;
            return hasInteraction || hasAnimation || hasOverlayStyle;
        });
        logDebug(`[WebApp] [renderOverlays] Re-filtered interactive elements count: ${interactiveElements.length}`);

        if (interactiveElements.length === 0) {
            logDebug('[WebApp] [renderOverlays] No interactive elements to render.');
            buildNavigationSequence(); // Still build sequence (might be empty)
            return;
        }

        // Get the set of hidden elements for the CURRENT slide index
        const currentHiddenSet = permanentlyHiddenElementsPerSlide[currentSlideIndex] || new Set();
        logDebug(`[WebApp] [renderOverlays] Checking against hidden set for slide ${currentSlideIndex}. Set contains ${currentHiddenSet.size} elements:`, Array.from(currentHiddenSet));

        // First pass: determine which elements should be visible immediately and which should be deferred
        interactiveElements.forEach((element) => {
            // Skip if element is marked as permanently hidden
            if (currentHiddenSet.has(element.id)) {
                logDebug(`[WebApp] [renderOverlays] SKIPPING render (permanently hidden): ${element.id}`);
                return; // Don't render or track for appearance
            }

            // Skip elements targeted by 'revealElement' that shouldn not be visible initially
            if (isTargetOfReveal(element.id)) {
                logDebug(`[WebApp] [renderOverlays] SKIPPING initial render (reveal target): ${element.id}`);
                return;
            }

            // Check appearance behavior
            const interaction = element.interaction || {};
            const appearanceBehavior = interaction.appearanceBehavior || 'withPresentation';

            if (appearanceBehavior === 'withPresentation') {
                // Show immediately with the presentation
                if (renderElement(element)) { // Only add if render succeeded
                    visibleElementIds.add(element.id);
                    logDebug(`[WebApp] [renderOverlays] Rendered element with presentation: ${element.id}`);
                }
            } else {
                // Store for later appearance
                pendingAppearanceElements.set(element.id, {
                    data: element,
                    behavior: appearanceBehavior,
                    dependsOn: interaction.appearAfterElementId || null
                });
                logDebug(`[WebApp] [renderOverlays] Element ${element.id} will appear ${appearanceBehavior} (depends on: ${interaction.appearAfterElementId || 'none'})`);
            }
        });

        // After rendering initial elements, check for any that should appear with them
        checkPendingAppearances(pendingAppearanceElements, visibleElementIds);

        // Build the navigation sequence once all initially visible elements are rendered
        buildNavigationSequence();

        logDebug(`[WebApp] [renderOverlays] Finished rendering. Visible: ${visibleElementIds.size}, Pending: ${pendingAppearanceElements.size}`);
    }


    /**
     * Renders a single element on the slide.
     * @param {Object} element - The element data to render
     * @returns {HTMLElement|null} - The created overlay element or null if failed
     */
    function renderElement(element) {
        try {
            // *** Check for DIRECT position properties ***
            if (!element || typeof element.top !== 'number' || typeof element.left !== 'number' ||
                typeof element.width !== 'number' || typeof element.height !== 'number') {
                logError(`[WebApp] [renderElement] Invalid element data received, missing direct position properties: ${JSON.stringify(element)}`);
                return null; // Cannot render without position/size
            }
            // *** END CHECK ***

            const scaleX = parseFloat(slideElement.dataset.scaleX) || 1;
            const scaleY = parseFloat(slideElement.dataset.scaleY) || 1;
            const slideWidthOrig = parseFloat(slideElement.dataset.origWidth) || 960;
            const slideHeightOrig = parseFloat(slideElement.dataset.origHeight) || 540;

            // Calculate position/size with precise scaling
            // Position is relative to slide origin (0,0)
            const left = Math.round(element.left * scaleX * 100) / 100;
            const top = Math.round(element.top * scaleY * 100) / 100;
            // Ensure minimum dimensions after scaling
            const width = Math.round(Math.max(element.width * scaleX, 10) * 100) / 100;
            const height = Math.round(Math.max(element.height * scaleY, 10) * 100) / 100;

            // *** ADDED DEBUG LOGGING START ***
            logDebug(`[WebApp] [renderElement ${element.id}] Scales: x=${scaleX.toFixed(4)}, y=${scaleY.toFixed(4)}`);
            logDebug(`[WebApp] [renderElement ${element.id}] Original Slide Size: ${slideWidthOrig}x${slideHeightOrig}`);
            logDebug(`[WebApp] [renderElement ${element.id}] Original Element Pos: T=${element.top}, L=${element.left}, W=${element.width}, H=${element.height}`);
            logDebug(`[WebApp] [renderElement ${element.id}] Calculated Style: T=${top.toFixed(2)}px, L=${left.toFixed(2)}px, W=${width.toFixed(2)}px, H=${height.toFixed(2)}px`);
            // *** ADDED DEBUG LOGGING END ***

            const overlay = document.createElement('div');
            overlay.className = 'overlay';
            overlay.dataset.elementId = element.id;

            // Apply the calculated position and size
            overlay.style.position = 'absolute';
            overlay.style.left = `${left}px`;
            overlay.style.top = `${top}px`;
            overlay.style.width = `${width}px`;
            overlay.style.height = `${height}px`;

            applyOverlayStyle(overlay, element);

            // Add text to overlay if configured
            if (element.interaction && element.interaction.showOverlayText && element.interaction.overlayText) {
                addOverlayText(overlay, element.interaction.overlayText, element); // Pass element for style lookup
            }

            // Add hover text (displayed as tooltip)
            if (element.interaction?.overlayStyle?.hoverText || globalOverlayDefaults.hoverText) {
                const hoverText = element.interaction?.overlayStyle?.hoverText || globalOverlayDefaults.hoverText;
                overlay.dataset.hoverText = hoverText;
            }

            // Set tooltip for debugging
            let tooltipParts = [`ID: ${element.id}`];
            if (element.interaction?.type && element.interaction.type !== 'none') tooltipParts.push(`I: ${element.interaction.type}`);
            if (element.interaction?.overlayStyle) tooltipParts.push(`[Style]`);
            if (element.animation?.type && element.animation.type !== 'none') tooltipParts.push(`A: ${element.animation.type}`);
            overlay.title = tooltipParts.join(' | ');

            // Add event listeners
            overlay.addEventListener('click', () => handleOverlayClick(element, element.id));
            overlay.addEventListener('mouseenter', () => overlay.classList.add('is-hovering'));
            overlay.addEventListener('mouseleave', () => overlay.classList.remove('is-hovering'));

            // Apply animation if configured
            if (element.animation && element.animation.type && element.animation.type !== 'none') {
                applyAnimation(overlay, element.animation);
            }

            // Add overlay to the slide and tracking Map
            slideElement.appendChild(overlay);
            overlayElementsMap.set(element.id, overlay);
            logDebug(`[WebApp] [renderElement] Successfully rendered overlay for ${element.id}`);

            return overlay;
        } catch (err) {
            // Use logError which includes console.error
            logError(`[WebApp] [renderElement] Error rendering element ${element?.id || 'unknown'}: ${err.message}`, err);
            return null;
        }
    }


    function isTargetOfReveal(elementId) {
        if (!currentSlide || !currentSlideElementsData) return false;
        // Check if any element on the slide has an interaction that targets this elementId
        return currentSlideElementsData.some(el =>
            (el.interaction?.type === 'revealElement' && el.interaction.targetElementId === elementId) ||
            (el.interaction?.type === 'revealAndSpotlight' && el.interaction.targetElementId === elementId)
        );
    }


    function applyAnimation(overlay, animation) {
        const animationClass = getAnimationClass(animation.type);
        if (!animationClass) {
            logDebug(`[WebApp] Unknown animation type: ${animation.type}`);
            return;
        }

        let speedClass = '';
        // Set speed/intensity classes
        if (animation.type === 'pulse' && animation.pulseSpeed) {
            speedClass = animation.pulseSpeed;
        } else if (animation.type === 'wiggle' && animation.wiggleIntensity) {
            speedClass = animation.wiggleIntensity;
        } else if (animation.type === 'float' && animation.floatSpeed) {
            speedClass = animation.floatSpeed;
        }

        const trigger = animation.trigger || 'automatic';
        logDebug(`[WebApp] Applying animation: ${animation.type} (${trigger}) to ${overlay.dataset.elementId} with speed/intensity: ${speedClass || 'default'}`);

        // For debugging, add a data attribute to confirm animation is applied
        overlay.dataset.animationType = animation.type;
        overlay.dataset.animationTrigger = trigger;

        switch (trigger) {
            case 'automatic':
                overlay.classList.add(animationClass);
                if (speedClass) overlay.classList.add(speedClass);
                break;
            case 'onHover':
                overlay.addEventListener('mouseenter', () => {
                    overlay.classList.add(animationClass);
                    if (speedClass) overlay.classList.add(speedClass);
                });
                overlay.addEventListener('mouseleave', () => {
                    overlay.classList.remove(animationClass);
                    if (speedClass) overlay.classList.remove(speedClass);
                });
                break;
            case 'onClick':
                // Handled within handleOverlayClick
                break;
            default:
                logDebug(`[WebApp] Unknown animation trigger: ${trigger}`);
        }

        // Log confirmation that animation was applied
        if (trigger === 'automatic') {
            logDebug(`[WebApp] Applied automatic animation ${animationClass} ${speedClass} to element ${overlay.dataset.elementId}`);
        }
    }


    /**
     * Checks for elements that should appear based on currently visible elements.
     * Handles cascading appearances where one element triggers others.
     * @param {Map} pendingAppearanceElements - Map of elements waiting to appear.
     * @param {Set} visibleElementIds - Set of currently visible element IDs.
     */
    function checkPendingAppearances(pendingAppearanceElements, visibleElementIds) {
        let newlyVisible = false;

        // First check elements that should appear WITH other elements
        pendingAppearanceElements.forEach((info, elementId) => {
            if (info.behavior === 'appearWith' && info.dependsOn && visibleElementIds.has(info.dependsOn)) {
                // The element it depends on is visible, so this one should also be visible
                logDebug(`[WebApp] [checkPendingAppearances] Element ${elementId} should appear with ${info.dependsOn}`);
                if (renderElement(info.data)) { // Render the element
                    visibleElementIds.add(elementId); // Mark as visible
                    pendingAppearanceElements.delete(elementId); // Remove from pending
                    newlyVisible = true; // Flag that a change occurred
                    logDebug(`[WebApp] [checkPendingAppearances] Rendered element ${elementId} with ${info.dependsOn}`);
                } else {
                    logError(`[WebApp] [checkPendingAppearances] Failed to render element ${elementId} scheduled to appear with ${info.dependsOn}`);
                    pendingAppearanceElements.delete(elementId); // Remove even if failed to prevent infinite loops
                }
            }
        });

        // If any new elements became visible, recursively check again
        // This handles cascading dependencies: A → B → C
        if (newlyVisible) {
            logDebug(`[WebApp] [checkPendingAppearances] New elements became visible, checking again`);
            checkPendingAppearances(pendingAppearanceElements, visibleElementIds);
        }
    }


    function clearOverlays() {
      overlayElementsMap.forEach(overlay => {
        if (overlay.parentNode) {
          overlay.parentNode.removeChild(overlay);
        }
      });
      overlayElementsMap.clear();
      logDebug('[WebApp] Cleared overlays');
    }


    function getAnimationClass(type) {
        switch (type) {
            case 'pulse': return 'animate-pulse';
            case 'wiggle': return 'animate-wiggle';
            case 'float': return 'animate-float';
            case 'bounce': return 'animate-bounce';
            case 'shake': return 'animate-shake';
            case 'flash': return 'animate-flash';
            case 'growShrink': return 'animate-growShrink';
            default: return null;
        }
    }


    /**
     * Handles click events on overlay elements, managing interactions, animations, and sequential appearances.
     * @param {Object} element - The element data object (might be stale, use ID to refetch)
     * @param {string} clickedElementId - The ID of the clicked element
     */
    function handleOverlayClick(element, clickedElementId) {
        // Debug logging
        logDebug(`[WebApp] Click handler triggered for: ${clickedElementId || 'unknown'}`, element);

        // Use the passed elementId or fall back to the element's id property
        const elementId = clickedElementId || element?.id;

        if (!elementId) {
            logError('[WebApp] handleOverlayClick called without a valid element ID.');
            return;
        }

        // Find the most up-to-date element data using the ID
        const currentElementData = currentSlideElementsData.find(el => el.id === elementId);

        if (!currentElementData) {
            logError(`[WebApp] Could not find current element data for ID: ${elementId} in handleOverlayClick`);
            return;
        }
        logDebug(`[WebApp] Processing click for element: ${elementId}`);

        let interactionHandled = false;
        let interactionType = 'none'; // Keep track of the type handled

        // --- Handle Interactions First ---
        if (currentElementData.interaction &&
            currentElementData.interaction.type &&
            currentElementData.interaction.type !== 'none') {

            const interaction = currentElementData.interaction;
            interactionType = interaction.type; // Store the type
            logDebug(`[WebApp] Handling interaction: ${interactionType}`);

            switch (interactionType) {
                case 'showText':
                    if (interaction.text) {
                        showTextModal(interaction.text, elementId);
                        interactionHandled = true;
                    }
                    break;
                case 'spotlight':
                    showSpotlight(elementId, interaction);
                    interactionHandled = true;
                    break;
                case 'revealElement':
                    if (interaction.targetElementId) {
                        revealElement(interaction.targetElementId, elementId, interaction.keepTriggerVisible);
                        interactionHandled = true;
                    }
                    break;
                case 'revealAndSpotlight':
                    if (interaction.targetElementId) {
                        logDebug(`[WebApp] Handling revealAndSpotlight. Trigger: ${elementId}, Target: ${interaction.targetElementId}`);
                        revealElement(interaction.targetElementId, elementId, interaction.keepTriggerVisible);
                        // Spotlight the *target* element after a delay to allow reveal
                        setTimeout(() => {
                            const targetData = currentSlideElementsData.find(el => el.id === interaction.targetElementId);
                            if (targetData && overlayElementsMap.has(interaction.targetElementId)) {
                                // Use the target's interaction data if available, otherwise create minimal spotlight data
                                const spotlightInteraction = targetData.interaction?.type === 'spotlight' ? targetData.interaction : { type: 'spotlight', text: interaction.text, notes: interaction.notes };
                                logDebug(`[WebApp] Applying spotlight to revealed element: ${interaction.targetElementId}`);
                                showSpotlight(interaction.targetElementId, spotlightInteraction);
                            } else {
                                logError(`[WebApp] Failed to find or spotlight revealed element ${interaction.targetElementId} after revealAndSpotlight`);
                                showError(`Failed to spotlight target element. Please try again.`);
                            }
                        }, 500); // Increased timeout for more reliability
                        interactionHandled = true;
                    }
                    break;
                case 'temporaryHighlight':
                     const overlay = overlayElementsMap.get(elementId);
                     if (overlay && interaction.highlightStyle) {
                         const originalBg = overlay.style.backgroundColor;
                         const originalBorder = overlay.style.border;
                         const originalShadow = overlay.style.boxShadow;
                         const duration = interaction.highlightDuration || 500; // Default 500ms

                         logDebug(`[WebApp] Applying temporary highlight to ${elementId} for ${duration}ms`);
                         // Apply highlight styles
                         if (interaction.highlightStyle.color) {
                             overlay.style.backgroundColor = hexToRgba(interaction.highlightStyle.color, interaction.highlightStyle.opacity ?? 50);
                         }
                         if (interaction.highlightStyle.outlineEnabled) {
                             overlay.style.border = `${interaction.highlightStyle.outlineWidth || 2}px ${interaction.highlightStyle.outlineStyle || 'solid'} ${interaction.highlightStyle.outlineColor || '#FFFF00'}`;
                         }
                         overlay.style.boxShadow = '0 0 10px rgba(255, 255, 0, 0.7)'; // Yellow glow

                         // Revert after duration
                         setTimeout(() => {
                             overlay.style.backgroundColor = originalBg;
                             overlay.style.border = originalBorder;
                             overlay.style.boxShadow = originalShadow;
                         }, duration);
                         interactionHandled = true;
                     }
                     break;
                // Add other interaction types here
            }
        }

        // --- Handle Animation Triggered by Click ---
        if (!interactionHandled && currentElementData.animation &&
            currentElementData.animation.type && currentElementData.animation.type !== 'none' &&
            currentElementData.animation.trigger === 'onClick') {

            const animation = currentElementData.animation;
            const overlay = overlayElementsMap.get(elementId);
            if (overlay) {
                logDebug(`[WebApp] Click animation triggered: ${animation.type}`);
                const animationClass = getAnimationClass(animation.type);
                let speedClass = '';
                if (animation.type === 'pulse' && animation.pulseSpeed) speedClass = animation.pulseSpeed;
                else if (animation.type === 'wiggle' && animation.wiggleIntensity) speedClass = animation.wiggleIntensity;
                else if (animation.type === 'float' && animation.floatSpeed) speedClass = animation.floatSpeed;

                if (animationClass) {
                    overlay.classList.add(animationClass);
                    if (speedClass) overlay.classList.add(speedClass);

                    // Remove animation after it plays (assuming non-infinite duration or handle differently)
                    // This requires knowing animation durations, which we don't have easily.
                    // Simple approach: remove after a fixed time slightly longer than typical animations.
                    const duration = 1000; // Adjust as needed
                    setTimeout(() => {
                        if (overlayElementsMap.has(elementId)) { // Check if element still exists
                            overlay.classList.remove(animationClass);
                            if (speedClass) overlay.classList.remove(speedClass);
                            logDebug(`[WebApp] Click animation ${animationClass} finished.`);
                        }
                    }, duration);
                }
                // If animation has showTextOnClick
                if (animation.showTextOnClick && animation.text) {
                    showTextModal(animation.text, elementId);
                }
            }
        }

        // --- Handle Disappear On Click Functionality ---
        if (currentElementData.interaction && currentElementData.interaction.disappearOnClick) {
            const overlay = overlayElementsMap.get(elementId);
            if (overlay) {
                logDebug(`[WebApp] Element ${elementId} disappearing on click.`);
                if (overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                }
                overlayElementsMap.delete(elementId);

                // Add to the set of permanently hidden elements for this slide
                if (!permanentlyHiddenElementsPerSlide[currentSlideIndex]) {
                    permanentlyHiddenElementsPerSlide[currentSlideIndex] = new Set();
                }
                permanentlyHiddenElementsPerSlide[currentSlideIndex].add(elementId);
                logDebug(`[WebApp] Added ${elementId} to hidden set for slide ${currentSlideIndex}`);

                // Rebuild navigation sequence as an element was removed
                buildNavigationSequence();
            }
        }

        // --- Handle Sequential Appearances ---
        // Check for elements that should appear after this one was clicked
        const elementsToAppear = currentSlideElementsData.filter(el =>
            el.interaction?.appearanceBehavior === 'appearAfterClick' &&
            el.interaction?.appearAfterElementId === elementId &&
            !overlayElementsMap.has(el.id) // Only consider elements not yet visible
        );

        if (elementsToAppear.length > 0) {
            logDebug(`[WebApp] Found ${elementsToAppear.length} elements to appear after clicking ${elementId}`);
            elementsToAppear.forEach(elToAppear => {
                if (renderElement(elToAppear)) {
                    logDebug(`[WebApp] Rendered element ${elToAppear.id} after click on ${elementId}`);
                } else {
                    logError(`[WebApp] Failed to render element ${elToAppear.id} scheduled to appear after click on ${elementId}`);
                }
            });
            // Rebuild navigation sequence after new elements appear
            buildNavigationSequence();
        }

        // --- NEW: Update lastActiveElementId AFTER handling interaction ---
        lastActiveElementId = elementId;
        logDebug(`[WebApp] Updated lastActiveElementId to: ${lastActiveElementId}`);
        // --- End NEW ---

        // Update navigation sequence and buttons slightly later to allow DOM changes
        setTimeout(() => {
            buildNavigationSequence(); // Ensure sequence is up-to-date
            updateSpotlightNavButtons(); // Update spotlight buttons if active
            updateModalNavigationButtons(); // Update modal buttons if active
            forceEnableNavigationButtons(); // Ensure main nav buttons are enabled if needed
            logDebug(`[WebApp] handleOverlayClick completed for ${elementId}, navigation updated`);
        }, 600); // Keep delay
    }



    function hasSpotlightCapability(element) {
        return element && element.interaction && (
            element.interaction.type === 'spotlight' ||
            element.interaction.type === 'revealAndSpotlight' ||
            (element.interaction.showText && element.interaction.text) // Elements with text can be spotlighted
        );
    }


    /**
     * Builds the list of elements that can be spotlighted in sequence.
     * @returns {number} The number of spotlightable elements found.
     */
    function buildSpotlightableElementsList() {
        // Reset the list
        spotlightableElements = [];
        // Get currently visible elements
        const currentlyVisibleElementIds = new Set(overlayElementsMap.keys());

        // Filter interactive elements that are visible and have spotlight capability
        spotlightableElements = interactiveElements.filter(el =>
            currentlyVisibleElementIds.has(el.id) && hasSpotlightCapability(el)
        );

        logDebug(`[WebApp] Built spotlightable elements list with ${spotlightableElements.length} elements`);

        // If not enough elements, log it (navigation will be disabled automatically)
        if (spotlightableElements.length <= 1) {
            logDebug(`[WebApp] Not enough spotlight elements for navigation`);
        }

        // Return the number of elements found
        return spotlightableElements.length;
    }


    /**
     * Shows the spotlight effect focusing on a specific element.
     * @param {string} targetId - The ID of the element to spotlight.
     * @param {Object} interactionData - The interaction data for the spotlight.
     */
    function showSpotlight(targetId, interactionData) {
        logDebug(`[WebApp] showSpotlight called for target: ${targetId}`, interactionData);
        hideSpotlight(); // Hide any existing spotlight first

        const targetElement = overlayElementsMap.get(targetId);
        if (!targetElement) {
            logError(`[WebApp] Cannot show spotlight: Target element ${targetId} not found in overlay map.`);
            // Attempt to find the element data even if not rendered
            const targetData = currentSlideElementsData.find(el => el.id === targetId);
            if (targetData && permanentlyHiddenElementsPerSlide[currentSlideIndex]?.has(targetId)) {
                 logDebug(`[WebApp] Element ${targetId} is permanently hidden`);
                 showError(`Cannot spotlight element (ID: ${targetId.substring(0,8)}...). It has been hidden.`);
            } else {
                 showError(`Cannot spotlight element (ID: ${targetId.substring(0,8)}...). It may not be visible yet.`);
            }
            return;
        }

        const targetRect = targetElement.getBoundingClientRect();
        logDebug(`[WebApp] Target element rect:`, targetRect);

        // Activate the dim overlay
        dimOverlay.classList.add('active');
        dimOverlay.style.pointerEvents = 'auto'; // Allow clicks on the overlay

        // Highlight the target element
        targetElement.classList.add('spotlight-active');

        // Store current spotlight info globally
        window.currentSpotlight = {
            targetId: targetId,
            targetRect: targetRect,
            interaction: interactionData || {} // Store interaction data
        };

        isSpotlightActive = true;

        // Show text bubble if configured
        if (interactionData.showText && interactionData.text) {
            showSpotlightText(interactionData.text, targetRect);
        }

        // Show notes panel if configured
        if (interactionData.showNotes && interactionData.notes) {
            showSpotlightNotes(interactionData.notes);
        }

        // Update spotlight navigation buttons
        buildSpotlightableElementsList(); // Ensure list is current
        currentSpotlightElementIndex = spotlightableElements.findIndex(el => el.id === targetId);
        logDebug(`[WebApp] Current spotlight index set to: ${currentSpotlightElementIndex}`);
        updateSpotlightNavButtons();

        // Disable main nav buttons while spotlight is active
        prevSlideBtn.disabled = true;
        nextSlideBtn.disabled = true;
        restartBtn.disabled = true;

        logDebug(`[WebApp] Spotlight activated for element: ${targetId}`);
    }


    /**
     * Hides the spotlight effect and cleans up all related elements.
     */
    function hideSpotlight() {
        if (!isSpotlightActive && !dimOverlay.classList.contains('active')) {
            // logDebug("[WebApp] hideSpotlight called but spotlight wasn't active.");
            return; // Already hidden or not active
        }
        logDebug("[WebApp] Hiding spotlight...");

        dimOverlay.classList.remove('active');
        dimOverlay.style.pointerEvents = 'none';

        // Remove highlight from the previously spotlighted element
        if (window.currentSpotlight && window.currentSpotlight.targetId) {
            const targetElement = overlayElementsMap.get(window.currentSpotlight.targetId);
            if (targetElement) {
                targetElement.classList.remove('spotlight-active');
            }
        }

        hideSpotlightText();
        hideSpotlightNotes();

        // Clear global spotlight info after a short delay
        setTimeout(() => {
            window.currentSpotlight = {};
        }, 200); // Delay to allow fade-out effects

        isSpotlightActive = false;
        currentSpotlightElementIndex = -1; // Reset index

        // Re-enable main nav buttons after a delay
        setTimeout(() => {
            forceEnableNavigationButtons();
        }, 100);

        logDebug("[WebApp] Spotlight hidden.");
    }


    /**
     * Creates and displays the text bubble for the spotlight.
     * @param {string} text - The text content for the bubble.
     * @param {DOMRect} targetRect - The bounding rectangle of the spotlighted element.
     */
    function showSpotlightText(text, targetRect) {
        hideSpotlightText(); // Remove any existing bubble first

        const bubble = document.createElement('div');
        bubble.id = 'spotlightTextBubble';
        bubble.style.position = 'fixed';
        bubble.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
        bubble.style.color = '#333';
        bubble.style.padding = '15px';
        bubble.style.borderRadius = '8px';
        bubble.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
        bubble.style.maxWidth = '350px';
        bubble.style.zIndex = '101'; // Above dim overlay
        bubble.style.opacity = '0'; // Start hidden for animation
        bubble.style.transition = 'opacity 0.3s';
        bubble.style.fontSize = '14px';
        bubble.style.lineHeight = '1.5';

        // Content
        const textContent = document.createElement('div');
        textContent.innerHTML = text.replace(/\\n/g, '<br>'); // Support newlines
        bubble.appendChild(textContent);

        // Navigation Container
        const navDiv = document.createElement('div');
        navDiv.className = 'spotlight-nav-container'; // Use class for styling

        const prevBtn = document.createElement('button');
        prevBtn.id = 'spotlightPrevBtn';
        prevBtn.className = 'spotlight-nav-button';
        prevBtn.innerHTML = '<span>←</span> Prev';
        prevBtn.addEventListener('click', navigateToPrevSpotlight);

        const nextBtn = document.createElement('button');
        nextBtn.id = 'spotlightNextBtn';
        nextBtn.className = 'spotlight-nav-button';
        nextBtn.innerHTML = 'Next <span>→</span>';
        nextBtn.addEventListener('click', navigateToNextSpotlight);

        navDiv.appendChild(prevBtn);
        navDiv.appendChild(nextBtn);

        // Add buttons to the container only if there's more than one spotlightable element
        if (spotlightableElements.length > 1) {
             bubble.appendChild(navDiv);
        }

        document.body.appendChild(bubble);

        // Position the bubble (prefer below, fallback above)
        const bubbleRect = bubble.getBoundingClientRect();
        const spaceBelow = window.innerHeight - targetRect.bottom;
        const spaceAbove = targetRect.top;
        const margin = 15; // Space between element and bubble

        let top, left;

        if (spaceBelow > bubbleRect.height + margin || spaceBelow >= spaceAbove) {
            // Position below
            top = targetRect.bottom + margin;
        } else {
            // Position above
            top = targetRect.top - bubbleRect.height - margin;
        }

        // Center horizontally, ensuring it stays within viewport
        left = targetRect.left + targetRect.width / 2 - bubbleRect.width / 2;
        left = Math.max(10, Math.min(left, window.innerWidth - bubbleRect.width - 10)); // Clamp within viewport

        bubble.style.top = `${top}px`;
        bubble.style.left = `${left}px`;

        // Trigger fade-in animation
        requestAnimationFrame(() => {
            bubble.style.opacity = '1';
        });

        logDebug(`[WebApp] Spotlight text shown. Current index: ${currentSpotlightElementIndex}, Total elements: ${spotlightableElements.length}`);
        updateSpotlightNavButtons(); // Update button states immediately
    }


    /**
     * Removes the spotlight text bubble from the DOM.
     */
    function hideSpotlightText() {
        const bubble = document.getElementById('spotlightTextBubble');
        if (bubble) {
            bubble.style.opacity = '0'; // Start fade out
            setTimeout(() => { // Remove from DOM after transition
                 if (bubble.parentNode) {
                     bubble.parentNode.removeChild(bubble);
                 }
            }, 300); // Match transition duration
        }
    }


    /**
     * Creates and displays the speaker notes panel below the spotlight bubble.
     * @param {string} notes - The speaker notes content.
     */
    function showSpotlightNotes(notes) {
        hideSpotlightNotes(); // Remove existing notes panel

        const notesPanel = document.createElement('div');
        notesPanel.id = 'spotlightNotesPanel';
        notesPanel.style.position = 'fixed';
        notesPanel.style.bottom = '20px'; // Position at the bottom
        notesPanel.style.left = '50%';
        notesPanel.style.transform = 'translateX(-50%)'; // Center horizontally
        notesPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        notesPanel.style.color = '#eee';
        notesPanel.style.padding = '15px 20px';
        notesPanel.style.borderRadius = '8px';
        notesPanel.style.maxWidth = '60%';
        notesPanel.style.maxHeight = '25vh'; // Limit height
        notesPanel.style.overflowY = 'auto';
        notesPanel.style.zIndex = '102'; // Above bubble
        notesPanel.style.opacity = '0'; // Start hidden for animation
        notesPanel.style.transition = 'opacity 0.3s';
        notesPanel.style.fontSize = '14px';
        notesPanel.style.lineHeight = '1.5';

        // Add a title and the notes content
        notesPanel.innerHTML = `<div style="font-weight: bold; margin-bottom: 8px; color: #ccc;">Speaker Notes:</div>${notes.replace(/\\n/g, '<br>')}`;

        document.body.appendChild(notesPanel);

        // Trigger fade-in animation
        requestAnimationFrame(() => {
            notesPanel.style.opacity = '1';
        });
        logDebug("[WebApp] Speaker notes panel shown.");
    }


    /**
     * Removes the speaker notes panel from the DOM.
     */
    function hideSpotlightNotes() {
        const panel = document.getElementById('spotlightNotesPanel');
        if (panel) {
             panel.style.opacity = '0'; // Start fade out
             setTimeout(() => { // Remove from DOM after transition
                 if (panel.parentNode) {
                     panel.parentNode.removeChild(panel);
                 }
             }, 300); // Match transition duration
        }
    }


    /**
     * Updates the state (enabled/disabled) of the spotlight navigation buttons.
     */
    function updateSpotlightNavButtons() {
        const prevBtn = document.getElementById('spotlightPrevBtn');
        const nextBtn = document.getElementById('spotlightNextBtn');

        if (!prevBtn || !nextBtn || !isSpotlightActive) {
            // logDebug("[WebApp] updateSpotlightNavButtons: Buttons not found or spotlight not active.");
            return; // Buttons might not exist if text bubble isn't shown or spotlight inactive
        }

        const numSpotlightable = spotlightableElements.length;
        prevBtn.disabled = currentSpotlightElementIndex <= 0;
        nextBtn.disabled = currentSpotlightElementIndex >= numSpotlightable - 1;

        // Ensure cursor style reflects disabled state
        prevBtn.style.cursor = prevBtn.disabled ? 'not-allowed' : 'pointer';
        nextBtn.style.cursor = nextBtn.disabled ? 'not-allowed' : 'pointer';

        logDebug(`[WebApp] Spotlight nav buttons updated: Index ${currentSpotlightElementIndex}, Total ${numSpotlightable}, Prev enabled: ${!prevBtn.disabled}, Next enabled: ${!nextBtn.disabled}`);
    }


    /**
     * Navigates to the previous element in the spotlight sequence.
     */
    function navigateToPrevSpotlight() {
        if (currentSpotlightElementIndex <= 0 || !window.currentSpotlight) return;

        // Get the previous element
        const prevElement = spotlightableElements[currentSpotlightElementIndex - 1];
        if (!prevElement) return;

        logDebug(`[WebApp] Navigating to previous spotlight: ${prevElement.id}`);
        // Hide current spotlight effects immediately before showing the next
        hideSpotlight();

        // Show spotlight for the previous element after a short delay
        setTimeout(() => {
             showSpotlight(prevElement.id, prevElement.interaction);
        }, 100); // Small delay
    }


    /**
     * Navigates to the next element in the spotlight sequence.
     */
    function navigateToNextSpotlight() {
        if (currentSpotlightElementIndex >= spotlightableElements.length - 1 || !window.currentSpotlight) return;

        // Get the next element
        const nextElement = spotlightableElements[currentSpotlightElementIndex + 1];
        if (!nextElement) return;

        logDebug(`[WebApp] Navigating to next spotlight: ${nextElement.id}`);
        // Hide current spotlight effects immediately before showing the next
        hideSpotlight();

        // Show spotlight for the next element after a short delay
        setTimeout(() => {
            showSpotlight(nextElement.id, nextElement.interaction);
        }, 100); // Small delay
    }


    // ---------- Modal Functions ----------
    /**
     * Shows the text modal with the given content and updates navigation.
     * This function is now simpler, focusing only on display and basic setup.
     * Navigation logic is handled by buildNavigationSequence and updateModalNavigationButtons.
     * @param {string} text - The text to display in the modal.
     * @param {string} elementId - The ID of the element that triggered the modal.
     */
    function showTextModal(text, elementId) {
        logDebug(`[WebApp] Showing text modal for element: ${elementId}`);
        modalTextDiv.innerHTML = text.replace(/\\n/g, '<br>');
        textModal.classList.add('visible');

        // Ensure navigation buttons exist and have correct listeners
        // Remove old listeners and add new ones to prevent duplicates
        const modalPrevBtn = document.getElementById('prevElementBtn');
        const modalNextBtn = document.getElementById('nextElementBtn');

        if (modalPrevBtn && modalNextBtn) {
            // Clone and replace to remove all old listeners reliably
            const freshPrevBtn = modalPrevBtn.cloneNode(true);
            const freshNextBtn = modalNextBtn.cloneNode(true);
            modalPrevBtn.parentNode.replaceChild(freshPrevBtn, modalPrevBtn);
            modalNextBtn.parentNode.replaceChild(freshNextBtn, modalNextBtn);

            // Add new listeners
            freshPrevBtn.addEventListener('click', navigateToPrevElement);
            freshNextBtn.addEventListener('click', navigateToNextElement);

            // Update button states based on the sequence
            buildNavigationSequence(); // Ensure sequence is up-to-date
            updateModalNavigationButtons(elementId); // Update based on current element

            // Show/hide based on sequence length
            const modalNavigation = document.querySelector('.modal-navigation');
            if (modalNavigation) {
                modalNavigation.style.display = navSequenceElements.length > 1 ? 'flex' : 'none';
            }
             // Force enable after a moment
             setTimeout(forceEnableNavigationButtons, 100);
        } else {
             logDebug("[WebApp] Modal navigation buttons not found in showTextModal");
        }

        highlightActiveModalElement(elementId);
        lastActiveElementId = elementId; // Update last active ID when modal is shown
        logDebug(`[WebApp] showTextModal set lastActiveElementId to: ${lastActiveElementId}`); // Log the element that triggered the modal
    }


    /**
     * Hides the text modal and resets related states.
     */
    function hideTextModal() {
        if (!textModal.classList.contains('visible')) return; // Already hidden

        logDebug('[WebApp] Hiding text modal');
        textModal.classList.remove('visible');
        resetModalElementHighlights();
        // Don't reset lastActiveElementId here, keep it for main navigation context

        // Re-enable main nav buttons after a delay
        setTimeout(forceEnableNavigationButtons, 100);
    }


    /**
     * Updates to the navigation functions to ensure they work with all interaction types
     */
    function navigateToNextElement() {
        logDebug("[WebApp] navigateToNextElement called");
        if (navSequenceElements.length === 0) {
            logDebug("[WebApp] Navigation sequence is empty.");
            return;
        }

        // Determine current index
        let currentIndex = -1;
        if (isSpotlightActive && window.currentSpotlight?.targetId) {
            currentIndex = navSequenceElements.findIndex(el => el.id === window.currentSpotlight.targetId);
            logDebug(`[WebApp] Current index based on spotlight: ${currentIndex} (Target ID: ${window.currentSpotlight.targetId})`);
        } else if (textModal.classList.contains('visible') && lastActiveElementId) {
            // If modal is open, use the element associated with the modal
            currentIndex = navSequenceElements.findIndex(el => el.id === lastActiveElementId);
             logDebug(`[WebApp] Current index based on modal: ${currentIndex}`);
        } else if (lastActiveElementId) {
            // Use the last interacted element if it's in the sequence
            currentIndex = navSequenceElements.findIndex(el => el.id === lastActiveElementId);
            logDebug(`[WebApp] Current index based on lastActiveElementId: ${currentIndex} (ID: ${lastActiveElementId})`);
        } else {
            // If nothing is active, assume we start from the beginning
            currentIndex = 0;
            logDebug('[WebApp] No active context found, starting navigation from beginning.');
        }

        // Get next index (with wrap-around)
        const nextIndex = (currentIndex >= navSequenceElements.length - 1) ? 0 : currentIndex + 1;

        // Get the next element data
        const nextElement = navSequenceElements[nextIndex];
        if (!nextElement || !nextElement.id) {
            logDebug('[WebApp] Could not find valid next element data.');
            return false;
        }

        logDebug(`[WebApp] Navigating TO element: index=${nextIndex}, id=${nextElement.id}, type=${nextElement.interaction?.type}`);

        // Clean up current state BEFORE triggering the next
        hideSpotlight();
        hideTextModal();

        // Short delay to ensure clean state and DOM updates
        setTimeout(() => {
            logDebug(`[WebApp] Triggering interaction for next element: ${nextElement.id}`);
            // Simulate a click or directly call the interaction handler
            // Using handleOverlayClick ensures all logic (reveal, spotlight, text) is processed
            handleOverlayClick(nextElement, nextElement.id);
        }, 150); // Delay to allow hide animations/cleanup

        return true;
    }


    /**
     * Navigates to the previous element in the sequence, triggering its interaction.
     */
    function navigateToPrevElement() {
        logDebug("[WebApp] navigateToPrevElement called");
        if (navSequenceElements.length === 0) {
            logDebug("[WebApp] Navigation sequence is empty.");
            return;
        }

        // Determine current index
        let currentIndex = -1;
        if (isSpotlightActive && window.currentSpotlight?.targetId) {
            currentIndex = navSequenceElements.findIndex(el => el.id === window.currentSpotlight.targetId);
            logDebug(`[WebApp] Current index based on spotlight: ${currentIndex} (Target ID: ${window.currentSpotlight.targetId})`);
        } else if (textModal.classList.contains('visible') && lastActiveElementId) {
            // If modal is open, use the element associated with the modal
            currentIndex = navSequenceElements.findIndex(el => el.id === lastActiveElementId);
             logDebug(`[WebApp] Current index based on modal: ${currentIndex}`);
        } else if (lastActiveElementId) {
            // Use the last interacted element if it's in the sequence
            currentIndex = navSequenceElements.findIndex(el => el.id === lastActiveElementId);
            logDebug(`[WebApp] Current index based on lastActiveElementId: ${currentIndex} (ID: ${lastActiveElementId})`);
        } else {
            // If nothing is active, assume we wrap around from the end
            currentIndex = navSequenceElements.length; // Will become length-1 after we subtract 1
            logDebug('[WebApp] No active context, starting navigation from end for previous.');
        }

        // Get previous index (with wrap-around)
        const prevIndex = (currentIndex <= 0) ? navSequenceElements.length - 1 : currentIndex - 1;

        // Get the previous element data
        const prevElement = navSequenceElements[prevIndex];
        if (!prevElement || !prevElement.id) {
            logDebug('[WebApp] Could not find valid previous element data.');
            return false;
        }

        logDebug(`[WebApp] Navigating TO previous element: index=${prevIndex}, id=${prevElement.id}, type=${prevElement.interaction?.type}`);

        // Clean up current state BEFORE triggering the previous
        hideSpotlight();
        hideTextModal();

        // Short delay to ensure clean state and DOM updates
        setTimeout(() => {
            logDebug(`[WebApp] Triggering interaction for previous element: ${prevElement.id}`);
            // Simulate a click or directly call the interaction handler
            // Using handleOverlayClick ensures all logic (reveal, spotlight, text) is processed
            handleOverlayClick(prevElement, prevElement.id);
        }, 150); // Delay to allow hide animations/cleanup

        return true;
    }


    /**
     * IMPORTANT: Function to force enable navigation buttons
     * Call this after any spotlight or modal is shown
     */
    function forceEnableNavigationButtons() {
        try {
            const navButtons = [
                document.getElementById('spotlightPrevBtn'),
                document.getElementById('spotlightNextBtn'),
                document.getElementById('prevElementBtn'),
                document.getElementById('nextElementBtn')
            ];
            
            navButtons.forEach(button => {
                if (button) {
                    // Enable all buttons and restore styling
                    button.disabled = false;
                    button.style.opacity = '1';
                    button.style.cursor = 'pointer';
                    
                    // Remove and re-attach event listeners based on button ID
                    if (button.id === 'spotlightPrevBtn' || button.id === 'prevElementBtn') {
                        // Clone to remove old listeners and create fresh button
                        const newButton = button.cloneNode(true);
                        button.parentNode.replaceChild(newButton, button);
                        newButton.addEventListener('click', function(e) {
                            e.preventDefault();
                            if (textModal.classList.contains('visible')) {
                                hideTextModal();
                            }
                            if (isSpotlightActive) {
                                hideSpotlight();
                            }
                            setTimeout(() => navigateToPrevElement(), 50);
                        });
                    } else if (button.id === 'spotlightNextBtn' || button.id === 'nextElementBtn') {
                        const newButton = button.cloneNode(true);
                        button.parentNode.replaceChild(newButton, button);
                        newButton.addEventListener('click', function(e) {
                            e.preventDefault();
                            if (textModal.classList.contains('visible')) {
                                hideTextModal();
                            }
                            if (isSpotlightActive) {
                                hideSpotlight();
                            }
                            setTimeout(() => navigateToNextElement(), 50);
                        });
                    }
                }
            });
            
            logDebug('[WebApp] Navigation buttons force enabled with fresh event listeners');
        } catch (err) {
            console.error('[WebApp] Error in forceEnableNavigationButtons:', err);
        }
    }


    // ---------- Loading and Error Handling ----------
    function showLoading(message) {
      logDebug(`[WebApp] Showing loading: ${message}`);
      const msgElement = loadingOverlay.querySelector('.loading-message');
      if (msgElement) msgElement.textContent = message || "Loading...";
      loadingOverlay.style.display = 'flex';
    }

    function hideLoading() {
      logDebug(`[WebApp] Hiding loading`);
      loadingOverlay.style.display = 'none';
    }

    function showError(message) {
        const errorMessageText = message || "An unknown error occurred.";
        logError(`[WebApp] Displaying error: ${errorMessageText}`); // Use logError
        errorElement.textContent = errorMessageText;
        errorElement.style.display = 'block';
        // Hide the error message after a few seconds
        setTimeout(() => {
            errorElement.style.display = 'none';
        }, 5000); // Show for 5 seconds
    }

    function handleLoadError(error) {
      // Attempt to parse a more specific message
      let errorMessage = "Failed to load slide data.";
      if (typeof error === 'string') {
          errorMessage = error;
      } else if (error && error.message) {
          errorMessage = error.message;
      } else if (error && error.details) {
          errorMessage = error.details;
      }

      // Log the full error object for debugging
      logError(`[WebApp] Slide load failed: ${errorMessage}`, error); // Use logError

      showError(`Failed to load slide data: ${errorMessage}. Please check console logs or presentation access.`);
      hideLoading(); // Ensure loading is hidden on error
      // Optionally update nav controls if some data (like index/total) came through
      updateSlideNavControls();
    }

    // NEW: Centralized error logging
    function logError(message, errorObject) {
        console.error(`[WebApp] Error: ${message}`, errorObject || '');
        if (debugMode && debugInfo.style.display !== 'none') {
            const time = new Date().toLocaleTimeString();
            const errorText = errorObject ? (errorObject.message || JSON.stringify(errorObject)) : '';
            debugInfo.innerHTML = `<span style="color: #ff8a80;">[${time}] ERROR: ${message} ${errorText}</span><br>` + debugInfo.innerHTML;
        }
    }


    /**
     * Handles the Escape key press to close modal or spotlight.
     */
    function handleEscapeKey() {
        if (textModal.classList.contains('visible')) {
            logDebug("[WebApp] Escape key pressed, hiding modal.");
            hideTextModal();
        } else if (isSpotlightActive) {
            logDebug("[WebApp] Escape key pressed, hiding spotlight.");
            hideSpotlight();
        }
    }

    /**
     * Handles keyboard navigation (ArrowLeft, ArrowRight, Enter, Space).
     */
    function tryNavigateWithKeyboard(key) {
         // Don't navigate if an input field or textarea is focused
         if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) {
             return;
         }

        if (isSpotlightActive) {
            // Spotlight navigation
            if (key === 'ArrowRight' || key === ' ' || key === 'Enter') {
                logDebug("[WebApp] Keyboard: Next Spotlight");
                navigateToNextSpotlight();
            } else if (key === 'ArrowLeft') {
                logDebug("[WebApp] Keyboard: Previous Spotlight");
                navigateToPrevSpotlight();
            }
        } else if (textModal.classList.contains('visible')) {
            // Modal navigation
            if (key === 'ArrowRight' || key === ' ' || key === 'Enter') {
                logDebug("[WebApp] Keyboard: Next Modal Element");
                navigateToNextElement(); // Use general next function
            } else if (key === 'ArrowLeft') {
                logDebug("[WebApp] Keyboard: Previous Modal Element");
                navigateToPrevElement(); // Use general prev function
            }
        } else {
            // Main slide navigation (or element navigation if sequence exists)
            if (navSequenceElements.length > 0) {
                 // If there's an element sequence, prioritize that
                 if (key === 'ArrowRight' || key === ' ' || key === 'Enter') {
                     logDebug("[WebApp] Keyboard: Next Element (Main)");
                     navigateToNextElement();
                 } else if (key === 'ArrowLeft') {
                     logDebug("[WebApp] Keyboard: Previous Element (Main)");
                     navigateToPrevElement();
                 }
            } else {
                 // Fallback to slide navigation if no element sequence
                 if (key === 'ArrowRight' || key === ' ' || key === 'Enter') {
                     logDebug("[WebApp] Keyboard: Next Slide");
                     if (!nextSlideBtn.disabled) loadSlide(currentSlideIndex + 1);
                 } else if (key === 'ArrowLeft') {
                     logDebug("[WebApp] Keyboard: Previous Slide");
                     if (!prevSlideBtn.disabled) loadSlide(currentSlideIndex - 1);
                 }
            }
        }
    }


    // Keyboard event handler for navigation
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            handleEscapeKey();
        } else if (['ArrowLeft', 'ArrowRight', ' ', 'Enter'].includes(e.key)) {
            e.preventDefault(); // Prevent default space bar scroll, etc.
            tryNavigateWithKeyboard(e.key);
        }
    });

    // Add this function to create and expose the missing element data when we only have IDs
    function createElementDataFromId(targetId) {
        logDebug(`[WebApp] Creating element data from ID: ${targetId}`);
        // Check if data already exists
        let elementData = currentSlideElementsData.find(el => el.id === targetId);
        if (elementData) {
            return elementData;
        }

        // Check metadata if not found in main list
        const existsInMetadata = currentSlide.allElementIds && currentSlide.allElementIds.includes(targetId);
        if (existsInMetadata) {
            // Create minimal fallback data
            elementData = {
                id: targetId,
                top: (currentSlide.slideHeight || 540) / 2 - 25,
                left: (currentSlide.slideWidth || 960) / 2 - 50,
                width: 100,
                height: 50,
                interaction: { type: 'none' },
                animation: { type: 'none' }
            };
            logDebug(`[WebApp] Created minimal element data for ${targetId}`, elementData);
            // Optionally add this to currentSlideElementsData? Might pollute it.
            // currentSlideElementsData.push(elementData);
            return elementData;
        } else {
            logDebug(`[WebApp] ID ${targetId} not found in all slide elements list`);
            return null; // ID is completely unknown
        }
    }


    /**
     * Restores the hidden state of elements when navigating back to a slide.
     */
    function restoreHiddenElementState() {
        // Skip if there are no tracked hidden elements
        if (!permanentlyHiddenElementsPerSlide[currentSlideIndex] || 
            permanentlyHiddenElementsPerSlide[currentSlideIndex].size === 0) {
            logDebug(`[WebApp] No hidden elements to restore for slide ${currentSlideIndex}`);
            return;
        }
        
        const hiddenElements = permanentlyHiddenElementsPerSlide[currentSlideIndex];
        logDebug(`[WebApp] Restoring hidden state for ${hiddenElements.size} elements on slide ${currentSlideIndex}`);
        
        // For each element that should be hidden
        hiddenElements.forEach(elementId => {
            const overlay = overlayElementsMap.get(elementId);
            if (overlay) {
                // Hide the overlay with transition
                overlay.style.opacity = '0';
                overlay.style.pointerEvents = 'none';
                
                logDebug(`[WebApp] Restored hidden state for element ${elementId}`);
                
                // Remove from overlay map after transition completes
                setTimeout(() => {
                    if (overlay.parentNode) {
                        overlay.parentNode.removeChild(overlay);
                    }
                    overlayElementsMap.delete(elementId);
                    logDebug(`[WebApp] Removed element ${elementId} from DOM and map`);
                }, 300);
            } else {
                // Element might not have been rendered initially (e.g., appearAfterClick)
                // but was marked hidden. Ensure it's not in the map.
                if (overlayElementsMap.has(elementId)) {
                     overlayElementsMap.delete(elementId);
                }
                logDebug(`[WebApp] Element ${elementId} marked as hidden but not found in overlay map (may not have been rendered yet)`);
            }
        });
        logDebug(`[WebApp] Finished restoring hidden state for slide ${currentSlideIndex}`);
    }
</script>
</body>
</html>
