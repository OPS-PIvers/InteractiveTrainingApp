<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Training</title>
  <style>
    /* Reset and base styles */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; overflow: hidden; } /* Prevent body scroll */
    body {
      font-family: 'Roboto', Arial, sans-serif;
      font-size: 16px;
      line-height: 1.5;
      color: #333;
      background-color: #f5f5f5;
      display: flex; /* Use flex for layout */
      flex-direction: column;
      position: relative; /* Needed for fixed overlays */
    }

    /* Main container */
    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

    /* Header */
    .header {
      padding: 15px;
      background-color: #1a73e8;
      color: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 10;
      flex-shrink: 0;
    }
    .header h1 { font-size: 1.5rem; font-weight: 400; margin: 0; }
    .nav-controls { display: flex; align-items: center; gap: 15px; }
    #slideTitle { font-size: 0.9rem; opacity: 0.8; max-width: 50%; text-overflow: ellipsis; white-space: nowrap; overflow: hidden; }

    /* Slide container - uses flex to center the slide */
    .slide-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      background-color: #f5f5f5; /* Light gray background around the slide */
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px; /* Padding around the slide */
      min-height: 400px; /* Ensure a minimum height */
    }

    /* The slide itself - aspect ratio maintained by JS */
    .slide {
      position: relative; /* Crucial for absolute positioning of children */
      background-color: white; /* Background of the slide area itself */
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      overflow: hidden;
      /* Width and height set by JS to maintain aspect ratio */
    }

    /* Background image within the slide div */
    .slide-background {
      display: block; /* Remove extra space below img */
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      z-index: 1;
      object-fit: cover; /* Fills the entire area, cropping if necessary */
      object-position: center; /* Center the image if it needs to be cropped */
    }

    /* Overlay elements - positioned relative to .slide */
    .overlay {
        position: absolute;
        z-index: 2;
        cursor: pointer;
        /* Base styles - Specifics (color, border, etc.) set by JS */
        background-color: transparent; /* Set by JS */
        border: none; /* Set by JS */
        border-radius: 0; /* Set by JS based on shape */
        box-shadow: none; /* Set by JS */
        /* Smooth Transitions for all properties */
        transition: background-color 0.2s, border-color 0.2s, border-style 0.2s,
                    border-width 0.2s, box-shadow 0.2s, transform 0.2s ease-out,
                    opacity 0.5s ease-out, border-radius 0.2s; /* Added border-radius transition */
        /* Position for overlay text */
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden; /* Prevent text overflow if needed */
    }

    .overlay-text {
        padding: 4px 8px;
        border-radius: 4px;
        font-weight: 500;
        text-align: center;
        max-width: 90%;
        word-break: break-word;
        line-height: 1.2;
        pointer-events: none;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8); /* Add shadow for better readability */
    }

    /* Styles for different overlay shapes (applied by JS) */
    .overlay.shape-rectangle { border-radius: 3px; } /* Slight rounding for default rectangle */
    .overlay.shape-roundedRectangle { border-radius: 15px; } /* More pronounced rounding */
    .overlay.shape-oval { border-radius: 50%; } /* Makes it an oval or circle */


    /* Revealed elements */
    .overlay.revealed {
        opacity: 0; /* Start hidden */
        transition: opacity 0.5s ease-in-out, background-color 0.2s,
                    border-color 0.2s, border-style 0.2s;
    }

    /* Hover Text (using data attribute set by JS) */
    .overlay::after {
        content: attr(data-hover-text); /* Get text from data attribute */
        position: absolute;
        bottom: -30px; /* Position below the overlay */
        left: 50%;
        transform: translateX(-50%); /* Center the text */
        background-color: rgba(0, 0, 0, 0.7); /* Dark background */
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap; /* Prevent text wrapping */
        z-index: 3;
        opacity: 0;
        visibility: hidden;
        pointer-events: none; /* Prevent interference */
        transition: opacity 0.2s ease-out, visibility 0.2s ease-out;
    }

    .overlay:hover {
        /* Hover effects can be subtle now as primary style is dynamic */
        filter: brightness(1.1); /* Slightly brighten on hover */
         /* Keep prominent border on hover IF outline is enabled */
         /* This is tricky with dynamic styles, JS might need to handle hover border */
         /* Example: JS could add a class on hover */
    }
     /* Example hover class (add/remove with JS) */
    .overlay.is-hovering {
         filter: brightness(1.1);
         /* You could potentially override border here if needed,
            but it might conflict with dynamic styles. */
         /* border-width: 3px !important; */ /* Use with caution */
    }


    /* Show the hover text - only if no overlay text is present */
    .overlay:not(.has-overlay-text):hover::after {
        opacity: 1;
        visibility: visible;
    }

    /* Style for element when its modal is open */
    .overlay.highlighted-for-modal {
        /* Use outline instead of border to avoid layout shifts */
        outline: 3px solid #1a73e8;
        outline-offset: 2px; /* Space between element and outline */
        box-shadow: 0 0 12px rgba(26, 115, 232, 0.5);
        z-index: 105; /* Ensure it's above dimmer and modal */
         /* Slightly dim the element itself to make outline pop */
         /* filter: brightness(0.9); */
    }
    /* Alias class for highlighting in modal */
    .overlay.modal-active-element {
        outline: 3px solid #1a73e8;
        outline-offset: 2px;
        box-shadow: 0 0 12px rgba(26, 115, 232, 0.5);
        z-index: 105;
    }


    /* Style for temporary highlight interaction */
     .overlay.highlighted-temporary {
        /* Apply styles directly via JS for immediate feedback */
        transition: background-color 0.1s, box-shadow 0.1s, filter 0.1s;
     }

    /* Control bar */
    .control-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 15px;
      background-color: #f5f5f5;
      border-top: 1px solid #ddd;
      flex-shrink: 0;
    }
    .slide-nav { display: flex; align-items: center; gap: 10px; }
    .nav-button {
      background-color: #1a73e8; color: white; border: none; border-radius: 4px;
      padding: 8px 15px; cursor: pointer; font-size: 0.9rem; display: flex;
      align-items: center; gap: 5px; transition: background-color 0.2s;
    }
    .nav-button:hover:not(:disabled) { background-color: #1558b7; } /* Ensure hover only if not disabled */
    .nav-button:disabled { background-color: #b0bec5; cursor: not-allowed; opacity: 0.7; } /* Style disabled */
    .slide-indicator { padding: 0 15px; color: #666; font-size: 0.9rem; }

    /* Text modal */
    #textModal {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.75);
      display: none; justify-content: center; align-items: center; z-index: 100;
      opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s;
    }
    #textModal.visible { opacity: 1; visibility: visible; display: flex; }
    #textModalContent {
      background-color: white; padding: 30px; border-radius: 8px;
      max-width: 80%; max-height: 80%; overflow: auto;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3); position: relative;
      transform: scale(0.9); transition: transform 0.3s;
    }
     #textModal.visible #textModalContent { transform: scale(1); }
    #closeModal {
      position: absolute; top: 10px; right: 10px; background: none; border: none;
      font-size: 1.8rem; cursor: pointer; color: #aaa; line-height: 1; padding: 0 5px;
    }
     #closeModal:hover { color: #333; }
    #modalText { margin-bottom: 15px; line-height: 1.6; }
    .modal-navigation {
      display: flex; justify-content: space-between; margin-top: 20px;
      padding-top: 15px; border-top: 1px solid #eee;
      gap: 15px; /* Add gap between buttons */
    }
    .modal-navigation button {
      padding: 8px 16px; background-color: #1a73e8; color: white; border: none;
      border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 5px;
      min-width: 100px; /* Set minimum width */
      transition: background-color 0.2s, opacity 0.2s; /* Add transition */
    }
     .modal-navigation button:hover:not(:disabled) { background-color: #1558b7; } /* Ensure hover only if not disabled */
     .modal-navigation button:disabled { background-color: #b0bec5; cursor: not-allowed; opacity: 0.7; } /* Style disabled */

    /* Animations, Loading, Error, Spotlight, Debug etc. - UNCHANGED from previous version */
    /* --- Animation Keyframes & Classes --- */
      /* --- Animation Keyframes & Classes --- */
    /* Existing */
    @keyframes pulse_anim { 0%, 100% { transform: scale(1); opacity: 0.7; } 50% { transform: scale(1.05); opacity: 1; } }
    @keyframes wiggle_anim { 0%, 100% { transform: rotate(0deg); } 25% { transform: rotate(3deg); } 75% { transform: rotate(-3deg); } }
    @keyframes float_anim { 0%, 100% { transform: translateY(0px); } 50% { transform: translateY(-8px); } }
    /* NEW Keyframes */
    @keyframes bounce_anim { 0%, 20%, 50%, 80%, 100% { transform: translateY(0); } 40% { transform: translateY(-10px); } 60% { transform: translateY(-5px); } }
    @keyframes shake_anim { 0% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); } 20%, 40%, 60%, 80%, 100% { transform: translateX(4px); } }
    @keyframes flash_anim { 0%, 100% { opacity: 1; } 50% { opacity: 0.2; } }
    @keyframes growShrink_anim { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.08); } }

    /* ADDED: Spotlight text bubble animation */
    @keyframes bubbleEnter {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    #spotlightTextBubble {
        animation: bubbleEnter 0.3s ease-out forwards; /* Apply the new animation */
    }

    /* Notes panel animation */
    @keyframes notesPanelFadeIn {
        from { opacity: 0; transform: translate(-50%, 20px); }
        to { opacity: 1; transform: translate(-50%, 0); }
    }

    #spotlightNotesPanel {
        animation: notesPanelFadeIn 0.3s ease-out forwards;
    }

    /* Base Animation Classes */
    .animate-pulse { animation: pulse_anim 2s infinite ease-in-out; }
    .animate-wiggle { animation: wiggle_anim 0.5s infinite ease-in-out; }
    .animate-float { animation: float_anim 3s infinite ease-in-out; }
    .animate-bounce { animation: bounce_anim 1.5s infinite ease-in-out; }
    .animate-shake { animation: shake_anim 0.6s infinite ease-in-out; }
    .animate-flash { animation: flash_anim 1s infinite steps(1, end); }
    .animate-growShrink { animation: growShrink_anim 2s infinite ease-in-out; }

    /* Speed/Intensity Variants */
    /* Pulse */
    .animate-pulse.slow { animation-duration: 3s; }
    .animate-pulse.medium { animation-duration: 2s; }
    .animate-pulse.fast { animation-duration: 1s; }
    /* Wiggle */
    .animate-wiggle.gentle { animation-duration: 1s; transform-origin: center; } /* Gentle needs longer duration */
    .animate-wiggle.medium { animation-duration: 0.5s; transform-origin: center; }
    .animate-wiggle.strong { animation-duration: 0.3s; transform-origin: center; }
    /* Float */
    .animate-float.slow { animation-duration: 4s; }
    .animate-float.medium { animation-duration: 3s; }
    .animate-float.fast { animation-duration: 2s; }

    /* Loading overlay */
    .loading-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(255, 255, 255, 0.8); display: flex; flex-direction: column;
      justify-content: center; align-items: center; z-index: 1000;
    }
    .loading-spinner {
      border: 5px solid #f3f3f3; border-top: 5px solid #1a73e8; border-radius: 50%;
      width: 50px; height: 50px; animation: spin 1s linear infinite; margin-bottom: 20px;
    }
    .loading-message { font-size: 1.2rem; color: #333; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* Error message */
    .error-message {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      background-color: #f44336; color: white; padding: 15px 20px; border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1001; max-width: 80%;
      display: none; /* Initially hidden */
    }

    /* Dim/Spotlight Overlay */
    .dim-overlay {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.7); /* Adjust darkness */
      z-index: 90; /* Below modal, above most content */
      opacity: 0;
      visibility: hidden;
      pointer-events: none; /* Prevent interaction when hidden */
      transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
      cursor: pointer; /* Indicate it's clickable to dismiss */
    }
    .dim-overlay.active {
      opacity: 1;
      visibility: visible;
      pointer-events: auto; /* Allow clicking the overlay to dismiss */
    }
    /* Style for the element being spotlighted */
    .overlay.spotlight-active {
        z-index: 95 !important; /* Ensure spotlighted element is above dimmer */
        background-color: transparent !important; /* Use transparent background */
        border: 2px solid rgba(255, 255, 255, 0.9) !important; /* White highlight */
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.7),
                    0 0 30px rgba(255, 255, 255, 0.3) !important; /* Glowing effect */
        cursor: default !important;
        pointer-events: none !important;
        filter: brightness(1.2) !important; /* Boost brightness to make it stand out */
        transition: background-color 0.3s, border 0.3s, box-shadow 0.3s !important; /* Smooth transitions */
    }

    /* Hide the "Click here" text when spotlighted */
    .overlay.spotlight-active::after {
        display: none !important;
    }

    /* --- ADDED: Spotlight Navigation Buttons --- */
    .spotlight-nav-container {
      display: flex;
      justify-content: space-between; /* Pushes Prev/Next to edges */
      margin-top: 12px; /* Space above buttons */
      padding-top: 10px; /* Space below text */
      border-top: 1px solid #eee; /* Separator line */
    }

    .spotlight-nav-button {
      padding: 6px 12px;
      background-color: #1a73e8; /* Blue background */
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px; /* Match sidebar button size */
      font-weight: 500;
      display: inline-flex; /* Use inline-flex */
      align-items: center;
      gap: 5px; /* Space between icon and text */
      transition: background-color 0.2s, opacity 0.2s;
      line-height: 1; /* Ensure consistent height */
    }

    .spotlight-nav-button:hover:not(:disabled) {
      background-color: #1558b7; /* Darker blue on hover */
    }

    .spotlight-nav-button:disabled {
      opacity: 0.5; /* Fade disabled buttons */
      cursor: not-allowed;
      background-color: #cccccc; /* Grey background when disabled */
    }

    /* Style for the arrow symbols within the buttons */
    .spotlight-nav-button span {
       font-size: 16px; /* Slightly larger arrows */
       line-height: 1; /* Align arrows vertically */
    }
    /* --- END ADDED CSS --- */

    /* Debug Tools */
    .debug-info {
      position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7);
      color: white; padding: 10px; border-radius: 4px; font-size: 12px;
      z-index: 1000; max-width: 300px; max-height: 200px; overflow: auto;
      display: none; /* Hidden by default */
    }
    .debug-toggle {
      position: fixed; bottom: 10px; right: 10px; /* Position toggle initially */
      background: #1a73e8; color: white; border: none; border-radius: 4px;
      padding: 5px 10px; font-size: 12px; cursor: pointer; z-index: 1001;
      display: none; /* Hidden by default, enabled via debugMode flag */
    }
    .debug-toggle.active {
       right: 320px; /* Move toggle when info panel is shown */
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .header h1 { font-size: 1.2rem; }
      #slideTitle { max-width: 40%; }
      #textModalContent { max-width: 95%; padding: 15px; }
      .nav-button { padding: 6px 10px; font-size: 0.8rem; }
      .slide-indicator { padding: 0 10px; }
      .control-bar { padding: 8px 10px; }
    }
  </style>
</head>
<body>
  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div class="loading-message">Loading presentation...</div>
  </div>

  <!-- Dim/Spotlight Overlay -->
  <div class="dim-overlay" id="dimOverlay"></div>

  <!-- Main Container -->
  <div class="container">
    <div class="header">
      <h1>Interactive Training</h1>
      <div class="nav-controls">
        <span id="slideTitle"></span>
      </div>
    </div>

    <div class="slide-container" id="slideContainer">
      <div class="slide" id="slide">
        <img class="slide-background" id="slideBackground" src="" alt="Slide background">
        <!-- Overlays will be added here dynamically -->
      </div>
    </div>

    <div class="control-bar">
      <div class="slide-nav">
        <button id="prevSlideBtn" class="nav-button" disabled>
          <span>←</span> Previous
        </button>
        <span class="slide-indicator" id="slideIndicator">Slide 1 of 1</span>
        <button id="nextSlideBtn" class="nav-button" disabled>
          Next <span>→</span>
        </button>
      </div>
      <div>
        <button id="restartBtn" class="nav-button">
          <span>↺</span> Restart
        </button>
      </div>
    </div>
  </div>

  <!-- Text modal -->
  <div id="textModal">
    <div id="textModalContent">
      <button id="closeModal">×</button>
      <div id="modalText"></div>
      <div class="modal-navigation">
        <button id="prevElementBtn">
          <span>←</span> Previous
        </button>
        <button id="nextElementBtn">
          Next <span>→</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Error Message Area -->
  <div id="errorMessage" class="error-message"></div>

  <!-- Debug tools -->
  <button id="debugToggle" class="debug-toggle">Debug</button>
  <div id="debugInfo" class="debug-info"></div>


<script>
    // ---------- Global Variables ----------
    const presentationId = "<?= presentationId ?>"; // Injected by GAS doGet
    let currentSlide = null;
    let currentSlideIndex = 0;
    let totalSlides = 0;
    let overlayElementsMap = new Map(); // Map<elementId, overlayDiv>
    // Store full element data received from backend
    let currentSlideElementsData = [];
    let interactiveElements = []; // Subset of currentSlideElementsData with interactions/animations
    let currentModalElementIndex = -1;
    let lastActiveElementId = null; // Track the last element interacted with
    let navSequenceElements = []; // Elements in the current navigation sequence
    let debugMode = false; // Set true for local debugging
    let permanentlyHiddenElementsPerSlide = {}; // Track hidden elements { slideIndex: Set<elementId> }

    // ADDED: Spotlight Navigation Variables
    let spotlightableElements = []; // Ordered list of elements eligible for spotlight nav
    let currentSpotlightElementIndex = -1; // Index in spotlightableElements array
    let isSpotlightActive = false;

    // Store global overlay defaults received from backend
    let globalOverlayDefaults = {
        shape: 'rectangle', color: '#e53935', opacity: 15, outlineEnabled: true,
        outlineColor: '#e53935', outlineWidth: 1, outlineStyle: 'dashed',
        textColor: '#ffffff', textSize: 14, hoverText: 'Click here', textBackground: false
    };

    // Default base styling (used if globals fail or aren't provided)
    let overlayOpacity = 15;
    let overlayShadow = true;

    // DOM element references
    const slideContainer = document.getElementById('slideContainer');
    const slideElement = document.getElementById('slide');
    const slideBackground = document.getElementById('slideBackground');
    const slideIndicator = document.getElementById('slideIndicator');
    const prevSlideBtn = document.getElementById('prevSlideBtn');
    const nextSlideBtn = document.getElementById('nextSlideBtn');
    const restartBtn = document.getElementById('restartBtn');
    const slideTitleElement = document.getElementById('slideTitle');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const textModal = document.getElementById('textModal');
    const modalTextDiv = document.getElementById('modalText');
    const closeModalBtn = document.getElementById('closeModal');
    const prevElementBtn = document.getElementById('prevElementBtn');
    const nextElementBtn = document.getElementById('nextElementBtn');
    const dimOverlay = document.getElementById('dimOverlay');
    const errorElement = document.getElementById('errorMessage');
    const debugToggle = document.getElementById('debugToggle');
    const debugInfo = document.getElementById('debugInfo');

    // ---------- Initialization ----------
    window.addEventListener('load', () => {
      logDebug(`[WebApp] Starting with presentation ID: ${presentationId}`);
      setupEventListeners();
      setupDebugTools();
      loadSlide(0); // Load the first slide
      window.addEventListener('resize', handleResize);
    });

    function setupEventListeners() {
      prevSlideBtn.addEventListener('click', () => loadSlide(currentSlideIndex - 1));
      nextSlideBtn.addEventListener('click', () => loadSlide(currentSlideIndex + 1));
      restartBtn.addEventListener('click', () => loadSlide(0));
      closeModalBtn.addEventListener('click', hideTextModal);
      textModal.addEventListener('click', (e) => { if (e.target === textModal) hideTextModal(); });
      dimOverlay.addEventListener('click', hideSpotlight);
      
      // Modal navigation buttons - use default 'modal' type
      prevElementBtn.addEventListener('click', () => navigateToPreviousElement('modal'));
      nextElementBtn.addEventListener('click', () => navigateToNextElement('modal'));
    }

    function setupDebugTools() {
      if (debugMode) {
        debugToggle.style.display = 'block';
        debugToggle.addEventListener('click', () => {
          const showDebug = debugInfo.style.display === 'none';
          debugInfo.style.display = showDebug ? 'block' : 'none';
          debugToggle.classList.toggle('active', showDebug);
          debugToggle.textContent = showDebug ? 'Hide Debug' : 'Debug';
        });
      } else {
         debugToggle.style.display = 'none';
         debugInfo.style.display = 'none';
      }
    }

    function logDebug(message, data) {
        if (debugMode) {
            console.log(message, data !== undefined ? data : '');
            if (debugInfo.style.display !== 'none') {
               const time = new Date().toLocaleTimeString();
               debugInfo.innerHTML = `[${time}] ${message}<br>` + debugInfo.innerHTML;
            }
        }
    }

    function updateDebugInfo(info) {
        if (!debugMode || debugInfo.style.display === 'none') return;
        const time = new Date().toLocaleTimeString();
        debugInfo.innerHTML = `[${time}] ${info}<br>` + debugInfo.innerHTML;
    }

    function handleResize() {
      if (currentSlide) {
        adjustSlideSize();
        renderOverlays();
        // If spotlight is active, re-position the bubble/notes
        if (isSpotlightActive && window.currentSpotlight?.targetId) {
            const targetElement = overlayElementsMap.get(window.currentSpotlight.targetId);
            if (targetElement) {
                 const targetRect = targetElement.getBoundingClientRect();
                 window.currentSpotlight.targetRect = targetRect; // Update rect
                 // Reposition text bubble
                 const bubble = document.getElementById('spotlightTextBubble');
                 if (bubble) {
                     positionSpotlightBubble(bubble, targetRect); // Use a helper if needed
                 }
                 // Reposition notes panel
                 const notesPanel = document.getElementById('spotlightNotesPanel');
                 if(notesPanel) {
                      // Notes panel positioning is simpler, usually just needs horizontal centering
                      notesPanel.style.left = '50%';
                      notesPanel.style.transform = 'translateX(-50%)';
                 }
            }
        }
      }
    }

    // Helper to position spotlight bubble (extracted from showSpotlightText)
    function positionSpotlightBubble(bubble, targetRect) {
        const bubbleRect = bubble.getBoundingClientRect();
        const spaceBelow = window.innerHeight - targetRect.bottom;
        const spaceAbove = targetRect.top;
        const margin = 15;

        let top, left;
        if (spaceBelow > bubbleRect.height + margin || spaceBelow >= spaceAbove) {
            top = targetRect.bottom + margin;
        } else {
            top = targetRect.top - bubbleRect.height - margin;
        }
        left = targetRect.left + targetRect.width / 2 - bubbleRect.width / 2;
        left = Math.max(10, Math.min(left, window.innerWidth - bubbleRect.width - 10)); // Clamp

        bubble.style.top = `${Math.max(10, top)}px`; // Ensure not off-screen top
        bubble.style.left = `${left}px`;
    }


    // ---------- Slide Loading ----------
    /**
     * Loads a slide by index and prepares it for display.
     * Improved version with better visibility state tracking.
     * @param {number} index - The 0-based index of the slide to load
     */
    function loadSlide(index) {
        if (index < 0 || (totalSlides > 0 && index >= totalSlides)) {
            logDebug(`[WebApp] Invalid slide index requested: ${index}`);
            return;
        }

        logDebug(`[WebApp] Loading slide index: ${index}, current index: ${currentSlideIndex}`);

        // Save visibility states before changing slides
        if (currentSlideIndex !== index && interactiveElements.length > 0) {
            // Initialize the set if it doesn't exist for the *previous* slide
             if (!permanentlyHiddenElementsPerSlide[currentSlideIndex]) {
                 permanentlyHiddenElementsPerSlide[currentSlideIndex] = new Set();
             }

            // Check which elements are currently *not* in the DOM map (meaning they are hidden)
            const currentHiddenSet = permanentlyHiddenElementsPerSlide[currentSlideIndex];
            interactiveElements.forEach(el => {
                if (!overlayElementsMap.has(el.id)) {
                     if (!currentHiddenSet.has(el.id)) { // Avoid duplicates if already marked
                         currentHiddenSet.add(el.id);
                         logDebug(`[WebApp] Saving element ${el.id} as hidden for slide ${currentSlideIndex}`);
                     }
                } else {
                     // If it *is* in the map, ensure it's *not* in the hidden set
                     if (currentHiddenSet.has(el.id)) {
                         currentHiddenSet.delete(el.id);
                         logDebug(`[WebApp] Removing element ${el.id} from hidden set (it became visible) for slide ${currentSlideIndex}`);
                     }
                }
            });

            logDebug(`[WebApp] Saved hidden state for slide ${currentSlideIndex}. Hidden: ${permanentlyHiddenElementsPerSlide[currentSlideIndex]?.size || 0} elements`);
        }

        showLoading("Loading slide...");
        hideTextModal(); // Ensure modal is closed
        hideSpotlight(); // Ensure spotlight is closed
        clearOverlays(); // Clear existing DOM elements
        overlayElementsMap.clear(); // Clear the tracking map

        // Reset state variables tied to the specific slide
        currentSlideElementsData = [];
        interactiveElements = [];
        currentModalElementIndex = -1;
        currentSpotlightElementIndex = -1; // Reset spotlight index
        spotlightableElements = []; // Clear spotlightable list
        lastActiveElementId = null;
        navSequenceElements = [];

        // Initialize the hidden set for the target slide if it doesn't exist
        if (!permanentlyHiddenElementsPerSlide[index]) {
            permanentlyHiddenElementsPerSlide[index] = new Set();
            logDebug(`[WebApp] Initialized hidden set for slide ${index}`);
        } else {
            logDebug(`[WebApp] Using existing hidden set for slide ${index} with ${permanentlyHiddenElementsPerSlide[index].size} elements`);
        }

        google.script.run
            .withSuccessHandler(handleSlideData)
            .withFailureHandler(handleLoadError)
            .getSlideDataForWebApp(presentationId, index);
    }

    /**
     * Handles slide data received from the backend and prepares it for display.
     * Improved version with better error handling and background caching integration.
     * @param {Object} data - The slide data object from the backend.
     */
    function handleSlideData(data) {
      logDebug(`[WebApp] Received slide data:`, data);

      // Safety timeout - ensure loading overlay gets hidden even if image loading hangs
      const loadingTimeout = setTimeout(() => {
        console.warn("[WebApp] Loading timeout reached, forcing hide of loading overlay");
        hideLoading();
      }, 5000); // 5 seconds timeout

      if (data.error) {
        handleLoadError(data.error);
        // Try to show minimal info if possible
        currentSlideIndex = data.index !== undefined ? data.index : currentSlideIndex;
        totalSlides = data.total !== undefined ? data.total : totalSlides;
        updateSlideNavControls(); // Update nav buttons even on error
        clearTimeout(loadingTimeout); // Clear the safety timeout
        return;
      }

      currentSlide = data;
      currentSlideIndex = data.index;
      totalSlides = data.total;

      // Store all element data, including non-interactive elements
      currentSlideElementsData = data.elements || [];

      // Handle global overlay settings from Code.gs
      if (data.globalOverlayDefaults && typeof data.globalOverlayDefaults === 'object') {
        logDebug("[WebApp] Using globalOverlayDefaults from server:", data.globalOverlayDefaults);
        globalOverlayDefaults = { ...globalOverlayDefaults, ...data.globalOverlayDefaults }; // Merge received defaults
        // Update base variables from potentially updated globals
        overlayOpacity = globalOverlayDefaults.opacity !== undefined ? globalOverlayDefaults.opacity : 15;
        overlayShadow = globalOverlayDefaults.outlineEnabled !== undefined ? globalOverlayDefaults.outlineEnabled : true;
      } else {
        // Fallback to initial defaults
        logDebug("[WebApp] No globalOverlayDefaults provided or invalid, using initial defaults");
        overlayOpacity = globalOverlayDefaults.opacity;
        overlayShadow = globalOverlayDefaults.outlineEnabled;
      }
      logDebug(`[WebApp] Applied overlay settings: Opacity=${overlayOpacity}%, Shadow=${overlayShadow}`);

      // Filter interactive elements
      interactiveElements = currentSlideElementsData.filter(el => {
        const hasInteraction = el.interaction && el.interaction.type && el.interaction.type !== 'none';
        const hasAnimation = el.animation && el.animation.type && el.animation.type !== 'none';
        const hasOverlayStyle = el.interaction?.overlayStyle && Object.keys(el.interaction.overlayStyle).length > 0;
        return hasInteraction || hasAnimation || hasOverlayStyle;
      });

      logDebug(`[WebApp] Found ${interactiveElements.length} interactive elements out of ${currentSlideElementsData.length} total`);

      currentModalElementIndex = -1; // Reset modal index

      updateSlideNavControls(); // Update buttons and indicator
      slideTitleElement.textContent = data.notes || ''; // Display speaker notes as title

      // Handle background image loading with proper error handling
      if (data.backgroundUrl) {
        logDebug("[WebApp] Setting background image...");
        slideBackground.src = data.backgroundUrl;

        // Set up proper loading events
        slideBackground.onload = () => {
          clearTimeout(loadingTimeout);
          logDebug("[WebApp] Background image loaded successfully");
          onSlideContentReady();
        };

        slideBackground.onerror = () => {
          clearTimeout(loadingTimeout);
          logError("[WebApp] Background image failed to load, continuing with blank background");
          slideBackground.src = ''; // Clear the source to avoid broken image icon
          onSlideContentReady();
        };

        // Failsafe in case events don't fire reliably
        setTimeout(() => {
          if (loadingOverlay.style.display !== 'none') {
            clearTimeout(loadingTimeout);
            logDebug("[WebApp] Background image loading failsafe timeout, continuing anyway");
            onSlideContentReady();
          }
        }, 3000); // Reduced failsafe timeout
      } else {
        logDebug("[WebApp] No background image, using blank slide");
        slideBackground.src = '';
        clearTimeout(loadingTimeout);
        setTimeout(onSlideContentReady, 50); // Short delay for blank background
      }
    }


    function onSlideContentReady() {
      try {
        logDebug("[WebApp] Preparing slide content...");
        adjustSlideSize(); // Calculate and apply slide dimensions
        renderOverlays(); // Render interactive overlays based on new size

        // Restore visibility states based on tracked hidden elements
        // This needs to happen *after* initial rendering attempt
        restoreHiddenElementState();

        // Build navigation sequences after initial render and state restoration
        buildNavigationSequence();
        buildSpotlightableElementsList(); // ADDED: Build spotlight list

        hideLoading(); // Hide loading indicator
        logDebug("[WebApp] Slide ready!");
      } catch (err) {
        logError("[WebApp] Error in onSlideContentReady: " + err.message, err);
        showError("Failed to prepare slide: " + err.message);
        hideLoading(); // Ensure loading indicator is hidden even on error
      }
    }

    function updateSlideNavControls() {
        slideIndicator.textContent = `Slide ${currentSlideIndex + 1} of ${totalSlides}`;
        prevSlideBtn.disabled = currentSlideIndex === 0;
        nextSlideBtn.disabled = currentSlideIndex >= totalSlides - 1;
    }

    // ---------- Overlay Rendering (UPDATED) ----------

    // Helper to convert HEX and opacity (0-100) to RGBA CSS string
    function hexToRgba(hex, opacityPercent) {
        if (!hex || typeof hex !== 'string' || !/^#([0-9A-F]{3}){1,2}$/i.test(hex)) {
            hex = '#000000'; // Default to black if invalid hex
            console.warn(`[WebApp] Invalid hex color received ('${hex}'), defaulting to black.`);
        }

        hex = hex.replace('#', '');
        let r, g, b;

        try { // Add try-catch for safety during parsing
            if (hex.length === 3) {
                r = parseInt(hex[0] + hex[0], 16);
                g = parseInt(hex[1] + hex[1], 16);
                b = parseInt(hex[2] + hex[2], 16);
            } else { // Assume 6 length after regex check
                r = parseInt(hex.substring(0, 2), 16);
                g = parseInt(hex.substring(2, 4), 16);
                b = parseInt(hex.substring(4, 6), 16);
            }
        } catch (e) {
            logError("Error parsing hex color:", hex, e);
            r = g = b = 0; // Default to black on error
        }

        // Clamp opacityPercent between 0 and 100, default if invalid, then convert to 0-1 alpha
        const numOpacity = parseFloat(opacityPercent);
        // Default to 15 if NaN or undefined, otherwise clamp
        const clampedOpacity = (isNaN(numOpacity) || typeof opacityPercent === 'undefined') ? 15 : Math.max(0, Math.min(100, numOpacity));
        const alpha = clampedOpacity / 100;

        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function adjustSlideSize() {
        const containerWidth = slideContainer.clientWidth;
        const containerHeight = slideContainer.clientHeight;

        // Use slide dimensions from the loaded data, fallback to 16:9
        const slideWidth = currentSlide?.slideWidth || 960;
        const slideHeight = currentSlide?.slideHeight || 540;
        const slideAspectRatio = slideWidth / slideHeight;

        let targetWidth, targetHeight;

        if (containerWidth / containerHeight > slideAspectRatio) {
            targetHeight = containerHeight;
            targetWidth = targetHeight * slideAspectRatio;
        } else {
            targetWidth = containerWidth;
            targetHeight = targetWidth / slideAspectRatio;
        }

        slideElement.style.width = `${targetWidth}px`;
        slideElement.style.height = `${targetHeight}px`;

        const scaleX = targetWidth / slideWidth;
        const scaleY = targetHeight / slideHeight;

        slideElement.dataset.scaleX = scaleX;
        slideElement.dataset.scaleY = scaleY;
        slideElement.dataset.origWidth = slideWidth;
        slideElement.dataset.origHeight = slideHeight;

        logDebug(`[WebApp] Slide dimensions adjusted to ${targetWidth.toFixed(1)}x${targetHeight.toFixed(1)}, Scale: ${scaleX.toFixed(4)}x${scaleY.toFixed(4)}`);
    }

    // Main function to apply styles (custom or global)
    function applyOverlayStyle(overlay, element) {
        const interaction = element.interaction || {};
        const customStyle = interaction.overlayStyle;
        const useGlobal = !customStyle; // Use global if no custom style block

        // Determine the source of styles
        const styleSource = useGlobal ? globalOverlayDefaults : { ...globalOverlayDefaults, ...customStyle };

        // Get style properties, falling back to global if needed
        const shape = styleSource.shape || 'rectangle';
        const color = styleSource.color || '#e53935'; // Default red
        const opacity = styleSource.opacity !== undefined ? styleSource.opacity : 15; // Default 15%
        const outlineEnabled = styleSource.outlineEnabled !== undefined ? styleSource.outlineEnabled : true;
        const outlineColor = styleSource.outlineColor || color; // Default to main color if outline color missing
        const outlineWidth = styleSource.outlineWidth !== undefined ? styleSource.outlineWidth : 1;
        const outlineStyle = styleSource.outlineStyle || 'dashed';

        // Calculate RGBA color with opacity
        const rgbaColor = hexToRgba(color, opacity);

        // Apply background color
        overlay.style.backgroundColor = rgbaColor;

        // Apply shape via border-radius
        overlay.classList.remove('shape-rectangle', 'shape-roundedRectangle', 'shape-oval'); // Clear previous shapes
        if (shape === 'roundedRectangle') {
            overlay.classList.add('shape-roundedRectangle');
            // overlay.style.borderRadius = '15px'; // Alternative direct style
        } else if (shape === 'oval') {
             overlay.classList.add('shape-oval');
             // overlay.style.borderRadius = '50%'; // Alternative direct style
        } else {
             overlay.classList.add('shape-rectangle'); // Default
             // overlay.style.borderRadius = '3px'; // Alternative direct style
        }

        // Apply outline or box-shadow
        overlay.style.border = 'none'; // Clear border first
        overlay.style.boxShadow = 'none'; // Clear shadow first

        if (outlineEnabled) {
            overlay.style.border = `${outlineWidth}px ${outlineStyle} ${outlineColor}`;
            logDebug(`[WebApp] Applied outline: ${outlineWidth}px ${outlineStyle} ${outlineColor} to ${element.id}`);
        } else if (overlayShadow) { // Apply default shadow only if outline is disabled AND default shadow is enabled
            overlay.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.3)';
            logDebug(`[WebApp] Applied default shadow to ${element.id}`);
        }

        // Apply hover text (tooltip)
        const hoverText = styleSource.hoverText || 'Click'; // Fallback hover text
        overlay.dataset.hoverText = hoverText;

        // Debugging log
        logDebug(`[WebApp] Applied style to ${element.id}: Shape=${shape}, Color=${rgbaColor}, Outline=${outlineEnabled ? 'Yes' : 'No'}, Hover='${hoverText}' (Source: ${useGlobal ? 'Global' : 'Custom'})`);
    }


    function addOverlayText(overlay, text, element) {
        if (!text || !text.trim()) return;

        const textElement = document.createElement('div');
        textElement.className = 'overlay-text';
        textElement.textContent = text;

        // Determine the source of styles (custom or global)
        const interaction = element.interaction || {};
        const customStyle = interaction.overlayStyle;
        const useGlobal = !customStyle;
        const styleSource = useGlobal ? globalOverlayDefaults : { ...globalOverlayDefaults, ...customStyle };

        // Get text style properties
        const textColor = styleSource.textColor || '#ffffff';
        const textSize = styleSource.textSize || 14;
        const useBackground = styleSource.textBackground || false;

        // Apply the styles directly
        textElement.style.color = textColor;
        textElement.style.fontSize = `${textSize}px`;

        if (useBackground) {
            textElement.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            textElement.style.padding = '2px 5px'; // Add padding if background is used
             textElement.style.borderRadius = '3px';
        } else {
            textElement.style.backgroundColor = 'transparent';
            textElement.style.padding = '4px 8px'; // Use original padding if no background
        }

        // Ensure text doesn't prevent overlay clicks
        textElement.style.pointerEvents = 'none';

        overlay.appendChild(textElement);
        overlay.classList.add('has-overlay-text');
        logDebug(`[WebApp] Added overlay text "${text}" with color ${textColor}, size ${textSize}px to element ${overlay.dataset.elementId}`);
    }


    /**
     * Renders all interactive overlay elements onto the current slide.
     * Handles initial visibility based on state.
     */
     function renderOverlays() {
        logDebug(`[WebApp] [renderOverlays] Start - Rendering overlays for ${interactiveElements.length} elements on slide ${currentSlideIndex}`);

        // Force-clear any previous overlays
        const existingOverlays = slideElement.querySelectorAll('.overlay');
        existingOverlays.forEach(overlay => {
            if (overlay.parentNode) {
                overlay.parentNode.removeChild(overlay);
            }
        });
        overlayElementsMap.clear();
        logDebug(`[WebApp] [renderOverlays] Cleared existing overlays and map.`);

        if (!currentSlide || !currentSlideElementsData) {
            logDebug('[WebApp] [renderOverlays] No current slide or element data, skipping overlay rendering.');
            return;
        }

        // Re-filter interactive elements just in case
        interactiveElements = currentSlideElementsData.filter(el => {
            const hasInteraction = el.interaction && el.interaction.type && el.interaction.type !== 'none';
            const hasAnimation = el.animation && el.animation.type && el.animation.type !== 'none';
            const hasOverlayStyle = el.interaction?.overlayStyle && Object.keys(el.interaction.overlayStyle).length > 0;
            return hasInteraction || hasAnimation || hasOverlayStyle;
        });
        logDebug(`[WebApp] [renderOverlays] Re-filtered interactive elements count: ${interactiveElements.length}`);

        if (interactiveElements.length === 0) {
            logDebug('[WebApp] [renderOverlays] No interactive elements to render.');
            buildNavigationSequence(); // Still build sequence (might be empty)
            buildSpotlightableElementsList(); // Still build spotlight list
            return;
        }

        // Get the set of hidden elements for the CURRENT slide index
        const currentHiddenSet = permanentlyHiddenElementsPerSlide[currentSlideIndex] || new Set();
        logDebug(`[WebApp] [renderOverlays] Checking against hidden set for slide ${currentSlideIndex}. Set contains ${currentHiddenSet.size} elements.`);

        // Render each element, skipping those marked as hidden
        interactiveElements.forEach((element) => {
            if (currentHiddenSet.has(element.id)) {
                logDebug(`[WebApp] [renderOverlays] SKIPPING render (permanently hidden): ${element.id}`);
                return; // Do not render if it's supposed to be hidden
            }
             // Do not render elements targeted by 'revealOnClick' initially
             if (isTargetOfRevealOnClick(element.id)) {
                 logDebug(`[WebApp] [renderOverlays] SKIPPING initial render (revealOnClick target): ${element.id}`);
                 return;
             }

            // Attempt to render the element
            renderElement(element);
        });

        logDebug(`[WebApp] [renderOverlays] Finished rendering attempt. Map size: ${overlayElementsMap.size}`);
        // Navigation sequences are built in onSlideContentReady after potential hides/reveals
    }

    /**
     * Checks if an element is the target of a 'revealOnClick' interaction on the current slide.
     * @param {string} elementId - The ID of the element to check.
     * @returns {boolean} - True if it's a target, false otherwise.
     */
    function isTargetOfRevealOnClick(elementId) {
        if (!currentSlide || !currentSlideElementsData) return false;
        return currentSlideElementsData.some(el =>
            el.interaction?.type === 'revealOnClick' &&
            el.interaction.targetElementId === elementId
        );
    }

    /**
     * Renders a single element on the slide.
     * @param {Object} element - The element data to render
     * @returns {HTMLElement|null} - The created overlay element or null if failed
     */
    function renderElement(element) {
        try {
            if (!element || typeof element.top !== 'number' || typeof element.left !== 'number' ||
                typeof element.width !== 'number' || typeof element.height !== 'number') {
                logError(`[WebApp] [renderElement] Invalid element data received, missing position/size: ID=${element?.id}`);
                return null;
            }

            const scaleX = parseFloat(slideElement.dataset.scaleX) || 1;
            const scaleY = parseFloat(slideElement.dataset.scaleY) || 1;

            const left = Math.round(element.left * scaleX);
            const top = Math.round(element.top * scaleY);
            const width = Math.round(Math.max(element.width * scaleX, 5)); // Min width 5px
            const height = Math.round(Math.max(element.height * scaleY, 5)); // Min height 5px

            // Check if already exists (shouldn't happen with clearOverlays, but good safety check)
            if (overlayElementsMap.has(element.id)) {
                 logDebug(`[WebApp] [renderElement] Element ${element.id} already exists in map, skipping re-render.`);
                 return overlayElementsMap.get(element.id);
            }

            const overlay = document.createElement('div');
            overlay.className = 'overlay';
            overlay.dataset.elementId = element.id;

            overlay.style.position = 'absolute';
            overlay.style.left = `${left}px`;
            overlay.style.top = `${top}px`;
            overlay.style.width = `${width}px`;
            overlay.style.height = `${height}px`;

            applyOverlayStyle(overlay, element);

            if (element.interaction?.showOverlayText && element.interaction.overlayText) {
                addOverlayText(overlay, element.interaction.overlayText, element);
            }

            let tooltipParts = [`ID: ${element.id}`];
            if (element.interaction?.type && element.interaction.type !== 'none') tooltipParts.push(`I: ${element.interaction.type}`);
            if (element.interaction?.overlayStyle) tooltipParts.push(`[Style]`);
            if (element.animation?.type && element.animation.type !== 'none') tooltipParts.push(`A: ${element.animation.type}`);
            overlay.title = tooltipParts.join(' | ');

            overlay.addEventListener('click', () => handleOverlayClick(element, element.id));
            overlay.addEventListener('mouseenter', () => overlay.classList.add('is-hovering'));
            overlay.addEventListener('mouseleave', () => overlay.classList.remove('is-hovering'));

            if (element.animation && element.animation.type && element.animation.type !== 'none') {
                applyAnimation(overlay, element.animation);
            }

            slideElement.appendChild(overlay);
            overlayElementsMap.set(element.id, overlay);
            logDebug(`[WebApp] [renderElement] Successfully rendered overlay for ${element.id}`);

            return overlay;
        } catch (err) {
            logError(`[WebApp] [renderElement] Error rendering element ${element?.id || 'unknown'}: ${err.message}`, err);
            return null;
        }
    }


    function applyAnimation(overlay, animation) {
        const animationClass = getAnimationClass(animation.type);
        if (!animationClass) {
            logDebug(`[WebApp] Unknown animation type: ${animation.type}`);
            return;
        }

        let speedClass = '';
        if (animation.type === 'pulse' && animation.pulseSpeed) speedClass = animation.pulseSpeed;
        else if (animation.type === 'wiggle' && animation.wiggleIntensity) speedClass = animation.wiggleIntensity;
        else if (animation.type === 'float' && animation.floatSpeed) speedClass = animation.floatSpeed;

        const trigger = animation.trigger || 'automatic';
        logDebug(`[WebApp] Applying animation: ${animation.type} (${trigger}) to ${overlay.dataset.elementId} with speed/intensity: ${speedClass || 'default'}`);

        overlay.dataset.animationType = animation.type;
        overlay.dataset.animationTrigger = trigger;

        // Clean up any existing animation classes before applying new ones
        overlay.className = overlay.className.replace(/animate-\S+|slow|medium|fast|gentle|strong/g, '').trim();

        switch (trigger) {
            case 'automatic':
                overlay.classList.add(animationClass);
                if (speedClass) overlay.classList.add(speedClass);
                break;
            case 'onHover':
                overlay.addEventListener('mouseenter', () => {
                    overlay.classList.add(animationClass);
                    if (speedClass) overlay.classList.add(speedClass);
                });
                overlay.addEventListener('mouseleave', () => {
                    overlay.classList.remove(animationClass);
                    if (speedClass) overlay.classList.remove(speedClass);
                });
                break;
            case 'onClick':
                // Handled within handleOverlayClick
                break;
            default:
                logDebug(`[WebApp] Unknown animation trigger: ${trigger}`);
        }
    }


    function clearOverlays() {
      // Clear the DOM
      const overlays = slideElement.querySelectorAll('.overlay');
      overlays.forEach(overlay => {
         if(overlay.parentNode) overlay.parentNode.removeChild(overlay);
      });
      // Clear the tracking map
      overlayElementsMap.clear();
      logDebug('[WebApp] Cleared overlays from DOM and map');
    }


    function getAnimationClass(type) {
        switch (type) {
            case 'pulse': return 'animate-pulse';
            case 'wiggle': return 'animate-wiggle';
            case 'float': return 'animate-float';
            case 'bounce': return 'animate-bounce';
            case 'shake': return 'animate-shake';
            case 'flash': return 'animate-flash';
            case 'growShrink': return 'animate-growShrink';
            default: return null;
        }
    }


    /**
     * Handles click events on overlay elements, managing interactions, animations, and sequential appearances.
     * @param {Object} element - The element data object (might be stale, use ID to refetch)
     * @param {string} clickedElementId - The ID of the clicked element
     */
    function handleOverlayClick(element, clickedElementId) {
        const elementId = clickedElementId || element?.id;
        if (!elementId) {
            logError('[WebApp] handleOverlayClick called without a valid element ID.');
            return;
        }

        // Find the most up-to-date element data using the ID from the full slide data
        const currentElementData = currentSlideElementsData.find(el => el.id === elementId);

        if (!currentElementData) {
            logError(`[WebApp] Could not find current element data for ID: ${elementId} in handleOverlayClick`);
            return;
        }
        logDebug(`[WebApp] Processing click for element: ${elementId}`, currentElementData);

        let interactionHandled = false;
        let interactionType = 'none';

        // --- Handle Interactions First ---
        if (currentElementData.interaction && currentElementData.interaction.type && currentElementData.interaction.type !== 'none') {
            const interaction = currentElementData.interaction;
            interactionType = interaction.type;
            logDebug(`[WebApp] Handling interaction: ${interactionType}`);

            switch (interactionType) {
                case 'showText':
                    if (interaction.text) {
                        showTextModal(interaction.text, elementId);
                        interactionHandled = true;
                    }
                    break;
                case 'spotlight':
                    showSpotlight(elementId, interaction);
                    interactionHandled = true;
                    break;
                case 'revealElement':
                case 'revealOnClick': // Treat revealOnClick similarly for revealing
                    if (interaction.targetElementId) {
                        // Reveal the target element
                        revealElement(interaction.targetElementId, elementId);
                        // If revealOnClick and showTextModal is configured, show modal *after* revealing
                         if (interactionType === 'revealOnClick' && interaction.showTextModal && interaction.textModal) {
                             setTimeout(() => { // Delay showing modal slightly
                                 showTextModal(interaction.textModal, interaction.targetElementId); // Show modal associated with target
                             }, 100);
                         }
                        interactionHandled = true;
                    }
                    break;
                case 'revealAndSpotlight':
                    if (interaction.targetElementId) {
                        logDebug(`[WebApp] Handling revealAndSpotlight. Trigger: ${elementId}, Target: ${interaction.targetElementId}`);
                        // Reveal the target element FIRST
                        revealElement(interaction.targetElementId, elementId);

                        // Spotlight the *target* element after a delay
                        // **MODIFIED: Increased delay slightly**
                        setTimeout(() => {
                            const targetData = currentSlideElementsData.find(el => el.id === interaction.targetElementId);
                            // Check if the overlay element exists in the map *after* reveal attempt
                            if (targetData && overlayElementsMap.has(interaction.targetElementId)) {
                                const spotlightInteraction = { // Construct spotlight data from revealAndSpotlight interaction
                                    type: 'spotlight', // Set type to spotlight for showSpotlight function
                                    showText: interaction.showText,
                                    text: interaction.text,
                                    showNotes: interaction.showNotes,
                                    // Pass the correct notes (from target if available, or from interaction)
                                    notes: targetData.notes || interaction.notes || null
                                };
                                logDebug(`[WebApp] Applying spotlight to revealed element: ${interaction.targetElementId}`);
                                showSpotlight(interaction.targetElementId, spotlightInteraction);
                            } else {
                                // Log error but avoid showing duplicate errors if reveal already failed
                                if(!overlayElementsMap.has(interaction.targetElementId)) {
                                     logError(`[WebApp] Failed to spotlight revealed element ${interaction.targetElementId} (not found in map) after revealAndSpotlight`);
                                     // showError(`Failed to spotlight target element. Please try again.`); // Avoid duplicate user error
                                } else if (!targetData) {
                                     logError(`[WebApp] Failed to spotlight revealed element ${interaction.targetElementId} (target data missing) after revealAndSpotlight`);
                                }
                            }
                        }, 400); // Increased delay to 400ms
                        interactionHandled = true;
                    }
                    break;
                 case 'openUrl':
                     if (interaction.url) {
                         logDebug(`[WebApp] Opening URL: ${interaction.url}`);
                         window.open(interaction.url, '_blank'); // Open in new tab
                         interactionHandled = true;
                     }
                     break;
                 case 'goToSlide':
                      if (interaction.targetSlide && !isNaN(interaction.targetSlide)) {
                          const targetIndex = parseInt(interaction.targetSlide, 10) - 1; // Convert to 0-based index
                          logDebug(`[WebApp] Going to slide index: ${targetIndex}`);
                          loadSlide(targetIndex);
                          interactionHandled = true;
                      }
                      break;
                 case 'highlight': // Temporary visual highlight
                     const overlayToHighlight = overlayElementsMap.get(elementId);
                     if (overlayToHighlight) {
                         logDebug(`[WebApp] Applying temporary highlight to ${elementId}`);
                         const originalBg = overlayToHighlight.style.backgroundColor;
                         const originalBorder = overlayToHighlight.style.border;
                         const originalShadow = overlayToHighlight.style.boxShadow;
                         const duration = 500; // Fixed duration for simple highlight

                         // Apply highlight styles (e.g., brighter color, thicker border)
                         overlayToHighlight.style.backgroundColor = hexToRgba(globalOverlayDefaults.color || '#e53935', 50); // Brighter opacity
                         overlayToHighlight.style.border = `2px solid ${globalOverlayDefaults.outlineColor || '#e53935'}`;
                         overlayToHighlight.style.boxShadow = '0 0 10px rgba(255, 255, 100, 0.7)'; // Yellow glow

                         setTimeout(() => {
                            // Check if element still exists before reverting
                            if (overlayElementsMap.has(elementId)) {
                                overlayToHighlight.style.backgroundColor = originalBg;
                                overlayToHighlight.style.border = originalBorder;
                                overlayToHighlight.style.boxShadow = originalShadow;
                            }
                         }, duration);
                         interactionHandled = true;
                     }
                     break;
            }
        }

        // --- Handle Animation Triggered by Click ---
        if (currentElementData.animation && currentElementData.animation.type && currentElementData.animation.type !== 'none' && currentElementData.animation.trigger === 'onClick') {
            const animation = currentElementData.animation;
            const overlay = overlayElementsMap.get(elementId);
            if (overlay) {
                logDebug(`[WebApp] Click animation triggered: ${animation.type}`);
                const animationClass = getAnimationClass(animation.type);
                let speedClass = '';
                if (animation.type === 'pulse' && animation.pulseSpeed) speedClass = animation.pulseSpeed;
                else if (animation.type === 'wiggle' && animation.wiggleIntensity) speedClass = animation.wiggleIntensity;
                else if (animation.type === 'float' && animation.floatSpeed) speedClass = animation.floatSpeed;

                if (animationClass) {
                    // Remove previous animation classes before adding new ones
                    overlay.className = overlay.className.replace(/animate-\S+|slow|medium|fast|gentle|strong/g, '').trim();
                    overlay.classList.add(animationClass);
                    if (speedClass) overlay.classList.add(speedClass);

                    // Remove animation class after duration (approximate)
                    const duration = 1000; // Example duration
                    setTimeout(() => {
                        if (overlayElementsMap.has(elementId)) { // Check if element still exists
                            overlay.classList.remove(animationClass);
                            if (speedClass) overlay.classList.remove(speedClass);
                        }
                    }, duration);
                }
            }
        }

        // --- Handle Disappear On Click Functionality ---
        // This should happen AFTER other interactions/animations might have played
        if (currentElementData.interaction && currentElementData.interaction.disappearOnClick) {
            // Use setTimeout to allow other actions (like URL opening) to potentially complete
            setTimeout(() => {
                const overlay = overlayElementsMap.get(elementId);
                if (overlay) {
                    logDebug(`[WebApp] Element ${elementId} disappearing on click.`);
                    overlay.style.opacity = '0'; // Fade out
                    overlay.style.pointerEvents = 'none'; // Disable further clicks

                    // Mark as permanently hidden
                    if (!permanentlyHiddenElementsPerSlide[currentSlideIndex]) {
                        permanentlyHiddenElementsPerSlide[currentSlideIndex] = new Set();
                    }
                    permanentlyHiddenElementsPerSlide[currentSlideIndex].add(elementId);
                    logDebug(`[WebApp] Added ${elementId} to hidden set for slide ${currentSlideIndex}`);

                    // Remove from map and DOM after transition
                    setTimeout(() => {
                        if (overlay.parentNode) {
                            overlay.parentNode.removeChild(overlay);
                        }
                        overlayElementsMap.delete(elementId);
                        // Rebuild navigation sequences as an element was removed
                        buildNavigationSequence();
                        buildSpotlightableElementsList(); // Also rebuild spotlight list
                    }, 500); // Match opacity transition duration
                }
            }, 50); // Short delay before disappearing
        }

        // Update last active element ID
        lastActiveElementId = elementId;

        // Update navigation based on the *current state* after click actions
        // Delay slightly to allow DOM changes from reveal/hide
        setTimeout(() => {
             buildNavigationSequence(); // Rebuild sequence after potential changes
             updateModalNavigationButtons(lastActiveElementId); // Update based on potentially new sequence/index
             updateSpotlightNavButtons(); // Update spotlight buttons if active
             forceEnableNavigationButtons(); // Check if main nav should be re-enabled
        }, 100); // Small delay
    }


    /**
     * Reveals a hidden element.
     * @param {string} targetElementId - The ID of the element to reveal.
     * @param {string} triggerElementId - The ID of the element that triggered the reveal.
     */
    function revealElement(targetElementId, triggerElementId) {
        logDebug(`[WebApp] Attempting to reveal element ${targetElementId} triggered by ${triggerElementId}`);

        // Find the data for the target element
        const targetElementData = currentSlideElementsData.find(el => el.id === targetElementId);

        if (!targetElementData) {
            logError(`[WebApp] Cannot reveal: Target element data not found for ID ${targetElementId}`);
            showError(`Could not find the element (ID: ${targetElementId.substring(0,8)}...) to reveal.`);
            return;
        }

        // Check if it's already visible
        if (overlayElementsMap.has(targetElementId)) {
            logDebug(`[WebApp] Element ${targetElementId} is already visible.`);
            // Optionally flash it briefly to indicate it was the target?
             const existingOverlay = overlayElementsMap.get(targetElementId);
             existingOverlay.style.transition = 'outline 0.1s linear';
             existingOverlay.style.outline = '3px solid yellow';
             setTimeout(() => { existingOverlay.style.outline = 'none'; }, 300);
            return;
        }

        // Render the element (it will be added to the DOM and overlayElementsMap)
        const newOverlay = renderElement(targetElementData);

        if (newOverlay) {
            logDebug(`[WebApp] Successfully rendered and revealed element ${targetElementId}`);
            // Optional: Add a 'revealed' class for CSS transition effect
            newOverlay.classList.add('revealed');
            requestAnimationFrame(() => { // Ensure transition applies
                newOverlay.style.opacity = '1'; // Trigger fade-in
            });

            // Remove element from the hidden set if it was there
             if (permanentlyHiddenElementsPerSlide[currentSlideIndex]?.has(targetElementId)) {
                 permanentlyHiddenElementsPerSlide[currentSlideIndex].delete(targetElementId);
                 logDebug(`[WebApp] Removed ${targetElementId} from hidden set as it was revealed.`);
             }

            // Rebuild navigation sequences as a new element is now visible
            buildNavigationSequence();
            buildSpotlightableElementsList(); // ADDED: Rebuild spotlight list

        } else {
            logError(`[WebApp] Failed to render element ${targetElementId} during reveal.`);
            showError(`Failed to reveal element (ID: ${targetElementId.substring(0,8)}...).`);
        }
    }


    // ---------- Modal Handling ----------

    /**
     * Shows the text modal with the provided content.
     * @param {string} text - The HTML or text content for the modal.
     * @param {string} elementId - The ID of the element that triggered the modal.
     */
    function showTextModal(text, elementId) {
        logDebug(`[WebApp] Showing text modal for element: ${elementId}`);
        modalTextDiv.innerHTML = text.replace(/\\n/g, '<br>'); // Replace escaped newlines
        textModal.classList.add('visible');

        lastActiveElementId = elementId; // Track the element that opened the modal

        // Update navigation buttons based on the element's position in the sequence
        buildNavigationSequence(); // Ensure sequence is up-to-date
        updateModalNavigationButtons(elementId);

        // Highlight the triggering element visually
        highlightActiveModalElement(elementId);

        // Disable main nav buttons
        prevSlideBtn.disabled = true;
        nextSlideBtn.disabled = true;
        restartBtn.disabled = true;
    }

    /**
     * Hides the text modal and cleans up.
     */
    function hideTextModal() { // <<< FUNCTION DEFINITION ADDED/CONFIRMED HERE
        if (!textModal.classList.contains('visible')) return; // Already hidden

        logDebug("[WebApp] Hiding text modal.");
        textModal.classList.remove('visible');

        // Reset highlight on the element that triggered the modal
        resetModalElementHighlights(); // Use the existing reset function

        // Re-enable main nav buttons after a short delay
        setTimeout(() => {
            forceEnableNavigationButtons();
        }, 100);

        // Reset modal navigation state
        currentModalElementIndex = -1;
        lastActiveElementId = null; // Reset last active when modal closes
    }


    /**
     * Unified function to navigate to the previous element in any sequence.
     * Works for both modal and spotlight navigation.
     * @param {string} navigationType - 'spotlight' or 'modal' to indicate navigation context
     */
    function navigateToPreviousElement(navigationType = 'modal') {
      logDebug(`[WebApp] navigateToPreviousElement called with type: ${navigationType}`);
      
      if (navigationType === 'spotlight') {
        // Spotlight navigation logic
        if (!isSpotlightActive || currentSpotlightElementIndex <= 0) {
          logDebug("[WebApp] Cannot navigate prev spotlight: Inactive or at start.");
          return;
        }

        const prevIndex = currentSpotlightElementIndex - 1;
        const prevElement = spotlightableElements[prevIndex];

        if (prevElement && prevElement.id) {
          logDebug(`[WebApp] Navigating to previous spotlight: ${prevElement.id} (index ${prevIndex})`);
          
          // Get the full interaction data needed for showSpotlight
          const fullPrevElementData = currentSlideElementsData.find(el => el.id === prevElement.id);
          if (!fullPrevElementData || !fullPrevElementData.interaction) {
            logError(`[WebApp] Could not find interaction data for prev spotlight element: ${prevElement.id}`);
            showError("Error getting previous element data.");
            return;
          }
          
          // IMPORTANT: Temporarily store the target index so it's not lost during spotlight hide/show
          const targetSpotlightIndex = prevIndex;
          
          // Create a clean copy of the interaction data to avoid reference issues
          const interactionData = JSON.parse(JSON.stringify(fullPrevElementData.interaction));
          
          // Call showSpotlight with the correct ID and the interaction object
          showSpotlight(prevElement.id, interactionData);
          
          // Explicitly set the spotlight index to ensure it's correct
          currentSpotlightElementIndex = targetSpotlightIndex;
          logDebug(`[WebApp] Set currentSpotlightElementIndex explicitly to ${currentSpotlightElementIndex}`);
          
          // Update button states after navigation
          updateSpotlightNavButtons();
        } else {
          logError(`[WebApp] Could not find previous spotlight element at index ${prevIndex}`);
        }
      } else {
        // Modal navigation logic (original navigateToPreviousElement code)
        if (navSequenceElements.length === 0 || !lastActiveElementId) return;

        const currentIndex = navSequenceElements.findIndex(el => el.id === lastActiveElementId);
        if (currentIndex <= 0) return; // Already at first or not found

        const prevElement = navSequenceElements[currentIndex - 1];
        if (prevElement && prevElement.interaction?.text) {
          logDebug(`[WebApp] Navigating modal to previous element: ${prevElement.id}`);
          showTextModal(prevElement.interaction.text, prevElement.id); // Show modal for the previous element
        } else {
          logDebug(`[WebApp] Previous element ${prevElement?.id} has no text to show in modal.`);
          // Optionally just highlight the element without changing modal content
          highlightActiveModalElement(prevElement.id);
          lastActiveElementId = prevElement.id;
          updateModalNavigationButtons(lastActiveElementId);
        }
      }
    }

    /**
     * Unified function to navigate to the next element in any sequence.
     * Works for both modal and spotlight navigation.
     * @param {string} navigationType - 'spotlight' or 'modal' to indicate navigation context
     */
    function navigateToNextElement(navigationType = 'modal') {
      logDebug(`[WebApp] navigateToNextElement called with type: ${navigationType}`);
      
      if (navigationType === 'spotlight') {
        // Spotlight navigation logic
        if (!isSpotlightActive || currentSpotlightElementIndex >= spotlightableElements.length - 1) {
          logDebug("[WebApp] Cannot navigate next spotlight: Inactive or at end.");
          return;
        }

        const nextIndex = currentSpotlightElementIndex + 1;
        const nextElement = spotlightableElements[nextIndex];

        if (nextElement && nextElement.id) {
          logDebug(`[WebApp] Navigating to next spotlight: ${nextElement.id} (index ${nextIndex})`);
          
          // Get the full interaction data needed for showSpotlight
          const fullNextElementData = currentSlideElementsData.find(el => el.id === nextElement.id);
          if (!fullNextElementData || !fullNextElementData.interaction) {
            logError(`[WebApp] Could not find interaction data for next spotlight element: ${nextElement.id}`);
            showError("Error getting next element data.");
            return;
          }
          
          // IMPORTANT: Temporarily store the target index so it's not lost during spotlight hide/show
          const targetSpotlightIndex = nextIndex;
          
          // Create a clean copy of the interaction data to avoid reference issues
          const interactionData = JSON.parse(JSON.stringify(fullNextElementData.interaction));
          
          // Call showSpotlight with the correct ID and the interaction object
          showSpotlight(nextElement.id, interactionData);
          
          // Explicitly set the spotlight index to ensure it's correct
          currentSpotlightElementIndex = targetSpotlightIndex;
          logDebug(`[WebApp] Set currentSpotlightElementIndex explicitly to ${currentSpotlightElementIndex}`);
          
          // Update button states after navigation
          updateSpotlightNavButtons();
        } else {
          logError(`[WebApp] Could not find next spotlight element at index ${nextIndex}`);
        }
      } else {
        // Modal navigation logic (original navigateToNextElement code)
        if (navSequenceElements.length === 0 || !lastActiveElementId) return;

        const currentIndex = navSequenceElements.findIndex(el => el.id === lastActiveElementId);
        if (currentIndex === -1 || currentIndex >= navSequenceElements.length - 1) return; // Not found or already at last

        const nextElement = navSequenceElements[currentIndex + 1];
        if (nextElement && nextElement.interaction?.text) {
          logDebug(`[WebApp] Navigating modal to next element: ${nextElement.id}`);
          showTextModal(nextElement.interaction.text, nextElement.id); // Show modal for the next element
        } else {
          logDebug(`[WebApp] Next element ${nextElement?.id} has no text to show in modal.`);
          // Optionally just highlight the element without changing modal content
          highlightActiveModalElement(nextElement.id);
          lastActiveElementId = nextElement.id;
          updateModalNavigationButtons(lastActiveElementId);
        }
      }
    }
    /**
     * Wrapper function for navigating to previous spotlight element.
     * Calls the generalized navigation function with 'spotlight' parameter.
     */
    function navigateToPrevSpotlight() {
      // Call the unified navigation function with spotlight context
      navigateToPreviousElement('spotlight');
    }

    /**
     * Wrapper function for navigating to next spotlight element.
     * Calls the generalized navigation function with 'spotlight' parameter.
     */
    function navigateToNextSpotlight() {
      // Call the unified navigation function with spotlight context
      navigateToNextElement('spotlight');
    }
    /**
     * Updates the modal navigation buttons based on the current element's position in sequence
     * @param {string} currentElementId - The ID of the current element
     */
    function updateModalNavigationButtons(currentElementId = lastActiveElementId) {
        const prevBtn = document.getElementById('prevElementBtn');
        const nextBtn = document.getElementById('nextElementBtn');

        if (!prevBtn || !nextBtn) {
            logDebug('[WebApp] Modal navigation buttons not found');
            return;
        }

        // Find current element's index in the navigation sequence
        const currentIndex = navSequenceElements.findIndex(el => el.id === currentElementId);

        if (currentIndex === -1 || navSequenceElements.length <= 1) {
            // Element not in sequence or only one element, disable both
            prevBtn.disabled = true;
            nextBtn.disabled = true;
        } else {
            // Enable/disable buttons based on position in sequence
            prevBtn.disabled = currentIndex === 0;
            nextBtn.disabled = currentIndex === navSequenceElements.length - 1;
        }

        // Update visual state to match disabled property
        prevBtn.style.opacity = prevBtn.disabled ? '0.7' : '1';
        prevBtn.style.cursor = prevBtn.disabled ? 'not-allowed' : 'pointer';
        nextBtn.style.opacity = nextBtn.disabled ? '0.7' : '1';
        nextBtn.style.cursor = nextBtn.disabled ? 'not-allowed' : 'pointer';

        logDebug(`[WebApp] Updated modal navigation buttons. Current index: ${currentIndex}, Total: ${navSequenceElements.length}. Prev: ${!prevBtn.disabled}, Next: ${!nextBtn.disabled}`);
    }


    /**
     * Highlights the active element in the modal
     * @param {string} elementId - The ID of the element to highlight
     */
    function highlightActiveModalElement(elementId) {
        resetModalElementHighlights(); // Reset previous highlights
        const overlay = overlayElementsMap.get(elementId);
        if (overlay) {
            overlay.classList.add('modal-active-element'); // Use specific class
            logDebug(`[WebApp] Highlighted modal active element: ${elementId}`);
        }
    }

    /**
     * Removes highlighting from all elements
     */
    function resetModalElementHighlights() {
        document.querySelectorAll('.modal-active-element').forEach(el => {
            el.classList.remove('modal-active-element');
        });
    }


    // ---------- Spotlight Handling (MODIFIED) ----------

    // ADDED: Helper function to check spotlight capability
    /**
     * Checks if an element has the capability to be part of the spotlight sequence.
     * @param {Object} element - The element data object.
     * @returns {boolean} True if the element can be spotlighted.
     */
    function hasSpotlightCapability(element) {
        // Define what makes an element eligible for spotlight sequence
        return element?.interaction &&
               (element.interaction.type === 'spotlight' || element.interaction.type === 'revealAndSpotlight');
    }


    // ADDED: Function to build the spotlight sequence
    /**
     * Builds the ordered list of elements currently visible and eligible for spotlighting.
     * Stores the result in the global `spotlightableElements` array.
     * Returns the number of spotlightable elements found.
     */
    function buildSpotlightableElementsList() {
        // Clear existing list
        spotlightableElements = [];
        
        if (!currentSlide || !currentSlideElementsData) {
            logDebug("[WebApp] Cannot build spotlight list: Missing slide or element data.");
            return 0;
        }
        
        // Get IDs of all currently visible elements
        const currentlyVisibleElementIds = new Set(overlayElementsMap.keys());
        logDebug(`[WebApp] Building spotlight list with ${currentlyVisibleElementIds.size} visible elements`);

        // Filter interactive elements that are visible and have spotlight capability
        const eligibleElements = currentSlideElementsData.filter(el => {
            const isVisible = currentlyVisibleElementIds.has(el.id);
            const hasCapability = hasSpotlightCapability(el);
            
            if (hasCapability && !isVisible) {
                logDebug(`[WebApp] Element ${el.id} has spotlight capability but is not visible`);
            }
            
            return isVisible && hasCapability;
        });

        // Optional: Sort based on position (top-to-bottom, left-to-right)
        eligibleElements.sort((a, b) => {
            const scaleY = parseFloat(slideElement.dataset.scaleY) || 1;
            const rowThreshold = 50 * scaleY; // Adjust threshold as needed
            if (Math.abs(a.top - b.top) < rowThreshold) {
                return a.left - b.left; // Same row: left-to-right
            }
            return a.top - b.top; // Different rows: top-to-bottom
        });

        spotlightableElements = eligibleElements;
        
        // Log detailed information about the spotlightable elements
        logDebug(`[WebApp] Built spotlightable elements list with ${spotlightableElements.length} elements`);
        for (let i = 0; i < spotlightableElements.length; i++) {
            logDebug(`[WebApp] Spotlight element ${i}: ${spotlightableElements[i].id} (${spotlightableElements[i].interaction?.type || 'unknown type'})`);
        }
        
        return spotlightableElements.length;
    }


    /**
     * Shows the spotlight effect focusing on a specific element.
     * @param {string} targetId - The ID of the element to spotlight.
     * @param {Object} interactionData - The interaction data for the spotlight.
     */
    function showSpotlight(targetId, interactionData) {
        logDebug(`[WebApp] showSpotlight called for target: ${targetId}`, interactionData);
        hideSpotlight(); // Hide any existing spotlight first

        const targetElement = overlayElementsMap.get(targetId);
        if (!targetElement) {
            logError(`[WebApp] Cannot show spotlight: Target element ${targetId} not found in overlay map.`);
            // Error handling code continues...
            return;
        }

        const targetRect = targetElement.getBoundingClientRect();
        logDebug(`[WebApp] Target element rect:`, targetRect);

        // Remove existing dim overlay approach
        dimOverlay.classList.remove('active');
        
        // Create four separate dimming panels
        // Create dimming panels using the helper function
        window.spotlightPanels = createSpotlightDimPanels(targetRect);
        
        // Highlight the active element with border/glow
        // Store original styles before applying spotlight
        if (!targetElement.dataset.originalBackgroundColor) {
            targetElement.dataset.originalBackgroundColor = targetElement.style.backgroundColor || '';
            targetElement.dataset.originalBorder = targetElement.style.border || '';
            targetElement.dataset.originalBoxShadow = targetElement.style.boxShadow || '';
            targetElement.dataset.originalFilter = targetElement.style.filter || '';
            logDebug(`[WebApp] Stored original styles for element ${targetId}`);
        }
        targetElement.classList.add('spotlight-active');

        // Store current spotlight info globally
        window.currentSpotlight = {
            targetId: targetId,
            targetRect: targetRect,
            interaction: interactionData || {}
        };
        isSpotlightActive = true;

        // Fetch notes for the target element specifically
        const targetElementData = currentSlideElementsData.find(el => el.id === targetId);
        // Get notes either from the target element's data OR from the passed interaction data (for revealAndSpotlight)
        const notesToShow = targetElementData?.notes || interactionData?.notes || null;

        if (interactionData.showText && interactionData.text) {
            showSpotlightText(interactionData.text, targetRect); // This will handle nav buttons now
        }
        if (interactionData.showNotes && notesToShow) {
            showSpotlightNotes(notesToShow);
        }

        // MODIFIED: Update spotlight sequence info and button states
        setTimeout(() => {
            updateSpotlightNavButtons(); // Update buttons after slight delay to ensure DOM is ready
            logDebug(`[WebApp] Updated spotlight nav buttons after index set to: ${currentSpotlightElementIndex}`);
        }, 100);
        // updateSpotlightNavButtons() is called within showSpotlightText if buttons are added

        // Disable main nav buttons while spotlight is active
        prevSlideBtn.disabled = true;
        nextSlideBtn.disabled = true;
        restartBtn.disabled = true;

        logDebug(`[WebApp] Spotlight activated for element: ${targetId}`);
    }


    /**
     * Hides the spotlight effect and cleans up all related elements.
     */
    function hideSpotlight() {
        if (!isSpotlightActive) {
            return; // Already hidden
        }
        logDebug("[WebApp] Hiding spotlight...");

        // Remove dim panels
        if (window.spotlightPanels) {
            window.spotlightPanels.forEach(panel => {
                if (panel.parentNode) panel.parentNode.removeChild(panel);
            });
            window.spotlightPanels = null;
        }

        // Remove highlight from the previously spotlighted element
        if (window.currentSpotlight && window.currentSpotlight.targetId) {
            const targetElement = overlayElementsMap.get(window.currentSpotlight.targetId);
            if (targetElement) {
                // Remove spotlight class
                targetElement.classList.remove('spotlight-active');
                
                // Restore original styles if they were saved
                if (targetElement.dataset.originalBackgroundColor !== undefined) {
                    targetElement.style.backgroundColor = targetElement.dataset.originalBackgroundColor;
                    targetElement.style.border = targetElement.dataset.originalBorder;
                    targetElement.style.boxShadow = targetElement.dataset.originalBoxShadow;
                    targetElement.style.filter = targetElement.dataset.originalFilter;
                    
                    // Clear stored original styles
                    delete targetElement.dataset.originalBackgroundColor;
                    delete targetElement.dataset.originalBorder;
                    delete targetElement.dataset.originalBoxShadow;
                    delete targetElement.dataset.originalFilter;
                    
                    logDebug(`[WebApp] Restored original styles for spotlight element ${window.currentSpotlight.targetId}`);
                }
            }
        }

        hideSpotlightText();
        hideSpotlightNotes();

        // Clear global spotlight info after a short delay
        setTimeout(() => {
            window.currentSpotlight = {};
        }, 200);

        isSpotlightActive = false;
        currentSpotlightElementIndex = -1; // Reset index

        // Re-enable main nav buttons after a delay
        setTimeout(() => {
            forceEnableNavigationButtons();
        }, 100);

        logDebug("[WebApp] Spotlight hidden.");
    }


    /**
     * Creates and displays the text bubble for the spotlight. Includes navigation buttons.
     * @param {string} text - The text content for the bubble.
     * @param {DOMRect} targetRect - The bounding rectangle of the spotlighted element.
     */
    function showSpotlightText(text, targetRect) {
        hideSpotlightText(); // Remove any existing bubble first

        const bubble = document.createElement('div');
        bubble.id = 'spotlightTextBubble';
        bubble.style.position = 'fixed';
        bubble.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
        bubble.style.color = '#333';
        bubble.style.padding = '15px';
        bubble.style.borderRadius = '8px';
        bubble.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
        bubble.style.maxWidth = '350px';
        bubble.style.zIndex = '101'; // Above dim overlay
        bubble.style.opacity = '0'; // Start hidden for animation
        // bubble.style.transition = 'opacity 0.3s'; // Animation handled by class now
        bubble.style.fontSize = '14px';
        bubble.style.lineHeight = '1.5';

        const textContent = document.createElement('div');
        textContent.innerHTML = text.replace(/\\n/g, '<br>'); // Support newlines
        bubble.appendChild(textContent);

        // --- MODIFIED: Add Navigation Container conditionally ---
        if (spotlightableElements.length > 1) {
            const navDiv = document.createElement('div');
            navDiv.className = 'spotlight-nav-container'; // Style this container

            const prevBtn = document.createElement('button');
            prevBtn.id = 'spotlightPrevBtn';
            prevBtn.className = 'spotlight-nav-button';
            prevBtn.innerHTML = '<span>←</span> Prev';
            prevBtn.addEventListener('click', () => navigateToPreviousElement('spotlight'));

            const nextBtn = document.createElement('button');
            nextBtn.id = 'spotlightNextBtn';
            nextBtn.className = 'spotlight-nav-button';
            nextBtn.innerHTML = 'Next <span>→</span>';
            nextBtn.addEventListener('click', () => navigateToNextElement('spotlight'));

            navDiv.appendChild(prevBtn);
            navDiv.appendChild(nextBtn);
            bubble.appendChild(navDiv);

            // Update button states immediately after adding them
            updateSpotlightNavButtons();
        }
        // --- End Navigation Container Modification ---

        document.body.appendChild(bubble);

        // Position the bubble
        positionSpotlightBubble(bubble, targetRect); // Use helper function

        // Apply animation class
        requestAnimationFrame(() => {
            // bubble.style.opacity = '1'; // Opacity handled by animation now
            // bubble.classList.add('animate-bubble'); // Add class if using CSS keyframes
        });

        logDebug(`[WebApp] Spotlight text shown. Index: ${currentSpotlightElementIndex}, Total: ${spotlightableElements.length}`);
        // updateSpotlightNavButtons(); // Moved inside the conditional button adding block
    }


    /**
     * Removes the spotlight text bubble from the DOM.
     */
    function hideSpotlightText() {
        const bubble = document.getElementById('spotlightTextBubble');
        if (bubble) {
            bubble.style.opacity = '0'; // Fade out before removing
            setTimeout(() => { if (bubble.parentNode) bubble.parentNode.removeChild(bubble); }, 300); // Match potential transition duration
        }
    }


    /**
     * Creates and displays the speaker notes panel below the spotlight bubble.
     * @param {string} notes - The speaker notes content.
     */
    function showSpotlightNotes(notes) {
        hideSpotlightNotes(); // Remove existing

        const notesPanel = document.createElement('div');
        notesPanel.id = 'spotlightNotesPanel';
        notesPanel.style.position = 'fixed';
        notesPanel.style.bottom = '20px';
        notesPanel.style.left = '50%';
        notesPanel.style.transform = 'translateX(-50%)';
        notesPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        notesPanel.style.color = '#eee';
        notesPanel.style.padding = '15px 20px';
        notesPanel.style.borderRadius = '8px';
        notesPanel.style.maxWidth = '60%';
        notesPanel.style.maxHeight = '25vh';
        notesPanel.style.overflowY = 'auto';
        notesPanel.style.zIndex = '102'; // Above bubble? Check z-index need
        notesPanel.style.opacity = '0'; // Start hidden for animation
        // notesPanel.style.transition = 'opacity 0.3s'; // Handled by animation class
        notesPanel.style.fontSize = '14px';
        notesPanel.style.lineHeight = '1.5';

        notesPanel.innerHTML = `<div style="font-weight: bold; margin-bottom: 8px; color: #ccc;">Speaker Notes:</div>${notes.replace(/\\n/g, '<br>')}`;
        document.body.appendChild(notesPanel);

        requestAnimationFrame(() => {
            // notesPanel.style.opacity = '1'; // Handled by animation class
            // notesPanel.classList.add('animate-notes'); // Apply animation
        });
        logDebug("[WebApp] Speaker notes panel shown.");
    }


    /**
     * Removes the speaker notes panel from the DOM.
     */
    function hideSpotlightNotes() {
        const panel = document.getElementById('spotlightNotesPanel');
        if (panel) {
             panel.style.opacity = '0'; // Fade out
             setTimeout(() => { if (panel.parentNode) panel.parentNode.removeChild(panel); }, 300); // Remove after fade
        }
    }


    // ADDED: Function to update spotlight navigation buttons
    /**
    /**
     * Updates the state (enabled/disabled) of the spotlight navigation buttons.
     */
    function updateSpotlightNavButtons() {
        const prevBtn = document.getElementById('spotlightPrevBtn');
        const nextBtn = document.getElementById('spotlightNextBtn');

        // Check if buttons exist (they might not if only 1 spotlightable element)
        if (!prevBtn || !nextBtn) {
            logDebug("[WebApp] Spotlight nav buttons not found or not needed.");
            return;
        }

        // Ensure spotlight is actually active before enabling/disabling
        if (!isSpotlightActive) {
            prevBtn.disabled = true;
            nextBtn.disabled = true;
            logDebug("[WebApp] Spotlight inactive, ensuring nav buttons are disabled.");
            return;
        }

        const numSpotlightable = spotlightableElements.length;
        
        // Log detailed diagnostic info
        logDebug(`[WebApp] updateSpotlightNavButtons - Index: ${currentSpotlightElementIndex}, Total: ${numSpotlightable}`);
        logDebug(`[WebApp] Number of spotlightable elements: ${spotlightableElements.length}`);
        for (let i = 0; i < spotlightableElements.length; i++) {
            logDebug(`[WebApp] Spotlight element ${i}: ${spotlightableElements[i]?.id || 'undefined'}`);
        }
        
        // Apply button state
        prevBtn.disabled = currentSpotlightElementIndex <= 0;
        nextBtn.disabled = currentSpotlightElementIndex >= numSpotlightable - 1;
        
        // Visual feedback for button state
        prevBtn.style.opacity = prevBtn.disabled ? '0.5' : '1';
        nextBtn.style.opacity = nextBtn.disabled ? '0.5' : '1';

        logDebug(`[WebApp] Spotlight nav updated: Idx ${currentSpotlightElementIndex}, Total ${numSpotlightable}, Prev ${!prevBtn.disabled}, Next ${!nextBtn.disabled}`);
    }



    /**
     * Creates consistent dimming panels around a spotlighted element.
     * @param {DOMRect} targetRect - The bounding rectangle of the spotlighted element.
     * @returns {Array} - Array of created panel elements
     */
    function createSpotlightDimPanels(targetRect) {
        // Remove any existing dim panels first
        if (window.spotlightPanels) {
            window.spotlightPanels.forEach(panel => {
                if (panel.parentNode) panel.parentNode.removeChild(panel);
            });
        }
        
        const dimPanels = [];
        const panelStyles = [
            // Top panel
            `position: fixed; z-index: 90; background: rgba(0,0,0,0.7); 
            left: 0; top: 0; width: 100%; height: ${targetRect.top}px;
            transition: opacity 0.3s ease;`,
            // Right panel
            `position: fixed; z-index: 90; background: rgba(0,0,0,0.7); 
            left: ${targetRect.right}px; top: ${targetRect.top}px; 
            width: calc(100% - ${targetRect.right}px); height: ${targetRect.height}px;
            transition: opacity 0.3s ease;`,
            // Bottom panel
            `position: fixed; z-index: 90; background: rgba(0,0,0,0.7); 
            left: 0; top: ${targetRect.bottom}px; 
            width: 100%; height: calc(100% - ${targetRect.bottom}px);
            transition: opacity 0.3s ease;`,
            // Left panel
            `position: fixed; z-index: 90; background: rgba(0,0,0,0.7); 
            left: 0; top: ${targetRect.top}px; 
            width: ${targetRect.left}px; height: ${targetRect.height}px;
            transition: opacity 0.3s ease;`
        ];
        
        // Create and append panels to the DOM
        for (let i = 0; i < 4; i++) {
            const panel = document.createElement('div');
            panel.className = 'spotlight-dim-panel';
            panel.style.cssText = panelStyles[i];
            panel.style.opacity = '0'; // Start transparent for animation
            panel.addEventListener('click', hideSpotlight); // Click to dismiss
            document.body.appendChild(panel);
            dimPanels.push(panel);
        }
        
        // Animate panels in
        requestAnimationFrame(() => {
            dimPanels.forEach(panel => {
                panel.style.opacity = '1';
            });
        });
        
        return dimPanels;
    }

    /**
     * Builds the navigation sequence of interactive elements for the current slide.
     * This creates an ordered list of elements that can be navigated through using prev/next in modal.
     */
    function buildNavigationSequence() {
        navSequenceElements = [];
        const visibleElementIds = new Set(overlayElementsMap.keys());
        logDebug(`[WebApp] Building navigation sequence with ${visibleElementIds.size} visible elements`);

        if (visibleElementIds.size === 0) {
            logDebug('[WebApp] No visible elements for navigation sequence');
            return 0;
        }

        // Filter elements that are visible AND have text to show in the modal
        const eligibleElements = interactiveElements.filter(el =>
            visibleElementIds.has(el.id) &&
            el.interaction?.type === 'showText' &&
            el.interaction?.text
        );

        // Sort by position (top-to-bottom, left-to-right)
        const sortedElements = [...eligibleElements].sort((a, b) => {
            const scaleY = parseFloat(slideElement.dataset.scaleY) || 1; // Get scale factor
            const rowThreshold = 50 * scaleY; // Scale threshold based on current view size
            if (Math.abs(a.top - b.top) < rowThreshold) {
                return a.left - b.left; // Same row: left-to-right
            }
            return a.top - b.top; // Different rows: top-to-bottom
        });

        navSequenceElements = sortedElements;
        logDebug(`[WebApp] Built navigation sequence with ${navSequenceElements.length} elements`);

        // Update modal buttons if the modal is currently visible
        if (textModal.classList.contains('visible') && lastActiveElementId) {
            updateModalNavigationButtons(lastActiveElementId);
        }

        return navSequenceElements.length;
    }


    /**
     * Forcefully enables the main navigation buttons if modal and spotlight are hidden.
     */
    function forceEnableNavigationButtons() {
        // Check if modal or spotlight are active
        if (!textModal.classList.contains('visible') && !isSpotlightActive) {
             logDebug("[WebApp] Modal and Spotlight hidden, re-enabling main nav buttons.");
             // Update based on current slide index only
             prevSlideBtn.disabled = currentSlideIndex === 0;
             nextSlideBtn.disabled = currentSlideIndex >= totalSlides - 1;
             restartBtn.disabled = false; // Restart is always enabled when modal/spotlight hidden
        } else {
            logDebug("[WebApp] Modal or Spotlight active, main nav buttons remain disabled.");
        }
    }


    // ---------- Loading and Error Handling ----------
    function showLoading(message) {
      logDebug(`[WebApp] Showing loading: ${message}`);
      const msgElement = loadingOverlay.querySelector('.loading-message');
      if (msgElement) msgElement.textContent = message || "Loading...";
      loadingOverlay.style.display = 'flex';
    }

    function hideLoading() {
      logDebug(`[WebApp] Hiding loading`);
      loadingOverlay.style.display = 'none';
    }

    function showError(message) {
        const errorMessageText = message || "An unknown error occurred.";
        logError(`[WebApp] Displaying error: ${errorMessageText}`); // Use logError
        errorElement.textContent = errorMessageText;
        errorElement.style.display = 'block';
        setTimeout(() => { errorElement.style.display = 'none'; }, 5000);
    }

    function handleLoadError(error) {
      let errorMessage = "Failed to load slide data.";
      if (typeof error === 'string') errorMessage = error;
      else if (error?.message) errorMessage = error.message;
      else if (error?.details) errorMessage = error.details;

      logError(`[WebApp] Slide load failed: ${errorMessage}`, error);
      showError(`Failed to load slide: ${errorMessage}. Check console or presentation access.`);
      hideLoading();
      updateSlideNavControls(); // Update nav controls even on error
    }

    // NEW: Centralized error logging
    function logError(message, errorObject) {
        console.error(`[WebApp] Error: ${message}`, errorObject || '');
        if (debugMode && debugInfo.style.display !== 'none') {
            const time = new Date().toLocaleTimeString();
            const errorText = errorObject ? (errorObject.message || JSON.stringify(errorObject)) : '';
            debugInfo.innerHTML = `<span style="color: #ff8a80;">[${time}] ERROR: ${message} ${errorText}</span><br>` + debugInfo.innerHTML;
        }
    }


    /**
     * Handles the Escape key press to close modal or spotlight.
     */
    function handleEscapeKey() {
        if (textModal.classList.contains('visible')) {
            logDebug("[WebApp] Escape key pressed, hiding modal.");
            hideTextModal();
        } else if (isSpotlightActive) {
            logDebug("[WebApp] Escape key pressed, hiding spotlight.");
            hideSpotlight();
        }
    }

    function tryNavigateWithKeyboard(key) {
      if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) {
        return; // Don't navigate if typing in an input
      }

      if (isSpotlightActive && window.currentSpotlight?.targetId) {
        if (key === 'ArrowRight' || key === ' ' || key === 'Enter') {
          logDebug("[WebApp] Keyboard: Next Element (Spotlight)");
          navigateToNextElement('spotlight');
        } else if (key === 'ArrowLeft') {
          logDebug("[WebApp] Keyboard: Previous Element (Spotlight)");
          navigateToPreviousElement('spotlight');
        }
      } else if (textModal.classList.contains('visible') && lastActiveElementId) {
        if (key === 'ArrowRight' || key === ' ' || key === 'Enter') {
          logDebug("[WebApp] Keyboard: Next Element (Modal)");
          navigateToNextElement('modal');
        } else if (key === 'ArrowLeft') {
          logDebug("[WebApp] Keyboard: Previous Element (Modal)");
          navigateToPreviousElement('modal');
        }
      } else { // Main slide navigation
        if (key === 'ArrowRight' || key === ' ' || key === 'Enter') {
          logDebug("[WebApp] Keyboard: Next Slide");
          if (!nextSlideBtn.disabled) loadSlide(currentSlideIndex + 1);
        } else if (key === 'ArrowLeft') {
          logDebug("[WebApp] Keyboard: Previous Slide");
          if (!prevSlideBtn.disabled) loadSlide(currentSlideIndex - 1);
        }
      }
    }


    // Keyboard event handler for navigation
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            handleEscapeKey();
        } else if (['ArrowLeft', 'ArrowRight', ' ', 'Enter'].includes(e.key)) {
             // Prevent default only if modal/spotlight is active or space/enter is pressed
             if (textModal.classList.contains('visible') || isSpotlightActive || [' ', 'Enter'].includes(e.key)) {
                e.preventDefault();
             }
            tryNavigateWithKeyboard(e.key);
        }
    });

    // Add this function to create fallback element data if needed (e.g., for reveal targets)
    function createElementDataFromId(targetId) {
        logDebug(`[WebApp] Creating element data from ID: ${targetId}`);
        let elementData = currentSlideElementsData.find(el => el.id === targetId);
        if (elementData) return elementData;

        logDebug(`[WebApp] ID ${targetId} not found in current slide elements data. Cannot create fallback.`);
        return null; // Don't create fallback if ID is completely unknown
    }


    /**
     * Restores the hidden state of elements when navigating back to a slide.
     */
     function restoreHiddenElementState() {
        const hiddenSet = permanentlyHiddenElementsPerSlide[currentSlideIndex];
        if (!hiddenSet || hiddenSet.size === 0) {
            logDebug(`[WebApp] No hidden elements to restore for slide ${currentSlideIndex}`);
            return;
        }

        logDebug(`[WebApp] Restoring hidden state for ${hiddenSet.size} elements on slide ${currentSlideIndex}`);

        hiddenSet.forEach(elementId => {
            const overlay = overlayElementsMap.get(elementId);
            if (overlay) {
                // Element exists in the map, means it was rendered. Remove it.
                if (overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                }
                overlayElementsMap.delete(elementId);
                logDebug(`[WebApp] Restored hidden state for element ${elementId} (removed from DOM/map).`);
            } else {
                 // Element was not in the map, likely because it was a revealOnClick target
                 // or was hidden before initial render completed. No action needed other than keeping it in the hidden set.
                 logDebug(`[WebApp] Element ${elementId} marked hidden, was not found in overlay map (state restored).`);
            }
        });
        logDebug(`[WebApp] Finished restoring hidden state for slide ${currentSlideIndex}. Map size: ${overlayElementsMap.size}`);
    }
    /**
     * Logs the current state of spotlight navigation for debugging.
     * Call this from console or add to key points in code.
     */
    function debugSpotlightNavigation() {
        console.log("===== SPOTLIGHT NAVIGATION DEBUG =====");
        console.log(`Active: ${isSpotlightActive}`);
        console.log(`Current Index: ${currentSpotlightElementIndex}`);
        console.log(`Total Spotlightable: ${spotlightableElements.length}`);
        
        if (spotlightableElements.length > 0) {
            console.log("Spotlightable Elements:");
            spotlightableElements.forEach((el, idx) => {
                console.log(`  ${idx}: ID=${el.id}, Type=${el.interaction?.type || 'unknown'}`);
            });
        }
        
        const currentId = window.currentSpotlight?.targetId;
        console.log(`Current Target ID: ${currentId || 'none'}`);
        
        const prevBtn = document.getElementById('spotlightPrevBtn');
        const nextBtn = document.getElementById('spotlightNextBtn');
        console.log(`Prev Button: ${prevBtn ? (prevBtn.disabled ? 'Disabled' : 'Enabled') : 'Not Found'}`);
        console.log(`Next Button: ${nextBtn ? (nextBtn.disabled ? 'Disabled' : 'Enabled') : 'Not Found'}`);
        console.log("=====================================");
        
        return {
            active: isSpotlightActive,
            currentIndex: currentSpotlightElementIndex,
            totalElements: spotlightableElements.length,
            elements: spotlightableElements.map(el => ({ id: el.id, type: el.interaction?.type })),
            currentTargetId: currentId,
            prevBtnEnabled: prevBtn ? !prevBtn.disabled : false,
            nextBtnEnabled: nextBtn ? !nextBtn.disabled : false
        };
    }
</script>
</body>
</html>